<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" 
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY api   "<acronym>API</acronym>">
<!ENTITY crc   "<acronym>CRC</acronym>">
<!ENTITY ieee  "<acronym>IEEE</acronym>">
<!ENTITY jtag  "<acronym>JTAG</acronym>">
<!ENTITY osci  "<acronym>OSCI</acronym>">
<!ENTITY pdf   "<acronym>PDF</acronym>">
<!ENTITY rtl   "<acronym>RTL</acronym>">
<!ENTITY soc   "<acronym>SoC</acronym>">
<!ENTITY tap   "<acronym>TAP</acronym>">
<!ENTITY vcd   "<acronym>VCD</acronym>">

<!-- ========== commonly used things ========== -->

<!ENTITY systemc "SystemC">
<!ENTITY tck     "<literal>TCK</literal>">
<!ENTITY tdi     "<literal>TDI</literal>">
<!ENTITY tdo     "<literal>TDO</literal>">
<!ENTITY tms     "<literal>TMS</literal>">
<!ENTITY trst    "<literal>TRST</literal>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY gdb       "<application class='software'><acronym>GDB</acronym></application>">
<!ENTITY linux     "<application class='software'>Linux</application>">
<!ENTITY verilator "<application class='software'>Verilator</application>">

<!-- = Hardware applications = -->

<!ENTITY orpsoc    "<application class='hardware'>ORPSoC</application>">

<!-- = Commands = -->

<!-- = Libraries = -->

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY lgpl "GNU Lesser General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2009 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing a SystemC cycle accurate interface to JTAG

$Id$

=========================================================================== -->

<book lang="en_GB">
  <title>
    Using &jtag; with &systemc;
  </title>
  <subtitle>
    Implementation of a Cycle Accurate Interface
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      January 2009
    </pubdate>

    <releaseinfo>
      Application Note 5. Issue 1
    </releaseinfo>

    <copyright>
      <year>
	2009
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, Jeremy Bennett of &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software for the &systemc; cycle accurate &jtag; interface written
	by &embecosm; and used in this document is licensed under the
	&gpl_www;. For detailed licensing information see the file
	<filename>COPYING</filename> in the source code.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      This document describes a cycle accurate &systemc; interface for
      &jtag; (IEEE 1149.1).
    </para>

    <para>
      This interface simplifies a number of common practical problems:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Interfacing to cycle accurate &systemc; models created from &rtl; using
	  tools such as Verilator, ARC VTOC or Carbon Design Systems
	  SpeedCompiler.
	</para>
      </listitem>

      <listitem>
	<para>
	  Interfacing to traditional event driven simulators, such as Cadence
	  NC, Synopsys VCS and Mentor Graphics ModelSim using &systemc;
	  co-simulation.
	</para>
      </listitem>

      <listitem>
	<para>
	  Implementing &systemc; test benches which drive physical hardware via
	  &jtag;
	</para>
      </listitem>

      <listitem>
	<para>
	  Interfacing to external tools such as debuggers. For example to
	  develop versions of &gdb; which can work through &jtag; ports.
	</para>
      </listitem>

    </itemizedlist>

    <sect1>
      <title>
	Rationale
      </title>

      <para>
	Directly interfacing to the &jtag; cycle accurate ports of a &systemc;
	model is a complex task, requiring careful modeling of the &jtag; Test
	Access Port (&tap;) state machine.
      </para>

      <para>
	More abstractly &jtag; is an interface allowing reading and writing of
	hardware registers.
      </para>

      <para>
	The interface described in this application note provides this
	abstraction. The user queues registers to be read or written, and the
	interface ensures the correct bit sequences are driven on the &jtag;
	pins. The interface is implemented as &systemc; module with a FIFO on
	which the user queues requests and signal ports to which the low level
	&jtag; ports are connected.
      </para>

      <para>
	A reference implementation is provided <xref linkend="ref_esp4"
	/>. This application note gives a number of examples of the interface
	in use (see <xref linkend="chap_examples"/>).
      </para>

    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>

      <para>
	If you need to interface &systemc; to a cycle accurate or pin level
	model of a &jtag; port, this interface and application note is for
	you. If at the end of your endeavors you are better informed, please
	help by adding to this document.
      </para>

    </sect1>

    <sect1>
      <title>
	Further Sources of Information
      </title>

      <sect2>
	<title>
	  Written Documentation
	</title>

	<para>
	  &jtag; and &systemc; are both &ieee; standards (1149.1 and 1666
	  respectively), and the standardization documents are the ultimate
	  reference. The &systemc; standard <xref linkend="ref_ieee_systemc"/>
	  is a free &pdf; download (a novelty for the &ieee;), but the &jtag;
	  standard <xref linkend="ref_ieee_jtag"/> costs money. The Texas
	  Instruments &jtag; primer <xref linkend="ref_ti_jtag"/> is a useful
	  free alternative.
	</para>

	<para>
	  The files making up the reference implementation for the &jtag;
	  &systemc; interface are comprehensively commented, and can be
	  processed with Doxygen <xref linkend="ref_doxygen" />. Each class,
	  member and methods behavior, parameters and any return value is
	  described.
	</para>
	<indexterm>
	  <primary>Doxygen</primary>
	</indexterm>
    
      </sect2>

      <sect2>
	<title>
	  Other Information Channels
	</title>

	<para>
	  There is a wealth of material to support both &systemc; and &jtag;
	  on the Internet.
	</para>

	<para>
	  The Open &systemc; Initiative (&osci;) provide an open source
	  reference implementation of the &systemc; library, which includes
	  tutorial material in its documentation directory. These may be
	  accessed from the &osci; website (<ulink
	  url="http://www.systemc.org">www.systemc.org</ulink>).
	</para>

	<para>
	  &osci; also provide a number of public mailing lists. The help forum
	  and the community forum are of particular relevance. Subscription is
	  through the &osci; website (see above).
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	About &embecosm;
      </title>

      <para>
	&embecosm; is a consultancy specializing in open source tools, models
	and training for the embedded software community. All &embecosm;
	products are freely available under open source licenses.
      </para>
      <indexterm>
	<primary>&embecosm;</primary>
      </indexterm>

      <para>
	&embecosm; offers a range of commercial services:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Customization of open source tools and software, including porting
	    to new architectures.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Support, tutorials and training for open source tools and software.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Custom software development for the embedded market, including
	    bespoke software models of hardware.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Independent evaluation of software tools.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	For further information, visit the &embecosm; website at <ulink
	url="http://www.embecosm.com/">www.embecosm.com</ulink>.
      </para>

    </sect1>

  </chapter>


  <chapter id="chap_overview">
    <title>
      Overview of Technologies
    </title>

    <sect1>
      <title>
	&jtag; (IEEE 1149.1)
      </title>

      <para>
	This section provides an introduction to IEEE 1149.1 <xref
	linkend="ref_ieee_jtag"/> developed by the Joint Test Action Group
	(&jtag;).
      </para>

      <para>
	&jtag; was developed as interface to support boundary scan
	testing. However the resulting interface has proved more generally
	useful as a way to get data into and out of registers in hardware.
      </para>

      <sect2>
	<title>
	  Boundary Scan
	</title>

	<para>
	  Boundary scan testing is a way of testing that the inputs and
	  outputs of components on a board, or sub-systems on a chip,
	  are connected correctly.
	</para>

	<para>
	  <xref linkend="fig_boundary_scan_chips"/> shows a board with two
	  chips, A and B, each with three inputs (numbered 1 to 3) and three
	  outputs (numbered 4 to 6).
	</para>
	  
	<figure id="fig_boundary_scan_chips">
	  <title>
	    Boundary scan example: two chips
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-1.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-1.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  These chips are interconnected as shown in <xref
	  linkend="fig_boundary_scan_connections"/>. Output pins 5 and 6 of
	  chip A are connected to the input pins 1 and 3 of chip B
	  respectively. Output pins 4 and 6 of chip B are connected to input
	  pins 1 and 2 of chip A respectively. The other pins are not
	  connected.
	</para>

	<figure id="fig_boundary_scan_connections">
	  <title>
	    Boundary scan example: chip interconnections
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-2.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-2.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The objective of boundary scanning is to determine that the inputs
	  and outputs which should be connected, are connected, and that those
	  which should not be connected are not connected.
	</para>

	<para>
	  Boundary scan adds a simple logic cell (a <emphasis>scan
	  cell</emphasis>) to each input and output, which can record the
	  current state of that input or output as shown in <xref
	  linkend="fig_boundary_scan_cells"/>.
	</para>

	<figure id="fig_boundary_scan_cells">
	  <title>
	    Boundary scan example: scan cells on inputs and outputs
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-3.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-3.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Normally the cell has no impact on the input or output. However the
	  cells may be directed to <emphasis>capture</emphasis> the current
	  state of the input or output. For inputs, the signal about to leave
	  the chip is captured in the cell. For outputs, the signal about to
	  enter the chip is captured in the cell.
	</para>

	<para>
	  The cells may also be directed to <emphasis>update</emphasis> their
	  associated input or output. For inputs the stored value is injected
	  onto the external connection. For outputs the stored value is
	  injected into the chip.
	</para>

	<note>
	  <para>
	    There is a single signal controlling all the cells. So they will
	    all capture or update their associated value at the same time.
	  </para>
	</note>

	<para>
	  The final component of boundary scan is to connect all the scan
	  cells together in a chain, so that each cell can transfer its value
	  to the adjacent cell. This is shown in <xref
	  linkend="fig_boundary_scan_full"/>.
	</para>

	<figure id="fig_boundary_scan_full">
	  <title>
	    Boundary scan example: scan cells connected
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-4.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="boundary-scan-4.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The connected cells form a large shift register, with one bit for
	  each input and output. The cells may be directed to
	  <emphasis>shift</emphasis> their value to the adjacent cell. A
	  sequence of shifts allows all the cells to be changed and all their
	  values to be read out.
	</para>

	<para>
	  In the example shown, the cells form a 12-bit shift register, as
	  shown in <xref linkend="fig_shift_register"/>.
	</para>

	<figure id="fig_shift_register">
	  <title>
	    Boundary scan example: shift register
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="shift-register.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="shift-register.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  A sequence of <emphasis>capture</emphasis>, followed by twelve
	  <emphasis>shifts</emphasis> and then <emphasis>update</emphasis>
	  allows the current state of each input to be recorded externally, a
	  new set of values to be set and then injected onto the
	  connections. In this way each input can be tested to check that when
	  it is changed, its connected output changes.
	</para>

      </sect2>

      <sect2>
	<title>
	  &jtag; Chip Architecture
	</title>

	<para>
	  IEEE 1149.1 describes a simple architecture for chips implementing
	  boundary scan testing. In its minimal configuration, it provides
	  four external pins, a clock (&tck;), data in (&tdi;), data out
	  (&tdo;) and a management signal (&tms;). Collectively these pins are
	  known as the <emphasis>Test Access Port</emphasis> (&tap;).
	</para>

	<para>
	  Internally there are two registers in addition to the boundary scan
	  register: the instruction register and the bypass
	  register. <xref linkend="fig_jtag_architecture_minimal"/> shows
	  this minimal architecture.
	</para>

	<figure id="fig_jtag_architecture_minimal">
	  <title>
	    &jtag; minimal architecture
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="jtag-architecture-1.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="jtag-architecture-1.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Bits are shifted in on the positive edge of &tck; and shifted out on
	  the negative edge. The &tms; signal is used to control the register
	  into which the bits are shifted (instruction register, bypass
	  register or boundary scan register). &tms; usage is described more
	  fully below.
	</para>

	<para>
	  The basic cycle of operation is a sequence of
	  <emphasis>capture</emphasis> a register, <emphasis>shift</emphasis>
	  in a new value from &tdi;, while simultaneously shifting out the old
	  value on &tdo;, then <emphasis>update</emphasis> the register with the
	  value shifted in.
	</para>

	<para>
	  The &tap; controller can shift values either through the instruction
	  register or through one of the other registers (collectively known
	  as <emphasis>data registers</emphasis>). In the minimal
	  configuration there are only two data registers: the boundary scan
	  register and the <emphasis>bypass register</emphasis>. The bypass
	  register is a convenient mechanism when boundary scan testing is not
	  being used.
	</para>

	<para>
	  The <emphasis>instruction register</emphasis> must be at least 2
	  bits long. IEEE 1149.1 requires a minimum of 4 instructions:
	</para>

	<variablelist termlength="2.5cm">
	  <varlistentry>
	    <term><literal>BYPASS</literal></term>
	    <listitem>
	      <para>
		Capture, shift and update data through the bypass entry. This
		allows the chip to continue its normal operation. IEEE 1149.1
		requires this instruction to consist of all 1's.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>SAMPLE</literal></term>
	    <listitem>
	      <para>
		Capture and shift data through the boundary scan register,
		thus taking a sample of the data entering and leaving the chip
		via its inputs and outputs. However the update phase does not
		drive data onto inputs or outputs.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>PRELOAD</literal></term>
	    <listitem>
	      <para>
		Shift data through the boundary scan register, thus setting up
		a value in the scan cells for future use. For this
		instruction, the capture phase does not get the previous value
		into the cell and the update phase does not drive data onto
		inputs or outputs.
	      </para>

	      <para>
		In early versions of the standard, this instruction was
		combined with <literal>SAMPLE</literal>.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>EXTEST</literal></term>
	    <listitem>
	      <para>
		The chip is placed in <emphasis>extest mode</emphasis> before
		data is captured, shifted and updated through the boundary
		scan register.
	      </para>

	      <para>
		This is used to test connectivity between multiple chips. In
		<emphasis>extest mode</emphasis> the chip does not try to
		drive outputs or accept inputs. It is normal to use
		<literal>PRELOAD</literal> to set up the boundary scan
		register prior to <literal>EXTEST</literal>.
	      </para>

	      <para>
		Early versions of IEEE 1149.1 required this instruction to
		consist of all 0's, although this is not the case in more
		recent versions.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<sect3>
	  <title id="sec_tap_state_machine">
	    &tap; State Machine
	  </title>

	  <para>
	    The &tck; and &tms; signals drive a finite state machine in the &tap;
	    controller. &tms; is sampled on the rising edge of &tck; and used to
	    advance the state. The state machine is shown in <xref
	    linkend="fig_tap_state_machine"/>.
	  </para>

	  <figure id="fig_tap_state_machine">
	    <title>
	      &tap; state machine
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="tap-state-machine.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="tap-state-machine.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The actions taken in each state are as follows:
	  </para>

	  <variablelist termlength="3.5cm">
	    <varlistentry>
	      <term>
		Test-Logic-Reset
	      </term>
	      <listitem>
		<para>
		  In this state all test-modes (for example extest-mode) are
		  reset, which will disable their operation, allowing the chip
		  to follow its normal operation.
		</para>

		<para>
		  At start-up the external logic will drive &tms; high for at
		  least 5 &tck; cycles. This guarantees to reach the
		  Test-Logic-Reset state and remain there.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Run-Test/Idle
	      </term>
	      <listitem>
		<para>
		  This is the resting state during normal operation.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Select-DR-Scan
	      </term>
	      <term>
		Select-IR-Scan
	      </term>
	      <listitem>
		<para>
		  These are the starting states respectively for accessing one
		  of the data registers (the boundary-scan or bypass register
		  in the minimal configuration) or the instruction register.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Capture-DR
	      </term>
	      <term>
		Capture-IR
	      </term>
	      <listitem>
		<para>
		  These capture the current value of one of the data registers
		  or the instruction register respectively into the scan
		  cells.
		</para>

		<para>
		  This is a slight misnomer for the instruction register,
		  since it is usual to capture status information, rather than
		  the actual instruction with Capture-IR.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Shift-DR
	      </term>
	      <term>
		Shift-IR
	      </term>
	      <listitem>
		<para>
		  Shift a bit in from &tdi; (on the rising edge of &tck;) and out
		  onto &tdo; (on the falling edge of &tck;) from the currently
		  selected data or instruction register respectively.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Exit1-DR
	      </term>
	      <term>
		Exit1-IR
	      </term>
	      <listitem>
		<para>
		  These are the exit states for the corresponding shift
		  state. From here the state machine can either enter a pause
		  state or enter the update state.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Pause-DR
	      </term>
	      <term>
		Pause-IR
	      </term>
	      <listitem>
		<para>
		  Pause in shifting data into the data or instruction
		  register. This allows for example test equipment supplying
		  &tdo; to reload buffers etc.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Exit2-DR
	      </term>
	      <term>
		Exit2-IR
	      </term>
	      <listitem>
		<para>
		  These are the exit states for the corresponding pause
		  state. From here the state machine can either resume
		  shifting or enter the update state.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>
		Update-DR
	      </term>
	      <term>
		Update-IR
	      </term>
	      <listitem>
		<para>
		  The value shifted into the scan cells during the previous
		  states is driven into the chip (from inputs) or onto the
		  interconnect (for outputs).
		</para>
	      </listitem>
	    </varlistentry>

	  </variablelist>
    
	  <para>
	    So we have a simple state machine, which allows either data
	    registers or the instruction register to go through its
	    capture-shift-update cycle, with an option to pause during the
	    shifting.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    Extending &jtag;
	  </title>

	  <para>
	    IEEE 1149.1 specifies an optional asynchronous reset pin, &trst;,
	    an optional identification register and a number of optional
	    instructions that may be included. The extended architecture is
	    shown in <xref linkend="fig_jtag_architecture_options"/>.
	  </para>

	  <figure id="fig_jtag_architecture_options">
	    <title>
	      &jtag; architecture with optional reset port and ID register
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="jtag-architecture-2.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="jtag-architecture-2.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The reset pin, &trst;, is active low. If driven low it immediately
	    takes the state machine to the Test-Logic-Reset state.
	  </para>

	  <note>
	    <para>
	      If &trst; is not present, a synchronous reset can always be
	      achieved by driving &tms; high for 5 &tck; cycles.
	    </para>
	  </note>

	  <para>
	    The <emphasis>device identification register</emphasis> is a
	    32-bit data register. It identifies version and part number for
	    both manufacture and user. It can be read using the optional
	    <literal>ICODE</literal> and <literal>USERCODE</literal>
	    instructions.
	  </para>

	  <para>
	    Additional instructions also support <literal>INTEST</literal>
	    (like <literal>EXTEST</literal>, but with on-chip test data),
	    <literal>RUNBIST</literal> (to run comprehensive
	    <emphasis>Built-in Self Test</emphasis> logic),
	    <literal>CLAMP</literal> (to clamp outputs to predefined logic
	    levels) and <literal>HIGHZ</literal> (to set all outputs to the
	    disabled (high impedance) state).
	  </para>
	</sect3>

	<sect3>
	  <title>
	    Adding User Specific Registers to &jtag;
	  </title>

	  <para>
	    &jtag; provides a generic mechanism for accessing registers on
	    chip. The standard allows the architecture to be extended with user
	    registers, accessed using the user's own instructions. <xref
	    linkend="fig_jtag_architecture_user_registers"/> shows how these
	    registers may be added.
	  </para>

	  <figure id="fig_jtag_architecture_user_registers">
	    <title>
	      &jtag; architecture with user registers
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="jtag-architecture-3.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="jtag-architecture-3.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The user will add their own instructions to access these
	    additional registers. This is a common mechanism to interface to
	    debug units on modern system-on-chip (&soc;) designs.
	  </para>

	</sect3>

      </sect2>

    </sect1>

    <sect1>
      <title>
	&osci; &systemc; IEEE 1666
      </title>

      <para>
	The development of &systemc; as a standard for modeling hardware
	started in 1996. Version 2.0 of the proposed standard was released by
	the Open &systemc; Initiative (&osci;) in 2002. In 2006, &systemc;
	became IEEE standard 1666-2005 <xref linkend="ref_ieee_systemc" />.
      </para>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one of the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling, particularly the
	parallelism of hardware, in a mainstream programming
	language.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc;, even though it is a hardware
	modeling language. Rather than invent a new language, &systemc; is
	based on the existing C++ language. &systemc; is a true super-set of
	C++, so any C++ program is automatically a valid &systemc; program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    A C++ class, <classname>sc_module</classname>, suitable for
	    defining hardware modules containing parallel
	    processes.
	  </para>

	  <note>
	    <para>
	      <emphasis>Process</emphasis> is a general term in &systemc;
	      to describe the various ways of representing parallel flows
	      of control. It has nothing to do with processes in the &linux;
	      or Microsoft Windows operating systems.
	    </para>
	  </note>
	</listitem>

	<listitem>
	  <para>
	    A mechanism to define functions modeling the parallel
	    threads of control within <classname>sc_module</classname>
	    classes;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Two classes, <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent points of
	    connection to and from a <classname>sc_module</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_interface</classname> to describe the
	    software services required by a <classname>sc_port</classname>
	    or provided by a <classname>sc_export</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_prim_channel</classname> to represent the
	    channel connecting ports;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A set of derived classes, of
	    <classname>sc_prim_channel</classname>,
	    <classname>sc_interface</classname>,
	    <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent and connect common
	    channel types used in hardware design such as signals, buffers and
	    FIFOs; and
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A comprehensive set of types to represent data in both
	    <firstterm>2-state</firstterm> and <firstterm>4-state</firstterm>
	    logic.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The full specification is 441 pages long <xref
	linkend="ref_ieee_systemc" />. The &osci; reference distribution
	includes a very useful introductory user guide and tutorial <xref
	linkend="ref_osci_systemc_ug" />.
      </para>
	
    </sect1>

  </chapter>

  <chapter>
    <title>
      Cycle Accurate &systemc; &jtag; Interface
    </title>

    <para>
      This interface is designed for modeling environments which are both
      cycle accurate and pin accurate. In other words the state of each &jtag;
      &tap; port is accurately modeled on each bus cycle.
    </para>

    <para>
      The objective is to provide a level of abstraction, so the user can
      concentrate on the modeling of register access through &jtag;, rather than
      the minutiae of the &tap; state machine and &tap; signal states
    </para>

    <sect1>
      <title>
	Abstract Representation of the &jtag; Interface
      </title>

      <para>
	&jtag; offers fundamentally two operations: scan bits through
	the instruction register or scan bits through a data register. The
	only other operation required is the ability to reset the &tap;
	controller.
      </para>

      <para>
	The &systemc; interface reflects this, with classes representing a &tap;
	instruction register scan (<classname>TapActionScanIR</classname>), a
	&tap; data register scan (<classname>TapActionScanDR</classname>) and
	reset (<classname>TapActionReset</classname>).
      </para>

      <para>
	The interface provides a &systemc; module class representing the
	&jtag; interface, <classname>JtagSC</classname>. The user can queue IR
	scan, DR scan and reset operations and <classname>JtagSC</classname>
	will generate the correct sequence of &tap; pin outputs.
      </para>

    </sect1>

    <sect1 id="sec_api">
      <title>
	Application Programming Interface (&api;)
      </title>

      <sect2>
	<title>
	  &tap; Action Classes
	</title>

	<para>
	  &tap; actions are represented by the abstract C++ class,
	  <classname>TapAction</classname>. The three specific actions for
	  reset, scan IR and scan DR are sub-classed from this. <xref
	  linkend="fig_tap_action_class_diagram"/> shows this relationship and
	  summarizes the public interface as a class diagram.
	</para>

	  <figure id="fig_tap_action_class_diagram">
	    <title>
	      Class diagram for <classname>JtagAction</classname> and
	      subclasses
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="tap-action-class-diagram.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="tap-action-class-diagram.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <sect3>
	    <title>
	      <classname>TapActionReset</classname>
	    </title>

	    <para>
	      This class represents a reset action for the &tap; controller.
	      There are no publicly accessible member variables of this
	      class. The public methods are:
	    </para>

	    <itemizedlist>
	      <listitem>
		<programlisting>
TapActionReset (sc_core::sc_event *_doneEvent)
		</programlisting>

		<para>
		  The constructor for new &tap; reset actions. It is passed a
		  pointer to a &systemc; event in <varname>_doneEvent</varname>,
		  which will be notified when the action is complete.
		</para>
	      </listitem>
	    </itemizedlist>

	  </sect3>

	  <sect3>
	    <title>
	      <classname>TapActionIRScan</classname>
	    </title>

	    <para>
	      This class represents the action of scanning a value through the
	      instruction register. There are no publicly accessible member
	      variables of this class. The public methods are:
	    </para>

	    <itemizedlist>
	      <listitem>
		<programlisting>
TapActionIRScan (sc_core::sc_event *_doneEvent,
                 uint32_t           _iRegIn,
                 int                _iRegSize)
		</programlisting>

		<para>
		  The constructor for new &tap; IR scan actions. It is passed
		  a pointer to a &systemc; event in
		  <varname>_doneEvent</varname>, which will be notified when
		  the action is complete.
		</para>

		<para>
		  The value to be scanned in (which will form the sequence of
		  bits on &tdi;) is represented as a 32-bit integer in
		  <varname>iRegIn</varname>. The actual number of bits to be
		  scanned is an integer in <varname>_iRegSize</varname>.
		</para>

		<para>
		  32-bits seems a reasonable limit for the size of instruction
		  register in any realistic &jtag; architecture.
		</para>
	      </listitem>

	      <listitem>
		<programlisting>
uint32_t  getIRegOut ();
		</programlisting>

		<para>
		  On completion of the action (as signaled through the
		  &systemc; event pointed to by <varname>_doneEvent</varname>
		  this method will return the information that was scanned out
		  of the instruction register. That is the sequence of bits
		  that have appeared on &tdo;
		</para>

		<para>
		  As noted above, in the case of the instruction register this
		  is not the actual value of the instruction, but some status
		  bits about the interface.
		</para>
	      </listitem>
	    </itemizedlist>

	  </sect3>

	  <sect3>
	    <title>
	      <classname>TapActionDRScan</classname>
	    </title>


	    <para>
	      This class represents the action of scanning a value through a
	      data register. This is more complex, because data
	      registers are potentially very large&mdash;often larger than the
	      64-bits the largest integer that can be held in a single C++
	      variable.
	    </para>

	    <para>
	      To support this, values are represented as an array of 64-bit
	      unsigned integers (<type>uint64_t</type>). However, for
	      efficient handling of smaller data registers, variants are
	      provided which represent the register in a single 64-bit
	      <type>uint64_t</type>.
	    </para>

	    <para>
	      There are no publicly accessible member variables of this
	      class. The public methods are:
	    </para>

	    <itemizedlist>
	      <listitem>
		<programlisting>
TapActionDRScan (sc_core::sc_event *_doneEvent,
                 uint64_t           _dRegInArray[],
                 int                _dRegSize)
		</programlisting>

		<para>
		  The constructor for new DR scan actions. It is passed a
		  &systemc; event in <varname>_doneEvent</varname>, which will
		  be notified when the action is complete.
		</para>

		<para>
		  The value to be scanned in (which will form the sequence of
		  bits on &tdi;) is represented as an array of 64-bit unsigned
		  integers in <varname>dRegInArray</varname>. The actual
		  number of bits to be scanned is an integer in
		  <varname>_dRegSize</varname>.
		</para>

		<para>
		  This interface allows data registers of any size to be
		  handled. However if this constructor is used for a small
		  value it will automatically use the more efficient
		  constructor described next.
		</para>
	      </listitem>

	      <listitem>
		<programlisting>
TapActionDRScan (sc_core::sc_event *_doneEvent,
                 uint64_t           _dRegIn,
                 int                _dRegSize)
		</programlisting>

		<para>
		  An alternative constructor for smaller registers (up to
		  64-bits). This is for use where the data to be scanned in is
		  up to 64-bits long. It can be used for larger registers, so
		  long as the actual value to be scanned in is only 64 bits or
		  fewer.
		</para>

		<para>
		  The constructor is passed a &systemc; event in
		  <varname>_doneEvent</varname>, which will be notified when
		  the action is complete.
		</para>

		<para>
		  The value to be scanned in (which will form the sequence of
		  bits on &tdi;) is supplied as a 64-bit unsigned integer in
		  <varname>dRegIn</varname>. The actual number of bits to be
		  scanned is an integer in <varname>_dRegSize</varname>.
		</para>
	      </listitem>

	      <listitem>
		<programlisting>
~TapActionDRScan ()
		</programlisting>

		<para>
		  The destructor for DR scan actions. When handling more than
		  64 bits, arrays are allocated for internal data. If such
		  arrays have been created, the destructor deletes them.
		</para>
	      </listitem>

	      <listitem>
		<programlisting>
void  getDRegOut (uint64_t  dRegArray[])
		</programlisting>

		<para>
		  On completion of the action (as signaled through the
		  &systemc; event pointed to by <varname>_doneEvent</varname>
		  this method will return the information that was scanned out
		  of the instruction register. That is, the sequence of bits
		  that have appeared on &tdo;
		</para>

		<para>
		  The result is copied into the <type>uint64_t</type> array
		  supplied in <varname>dRegArray</varname>. This interface can
		  be used, even if this is a small register that can be held
		  in a single variable. The result will be copied into
		  <literal>dRegArray[0]</literal>.
		</para>
	      </listitem>

	      <listitem>
		<programlisting>
uint64_t  getDRegOut ();
		</programlisting>

		<para>
		  On completion of the action (as signaled through the
		  &systemc; event pointed to by <varname>_doneEvent</varname>
		  this method will return the information that was scanned out
		  of the instruction register. That is, the sequence of bits
		  that have appeared on &tdo;.
		</para>

		<para>
		  The value returned can be no larger than 64-bits. However
		  this call may be used with a larger data register, in which
		  case it will return the least significant 64 bits.
		</para>
	      </listitem>

	    </itemizedlist>

	  </sect3>
	      
      </sect2>

      <sect2>
	<title>
	  The <classname>JtagSC</classname> &systemc; Module Class
	</title>

	<para>
	  This &systemc; module class provides the primary interface. Users can
	  queue instances of <classname>TapAction</classname> on its FIFO and
	  it will generate the correct sequence of &jtag; tap pin signals.
	</para>

	<para>
	  <classname>JtasSC</classname> defines a set of signal ports to
	  connect to the target model implementing &jtag;
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
sc_core::sc_in&lt;bool&gt;  sysReset
	    </programlisting>

	    <para>
	      <emphasis>Input</emphasis>. The system wide reset signal (active
	      high). Whenever this is active <classname>JtagSC</classname> will
	      drive the &trst; signal to its active state (low).
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
sc_core::sc_in&lt;bool&gt;  tck
	    </programlisting>

	    <para>
	      <emphasis>Input</emphasis>. The &jtag; clock signal. This must be
	      synchronous with the &tck; signals to connected devices
	      implementing &jtag;
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
sc_core::sc_out&lt;bool&gt;  tdi
	    </programlisting>

	    <para>
	      <emphasis>Output</emphasis>. The &tdi; signal. For
	      <classname>JtagSC</classname> it is an
	      <emphasis>output</emphasis>, because this class is generating
	      the required signals on &tdi; from the actions which have been
	      queued.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
sc_core::sc_in&lt;bool&gt;  tdo
	    </programlisting>

	    <para>
	      <emphasis>Input</emphasis>. The &tdo; signal. For
	      <classname>JtagSC</classname> it is an
	      <emphasis>output</emphasis> from which the result of the actions
	      which have been queued is built up
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
sc_core::sc_out&lt;bool&gt;  tms
	    </programlisting>

	    <para>
	      <emphasis>Output</emphasis>. The &tms; signal. For
	      <classname>JtagSC</classname> it is an
	      <emphasis>output</emphasis>, because this class is generating
	      the required signals to drive the &tap; state machine from the
	      actions which have been queued.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
sc_core::sc_out&lt;bool&gt;  trst
	    </programlisting>

	    <para>
	      <emphasis>Output</emphasis>. The &trst; signal. Driven low
	      (active) whenever the system reset (<varname>sysReset</varname>)
	      is active (high). For <classname>JtagSC</classname> it is an
	      <emphasis>output</emphasis>, because this class generates the
	      reset when required.
	    </para>

	    <para>
	      Users connecting to modules which do not implement &trst; should
	      tie this off to a dummy signal
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  <classname>JtasSC</classname> defines a FIFO on which users queue
	  &jtag; actions.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
sc_core::sc_fifo&lt;TapAction *&gt; *tapActionQueue
	    </programlisting>

	    <para>
	      The &jtag; actions are of type <classname>TapAction</classname>
	      and its subclasses. Over successive &tck; cycles, the
	      <classname>JtagSC</classname> will generate the required &tms; and
	      &tdi; signals and capture the &tdo; signals. When complete the
	      &systemc; <classname>sc_event</classname> from the action's
	      creation is signaled.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  The public methods of <classname>JtagSC</classname> are:
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
JtagSC (sc_core::sc_module_name  name,
        int                      fifo_size = DEFAULT_TAP_FIFO_SIZE)
	    </programlisting>

	    <para>
	      The constructor of new &jtag; modules. The first argument,
	      <varname>name</varname>, like all &systemc; modules, is the name
	      of the module. The optional second argument specifies the size
	      of FIFO on which actions may be queued. Its default value,
	      <constant>DEFAULT_TAP_FIFO_SIZE</constant> is 256 in the current
	      implementation.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
~JtagSC ()
	    </programlisting>

	    <para>
	      The destructor for &jtag; modules. This deletes the FIFO and a
	      number of internal data structures.
	    </para>
	  </listitem>

	</itemizedlist>
      </sect2>

      <sect2>
	<title>
	  Using the Interface
	</title>

	<para>
	  The user should instantiate an instance of
	  <classname>JtagSC</classname> for each &jtag; interface on the
	  target model. The <classname>JtagSC</classname> ports should be
	  connected to the system reset and &tap; signal ports on the model
	  using &systemc; signals of type
	  <classname>sc_signal&lt;bool&gt;</classname>.
	</para>

	<para>
	  Other &systemc; modules may then queue actions by writing instances of
	  <classname>TapActionReset</classname>,
	  <classname>TapActionIRScan</classname> and
	  <classname>TapActionDRScan</classname> to the
	  <classname>JtagSC</classname> FIFO. This is normally within the
	  context of a <function>SC_THREAD</function>, allowing the module to
	  <function>wait</function> for notification when each action is
	  complete.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Installation
      </title>

      <para>
	The current implementation has been verified under Fedora 9 Linux
	using OSCI &systemc; 2.2 and GCC 4.3.0. The author welcomes feedback
	about use under other operating systems.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Unpack the source file, and change to the directory where the
	    source is unpacked.
	  </para>

	  <programlisting>
jxf embecosm-esp4-sysc-jtag-ca-1.0.tar.bz2
cd embecosm-esp4-sysc-jtag-ca-1.0
	  </programlisting>
	</listitem>

	<listitem>
	  <para>
	    Ensure the environment variable <envar>SYSTEMC</envar> is set to
	    point to your &systemc; distribution.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Build the cycle accurate &systemc; &jtag; library.
	  </para>

	  <programlisting>
make
	  </programlisting>
	</listitem>

	<listitem>
	  <para>
	    In the current implementation, there is no
	    <literal>make&nbsp;install</literal>. Copy the resulting
	    <filename>libjtagsc.a</filename> library and
	    <filename>jtagsc.h</filename> header to the library and header
	    directories of choice if desired.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	To use the library, add the header directory to the GCC preprocessor
	flags and the library directory and library to the final linking
	command line. For example.
      </para>

      <programlisting>
gcc -Iembecosm-esp4-sysc-jtag-ca-1.0 testprog.cpp
gdd -Lembecosm-esp4-sysc-jtag-ca-1.0 testprog.o -ljtagsc -o testprog
      </programlisting>

    </sect1>
	
    <sect1>
      <title>
	Implementation Detail
      </title>

      <para>
	Each class described in the &api; is implemented as a header file
	defining the class and a code file with implementation of all the
	methods. So the class <classname>JtagSC</classname> is defined in
	<filename>JtagSC.h</filename> and implemented in
	<filename>JtagSC.cpp</filename>.
      </para>

      <para>
	In addition to the classes described in <xref linkend="sec_api"/>,
	there is one more class, <classname>TapStateMachine</classname>,
	implementing the behavior of the &tap; state machine.
      </para>

      <para>
	The following sections provide brief notes on the implementation of
	each class.
      </para>

      <sect2>
	<title>
	  <classname>JtagSC</classname>
	</title>

	<para>
	  In addition to the public instance variables which form part of the
	  &api;, the main &jtag; module maintains some private state.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
TapStateMachine *stateMachine
	    </programlisting>

	    <para>
	      This is an instance of the &tap; state machine class (see <xref
	      linkend="sec_tap_state_machine_class"/>), modeling the &tap;
	      state machine in the target to which this module is connected.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
TapAction *currentTapAction
	    </programlisting>

	    <para>
	      This is the &jtag; action currently being processed through the
	      &tap; state machine. It has already been read from the FIFO.
	    </para>
	  </listitem>
	</itemizedlist>

	<sect3>
	  <title>
	    Constructor and Destructor Implementation
	  </title>

	  <para>
	    The constructor initializes the current &tap; action
	    (<varname>currentTapAction</varname>) to <constant>NULL</constant>
	    and allocates new instances of the FIFO
	    (<classname>sc_fifo</classname>) and the &tap; state machine
	    (<classname>TapStateMachine</classname>).
	  </para>

	  <para>
	    It also declares the protected method
	    <function>processActions</function> to be a &systemc; method
	    (<literal>SC_METHOD</literal>), sensitive to the rising &tck;
	    (<literal>tck.pos()</literal>). It is this method that is
	    responsible for progressing the queued actions on each clock
	    cycle.
	  </para>

	  <para>
	    The destructor deletes the FIFO and &tap; state machine to free
	    the memory on completion.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>processActions</function>
	  </title>

	  <para>
	    This function is declared in the constructor as a &systemc;
	    <literal>SC_METHOD</literal>. It is invoked on every rising edge
	    of &tck;.
	  </para>

	  <para>
	    &trst; takes its value as the inverse of the System reset (since it
	    is active low, while the latter is active high). If the system is
	    in reset, there is nothing else to do and the method returns.
	  </para>

	  <para>
	    If there is no &tap; action currently being processed
	    (i.e. <varname>currentTapAction</varname> is
	    <constant>NULL</constant>) then the method attempts a non-blocking
	    read from the FIFO.
	  </para>

	  <para>
	    If no new action is available from the FIFO, then &tms; is driven to
	    the appropriate state to move towards the Run-Test/Idle
	    state and the method returns.
	  </para>

	  <para>
	    Having obtained (or already in progress of) a &tap; action, its
	    <function>process</function> method is invoked. This takes the
	    current state machine and &tdo; and returns (via parameters) new
	    values of &tdi; and &tms;. It returns success if this completes the
	    action.
	  </para>

	  <para>
	    In the event of successful completion, the &systemc; event
	    associated with the action is notified, and
	    <varname>currentTapAction</varname> marked null, so a new action
	    will be obtained from the FIFO on the next cycle.
	  </para>

	  <para>
	    The state machine is then advanced to its next state (based on the
	    value of &tms;), and the values of &tms; and &tdi; used to drive the
	    &systemc; signals in <varname>tdi_o</varname> and
	    <varname>tms_o</varname>.
	  </para>

	  <note>
	    <para>
	      This function is only called on the positive edge of the clock,
	      although &tdo; changes on the negative edge. However the value
	      will still be there at the positive edge in all practical
	      designs, so an additional call (with the associated
	      computational overhead) is not required.
	    </para>
	  </note>

	</sect3>

      </sect2>

      <sect2 id="sec_tap_action_class">
	<title>
	  <classname>TapAction</classname>
	</title>

	<para>
	  This is the abstract base class of all the &tap; action classes. It
	  provides the common interface, expected by
	  <classname>JtagSC</classname>.
	</para>

	<para>
	  <classname>JtagSC</classname> is declared a
	  <literal>friend</literal> class and the pure virtual
	  <function>process</function> method is made protected. This method
	  can therefore be called by <classname>JtagSC</classname>, but not by
	  other users of the class. Subclasses of
	  <classname>TapAction</classname> are expected to implement this
	  method.
	</para>

	<para>
	  Although there are no public instance variables which form part of the
	  &api;, <classname>TapAction</classname> maintains some private state.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
sc_core::sc_event *doneEvent
	    </programlisting>

	    <para>
	      The &systemc; event which will be notified when an action
	      completes.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
int  resetCounter
	    </programlisting>

	    <para>
	      A counter for use when resetting the &tap; state machine of the
	      target through <function>checkResetDone</function> (see below).
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  In addition to the pure virtual <function>process</function> method,
	  <classname>TapAction</classname> provides the function
	  <function>checkResetDone</function> (see below) as a utility for its
	  subclasses.
	</para>

	<sect3>
	  <title>
	    <function>checkResetDone</function>
	  </title>

	  <para>
	    The <classname>TapActionIRScan</classname> and
	    <classname>TapActionDRScan</classname> subclasses rely on the
	    &tap; state machine in <classname>JtagSC</classname> being an
	    accurate reflection of the &tap; state machine in the target. This
	    can only be the case if both have been through a synchronous reset
	    cycle (5 or more &tms;=1 cycles).
	  </para>

	  <para>
	    The &trst; signal cannot be used as a guide, since it is an optional
	    signal, which may not be implemented by targets.
	  </para>

	  <para>
	    Instead the &tap; state machine class,
	    <classname>TapStateMachine</classname> records whether it has been
	    through a reset cycle. It relies on other classes to use (and set)
	    this information as is helpful.
	  </para>

	  <para>
	    Both <classname>TapActionIRScan</classname> and
	    <classname>TapActionDRScan</classname> check this information, and
	    if necessary force the state machine through a reset to
	    synchronize with the model.
	  </para>

	  <para>
	    This method is a utility to provide that function for
	    subclasses. A subtlety of its implementation is that it sets the
	    value of the &tap; state machine flag as soon as it has provided
	    the final (fifth) &tms; signal, but does not return
	    <literal>true</literal> to indicate no reset is needed until its
	    subsequent call. This allows users to distinguish whether they are
	    about to complete reset, or have already completed it in the
	    previous &tck; cycle. This in turn allows the method to provide the
	    functionality for <classname>TapActionReset</classname>.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  <classname>TapActionReset</classname>
	</title>

	<para>
	  This is the simplest of the <classname>TapAction</classname>
	  subclasses, implementing a &jtag; reset cycle. It has a sole private
	  instance variable.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
bool  firstTime
	    </programlisting>

	    <para>
	      This is used to track the first call of the
	      <function>process</function> method.
	    </para>
	  </listitem>
	</itemizedlist>

	<sect3>
	  <title>
	    Constructor
	  </title>

	  <para>
	    The constructor's key action is to set the
	    <varname>firstTime</varname> instance variable to
	    <constant>true</constant>.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>process</function>
	  </title>

	  <para>
	    On the first cycle through, the &tap; state machine's
	    <varname>resetDone</varname> flag is cleared.
	  </para>

	  <para>
	    This allows the base class <function>checkResetDone</function>
	    method to be used to drive the reset.
	  </para>

	  <para>
	    In this case completion is when the &tap; state machine records
	    the reset is done, not when the
	    <function>checkResetDone</function> function returns
	    <constant>true</constant>. This means completion is signaled on
	    the final reset cycle, rather than after the final reset
	    cycle. See <xref linkend="sec_tap_action_class"/> for the
	    explanation of this behavior.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  <classname>TapActionIRScan</classname>
	</title>

	<para>
	  This class implements capture, shift and update of a value through
	  the instruction register. It has a number of private instance
	  variables.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
uint32_t  iRegIn
	    </programlisting>

	    <para>
	      This is the value being shifted in through &tdi;. It holds the
	      remaining bits to be shifted.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
int  iRegSize
	    </programlisting>

	    <para>
	      This is the number of bits to be shifted in through &tdi; and out
	      through &tdo;
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint32_t  iRegOut
	    </programlisting>

	    <para>
	      This is the value being shifted out through &tdo;. It holds the
	      bits shifted out so far.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
int       bitsShifted
	    </programlisting>

	    <para>
	      The number of bits shifted in so far.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
enum {
    SHIFT_IR_PREPARING,
    SHIFT_IR_SHIFTING,
    SHIFT_IR_UPDATING
  } iRScanState
	    </programlisting>

	    <para>
	      This enumeration records where the action is in its process. The
	      <function>process</function> method follows a state machine (see
	      below) whose state is recorded here.
	    </para>
	  </listitem>

	</itemizedlist>

	<sect3>
	  <title>
	    Constructor
	  </title>

	  <para>
	    The primary responsibility of the constructor is to initialize all
	    the instance variables. The input register and size are taken from
	    the arguments, the output register and count of bits shifted are
	    zeroed and the IR-Scan process state machine is set to
	    <constant>SHIFT_IR_PREPARING</constant>.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>process</function>
	  </title>

	  <para>
	    This method generates the appropriate values of &tdi; and &tms; to
	    process the action and capture &tdi;. It is controlled by its own
	    state machine, whose state is recorded in
	    <varname>iRScanState</varname> as shown in <xref
	    linkend="fig_instruction_state_machine"/>
	  </para>

	  <figure id="fig_instruction_state_machine">
	    <title>
	      State machine for the <classname>JtagActionIRScan</classname>
	      process.
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="instruction-state-machine.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="instruction-state-machine.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    A subtlety of the implementation is that, because &tdo; changes on
	    the <emphasis>falling</emphasis> edge, its value is always one
	    step later than that of &tdi;. Thus &tdo; is not captured on the first
	    cycle in Shift-IR state and its last bit is captured immediately
	    after leaving Shift-IR state.
	  </para>
	</sect3>

	<sect3>
	  <title>
	    <function>getIRegOut</function>
	  </title>

	  <para>
	    This function is part of the public &api;, allowing the user to
	    access the value shifted through &tdo; on completion.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  <classname>TapActionDRScan</classname>
	</title>

	<para>
	  This class implements capture, shift and update of a value through a
	  data register. Functionally it is very similar to
	  <classname>TapActionIRScan</classname>. However complexity is added,
	  because data registers may be too large for a single C++ variable,
	  so must be represented in
	  arrays. <classname>TapActionDRScan</classname> has a number of
	  private instance variables.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
int  dRegBitSize
	    </programlisting>

	    <para>
	      This is the number of bits to be shifted in through &tdi; and out
	      through &tdo;.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
int  dRegWordSize
	    </programlisting>

	    <para>
	      If <varname>dRegBitSize</varname> is more than 64, this is the
	      number of elements in the <type>uint64_t</type> array used to
	      represent the input and output registers, with the least
	      significant bits in element 0.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint64_t  topMask
	    </programlisting>

	    <para>
	      If register values are held in an array
	      (i.e. <varname>dRegBitSize</varname> is more than 64), any odd
	      number of bits (if <varname>dRegBitSize</varname> is not an
	      exact multiple of 64) are held in the most significant element
	      of the array. This is a mask for those bits.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint64_t *dRegInArray
	    </programlisting>

	    <para>
	      When the registers are held in an array
	      (i.e. <varname>dRegBitSize</varname> is more than 64), this is a
	      pointer to the array representing the value being shifted in
	      through &tdi;. It holds the remaining bits to be shifted.
	    </para>

	    <para>
	      Since the original value is destroyed during processing, this is
	      a copy of the array supplying the original value to the
	      constructor.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint64_t  dRegIn
	    </programlisting>

	    <para>
	      If the number of bits in a register (held in
	      <varname>dRegBitSize</varname>) is 64 or less, the value to be
	      shifted through &tdi; can be held in this simple variable for
	      efficiency.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint64_t *dRegOutArray
	    </programlisting>

	    <para>
	      When the registers are held in an array
	      (i.e. <varname>dRegBitSize</varname> is more than 64), this is a
	      pointer to the array representing the value being shifted out
	      through &tdo;. It holds the bits shifted out so far.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
uint64_t  dRegOut
	    </programlisting>

	    <para>
	      If the number of bits in a register (held in
	      <varname>dRegBitSize</varname>) is 64 or less, the value being
	      shifted out through &tdo; can be held in this simple variable for
	      efficiency.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
int  bitsShifted
	    </programlisting>

	    <para>
	      The number of bits shifted in so far.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
enum {
  SHIFT_DR_PREPARING,
  SHIFT_DR_SHIFTING,
  SHIFT_DR_UPDATING
} dRScanState
	    </programlisting>

	    <para>
	      This enumeration records where the action is in its process. The
	      <function>process</function> method follows a state machine (see
	      below) whose state is recorded here.
	    </para>
	  </listitem>
	</itemizedlist>

	<sect3>
	  <title>
	    Constructors and destructor
	  </title>

	  <para>
	    As with the instruction register, the primary responsibility of
	    the constructor is to initialize all
	    the instance variables. The register size is taken from 
	    the arguments, the count of bits shifted is
	    zeroed and the DR-Scan process state machine is set to
	    <constant>SHIFT_DR_PREPARING</constant>.
	  </para>

	  <para>
	    There are two variants depending on whether the value to be
	    shifted in through &tdo; is small enough to fit in a single 64-bit
	    variable.
	  </para>

	  <para>
	    In either case, if the number of bits in the register size is
	    greater than 64, the registers will be represented as an array of
	    <type>uint64_t</type>. Otherwise they will be represented as
	    simple <type>uint64_t</type> variables for efficiency.
	  </para>

	  <para>
	    Where registers are represented as vectors, new vectors of the
	    correct size are allocated and the supplied input value copied
	    to the input register. The output register is zeroed. The size of
	    the vectors is recorded in <varname>dRegWordSize</varname>.
	  </para>

	  <para>
	    Otherwise the input value is copied to the local instance variable
	    (<varname>dRegIn</varname>) and the output value
	    (<varname>dRegOut</varname>) is zeroed.
	  </para>

	  <para>
	    The destructor is used to delete the local copies of registers
	    where they have been represented as arrays to free the memory.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>process</function>
	  </title>

	  <para>
	    As with <classname>TapActionIRScan</classname>, this method
	    generates the appropriate values of &tdi; and &tms; to process the
	    action and capture &tdi;. It is controlled by its own state machine,
	    whose state is recorded in <varname>iRScanState</varname> as shown
	    in <xref linkend="fig_data_state_machine"/>
	  </para>

	  <figure id="fig_data_state_machine">
	    <title>
	      State machine for the <classname>JtagActionDRScan</classname>
	      process.
	    </title>
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="data-state-machine.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="data-state-machine.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The operations on the registers vary depending on whether the
	    register is more than 64 bits long. These operations (to shift
	    bits out for &tdi; and in from &tdo;) are placed in separate
	    utility functions, <function>shiftDRegOut</function> and
	    <function>shiftDRegIn</function> (see below).
	  </para>
	</sect3>

	<sect3>
	  <title>
	    <function>getDRegOut</function>
	  </title>

	  <para>
	    This function is part of the public &api;, allowing the user to
	    access the value shifted through &tdo; on completion.
	  </para>

	  <para>
	    It is provided in two versions. In the first, the result is copied
	    to an array of <type>uint64_t</type> provided as an argument. This
	    version may be used even if the register is 64 bits or
	    smaller. The value will be copied into element 0 of the array.
	  </para>

	  <para>
	    The second version returns the value as a
	    <type>uint64_t</type>. This version may be used, even if the
	    register is more than 64 bits long. The least significant 64 bits
	    will be returned.
	  </para>
	</sect3>

	<sect3>
	  <title>
	    <function>shiftDRegOut</function> and
	    <function>shiftDRegIn</function>
	  </title>

	  <para>
	    These functions are used to shift the least significant bit out of
	    <varname>dRegInArray</varname> (for use as &tdi;) and the shift in
	    the most significant bit (from &tdo;) of
	    <varname>dRegOutArray</varname>. However if the data register is
	    represented as a scalar <type>uint64_t</type> variable they will
	    perform the equivalent operation on <varname>DRegIn</varname> and
	    <varname>DRegOut</varname> instead.
	  </para>

	</sect3>

      </sect2>

      <sect2 id="sec_tap_state_machine_class">
	<title>
	  <classname>TapStateMachine</classname>
	</title>

	<para>
	  This class is for internal use by <classname>JtagSC</classname> and
	  the various &tap; action classes. It maintains the interface's model
	  of the state machine in the &tap; Controller.
	</para>

	<para>
	  The header defining this class also defines
	  <classname>enum&nbsp;TapState</classname> for the various states of
	  the &tap; state machine.
	</para>

	<para>
	  <classname>TapStateMachine</classname> has a number of private
	  instance variables.
	</para>

	<itemizedlist>
	  <listitem>
	    <programlisting>
TapState  state
	    </programlisting>

	    <para>
	      The current state.
	    </para>
	  </listitem>

	  <listitem>
	    <programlisting>
bool  resetDone
	    </programlisting>

	    <para>
	      The &tap; state machine is only of use if it correctly reflects
	      the state machine in the &tap; Controller of the target. This
	      flag may be set and read by users to reflect whether the two are
	      in synchrony (for example having gone through a sequence of 5 or
	      more &tms;=1 transitions).
	    </para>
	  </listitem>
	</itemizedlist>

	<sect3>
	  <title>
	    Constructor
	  </title>

	  <para>
	    The constructor initializes the state to Test-Logic-Reset and
	    clears the flag indicating the &tap; controller has been
	    reset. Until a reset has been completed, there can be no
	    confidence that the state is a correct reflection of reality.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    Accessor Functions
	  </title>

	  <para>
	    The functions <function>getState</function> is provided to get the
	    current state. The functions <function>getResetDone</function> and
	    <function>setResetDone</function> are provided to access the flag
	    indicating whether a reset has been completed. Although
	    initialized to false, it is the responsibility of users to set
	    this flag to its correct value.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>nextState</function>
	  </title>

	  <para>
	    This uses table lookup to advance the state, based on the supplied
	    value of &tms;.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    <function>targetState</function>
	  </title>

	  <para>
	    This function returns through its second argument a value of &tms;
	    which will move from the current state to the specified target
	    state most efficiently (i.e. smallest number of steps). Table
	    lookup makes this an efficient function.
	  </para>

	  <para>
	    The return value indicates if the state machine was already in the
	    target state.
	  </para>

	  <para>
	    This function is used by the instruction and data scan &tap;
	    action classes to get to the correct state during their
	    <function>process</function> functions.
	  </para>

	</sect3>

      </sect2>

    </sect1>

  </chapter>

  <chapter id="chap_examples">
    <title>
      Examples
    </title>

    <para>
      Both examples in this chapter use the OpenRISC Reference Platform
      System-on-Chip, &orpsoc; (<xref linkend="ref_orpsoc"/>). A cycle
      accurate &systemc; model was generated automatically from the source
      using &verilator; (<xref linkend="ref_verilator"/>).
    </para>

    <para>
      &orpsoc; features a &jtag; interface with a number of user register
      which drive its debug unit. These examples show the result of resetting
      the unit, writing a register less than 64-bits long and reading a
      register more than 64-bits long.
    </para>

    <para>
      The &systemc; model consists of four modules: the ORPSoC module created
      by &verilator; (class <classname>Vorpsoc</classname>), a reset signal
      generator (class <classname>ResetSC</classname>), the &jtag; module
      using the interface described in this application note (class
      <classname>jtagSC</classname>) and a simple driver module to inject
      &jtag; requests (class <classname>JtagDriver</classname>). The module
      structure and their interconnects are shown in <xref
      linkend="fig_example_module_structure"/>.
    </para>

    <figure id="fig_example_module_structure">
      <title>
	Module structure for the &orpsoc; &jtag; example
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="example-module-structure.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="example-module-structure.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      The clock is provided by a <classname>sc_clock</classname> and used to
      drive both the system clock of &orpsoc; and the &jtag; &tck; signals. The
      reset generator, <classname>ResetSC</classname> generates a reset signal
      for a predefined number of clock cycles after time zero. The two outputs
      offer active high (<varname>rst</varname>) and active low
      (<varname>rstn</varname>) versions, synchronous with each other.
    </para>

    <sect1>
      <title>
	&jtag; Reset
      </title>

      <para>
	The code to drive reset of the &jtag; is as follows.
      </para>

      <programlisting>
sc_core::sc_event *actionDone = new sc_core::sc_event();
TapActionReset    *resetAction;

resetAction = new TapActionReset (actionDone);
tapActionQueue-&gt;write (resetAction);
wait (*actionDone);

delete resetAction;
delete actionDone;
      </programlisting>

      <para>
	A new instance of <classname>TapActionReset</classname>,
	<varname>resetAction</varname> is created using the &systemc; event,
	<varname>actionDone</varname>. This action is queued by writing to the
	FIFO (<varname>tapActionQueue</varname>, waiting for the result on
	<varname>actionDone</varname>.
      </para>

      <para>
	With the results traced in a &vcd; the effect can be seen clearly. The
	trace is shown in <xref linkend="fig_reset_vcd"/>.
      </para>

      <figure id="fig_reset_vcd">
	<title>
	  &vcd; trace of a &jtag; reset request
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="reset.png"
		       format="PNG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="reset.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	During system reset, the &jtag; &trst; is driven low. As soon as the
	system reset is complete at 1&mu;s, the &jtag; reset can be
	processed. A sequence of 5 cycles of &tms;=1 is seen from 1&mu;s
	onwards.
      </para>

      <note>
	<para>
	  The &vcd; trace shows the signals changing on the falling edge of the
	  clock. This is a cycle accurate model, with values only sampled on
	  clock edges. The &jtag; signals change in response to the stimulus
	  from the clock, so only appear in the trace at the next clock
	  edge. This is a common effect in cycle accurate modeling, but does
	  not affect the behavior of the model.
	</para>
      </note>

    </sect1>

    <sect1>
      <title>
	Writing the Instruction Register
      </title>

      <para>
	The &orpsoc; &jtag; interface uses a 4-bit instruction register with a
	number of custom instructions. One such instruction
	<literal>CHAIN</literal> is used to select the custom CHAIN
	register. This instruction has the binary value 0011.
      </para>

      <para>
	The code to write the <literal>CHAIN</literal> instruction into the
	instruction register is:
      </para>

      <programlisting>
sc_core::sc_event *actionDone = new sc_core::sc_event();
TapActionIRScan   *iRScan;

iRScan = new TapActionIRScan (actionDone, CHAIN_SELECT_IR, JTAG_IR_LEN);
tapActionQueue-&gt;write (iRScan);
wait (*actionDone);

delete iRScan;
      </programlisting>

      <para>
	The action is created as a new instance of
	<classname>TapActionIRScan</classname>, passing in a &systemc; event
	for signaling completion, with the value of the instruction
	(<literal>CHAIN_SELECT_IR</literal>, binary 0011) and the instruction
	register length (<literal>JTAG_IR_LEN</literal>, 4 in the case of
	ORPSoC).
      </para>

      <note>
	<para>
	  In this case the &systemc; event, <varname>actionDone</varname> is
	  not deleted. It will be reused for the following data register write
	  action (see <xref linkend="sec_dr_small_write"/>).
	</para>
      </note>

      <para>
	The results are again traced in a &vcd; and shown in <xref
	linkend="fig_ir_write_vcd"/>.
      </para>

      <figure id="fig_ir_write_vcd">
	<title>
	  &vcd; trace of a &jtag; instruction register write request
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="ir-write.png"
		       format="PNG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="ir-write.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The instruction register write action commences at 1.6&mu;s. A
	sequence of 0-1-1-0-0 on &tms; takes the state machine from its starting
	point of Test-Logic-Reset through Run-Test/Idle, Select-DR-Scan,
	Select-IR-Scan and Capture-IR to Shift-IR.
      </para>

      <para>
	At this point a sequence of four &tms;=0, starting at 2.0&mu;s allow the
	bits of the instruction register to be shifted in from &tdi;. The
	sequence 1-1-0-0 can be seen on <literal>jtag_tdi</literal>. Since the
	bits are shifted in least-significant bit first, this represents the
	binary number 0011, the <literal>CHAIN</literal> instruction.
      </para>

      <para>
	A sequence of 1-1 on &tms; moves the state machine through Exit1-IR to
	Update-IR at which point completion is signaled (2.5&mu;s).
      </para>

    </sect1>

    <sect1 id="sec_dr_small_write">
      <title>
	Writing a 12-bit &jtag; Data Register
      </title>

      <para>
	The &orpsoc; &jtag; <literal>CHAIN</literal> instruction selects the
	debug unit's 12-bit CHAIN register as the data register to be written.
      </para>

      <para>
	The code to write the data into the CHAIN data register is:
      </para>

      <programlisting>
uint64_t  dReg = 0x4;
dReg |= crc8 (chain, 4) &lt;&lt; 4;

dRScan = new TapActionDRScan (actionDone, dReg, 12);
tapActionQueue-&gt;write (dRScan);
wait (*actionDone);

delete dRScan;
delete actionDone;
      </programlisting>

      <para>
	The 12-bit data is built up in <varname>dReg</varname> from a value
	(bits 0-3) and a CRC (bits 4-11). The action is created as a new
	instance of <classname>TapActionDRScan</classname>, passing in a
	&systemc; event for signaling completion (reusing the signal from the
	instruction register write earlier), with the data value and the data
	register length. In this example the 12-bit value is 0000_1110_0100.
      </para>

      <para>
	The results are again traced in a &vcd; and shown in <xref
	linkend="fig_dr_write_vcd"/>.
      </para>

      <figure id="fig_dr_write_vcd">
	<title>
	  &vcd; trace of a "small" &jtag; data register write request
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="dr-write.png"
		       format="PNG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="dr-write.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The data register write action commences at 2.6&mu;s. The &tap; state
	machine is currently at Update-IR from the previous write of an
	instruction register. A &tms; sequence of 1-0-0 takes the state through
	Select-DR-Scan and Capture-DR to Shift-DR. 12 cycles in Shift-DR (the
	last with &tms;=1 to move out of Shift-DR) starting at 2.9&mu;s shift in
	the sequence 0-0-1-0-0-1-1-1-0-0-0-0 on &tdi;, the value specified,
	least significant bit first. The final &tms;=1 moves the state to
	Exit1-DR, followed by another &tms;=1 to move to Update-DR. Completion
	can be signaled at this point, at time 4.1&mu;s.
      </para>

      <para>
	In this example the bits being shifted out on &tdo; can also be
	seen. The &orpsoc; debug unit always shifts out the CRC as the last
	8-bits, and the sequence 0-1-1-1-0-0-0-0 can be seen as the final bits
	on &tdo;, which is the original 8-bit CRC (00001110) in least
	significant bit first.
      </para>

      <para>
	Note how the bits are delayed half a cycle from the &tdi; bits, because
	&tdo; changes on the falling edge of &tck; (and on this cycle accurate
	trace will be shown on the following rising edge). Thus the final bit
	is picked up as the Exit1-DR state is entered.
      </para>

    </sect1>

    <sect1>
      <title>
	Reading a 73-bit &jtag; Data Register
      </title>

      <para>
	This final example shows the &jtag; interface's facilities for
	handling large data registers. This example shows a
	read from one of the &orpsoc; &jtag; 73-bit debug registers
      </para>

      <para>
	The code to read a register also involves scanning in data, and for
	&orpsoc; that data must have a correct CRC to be accepted. The code is
	as follows:
      </para>

      <programlisting>
sc_core::sc_event *actionDone = new sc_core::sc_event();
uint64_t dRegArray[2];
memset (dRegArray, 0, 16);
dRegArray[0] |= data;
uint8_t crc_in = crc8 (dRegArray, 65);
insertBits (crc_in, 8, dRegArray, 65);

TapActionDRScan *dRScan = new TapActionDRScan (actionDone, dRegArray, 73);
tapActionQueue-&gt;write (dRScan);
wait (*actionDone);

dRScan-&gt;getDRegOut (dRegArray);
delete dRScan;
delete  actionDone;
      </programlisting>

      <para>
	The 73-bit data is built up in the array <varname>dRegArray</varname>
	from a value (bits 0-64) and a CRC (bits 65-72). The action is created
	as a new instance of <classname>TapActionDRScan</classname>, passing
	in a &systemc; event for signaling completion, with the data value
	array and the data register length.
      </para>

      <para>
	After completion, the result is retrieved back into <varname>dRegArray</varname> using
	the <function>getDRegOut</function> method of the
	<classname>TapActionDRScan</classname> class.
      </para>

      <para>
	The results are again traced in a &vcd; and shown in <xref
	linkend="fig_dr_read_vcd"/>.
      </para>

      <figure id="fig_dr_read_vcd">
	<title>
	  &vcd; trace of a "large" &jtag; data register read request
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="dr-read.png"
		       format="PNG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="dr-read.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The data register read action commences at 23.4&mu;s. The &tap; state
	machine is currently at Update-IR from the previous write of an
	instruction register. A &tms; sequence of 1-0-0 takes the state through
	Select-DR-Scan and Capture-DR to Shift-DR. There are then 73 cycles in
	Shift-DR (the last with &tms;=1 to move out of Shift-DR) starting at
	23.7&mu;s. The value is shifted out least significant bit first on &tdo;
	(one cycle delayed, since it is on the negative edge). The value is
	0x0620000000200000000.
      </para>

      <para>
	The final &tms;=1 moves the state to Exit1-DR, followed by another &tms;=1
	to move to Update-DR. Completion can be signaled at this point, at
	time 31.1&mu;s.
      </para>

    </sect1>

  </chapter>

  <chapter>
    <title>
      Summary
    </title>

    <para>
      This application note presents a &systemc; interface suitable for cycle
      accurate modeling of &jtag;. It will be of value to engineers developing
      cycle accurate models, who need to interface to other modules, to
      develop test benches, or to connect to tools such as debuggers.
    </para>

    <para>
      Suggestions for corrections or improvements are welcomed. Please contact
      the author at <ulink
      url="mailto:jeremy.bennett@embecosm.com"><literal>jeremy.bennett@embecosm.com</literal></ulink>.
    </para>

  </chapter>

  <glossary id="sec_glossary">
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>2-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Joint Test Action Group</glossterm>
      <acronym>JTAG</acronym>
      <glossdef>
	<para>
	  &jtag; is the usual name used for the IEEE 1149.1 standard entitled
	  <emphasis>Standard Test Access Port and Boundary-Scan
	  Architecture</emphasis> for test access ports used for testing
	  printed circuit boards and chips using boundary scan.
	</para>
	<indexterm>
	  <primary>&jtag;</primary>
	</indexterm>

	<para>
	  This standard allows external reading of state within the board or
	  chip. It is thus a natural mechanism for debuggers to connect to
	  embedded systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open &systemc; Initiative</glossterm>
      <acronym>OSCI</acronym>
      <glossdef>
	<para>
	  The industry standardization body for &systemc;/
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>SystemC</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Test Access Port</glossterm>
      <acronym>TAP</acronym>
      <glossdef>
	<para>
	  The interface to a &jtag; interface defined by IEEE 1149.1.
	</para>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_doxygen">
      <title id="ref_gdb_doxygen_xr">
	Doxygen: Source code documentation generator tool,
      </title>
      <firstname>Dimitri</firstname> <surname>van Heesch</surname>,
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.doxygen.org"/>
      </bibliosource>
      <indexterm>
	<primary>Doxygen</primary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_esp4">
      <title id="ref_app_note_2_xr">
	&embecosm; Software Package 4. Cycle Accurate &systemc; &jtag;
	Interface: Reference Implementation.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	January 2009.
      </pubdate>
      Available for free download from the &embecosm; website at
      <bibliosource class="uri">
	<ulink url="http://www.embecosm.com">www.embecosm.com</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_ieee_jtag">
      <title>
	IEEE standard test access port and boundary-scan architecture
      </title>
      <publisher>
	<publishername>
	  IEEE Computer Society
	</publishername>
      </publisher>
      <pubdate>
	2001 (reaffirmed 2008)
      </pubdate>.
      <biblioid class="pubnumber">
	IEEE Std 1149.1&trade;-2001
      </biblioid>.
    </bibliomixed>

    <bibliomixed id="ref_ti_jtag">
      <title>
	IEEE Std 1149.1 (&jtag;) Testability:
      </title>
      <subtitle>
	Primer.
      </subtitle>
      <publisher>
	<publishername>
	  Texas Instruments Semiconductor Group
	</publishername>
      </publisher>
      <pubdate>
	1997.
      </pubdate>
      Available for free download from the Texas Instruments website at
      <bibliosource class="uri">
	<ulink url="http://focus.ti.com/lit/an/ssya002d/ssya002d.pdf">focus.ti.com/lit/an/ssya002d/ssya002d.pdf</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_ieee_systemc">
      <title>
	IEEE Standard &systemc;&reg; Language:
      </title>
      <subtitle>
	Reference Manual.
      </subtitle>
      <publisher>
	<publishername>
	  IEEE Computer Society
	</publishername>
      </publisher>
      <pubdate>
	2005
      </pubdate>.
      <biblioid class="pubnumber">
	IEEE Std 1666&trade;-2005.
      </biblioid>
      Available for free download from
      <bibliosource class="uri">
	<ulink
	    url="http://standards.ieee.org/getieee/1666/index.html">standards.ieee.org/getieee/1666/index.html</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_orpsoc">
      <title>
	The OpenRISC Reference Platform System-on-Chip
      </title>
      <publisher>
	<publishername>
	  ORSoC AB (through the OpenCores website)
	</publishername>
      </publisher>
      <bibliosource class="uri">
	<ulink url="http://www.opencores.org">www.opencores.org</ulink>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_osci_systemc_ug">
      <title>
	&systemc; Version 2.0 User Guide.
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative,
	</publishername>
      </publisher>
      <pubdate>
	2002.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_verilator">
      <title>
	Verilator 3.700.
      </title>
      <firstname>Wilson</firstname> <surname>Snyder</surname>,
      <pubdate>
	January 2009.
      </pubdate>
      <publisher>
	<publishername>
	  Veripool,
	</publishername>
      </publisher>
      <bibliosource class="uri">
	<ulink url="http://www.veripool.org/wiki/verilator">www.veripool.org/wiki/verilator</ulink>
      </bibliosource>
    </bibliomixed>

  </bibliography>

</book>
