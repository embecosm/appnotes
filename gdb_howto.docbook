<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY abi   "<acronym>ABI</acronym>">
<!ENTITY bfd   "<acronym>BFD</acronym>">
<!ENTITY dcr   "<acronym>DCR</acronym>">
<!ENTITY dvr   "<acronym>DVR</acronym>">
<!ENTITY fp    "<acronym>FP</acronym>">
<!ENTITY fsa   "<acronym>FSA</acronym>">
<!ENTITY gcc   "<acronym>GCC</acronym>">
<!ENTITY gdb   "<acronym>GDB</acronym>">
<!ENTITY gnu   "<acronym>GNU</acronym>">
<!ENTITY gpr   "<acronym>GPR</acronym>">
<!ENTITY html  "<acronym>HTML</acronym>">
<!ENTITY iss   "<acronym>ISS</acronym>">
<!ENTITY jtag  "<acronym>JTAG</acronym>">
<!ENTITY pc    "<acronym>PC</acronym>">
<!ENTITY pdf   "<acronym>PDF</acronym>">
<!ENTITY rtems "<acronym>RTEMS</acronym>">
<!ENTITY rsp   "<acronym>RSP</acronym>">
<!ENTITY sal   "<acronym>SAL</acronym>">
<!ENTITY soc   "<acronym>SoC</acronym>">
<!ENTITY sp    "<acronym>SP</acronym>">
<!ENTITY spr   "<acronym>SPR</acronym>">
<!ENTITY usb   "<acronym>USB</acronym>">

<!-- ========== commonly used things ========== -->

<!ENTITY null         "<constant>NULL</constant>">
<!ENTITY this         "<emphasis>THIS</emphasis>">
<!ENTITY prev         "<emphasis>PREVIOUS</emphasis>">
<!ENTITY next         "<emphasis>NEXT</emphasis>">
<!ENTITY arch         "<emphasis>arch</emphasis>">
<!ENTITY os           "<emphasis>os</emphasis>">

<!ENTITY frame_info   "<structname>struct&nbsp;frame_info</structname>">
<!ENTITY gdbarch      "<structname>struct&nbsp;gdbarch</structname>">
<!ENTITY gdbarch_info "<structname>struct&nbsp;gdbarch_info</structname>">
<!ENTITY gdbarch_tdep "<structname>struct&nbsp;gdbarch_tdep</structname>">
<!ENTITY regcache     "<structname>struct&nbsp;regcache</structname>">
<!ENTITY target_ops   "<structname>struct&nbsp;target_ops</structname>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">

<!-- = Commands = -->

<!ENTITY xterm "<application>xterm</application>" >

<!-- = Libraries = -->

<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY lgpl "GNU Lesser General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2008 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing how to port GDB

$Id$

=========================================================================== -->

<book lang="en_GB">
  <title>
    Howto: Porting the &gnu; Debugger
  </title>
  <subtitle>
    Practical Experience with the OpenRISC 1000 Architecture
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      August 2008
    </pubdate>

    <releaseinfo>
      Application Note 3. Issue 1
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, Jeremy Bennett of &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software for the port of the &gnu; Debugger written by &embecosm;
	and used in this document are licensed under the &gpl_www;. For
	detailed licensing information see the files
	<filename>COPYING</filename>, <filename>COPYING3</filename>,
	<filename>COPYING.LIB</filename> and <filename>COPYING3.LIB</filename>
	in the source code.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      This document complements the existing documentation for &gdb; (<xref
      linkend="ref_gdb_ug" />, <xref linkend="ref_gdb_int" />, <xref
      linkend="ref_bfd" />). It is intended to help software engineers porting
      &gdb; to a new architecture for the first time.
    </para>

    <para>
      This is a work in progress, capturing the author's experience to
      date. Suggestions for improvements are always welcome.
    </para>

    <sect1>
      <title>
	Rationale
      </title>

      <para>
	Although the &gdb; project includes a 100 page guide to its internals,
	that document is aimed primarily at those wishing to develop &gdb;
	itself. The document also suffers from three limitations.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    It tends to document at a low-level. Individual functions are
	    described well, but it is hard to get the <emphasis>big
	    picture</emphasis>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    It is incomplete. Many of the most useful sections (for example on
	    frame interpretation) are yet to be written.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Is tends to be out of date. For example the documentation of the
	    UI-Independent output describes a number of functions which no
	    longer exist.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Consequently the engineer faced with their first port of &gdb; to a new
	architecture is faced with discovering how &gdb; works by reading the
	source code and looking at how other architectures have been ported.
      </para>

      <para>
	The author of this paper went through that process when porting the
	OpenRISC 1000 architecture to &gdb;. This document captures the learning
	experience, in the hope that it will help others.
      </para>

    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>

      <para>
	If you are about to start a port of &gdb; to a new architecture, this
	document is for you. Hopefully this document will help you. If at the
	end of your endeavors you are better informed, please help by adding
	to this document.
      </para>

      <para>
	If you have already been through the porting process, please help
	others by adding to this document.
      </para>

    </sect1>

    <sect1>
      <title>
	Other Sources of Information
      </title>

      <para>
	The main user guide for &gdb; <xref linkend="ref_gdb_ug" /> provides a
	great deal of context about how &gdb; is intended to work.
      </para>

      <para>
	The &gdb; Internals guide <xref linkend="ref_gdb_int" /> is
	essential reading before and during any porting exercise. It is not
	complete, nor is it always up to date, but it provides the first place
	to look for explanation of what a particular function does.
      </para>

      <para>
	&gdb; relies on a separate specification of the Application Binary
	Interface &abi; for each architecture. That has its
	own comprehensive user guide <xref linkend="ref_bfd" />.
      </para>

      <para>
	The main &gdb; code base is generally well commented, particularly in
	the headers for the major interfaces. Inevitably this must be the
	definitive place to find out exactly how a particular function
	behaves.
      </para>

      <para>
	The files making up the port for the OpenRISC 1000 are comprehensively
	commented, and can be processed with Doxygen <xref
	linkend="ref_doxygen" />. Each function's behavior, its parameters and
	any return value is described.
      </para>

    </sect1>

  </chapter>

  <chapter id="chap_gdb_internals">
    <title>
      Overview of &gdb; Internals
    </title>

    <para>
      There are three major areas to &gdb;:
    </para>

    <orderedlist>
      <listitem>
	<para>
	  The <emphasis>user interface</emphasis>. How &gdb; communicates with
	  the user
	</para>
      </listitem>

      <listitem>
	<para>
	  The <emphasis>symbol side</emphasis>. The analysis of object files,
	  and the mapping of the information contained to the corresponding
	  source files.
	</para>
      </listitem>

      <listitem>
	<para>
	  the <emphasis>target side</emphasis>. Executing programs and
	  analyzing their data.
	</para>
      </listitem>
    </orderedlist>

    <para>
      &gdb; has a very simple view of a processor. It has a block of memory
      and a block of registers. Executing code contains its state in the
      registers and in memory, statically allocated, dynamically allocated
      from the heap or in stack frames. &gdb; maps that information to the
      source level program being debugged.
    </para>

    <para>
      Porting a new architecture to &gdb; means providing a way to read
      executable files, a description of the &abi; a description of the
      physical architecture and operations to access the target being
      debugged.
    </para>

    <para>
      Probably the most common use of &gdb; is to debug the architecture on
      which it is actually running. This is <emphasis>native</emphasis>
      debugging where the architecture of the host and target are the same.
    </para>

    <para>
      For the OpenRISC 1000 we will normally expect to run &gdb; on a host
      separate to the target (typically a workstation) connecting to the
      OpenRISC 1000 target via &jtag;, using the OpenRISC 1000 Remote &jtag;
      Protocol. <emphasis>Remote</emphasis> debugging in this way is the most
      common method of working for embedded systems.
    </para>

    <sect1>
      <title>
	&gdb; Nomenclature
      </title>

      <para>
	A full glossary is provided at the end of this document (see <xref
	linkend="sec_glossary" />). However a number of key concepts are worth
	explaining up front.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Exec</emphasis> or <emphasis>program</emphasis>. An
	    executable program, i.e. a binary file which may be run
	    independently of other programs. Commonly the term
	    <emphasis>program</emphasis> is found in user documentation, and
	    <emphasis>exec</emphasis> in comments and &gdb; internal
	    documentation.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Inferior</emphasis>. A &gdb; entity representing a
	    program/exec which has run, is running, or will run in the
	    future. An inferior corresponds to a process or a core dump file.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Address space</emphasis>. A &gdb; entity which can
	    interpret addresses (that is values of type
	    <type>CORE_ADDR</type>). Inferiors must have at least one address
	    space and inferiors may share an address space.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Thread</emphasis>. A single thread of control within an
	    inferior.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The OpenRISC 1000 port for &gdb; is designed for "bare metal"
	debugging, so will have only a single address space and inferiors with
	a single thread.
      </para>

    </sect1>

    <sect1 id="sec_main_areas">
      <title>
	Main Functional Areas and Data Structures
      </title>

      <sect2 id="sec_bfd">
	<title>
	  Binary File Description (&bfd;)
	</title>

	<para>
	  &bfd; is a package which allows applications to use the same routines
	  to operate on object files whatever the object file format. A new
	  object file format can be supported simply by creating a new &bfd;
	  back end and adding it to the library.
	</para>

	<para>
	  The &bfd; library back end creates a number of data structures
	  describing the data held in a particular type of object
	  file. Ultimately a unique enumerated constant (of type
	  <type>enum&nbsp;bfd_architecture</type>) is defined for each
	  individual architecture. This constant is then used to access the
	  various data structures associated with the &bfd; of the particular
	  architecture.
	</para>

	<para>
	  In the case of the OpenRISC 1000, 32-bit implementation (which may
	  be a <acronym>COFF</acronym> or <acronym>ELF</acronym> binary), the
	  enumerated constant is <constant>bfd_arch_or32</constant>.
	</para>

	<para>
	  &bfd; is part of the <application>binutils</application> package. A
	  binutils implementation must be provided for any architecture
	  intending to support the &gnu; tool chain.
	</para>

	<para>
	  The OpenRISC 1000 is supported by the &gnu; tool chain. &bfd; back
	  ends already exist suitable for use with 32-bit OpenRISC 1000 images
	  in <acronym>ELF</acronym> or <acronym>COFF</acronym> format as used
	  with either the &rtems; or Linux operating systems.
	</para>

      </sect2>

      <sect2 id="sec_arch_description">
	<title>
	  Architecture Description
	</title>

	<para>
	  Any architecture to be debugged by &gdb; is described in a
	  &gdbarch;. When an object file is to be debugged, &gdb; will select
	  the correct &gdbarch; using information about the object file
	  captured in its &bfd;.
	</para>

	<para>
	  The data in &gdbarch; facilitates both the <emphasis>symbol
	  side</emphasis> processing in (for which it also uses the
	  &bfd; information) and the <emphasis>target side</emphasis>
	  processing (in combination with the frame and target operation
	  information).
	</para>

	<para>
	  &gdbarch; is a mixture of data values (number of bytes in a word for
	  example) and functions to perform standard operations (e.g. to print
	  the registers). The major functional groups are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Data values capturing details of the hardware architecture. For
	      example the endianism and the number of bits in an address and
	      in a word. Some of this data is captured in the &bfd;, to which
	      there is a reference in the &gdbarch;. There is also a structure
	      to capture additional target specific data, beyond that which is
	      covered by the standard &gdbarch;.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Data values describing how all the standard high level scalar
	      data structures are represented (<type>char</type>,
	      <type>int</type>, <type>double</type> etc).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access and display registers. &gdb; includes the
	      concept of "pseudo-registers", those registers which do not
	      physically exist, but which have a meaning within the
	      architecture. For example in the OpenRISC 1000, floating point
	      registers are actually the same as the General Purpose
	      Registers. However a set of floating point pseudo-registers
	      could be defined, to allow the &gpr;s to be displayed in floating
	      point format.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access information on stack frames. This includes
	      setting up "dummy" frames to allow &gdb; to evaluate functions
	      (for example using the <command>call</command> command).
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  An architecture will need to specify most of the contents of
	  &gdbarch;, for which a set of functions (all starting
	  <literal>set_gdbarch_</literal>) are provided. Defaults are provided
	  for all entries, and in a small number of cases these will be
	  suitable.
	</para>

	<para>
	  Analysis of the stack frames of executing programs is complex with
	  different approaches are needed for different circumstances. A set
	  of functions to identify stack frames and analyze their contents is
	  associated with each &gdbarch;.
	</para>

	<para>
	  A set of utility functions are provided to access the members of
	  &gdbarch;. Element <literal>xyz</literal> of a &gdbarch; pointed to
	  by <varname>g</varname> may be accessed by using
	  <function>gdbarch_xyz&nbsp;(g, ...)</function>. This will check,
	  using <function>gdb_assert</function> that <varname>g</varname> is
	  defined, and in the case of functions that <function>g->x</function>
	  is not &null; and return either the value <literal>g->xyz</literal>
	  (for values) or the result of calling
	  <literal>g->xyz&nbsp;(...)</literal> (for functions). This saves the
	  user testing for existence before each function call, and ensures
	  any errors are handled cleanly.
	</para>

      </sect2>

      <sect2>
	<title>
	  Target Operations
	</title>

	<para>
	  A set of operations is required to access a program using the target
	  architecture described by &gdbarch; in order to implement the
	  <emphasis>target side</emphasis> functionality. For any given
	  architecture there may be multiple ways of connecting to the target,
	  specified using the &gdb; <command>target</command> command. For
	  example with the OpenRISC 1000 architecture, the connection may be
	  directly to a &jtag; interface connected through the host computer's
	  parallel port, or through a the OpenRISC 1000 Remote &jtag; protocol
	  over TCP/IP.
	</para>

	<para>
	  These target operations are described in a &target_ops;. As with
	  &gdbarch; this comprises a mixture of data and functions to be
	  called. The major functional groups are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Functions to establish and close down a connection to the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access registers and memory on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to insert and remote breakpoints and watchpoints on
	      the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to start and stop programs running on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A set of data describing the features of the target, and hence
	      what operations can be applied. For example when examining a
	      core dump, the data can be inspected, but the program cannot be
	      executed.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  As with &gdbarch;, defaults are provided for the &target_ops;
	  values. In many cases these are sufficient, so need not be
	  provided.
	</para>

      </sect2>

      <sect2>
	<title>
	  Adding Commands to &gdb;
	</title>

	<para>
	  &gdb;'s command handling is intended to be extensible. A set of
	  functions (defined in <filename>cli-decode.h</filename>) provide
	  that extensibility.
	</para>

	<para>
	  &gdb; groups its commands into a number of command lists (of
	  <structname>struct&nbsp;cmd_list_element</structname>), pointed to by
	  a number of global variables (defined in
	  <filename>cli-cmds.h</filename>). Of these, <varname>cmdlist</varname>
	  is the list of all defined commands. Separate lists defined
	  sub-commands of various top level commands. For example
	  <varname>infolist</varname> is the list of all <command>info</command>
	  sub-commands.
	</para>

	<para>
	  Commands are also classified according the the area they address, for
	  example commands that provide support, commands that examine data,
	  commands for file handling etc. These classes are specified by
	  <type>enum&nbsp;command_class</type>, defined in
	  <filename>command.h</filename>. These classes provide the top level
	  categories in which help will be given.
	</para>

      </sect2>

    </sect1>



    <sect1 id="sec_gdbarch">
      <title>
	&gdb; Architecture Specification
      </title>

      <para>
	A &gdb; description for a new architecture, &arch; is created by
	defining a global function
	<function>_initialize_&arch;_tdep</function>, by
	convention in the source file <filename>&arch;-tdep.c</filename>. In the
	case of the OpenRISC 1000, this function is called
	<function>_initialize_or1k_tdep</function> and is found in the file
	<filename>or1k-tdep.c</filename>.
      </para>

      <para>
	The resulting object files containing the implementation of the
	<function>_initialize_&arch;_tdep</function> function are specified in
	the &gdb; <filename>configure.tgt</filename> file, which includes a
	large case statement pattern matching against the
	<option>--target</option> option of the <command>configure</command>
	command.
      </para>

      <para>
	The new &gdbarch; is created within the
	<function>_initialize_&arch;_tdep</function> function by calling
	<function>gdbarch_register</function>:
      </para>

      <informalexample>
	<programlisting>
void gdbarch_register (enum bfd_architecture    architecture,
                       gdbarch_init_ftype      *init_func,
                       gdbarch_dump_tdep_ftype *tdep_dump_func);
	</programlisting>
      </informalexample>

      <para>
	For example the <function>_initialized_or1k_tdep</function> creates
	its architecture for 32-bit OpenRISC 1000 architectures by calling.
      </para>

      <informalexample>
	<programlisting>
gdbarch_register (bfd_arch_or32, or1k_gdbarch_init, or1k_dump_tdep);
	</programlisting>
      </informalexample>

      <para>
	The <varname>architecture</varname> enumeration will identify the
	unique &bfd; for this architecture (see <xref linkend="sec_bfd"
	/>). The <function>init_func</function> is called to create and return
	the new &gdbarch; (see <xref linkend="sec_gdbarch" />). The
	<function>tdep_dump_func</function> is a function which will dump the
	target specific details associated with this architecture (also
	described in <xref linkend="sec_gdbarch" />).
      </para>

      <para>
	The call to <function>gdbarch_register</function> (see <xref
	linkend="sec_main_areas" />) specifies a function which will
	define a &gdbarch; for a particular &bfd; architecture.
      </para>

      <informalexample>
	<programlisting>
struct gdbarch  gdbarch_init_func (struct gdbarch_info  info,
                                   struct gdbarch_list *arches);
	</programlisting>
      </informalexample>

      <para>
	For example, in the case of the OpenRISC 1000 architecture, the
	initialization function is <function>or1k_gdbarch_init</function>.
      </para>

      <tip>
	<para>
	  By convention all target specific functions and global variables
	  in &gdb; begin with a string unique to that architecture. This
	  helps to avoid namespace pollution when using C. Thus all the MIPS
	  specific functions begin <literal>mips_</literal>, the ARM specific
	  functions begin <literal>arm_</literal> etc.
	</para>

	<para>
	  For the OpenRISC 1000 all target specific functions and global
	  variables begin with <literal>or1k_</literal>.
	</para>
      </tip>

      <sect2>
	<title>
	  Looking up an Existing Architecture
	</title>

	<para>
	  The first argument to the architecture initialization function is a
	  &gdbarch_info; containing all the known information about this
	  architecture (deduced from the &bfd; enumeration provided to
	  <function>gdbarch_register</function>). The second argument is a list
	  of the currently defined architectures within &gdb;.
	</para>

	<para>
	  The lookup is done using
	  <function>gdbarch_lookup_by_arches</function>. It is passed the list
	  of existing architectures and the &gdbarch_info; (possibly updated)
	  and returns the first matching architecture it finds, or
	  &null; if none are found. If an architecture is found, the
	  initialization function can finish, returning the found architecture
	  as result.
	</para>

	<sect3>
	  <title>
	    &gdbarch_info;
	  </title>

	  <para>
	    The &gdbarch_info; has the following components:
	  </para>

	  <informalexample>
	    <programlisting>
	      struct gdbarch_info
	      {
	      const struct bfd_arch_info *bfd_arch_info;
	      int                         byte_order;
	      bfd                        *abfd;
	      struct gdbarch_tdep_info   *tdep_info;
	      enum gdb_osabi              osabi;
	      const struct target_desc   *target_desc;
	      };
	    </programlisting>
	  </informalexample>

	  <para>
	    <varname>bfd_arch_info</varname> holds the key details about the
	    architecture. <varname>byte_order</varname> is an enumeration
	    indicating the endianism. <varname>abfd</varname> is a pointer to
	    the full &bfd;, <varname>tdep_info</varname> is additional custom
	    target specific information, <varname>gdb_osabi</varname> is an
	    enumeration identifying which (if any) of a number of operating
	    specific &abi;s are used by this architecture and
	    <varname>target_desc</varname> is a set of name-value pairs with
	    information about register usage in this target.
	  </para>

	  <para>
	    When the &gdbarch; initialization function is called, not all the
	    fields are provided&mdash;only those which can be deduced from the
	    &bfd;. The &gdbarch_info; is used as a look-up key with the list of
	    existing architectures (the second argument to the initialization
	    function) to see if a suitable architecture already exists. The
	    <varname>tdep_info</varname> <varname>osabi</varname> and
	    <varname>target_desc</varname> fields may be added before this
	    lookup to refine the search.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  Creating a New Architecture
	</title>

	<para>
	  If no architecture is found, then a new architecture must be
	  created, by calling <function>gdbarch_alloc</function> using the
	  supplied &gdbarch_info; and and any additional custom target specific
	  information in a &gdbarch_tdep;.
	</para>

	<para>
	  The newly created &gdbarch; must then be populated. Although there are
	  default values, in most cases they are not what is required. For each
	  element, <emphasis>X</emphasis>, there is a corresponding accessor
	  function to set the value of that element,
	  <function>set_gdbarch_X</function>.
	</para>

	<para>
	  The following sections identify the main elements that should be set
	  in this way. This is not the complete list, but represents the
	  functions and elements that must commonly be specified for a new
	  architecture. Many of the functions are described in the header file,
	  <filename>gdbarch.h</filename> and many may be found in the &gdb;
	  internals manual <xref linkend="ref_gdb_int" />.
	</para>

	<sect3>
	  <title>
	    &gdbarch_tdep;
	  </title>

	  <informalexample>
	    <programlisting>
struct gdbarch *gdbarch_alloc (const struct gdbarch_info *info,
                               struct gdbarch_tdep       *tdep);
	    </programlisting>
	  </informalexample>

	  <para>
	    &gdbarch_tdep; is not defined within &gdb;&mdash;it is up to the
	    user to define this <literal>struct</literal> if it is needed to
	    hold custom target information that is not covered by the standard
	    &gdbarch;. For example with the OpenRISC 1000 architecture it is
	    used to hold the number of matchpoints available in the target
	    (along with other information). If there is no additional target
	    specific information, it can be set to &null;.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  Specifying the Hardware Data Representation
	</title>

	<para>
	  A set of values in &gdbarch; define how different data types are
	  represented within the architecture.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>short_bit</varname>. Number of bits in a C/C++
	      <type>short</type> variable. Default is
	      <literal>2*TARGET_CHAR_BIT</literal>.
	      <constant>TARGET_CHAR_BIT</constant> is a defined constant, which
	      if not set explicitly defaults to 8.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>int_bit</varname>, <varname>long_bit</varname>,
	      <varname>long_long_bit</varname>, <varname>float_bit</varname>,
	      <varname>double_bit</varname>,
	      <varname>long_double_bit</varname>. These are analogous to
	      <varname>short</varname> and are the number of bits in a C/C++
	      variable of the corresponding time. Defaults are
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>int</type>,
	      <type>long</type> and <type>float</type> and
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>long long</type>,
	      <type>double</type> and <type>long double</type>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>ptr_bit</varname>. Number of bits in a C/C++
	      pointer. Default is <literal>4*TARGET_CHAR_BIT</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>float_format</varname>,
	      <varname>double_format</varname> and
	      <varname>long_double_format</varname>. These point to an array
	      of structs (one for each endianism), defining the format for
	      each of the floating point types. A number of these arrays are
	      predefined. They in turn are built on top of a set of standard
	      types defined by the library <literal>libiberty</literal>.
	    </para>
	  </listitem>
	    
	  <listitem>
	    <para>
	      <varname>char_signed</varname>. 1 if <type>char</type> to be
	      treated as signed, 0 if <type>char</type> is to be treated as
	      unsigned. The default is -1 (undefined), so this should always
	      be set.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  Specifying the Hardware Architecture and &abi;
	</title>

	<para>
	  A set of function members of &gdbarch; define aspects of the
	  architecture and its &abi;. For some of these functions, defaults
	  are provided which will be suitable for most architectures.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>return_value</function>. This function determines the
	      return convention for a particular type. For example on the
	      OpenRISC 1000, structs/unions and large (>32 bit) scalars are
	      returned as references, while small scalars are returned in
	      &gpr;&nbsp;11. This function should always be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>breakpoint_from_pc</function>. Returns the breakpoint
	      instruction to be used when the &pc; is at a particular location
	      in memory. For architectures with variable length instructions,
	      the choice of breakpoint instruction may depend on the length of
	      the instruction at the program counter. Returns the instruction
	      sequence and its length.
	    </para>

	    <para>
	      The default value is &null; (undefined). This function should
	      always be defined if &gdb; is to support breakpointing for this
	      architecture.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>adjust_breakpoint_address</function>. Some
	      architectures do not allow breakpoints to be placed at all
	      points. Given a program counter, this function returns an
	      address where a breakpoint <emphasis>can</emphasis> be
	      placed. Default value is &null; (undefined). The function need
	      only be defined for architectures which cannot accept a
	      breakpoint at all program counter locations.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>memory_insert_breakpoint</function> and
	      <function>memory_remove_breakpoint</function>. These functions
	      insert or remove memory based (a.k.a. soft) breakpoints. The
	      default values
	      <function>default_memory_insert_breakpoint</function> and
	      <function>default_memory_remove_breakpoint</function> are
	      suitable for most architectures, so in most cases these
	      functions need not be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>decr_pc_after_break</function>. Some architectures
	      require the program counter to be decremented after a break, to
	      allow the broken instruction to be executed on resumption. This
	      function returns the number of bytes by which to decrement the
	      address. The default value is &null; (undefined) which means the
	      program counter is left unchanged. This function need only be
	      defined if the functionality is required.
	    </para>

	    <para>
	      In practice this function is only of use for the very simplest
	      architectures. It applies only to software breakpoints, not
	      watchpoints or hardware breakpoints. It is more usual to adjust
	      the program counter as required in the target
	      <function>to_wait</function> and <function>to_resume</function>
	      functions (see <xref linkend="sec_target_ops" />).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>single_step_through_delay</function>. Returns 1 if the
	      target is executing a delay slot and a further single step is
	      needed before the instruction finishes. The default value is
	      &null; (not defined). This function should be implemented if the
	      target has delay slots.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_insn</function>. Disassemble an instruction and
	      print it. Default value is &null; (undefined). This function
	      should be defined if disassembly of code is to be supported.
	    </para>

	    <para>
	      Disassembly is a function required by the
	      <application>binutils</application> library. This function is
	      defined in the <filename>opcodes</filename> sub-directory. A
	      suitable implementation may already exist if
	      <application>binutils</application> has already been ported.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect2>

      <sect2>
	<title>
	  Specifying the Register Architecture
	</title>

	<para>
	  &gdb; considers registers to be a set with members numbered linearly
	  from 0 upwards. The first part of that set corresponds to real
	  physical registers, the second part to any
	  "pseudo-registers". Pseudo-registers have no independent physical
	  existence, but are useful representations of information within the
	  architecture. For example the OpenRISC 1000 architecture has up to
	  32 general purpose registers, which are typically represented as
	  32-bit (or 64-bit) integers. However it could be convenient to
	  define a set of pseudo-registers, to show the &gpr;s represented as
	  floating point registers.
	</para>

	<para>
	  For any architecture, the implementer will decide on a mapping from
	  hardware to &gdb; register numbers. The registers corresponding to
	  real hardware are referred to as <emphasis>raw</emphasis> registers,
	  the remaining registers are
	  <emphasis>pseudo-</emphasis>registers. The total register set (raw
	  and pseudo) is called the <emphasis>cooked</emphasis> register set.
	</para>

	<sect3>
	  <title>
	    &gdbarch; Functions Specifying the Register Architecture
	  </title>

	  <para>
	    These functions specify the number and type of registers in the
	    architecture.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>read_pc</function> and
		<function>write_pc</function>. Functions to read the program
		counter. The default value is &null; (no function
		available). However, if the program counter is just an ordinary
		register, it can be specified in &gdbarch; instead (see
		<varname>pc_regnum</varname> below) and it will be read or
		written using the standard routines to access registers. Thus
		this function need only be specified <emphasis>if</emphasis> the
		program counter is not an ordinary register.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>pseudo_register_read</function> and
		<function>pseudo_register_write</function>. These functions
		should be defined if there are any pseudo-registers (see <xref
		linkend="sec_arch_description" /> and <xref
		linkend="sec_regcache" /> for more information on
		pseudo-registers). The default value is &null;.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>num_regs</varname> and
		<varname>num_pseudo_regs</varname>. These define the number of
		real and pseudo-registers. They default to -1 (undefined) and
		should always be explicitly defined.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>sp_regnum</varname>, <varname>pc_regnum</varname>,
		<varname>ps_regnum</varname> and
		<varname>fp0_regnum</varname>. These specify the register
		holding the stack pointer, program counter, processor status and
		first floating point register. All except the first
		floating-point register (which defaults to 0) default to -1 (not
		defined). They may be real or
		pseudo-registers. <varname>sp_regnum</varname> must always be
		defined. If <varname>pc_regnum</varname> is not defined, then
		the functions <function>read_pc</function> and
		<function>write_pc</function> (see above) must be defined. If
		<varname>ps_regnum</varname> is not defined, then the
		<varname>$ps</varname> variable will not be available to the &gdb;
		user. <varname>fp0_regnum</varname> is not needed unless the
		target offers support for floating point.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions Giving Register Information
	  </title>

	  <para>
	    These functions return information about registers.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>register_name</function>. This function should
		convert a register number (raw or pseudo) to a register name
		(as a char *). This is used both to determine the name of a
		register for output and to work out the meaning of any
		register names used as input. For example with the OpenRISC
		1000, &gdb; registers 0-31 are the &gpr;s, register 32 is the
		program counter and register 33 is the supervision register,
		which map to the strings <literal>"gpr00"</literal> through
		<literal>"gpr31"</literal>, <literal>"pc"</literal> and
		<literal>"sr"</literal> respectively. This means that the
		&gdb; command <command>print $gpr5</command> should print the
		value of the OR1K general purpose register 5. The default
		value for this function is &null;. It should always be
		defined.
	      </para>

	      <para>
		Historically, &gdb; always had a concept of a <emphasis>frame
		pointer</emphasis> register, which could be accessed via the
		&gdb; variable, <command>$fp</command>. That concept is now
		deprecated, recognizing that not all architectures have a
		frame pointer. However if an architecture does have a frame
		pointer register, and defines a register or pseudo-register
		with the name <literal>"fp"</literal>, then that register will
		be used as the value of the <command>$fp</command> variable.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>register_type</function>. Given a register number,
		this function identifies the type of data it may be holding,
		specified as a <structname>struct&nbsp;type</structname>. &gdb;
		allows creation of arbitrary types, but a number of built in
		types are provided (<varname>builtin_type_void</varname>,
		<varname>builtin_type_int32</varname> etc), together with
		functions to derive types from these. Typically the program
		counter will have a type of "pointer to function" (it points to
		code), the frame pointer and stack pointer will have types of
		"pointer to void" (they point to data on the stack) and all
		other integer registers will have a type of 32-bit integer or
		64-bit integer. This information is used to help when displaying
		out register information. The default value is &null; meaning no
		information is available to help when displaying registers.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>print_registers_info</function>. Define this function
		to print out one or all of the registers for the &gdb;
		<command>info&nbsp;registers</command> command. The default
		value is the function
		<function>default_print_registers_info</function> which uses the
		type information (see <function>register_type</function> above)
		to determine how each register should be printed. Define this
		function for fuller control over how the registers are
		displayed.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>print_float_info</function> and
		<function>print_vector_info</function>. Define this function to
		provide output for the &gdb; <command>info&nbsp;float</command>
		and <command>info&nbsp;vector</command> commands
		respectively. The default value is &null; (not defined), meaning
		no information will be provided. Define each function if the
		target supports floating point or vector operations
		respectively.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>register_reggroup</function>. &gdb; groups registers
		into different categories (general, vector, floating point
		etc). This function given a register and group returns 1 (true)
		if the register is in the group and 0 otherwise. The default
		value is the function
		<function>default_register_reggroup_p</function> which will do a
		reasonable job based on the type of the register (see the
		function <function>register_type</function> above) and groups
		for general purpose registers, floating point registers, vector
		registers and real (i.e not pseudo) registers.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3 id="sec_regcache">
	  <title>
	    Register Caching
	  </title>

	  <para>
	    Caching of registers is used, so that the target does not need to
	    be accessed and reanalyzed multiple times for the register in
	    circumstances where the register value cannot have changed.
	  </para>

	  <para>
	    &gdb; provides &regcache;, associated with a particular &gdbarch; to
	    hold the cached values of the raw registers. A set of functions is
	    provided to access both the raw registers (with
	    <literal>raw</literal> in their name) and the full set of cooked
	    registers (with <literal>cooked</literal> in their name). Functions
	    are provided to ensure the register cache is kept synchronized with
	    the values of the actual registers in the target.
	  </para>

	  <para>
	    Accessing registers through the &regcache; routines will ensure that
	    the appropriate &gdbarch; functions are called when necessary to
	    access the underlying target architecture. In general users should
	    use the "cooked" functions, since these will map to the "raw"
	    functions automatically as appropriate.
	  </para>

	  <para>
	    The two key functions are <function>regcache_cooked_read</function>
	    and <function>regcache_cooked_write</function> which read or write a
	    register to or from a byte buffer (type
	    <type>gdb_byte&nbsp;*</type>). For convenience the wrapper functions
	    <function>regcache_cooked_read_signed</function>,
	    <function>regcache_cooked_read_unsigned</function>,
	    <function>regcache_cooked_write_signed</function> and
	    <function>regcache_cooked_write_unsigned</function> are provided,
	    which read or write the value and convert to or from a value as
	    appropriate.
	  </para>

	</sect3>

      </sect2>

      <sect2 id="sec_frames">
	<title>
	  Specifying Frame Handling
	</title>

	<para>
	  &gdb; needs to understand the stack on which local (automatic)
	  variables are stored. The area of the stack containing all the local
	  variables for a function invocation is known as the <emphasis>stack
	  frame</emphasis> for that function. In turn the function that called
	  the function will have its stack frame, and so on back through the
	  chain of functions that have been called.
	</para>

	<para>
	  Almost all architectures have one register dedicated to point to the
	  end of the stack (the <emphasis>stack pointer</emphasis>). Many have
	  a second register which points to the start of the currently active
	  stack frame (the <emphasis>frame pointer</emphasis>). The specific
	  arrangements for an architecture are a key part of the &abi;.
	</para>

	<para>
	  A diagram helps to explain this. Here is a simple program to compute
	  factorials:
	</para>

	<informalexample>
	  <programlisting>
 1:   #include &lt;stdio.h&gt;
 2:   
 3:   int fact( int  n )
 4:   {
 5:     if( 0 == n ) {
 6:       return 1;
 7:     }
 8:     else {
 9:       return n * fact( n - 1 );
10:     }
11:   }
12:   
13:   main()
14:   {
15:     int  i;
16:   
17:     for( i = 0 ; i &lt; 10 ; i++ ) {
18:       int   f = fact( i );
19:       printf( "%d! = %d\n", i, f );
20:     }
21:   }
	  </programlisting>
	</informalexample>

        <para>
	  Consider the state of the stack when the code reaches line 6 after
	  the main program has called <function>fact&nbsp;(3)</function>. The
	  chain of function calls will be <function>main</function>,
	  <function>fact&nbsp;(3)</function>,
	  <function>fact&nbsp;(2)</function>,
	  <function>fact&nbsp;(1)</function> and
	  <function>fact&nbsp;(0)</function>. In this example the stack is
	  falling (as used by the OpenRISC 1000 &abi;). The stack pointer
	  (&sp;) is at the end of the stack (lowest address) and the frame
	  pointer (&fp;) is at the highest address in the current stack
	  frame. <xref linkend="fig_stack_frame" /> shows how the stack looks.
	</para>

	<figure id="fig_stack_frame">
	  <title>
	    An example stack frame
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  In each stack frame, offset 0 from the stack pointer is the frame
	  pointer of the <emphasis>previous frame</emphasis> and offset 4
	  (this is illustrating a 32-bit architecture) from the stack pointer
	  is the return address. Local variables are indexed from the frame
	  pointer, with negative indexes. In the function
	  <function>fact</function>, offset -4 from the frame pointer is the
	  argument <varname>n</varname>. In the <function>main</function>
	  function, offset -4 from the frame pointer is the local variable
	  <varname>i</varname> and offset -8 from the frame pointer is the
	  local variable <varname>f</varname>.
	</para>

	<note>
	  <para>
	    This is a simplified example for illustrative purposes only. Good
	    optimizing compilers would not put anything on the stack for such
	    simple functions. Indeed they might eliminate the recursion and
	    use of the stack entirely!
	  </para>
	</note>

	<para>
	  It is very easy to get confused when examining stacks. &gdb; has
	  terminology it uses rigorously throughout. The stack frame of the
	  function currently executing, or where execution stopped is numbered
	  zero. In this example frame #0 is the stack frame of the call to
	  <function>fact&nbsp;(0)</function>. The stack frame of its calling
	  function (<function>fact(1)</function> in this case) is numbered #1 and
	  so on back through the chain of calls.
	</para>

	<para>
	  The main &gdb; data structure describing frames is &frame_info;. It
	  is not used directly, but only via its accessor
	  functions. &frame_info; includes information about the registers in
	  the frame and a pointer to the code of the function with which the
	  frame is associated. The entire stack is represented as a linked
	  list of &frame_info;.
	</para>

	<sect3>
	  <title>
	    Frame Handling Terminology
	  </title>

	  <para>
	    It is easy to get confused when referencing stack frames. &gdb; uses
	    some precise terminology.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		&this; frame is the frame currently under consideration.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		The &next; frame, also sometimes called the
		<emphasis>inner</emphasis> or <emphasis>newer</emphasis> frame
		is the frame of the function called by the function of &this;
		frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		The &prev; frame, also sometimes called the
		<emphasis>outer</emphasis> or <emphasis>older</emphasis> frame
		is the frame of the function which called the function of &this;
		frame.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    So in the example of <xref linkend="fig_stack_frame" />, if
	    &this; frame is #3 (the call to
	    <function>fact&nbsp;(3)</function>), the &next; frame is frame #2 (the
	    call to <function>fact&nbsp;(2)</function>) and the &prev; frame is
	    frame #4 (the call to <function>main&nbsp;()</function>).
	  </para>

	  <para>
	    The <emphasis>innermost</emphasis> frame is the frame of the current
	    executing function, or where the program stopped, in this example,
	    in the middle of the call to <function>fact&nbsp;(0)</function>). It
	    is always numbered frame #0.
	  </para>

	  <para>
	    The <emphasis>base</emphasis> of a frame is the address immediately
	    before the start of the &next; frame. For a falling stack this will
	    be the lowest address and for a rising stack this will be the
	    highest address in the frame.
	  </para>

	  <para>
	    &gdb; functions to analyze the stack are typically given a pointer
	    to the &next; frame to determine information about &this;
	    frame. Information about &this; frame includes data on where the
	    registers of the &prev; frame are stored in this stack frame. In
	    this example the frame pointer of the &prev; frame is stored at
	    offset 0 from the stack pointer of &this; frame.
	  </para>

	  <para>
	    The process whereby a function is given a pointer to the &next;
	    frame to work out information about &this; frame is referred to as
	    <emphasis>unwinding</emphasis>. The &gdb; functions involved in this
	    typically include <literal>unwind</literal> in their name.
	  </para>

	  <para>
	    The process of analyzing a target to determine the information that
	    should go in &frame_info; is called
	    <emphasis>sniffing</emphasis>. The functions that carry this out are
	    called <emphasis>sniffers</emphasis> and typically include
	    <literal>sniffer</literal> in their name. More than one sniffer may
	    be required to extract all the information for a particular frame.
	  </para>

	  <para>
	    Because so many functions work using the &next; frame, there is an
	    issue about addressing the <emphasis>innermost</emphasis>
	    frame&mdash;it has no &next; frame. To solve this &gdb; creates a
	    dummy frame #-1, known as the <emphasis>sentinel</emphasis> frame.
	  </para>
	</sect3>

	<sect3 id="sec_prologue_cache">
	  <title>
	    Prologue Caches
	  </title>

	  <para>
	    All the frame sniffing functions typically examine the code at the
	    start of the corresponding function, to determine the state of
	    registers. The &abi; will save old values and set new values of
	    key registers at the start of each function in what is known as
	    the function <emphasis>prologue</emphasis>.
	  </para>

	  <para>
	    For any particular stack frame this data does not change, so all
	    the standard unwinding functions, in addition to receiving a
	    pointer to the &next; frame as their first argument, receive a
	    pointer to a <emphasis>prologue cache</emphasis> as their second
	    argument. This can be used to store values associated with a
	    particular frame, for reuse on subsequent calls involving the same
	    frame.
	  </para>

	  <para>
	    It is up to the user to define the structure used (it is a
	    <type>void&nbsp;*</type> pointer) and arrange allocation and
	    deallocation of storage. However for general use, &gdb;
	    provides <structname>struct&nbsp;trad_frame_cache</structname>, with a
	    set of accessor routines. This structure holds the stack and code
	    address of &this; frame, the base address of the frame, a pointer
	    to the &frame_info; for the &next; frame and details of where the
	    registers of the &prev; frame may be found in &this; frame.
	  </para>

	  <para>
	    Typically the first time any sniffer function is called with
	    &next; frame, the prologue sniffer for &this; frame will be
	    &null;. The sniffer will analyze the frame, allocate a prologue
	    cache structure and populate it. Subsequent calls using the same
	    &next; frame will pass in this prologue cache, so the data can be
	    returned with no additional analysis.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions to Analyze Frames
	  </title>

	  <para>
	    These &gdbarch; functions and value provide analysis of the stack
	    frame and allow it to be adjusted as required.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>skip_prologue</function>. The prologue of a function is
		the code at the beginning of the function which sets up the
		stack frame, saves the return address etc. The code representing
		the behavior of the function starts after the prologue.
	      </para>

	      <para>
		This function skips past the prologue of a function if the program
		counter is within the prologue of a function. With modern
		optimizing compilers, this may be a far from trivial
		exercise. However the required information may be within the
		binary as DWARF2 debugging information, making the job much
		easier.
	      </para>

	      <para>
		The default value is &null; (not defined). This function should
		always may be provided, but can take advantage of DWARF2
		debugging information if that is available.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>inner_than</function>. Given two frame or stack
		pointers, return 1 (true) if the first represents the "inner"
		stack frame and 0 (false) otherwise. This is used to determine
		whether the target has a rising or a falling stack frame. See
		<xref linkend="sec_frames" /> for an explanation of "inner"
		frames.
	      </para>

	      <para>
		The default value of this function is &null; and it should
		always be defined. However for almost all architectures one of
		the built-in functions can be used:
		<function>core_addr_lessthan</function> (for falling stacks)
		or <function>core_addr_greaterthan</function> (for rising
		stacks).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_align</function>. The architecture may have
		constraints on how its frames are aligned. Given a proposed
		address for the stack pointer, this function returns a
		suitably aligned address (by expanding the stack frame). The
		default value is &null; (undefined). This function should be
		defined for any architecture where it is possible the stack
		could become misaligned. The utility functions
		<function>align_down</function> (for falling stacks) and
		<function>align_up</function> (for rising stacks) will
		facilitate the implementation of this function.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<varname>frame_red_zone_size</varname>. Some &abi;s reserve
		space beyond the end of the stack for use by leaf functions
		without prologue or epilogue or by exception handlers
		(OpenRISC 1000 is in this category). This is known as a
		<emphasis>red zone</emphasis> (<acronym>AMD</acronym>
		terminology). The default value is 0. Set this field if the
		architecture has such a red zone.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions to Access Frame Data
	  </title>

	  <para>
	    These functions provide access to key registers and arguments int
	    the stack frame.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>unwind_pc</function> and
		<function>unwind_sp</function>. These functions are given a
		pointer to &this; stack frame (see <xref linkend="sec_frames"
		/> for how frames are represented) and return the value of the
		program counter and stack pointer respectively in the &prev;
		frame (i.e. the frame of the function that called this one).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_num_args</function>. Given a pointer to &this;
		stack frame (see <xref linkend="sec_frames" /> for how frames
		are represented), return the number of arguments that are
		being passed, or -1 if not known. The default value is -1
		(undefined), in which case the number of arguments passed on
		any stack frame is always unknown. For many architectures this
		will be a suitable default.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions Creating Dummy Frames
	  </title>

	  <para>
	    &gdb; can call functions in the target code (for example by using
	    the <command>call</command> or <command>print</command>
	    commands). These functions may be breakpointed, and it is
	    essential that if a function does hit a breakpoint, commands like
	    <command>backtrace</command> work correctly.
	  </para>

	  <para>
	    This is achieved by making the stack look as though the function
	    had been called from the point where &gdb; had previously
	    stopped. This requires that &gdb; can set up stack frames
	    appropriate for such function calls.
	  </para>

	  <para>
	    The following functions provide the functionality to set up such
	    "dummy" stack frames.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>push_dummy_call</function>. &gdb; allows you to
		execute parts of the program being debugged, either directly via
		the <command>call</command> command or indirectly when function
		calls form arguments to commands such as
		<command>print</command>. &gdb; needs to make it look as though
		these functions have been called from the existing point in the
		code, with their own stack frame. This means if the function
		hits a breakpoint, a stack backtrace will work correctly.
	      </para>

	      <para>
		To make this work, &gdb; sets up a "dummy" stack frame for the
		function about to be
		called. <function>push_dummy_call</function> is given the
		arguments to be passed and must copy them into registers or push
		them on to the stack as appropriate for the &abi;. &gdb; will
		then pass control to the target at the address of the function,
		and it will find the stack and registers set up just as
		expected.
	      </para>

	      <para>
		The default value of this function is &null; (undefined). If the
		function is not defined, then &gdb; will not allow the user to
		call functions within the target being debugged.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>unwind_dummy_id</function>. This is the inverse of
		<function>push_dummy_call</function> which restores the stack
		and frame pointers after a call to evaluate a function using a
		dummy stack frame. The default value is &null; (undefined). If
		<function>push_dummy_call</function> is defined, then this
		function should also be defined.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>push_dummy_code</function>. If this function is not
		defined (its default value is &null;), a dummy call will use the
		entry point of the target as its return address. A temporary
		breakpoint will be set there, so the location must be writable
		and have room for a breakpoint.
	      </para>

	      <para>
		It is possible that this default is not suitable. It might not
		be writable (in ROM possibly), or the &abi; might require code
		to be executed on return from a call to unwind the stack before
		the breakpoint is encountered.
	      </para>

	      <para>
		If either of these is the case, then
		<function>push_dummy_code</function> should be defined to push
		an instruction sequence onto the end of the stack to which the
		dummy call should return.
	      </para>

	      <note>
		<para>
		  This does require that code in the stack can be executed. Some
		  Harvard architectures may not allow this.
		</para>
	      </note>
	    </listitem>
	  </itemizedlist>
	</sect3>

	<sect3>
	  <title>
	    Analyzing Stacks: Frame Sniffers
	  </title>

	  <para>
	    When a program stops, &gdb; needs to construct the chain of
	    &frame_info; representing the state of the stack using appropriate
	    <emphasis>sniffers</emphasis>.
	  </para>

	  <para>
	    Each architecture requires appropriate sniffers, but they do not
	    form entries in &gdbarch;, since more than one sniffer may be
	    required and a sniffer may be suitable for more than one
	    &gdbarch;. Instead sniffers are associated with architectures using
	    the following functions.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>frame_unwind_append_sniffer</function> is used to
		add a new sniffer to analyze &this; frame when given a pointer
		to the &next; frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_append_sniffer</function> is used to add
		a new sniffer which can determine information about the base
		of a stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_set_default</function> is used to specify
		the default base sniffer.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    These functions all take a reference to &gdbarch;, so they are
	    associated with a specific architecture. They are usually called
	    in the &gdbarch; initialization function, after the &gdbarch; has
	    been set up. Unless a default has been set, the sniffers will be
	    tried most recently appended first.
	  </para>

	  <para>
	    The main frame unwinding sniffer (as set by
	    <function>frame_unwind_append_sniffer</function>) returns a
	    structure specifying a set of sniffing functions:
	  </para>

	  <informalexample>
	    <programlisting>
struct frame_unwind
{
  enum frame_type            type;
  frame_this_id_ftype       *this_id;
  frame_prev_register_ftype *prev_register;
  const struct frame_data   *unwind_data;
  frame_sniffer_ftype       *sniffer;
  frame_prev_pc_ftype       *prev_pc;
  frame_dealloc_cache_ftype *dealloc_cache;
};
	    </programlisting>
	  </informalexample>

	  <para>
	    The <varname>type</varname> field indicates the type of frame this
	    sniffer can handle: normal, dummy (see
	    <function>push_dummy_call</function> in <xref
	    linkend="sec_gdbarch" />), signal handler or sentinel. Signal
	    handlers sometimes have their own simplified stack structure for
	    efficiency, so may need their own handlers.
	  </para>

	  <para>
	    <varname>unwind_data</varname> holds additional information which
	    may be relevant to particular types of frame. For example it may
	    hold additional information for signal handler frames.
	  </para>

	  <para>
	    The remaining fields define functions that yield different types
	    of information when given a pointer to the &next; stack frame. Not
	    all functions need be provided. If an entry is &null;, the next
	    sniffer will be tried instead.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>this_id</function> determines the stack pointer and
		function (code entry point) for &this; stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_register</function> determines where the values
		of registers for the &prev; stack frame are stored in &this;
		stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>sniffer</function> takes a look at &this; frame's
		registers to determine if this is the appropriate unwinder.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_pc</function> determines the program counter
		for &this; frame. Only needed if the program counter is not an
		ordinary register (see <function>prev_pc</function> in <xref
		linkend="sec_gdbarch" />).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>dealloc_cache</function> frees any additional memory
		associated with the prologue cache for this frame (see <xref
		linkend="sec_prologue_cache" />).
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    In general it is only the <function>this_id</function> and
	    <function>prev_register</function> functions that need be defined
	    for most custom sniffers.
	  </para>

	  <para>
	    The frame base sniffer is much simpler. It is a
	    <structname>struct&nbsp;frame_base</structname>, which refers to the
	    corresponding <structname>struct&nbsp;frame_unwind</structname> and
	    provides functions yielding various addresses within the frame.
	  </para>

	  <informalexample>
	    <programlisting>
struct frame_base
{
  const struct frame_unwind *unwind;
  frame_this_base_ftype     *this_base;
  frame_this_locals_ftype   *this_locals;
  frame_this_args_ftype     *this_args;
};
	    </programlisting>
	  </informalexample>

	  <para>
	    All these functions take a pointer to the &next; frame as
	    argument. <function>this_base</function> returns the base address
	    of &this; frame, <function>this_locals</function> returns the base
	    address of local variables in &this; frame and
	    <function>this_args</function> returns the base address of the
	    function arguments in this frame.
	  </para>

	  <para>
	    As described above the <emphasis>base</emphasis> address of a
	    frame is the address immediately before the start of the &next;
	    frame. For a falling stack, this is the lowest address in the
	    frame and for a falling stack it is the highest address in the
	    frame. For most architectures the same address is also the base
	    address for local variables and arguments, in which case the same
	    function can be used for all three entries.
	  </para>

	  <para>
	    It is worth noting that if it cannot be determined in any other
	    way (for example by their being a register with the name
	    <literal>"fp"</literal>), then the result of the
	    <function>this_base</function> function will be used as the value
	    of the frame pointer variable <varname>$fp</varname> in &gdb;
	  </para>
	</sect3>

      </sect2>

    </sect1>

    <sect1 id="sec_target_ops">
      <title>
	Target Operations
      </title>

      <para>
	The communication with the target is down to a set of <emphasis>target
	operations</emphasis>. These operations are held in a &target_ops;,
	together with flags describing the behavior of the target. The
	&target_ops; elements are defined and documented in
	<filename>target.h</filename>. The sections following describe the
	most important of these functions.
      </para>

      <sect2>
	<title>
	  Target Strata
	</title>

	<para>
	  &gdb; has several different types of target: executable files, core
	  dumps, executing processes etc. At any time, &gdb; may have several
	  sets of target operations in use. For example target operations for
	  use with an executing process (which can run code) might be
	  different from the operations used when inspecting a core dump.
	</para>

	<para>
	  All the targets &gdb; knows about are held in a stack. &gdb; walks
	  down the stack to find the set of target operations suitable for
	  use. The stack is organized as a series of <emphasis>strata</emphasis>
	  or decreasing importance: target operations for threads, then target
	  operations suitable for processes, target operations to download
	  remote targets, target operations for core dumps, target operations
	  for executable files and at the bottom target operations for dummy
	  targets. So &gdb; when debugging a running process will always select
	  target operations from the process_stratum if available, over target
	  operations from the file stratum, even if the target operations from
	  the file stratum were pushed onto the stack more recently.
	</para>

	<para>
	  At any particular time, there is a <emphasis>current</emphasis>
	  target, held in the global variable
	  <varname>current_target</varname>. This can never be &null;&mdash;if
	  there is no other target available, it will point to the dummy target.
	</para>

	<para>
	  <filename>target.h</filename> defines a set of convenience macros to
	  access functions and values in the
	  <varname>current_target</varname>. Thus
	  <function>current_target->to_xyz</function> can be accessed as
	  <function>target_xyz</function>.
	</para>
      </sect2>

      <sect2>
	<title>
	  Specifying a New Target
	</title>

	<para>
	  Some targets (sets of target operations in a &target_ops;) are set up
	  automatically by &gdb;&mdash;these include the operations to drive
	  simulators (see <xref linkend="ref_simulators" /> and the operations
	  to drive the &gdb; <emphasis>Remote Serial Protocol</emphasis> (&rsp;)
	  (see <xref linkend="sec_rsp" />).
	</para>

	<para>
	  Other targets must be set up explicitly by the implementer, using
	  the <function>add_target</function> function. By far the most common
	  is the <emphasis>native</emphasis> target for native debugging of the
	  host. Less common is to set up a non-native target, such as the
	  &jtag; target used with the OpenRISC 1000<footnote>
	  <para>
	    For a new remote target of any kind, the recommended approach is
	    to use the standard &gdb; Remote Serial Protocol and have the
	    target implement the server side of this interface. The only
	    remote targets remaining are historic legacy interfaces, such as
	    the OpenRISC 1000 Remote &jtag; Protocol.
	  </para>
	  </footnote>.
	</para>

	<sect3>
	  <title>
	    Native Targets
	  </title>

	  <para>
	    A new native target is created by defining a function
	    <function>_initialize_&arch;_&os;_nat</function> for the
	    architecture, &arch; and operating system &os;, in the source file
	    <filename>&arch;-&os;-nat.c</filename>. A fragment of a makefile
	    to create the binary from the source is created in the file
	    <filename>config/&arch;/&os;.mh</filename> with a header giving
	    any macro definitions etc in
	    <filename>config/&arch;/nm-&os;.h</filename> (which will be linked
	    to <filename>nm.h</filename> at build time).
	  </para>

	  <para>
	    The <literal>_initialize_</literal> function should create a new
	    &target_ops; and call <function>add_target</function> to add this
	    target to the list of available targets.
	  </para>

	  <para>
	    For new native targets there are standard implementations which
	    can be reused, with just one or two changes. For example the
	    function <function>linux_trad_target</function> returns a
	    &target_ops; suitable for most Linux native targets. It may prove
	    necessary only to alter the description field and the functions to
	    fetch and store registers.
	  </para>

	</sect3>

	<sect3>
	  <title>
	    Remote Targets
	  </title>

	  <para>
	    For a new remote target, the procedure is a little simpler. The
	    source files should be added to <filename>configure.tgt</filename>,
	    just as for the architectural description (see <xref
	    linkend="sec_gdbarch" />). Within the source file, define a new
	    function
	    <function>_initialize_remote_&arch;</function> to
	    implement a new remote target, &arch;.
	  </para>

	  <para>
	    For new remote targets, the definitions in
	    <filename>remote.c</filename> used to implement the &rsp; provide a
	    good starting point.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions and Variables Providing Information
	</title>

	<para>
	  These functions and variables provide information about the
	  target. The first group identify the name of the target and provide
	  help information for the user.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_shortname</varname>. This string is the name of
	      target, for use with &gdb;s <command>target</command>. Setting
	      <varname>to_shortname</varname> to <emphasis>foo</emphasis>
	      means that <command>target&nbsp;</command><emphasis>foo</emphasis>
	      will connect to the target, invoking to
	      <function>to_open</function> for this target (see below).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_longname</varname>. A string giving a brief
	      description of the type of target. This is printed with the
	      <command>info target</command> information (see also
	      <function>to_files_info</function> below).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_doc</varname>. The help text for this target. If the
	      short name of the target is <emphasis>foo</emphasis>, then the
	      command <command>help&nbsp;target</command> will print
	      <literal>target </literal><emphasis>foo</emphasis> followed by
	      the first sentence of this help text. The command
	      <command>help&nbsp;target&nbsp;</command><emphasis>foo</emphasis>
	      will print out the complete text.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_files_info</function>. This function provides
	      additional information for the <command>info target</command>
	      command.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  The second group of variables provide information about the current
	  state of the target.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_stratum</varname>. An enumerated constant indicating
	      to which stratum this &target_ops; belongs
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_all_memory</varname>. Boolean indicating if the
	      target includes all of memory, or only part of it. If only part,
	      then a failed memory request may be able to be satisfied by a
	      different target in the stack.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_memory</varname>. Boolean indicating if the
	      target has memory (dummy targets to not)
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_stack</varname>. Boolean indicating if the
	      target has a stack. Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_registers</varname>. Boolean indicating if the
	      target has registers.  Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_execution</varname>. Boolean indicating if the
	      target is currently executing. For some targets that is the same
	      as if they are capable of execution. However some remote targets
	      can be in the position where they are not executing until
	      <function>create_inferior</function> or
	      <function>attach</function> is called.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions Controlling the Target Connection
	</title>

	<para>
	  These functions control the connection to the target. For remote
	  targets this may mean establishing and tearing down links using
	  protocols such as <acronym>TCP/IP</acronym>. For native targets,
	  these functions will be more concerned with setting flags describing
	  the state.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_open</function>. This function should establish the
	      communications with the target. It should establish the state of
	      the target (is it already running for example), and initialize
	      data structures appropriately. It should
	      <emphasis>not</emphasis> start the target running if it is not
	      currently running&mdash;that is the job of the &gdb;
	      <command>run</command> command.
	    </para>

	    <para>
	      <function>to_open</function> is invoked by the &gdb;
	      <command>target</command> command. Any additional arguments
	      (beyond the name of the target being invoked) are passed to this
	      function.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xclose</function> and
	      <function>to_close</function>. Both these functions should close
	      the remote connection. <function>to_close</function> is the
	      legacy function. New implementations should use
	      <function>to_xclose</function> which should also free any memory
	      allocated for this target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_attach</function>. For targets which can run
	      without a debugger connected, this function attaches the
	      debugger to a running target (which should first have been
	      opened).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_detach</function>. Function to detach from a
	      target, leaving it running.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_disconnect</function>. This is similar to
	      <function>to_detach</function>, but makes no effort to inform
	      the target that the debugger is detaching. It should just drop
	      the connection to the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_terminal_inferior</function>. This function
	      connects the target's terminal I/O to the local terminal. This
	      functionality is not always available with remote targets.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_rcmd</function>. If the target is capable of
	      running commands, then this function requests that command to be
	      run on the target. This is of most relevance to remote targets.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Access Memory and Registers
	</title>

	<para>
	  These functions transfer data to and from the target registers and
	  memory.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_fetch_registers</function> and
	      <function>to_store_registers</function>. Functions to populate
	      the register cache with values from the target and to set target
	      registers with values in the register cache.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_prepare_to_store</function>. This function is
	      called prior to storing registers to set up any additional
	      information required. In most cases it will be an empty function.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_load</function>. Load a file into the target. Since
	      this is built on top of the other target operations the generic
	      function <function>generic_load</function> is suitable for most
	      implementations.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xfer_partial</function>. This function is a generic
	      function to transfer data to and from the target. Its most
	      important function (often the only one actually implemented) is
	      to load and store data from and to target memory.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Handle Breakpoints and Watchpoints
	</title>

	<para>
	  For all targets, &gdb; can implement breakpoints and write access
	  watchpoints in software, by inserting code in the target. However
	  many targets provide hardware assistance for these functions which
	  is far more efficient, and in addition may implement read access
	  watchpoints.
	</para>

	<para>
	  These functions in &target_ops; provide a mechanism to access such
	  functionality if it is available.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_insert_breakpoint</function> and
	      <function>to_remove_breakpoint</function>. These functions
	      insert and remove breakpoints on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_can_use_hw_breakpoint</function>. This function
	      should return 1 (true) if the target can set a hardware
	      breakpoint or watchpoint and 0 otherwise. The function is passed
	      an enumeration to indicate whether watchpoints or breakpoints
	      are being queried, and should use information about the number
	      of hardware breakpoints/watchpoints currently in use to
	      determine if a breakpoint/watchpoint can be set.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_insert_hw_breakpoint</function> and
	      <function>to_remove_hw_breakpoint</function>. Functions to
	      insert and remove hardware breakpoints.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_remove_watchpoint</function> and
	      <function>to_insert_watchpoint</function>. Functions to remove
	      and insert watchpoints.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_by_watchpoint</function>. Function returns
	      1 (true) if the last stop was due to a watchpoint.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_data_address</function>. If the last stop
	      was due to a watchpoint, this function returns the address of
	      the data which triggered the watchpoint.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Control Execution
	</title>

	<para>
	  for targets capable of execution, these functions provide the
	  mechanisms to start and stop execution.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_resume</function>. Function to tell the target to
	      start running again (or for the first time).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_wait</function>. Function to wait for the target to
	      return control to the debugger. Typically this will be when the
	      target finishes execution or hits a breakpoint. It could also
	      occur if the connection is interrupted (for example by ctrl-C).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stop</function>. Function to stop the target - used
	      whenever the target is to be interrupted (for example by ctrl-C).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_kill</function>. Kill the target. This should work,
	      even if the connection to the target is broken.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_create_inferior</function>. For targets which can
	      execute, this initializes a program running, read for it to
	      start executing. It is
	      invoked by the &gdb; <command>run</command> command, which will
	      subsequently call <function>to_resume</function> to start
	      execution.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_mourn_inferior</function>. Tidy up after execution
	      of the target has finished (for example after it has exited or
	      been killed). Most implementations call the generic function,
	      <function>generic_mourn_inferior</function>, but may do some
	      additional tidying up.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

    </sect1>

    <sect1 id="sec_adding_commands">
      <title>
	Adding Commands to &gdb;
      </title>

      <para>
	As noted in <xref linkend="sec_main_areas" />, &gdb;'s command
	handling is extensible. Commands are grouped into a number of command
	lists (of type <structname>struct&nbsp;cmd_list_element</structname>),
	pointed to by a number of global variables (defined in
	<filename>cli-cmds.h</filename>). Of these, <varname>cmdlist</varname>
	is the list of all defined commands, with separate lists defined for
	sub-commands of various top level commands. For example
	<varname>infolist</varname> is the list of all <command>info</command>
	sub-commands.
      </para>

      <para>
	Each command (or sub-command) is associated with a callback function
	which implements the behavior of the functions. There are additional
	requirements for functions which set or show values within &gdb;. Each
	function also takes a documentation string (used by the help
	command). Functions for adding commands all return a pointer
	to the <structname>struct&nbsp;cmd_list_element</structname> for the
	command added (which is not necessarily the head of its command
	list). The most useful functions are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>add_cmd</function>. Add a function to a command list.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_com</function>. Add a function to the main command
	    list, <varname>cmdlist</varname>. This is a convenience wrapper
	    for <function>add_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_prefix_cmd</function>. Add a new prefix
	    command. This command should have its own function for use if it
	    is called on its own, and a global command list pointer specific
	    to the prefix command to which all its sub-commands will be
	    added. If a prefix command is called with an unknown sub-command,
	    it can either give an error or call the function of the prefix
	    command itself. Which of these is used is specified by a flag in
	    the call to <function>add_prefix_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_alias_cmd</function>. Add an alias for a command
	    already defined.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_info</function>. Add a sub-command to the
	    <command>info</command>. A convenience wrapper for
	    <function>add_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_cmd</function>. Add a function to a command list.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	New commands are usually added in the
	<function>initialize_&arch;</function> function after the &gdbarch;
	has been defined.
      </para>
    </sect1>

    <sect1 id="ref_simulators">
      <title>
	Simulators
      </title>

      <para>
	&gdb; enables implementers to link gdb to a built-in simulator, so
	that a simulated target may be executed through use of the
	<command>target&nbsp;sim</command> command.
      </para>

      <para>
	The simulator should be built as a library,
	<filename>libsim.a</filename>, implementing the standard &gdb;
	simulator interface. The location of the library is specified by
	setting the <parameter>gdb_sim</parameter> parameter in
	<filename>configure.tgt</filename>.
      </para>

      <para>
	The interface consists of a set of functions which should be
	implemented. The detailed specification is found in the header
	<filename>remote-sim.h</filename> in the include directory.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>sim_open</function>. Initialize the simulator.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_close</function>. Destroy the simulator instance,
	    including freeing any memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_load</function>. Load a program into the simulator's
	    memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_create_inferior</function>. Prepare to run the
	    simulated program. Don't actually run it until
	    <function>sim_resume</function> (see below) is called.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_read</function> and
	    <function>sim_write</function>. Read and write bytes from and to
	    the simulator's memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_fetch_register</function> and
	    <function>sim_store_register</function>. Read and write the
	    simulator's registers.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_info</function>. Print information for the
	    <command>info sim</command> command.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_resume</function>. Resume (or start) execution of
	    the simulated program.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop</function>. Stop execution of the simulated
	    program.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop_reason</function>. Return the reason why the
	    program stopped.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_do_command</function>. Execute some arbitrary
	    command that the simulator supports.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="sec_rsp">
      <title>
	Remote Serial Protocol
      </title>

      <para>
	The &gdb; <emphasis>Remote Serial Protocol</emphasis> is a general
	purpose protocol for connecting to remote targets. It is invoked
	through the <command>target remote</command> command.
      </para>

      <para>
	The protocol is a simple text command-response protocol. Any remote
	target can communicate with &gdb; by implementing the server side of
	the &rsp;. A number of stub implementations are provided for various
	architectures, which can be used as the basis of new implementations.
      </para>

      <para>
	It is strongly recommended that any new remote target should be
	implemented using the &rsp;, rather than by creating a new remote
	target protocol.
      </para>
    </sect1>

    <sect1>
      <title>
	&gdb; File Organization
      </title>

      <para>
	The bulk of the &gdb; source code is in a small number of
	directories. Some components of &gdb; are libraries used elsewhere
	(for example &bfd; is used in &gnu; binutils), and these have their own
	directory. The main directories are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>include</filename>. Header files for information which
	    straddles major components. For example the main simulator
	    interface header is here (<filename>remote-sim.h</filename>),
	    because it links &gdb; (in directory <filename>gdb</filename>) to
	    the simulators (in directory <filename>sim</filename>). Other
	    headers, specific to a particular component reside in the
	    directory of that component.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>bfd</filename>. The Binary File Descriptor library. If a
	    new object file type must be recognized, it should be added here.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb</filename>. The main &gdb; directory. All source
	    files should include <filename>defs.h</filename> first and then
	    any other headers they reference. Headers should also include any
	    headers they reference, but may assume that
	    <filename>defs.h</filename> has been included.
	  </para>

	  <para>
	    The file <filename>configure.tgt</filename> contains a huge switch
	    statement to match targets specified to the main
	    <command>configure</command> command. Add a new target by
	    incorporating its pattern match in this file.
	  </para>

	  <para>
	    The sub-directory <filename>config</filename> contains target
	    specific configuration information for native targets.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>libiberty</filename>. Before POSIX and <application>glibc</application>, this was a
	    &gnu; project to provide a set of standard functions. It lives on in
	    &gnu;. Most valuable are its free store management and argument
	    parsing functions.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>opcodes</filename>. This contains disassemblers for use
	    by &gdb; (the <command>disassemble</command> command);. In a
	    directory of its own, because this code is also used in binutils.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>sim</filename>. The simulators for various targets. Each
	    target architecture simulator is built in its own sub-directory.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>
	Testing &gdb;
      </title>

      <para>
	Running the &gdb; test suite requires that the
	<application>DejaGNU</application> package is installed. The tests can
	then be run with:
      </para>

      <informalexample>
	<para>
	  <command>make check</command>
	</para>
      </informalexample>

      <para>
	On completion of the run, the summary results will be in the
	<filename>gdb/testsuite</filename> directory in
	<filename>gdb.sum</filename> with the detailed log in
	<filename>gdb.log</filename>
      </para>

      <para>
	For the most comprehensive tests in an environment where host and
	target differ, <application>DejaGNU</application> needs some additional configuration. This can be
	achieved by setting the <constant>DEJAGNU</constant> environment
	variable to refer to a suitable configuration file, and defining a
	custom board configuration file in the directory
	<filename>~/boards</filename>. These configuration files can be used
	to specify a suitable simulator and how to connect it when running
	tests.
      </para>
    </sect1>

    <sect1>
      <title>
	Documentation
      </title>

      <para>
	Some of &gdb; sub-directories in turn have <filename>doc</filename>
	sub-directories. The documentation is written in
	<application>texinfo</application> <xref linkend="ref_texinfo" />,
	from which documents can be generated as &pdf;, <application>PostScript</application>, &html; or
	<command>info</command> files. The documentation is not built
	automatically with <command>make&nbsp;all</command>, nor with
	<command>make&nbsp;doc</command>.
      </para>

      <para>
	To create documentation, change to the individual documentation
	directory and use <command>make&nbsp;html</command>,
	<command>make&nbsp;pdf</command>, <command>make&nbsp;ps</command> or
	<command>make&nbsp;info</command> as required.
      </para>

      <para>
	The main documents of interest are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>bfd/doc/bfd.texinfo</filename>. This is the &bfd; manual.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdb.texinfo</filename>. This is the main &gdb;
	    user guide <xref linkend="ref_gdb_ug" />.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdbint.texinfo</filename>. This is the internals
	    user guide <xref linkend="ref_gdb_int" />. It is essential reading
	    for any developer porting the code.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The exception to automatic building is with
	<command>make&nbsp;install</command>. This will build
	<command>info</command> files for any documents in the
	<filename>gdb/doc</filename> directory and install them in the
	<filename>info</filename> sub-directory of the install directory.
      </para>

    </sect1>      

    <sect1>
      <title>
	Example Procedure Flows in &gdb;
      </title>

      <para>
	It is instructive to see how the architecture specification functions
	and target operations are invoked in response to various &gdb;
	commands. This gives useful points for debugging a new architecture
	port.
      </para>

      <para>
	In the following sections, several procedure flows are described
	illustrated by sequence diagrams. These show the calling chain for
	procedures. Only the key functions are shown - the actual calls usually
	involve several intermediate function calls.
      </para>

      <sect2>
	<title>
	  Initial Start up
	</title>

	<para>
	  <xref linkend="fig_startup_flow" /> shows the sequence diagram for
	  &gdb; start up.
	</para>

	<figure id="fig_startup_flow">
	  <title>
	    Sequence diagram for &gdb; start up
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="startup_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="startup_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  On start up, the &gdb; initialization function,
	  <function>gdb_init</function> calls all the
	  <function>_initialize</function> functions, including those for any
	  architectures or remote targets.
	</para>

	<para>
	  Having initialized all the architectures, the first alphabetically
	  is selected as the default architecture by
	  <function>initialize_current_architecture</function>, and its
	  initialization function, (by convention
	  <function>&arch;_gdbarch_init</function>) is called.
	</para>

	<para>
	  Control returns to <function>gdb_main</function>, which sits in the
	  command interpreter, waiting for commands to execute.
	</para>

      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>target</command> Command
	</title>

	<para>
	  <xref linkend="fig_target_hl_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>target</command> command.
	</para>

	<figure id="fig_target_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>target</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="target_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="target_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>
	  
	<para>
	  The <command>target</command> command maps directly on to the
	  current target <function>to_open</function>. A typical
	  implementation establishes physical connection to the target (for
	  example by opening a TCP/IP link to a remote target). For a remote
	  target, it then typically calls <function>start_remote</function>,
	  which waits for the target to stop (using the current target
	  <function>to_wait</function> function), determines the reason for
	  stopping (<function>handle_inferior_event</function>) and then marks
	  this as a normal stop (<function>normal_stop</function>).
	</para>

	<para>
	  <function>handle_inferior_event</function> is a central function in
	  &gdb;. Whenever control is returned to &gdb;, via the target
	  <function>to_wait</function> function, it must determine what has
	  happened and how it should be handled. <xref
	  linkend="fig_target_handle_inferior_flow" /> shows the behavior of
	  <function>handle_inferior_event</function> in response to the
	  <command>target</command> command.
	</para>

	<figure id="fig_target_handle_inferior_flow">
	  <title>
	    <function>handle_inferior_event</function> sequence diagram in
	    response to the &gdb; <command>target</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="target_handle_inferior_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="target_handle_inferior_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  <function>handle_inferior_event</function> needs to establish the
	  program counter at which execution stopped, so calls
	  <function>read_pc_pid</function>. Since the program counter is a
	  register, this causes creation of a register cache, for which the
	  type of each register must be determined by
	  <function>gdbarch_register_type</function> (a one-off exercise,
	  since this never changes). Having determined register types, the
	  register cache is populated with the value of the program counter by
	  calling the current target <function>to_fetch_registers</function>
	  for the relevant register.
	</para>

	<para>
	  <function>handle_inferior_event</function> then determines if the
	  stop was due to a breakpoint or watchpoint. The function
	  <function>watchpoints_triggered</function> uses the target
	  <function>target_stopped_by_watchpoint</function> to determine if it
	  was a watchpoint which triggered the stop.
	</para>

	<para>
	  The call to <function>normal_stop</function> also invokes the
	  &gdbarch; functions, calling <function>gdbarch_unwind_pc</function>
	  to establish the current program counter and and frame sniffer
	  functions to establish the frame sniffer stack.
	</para>
      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>load</command> Command
	</title>

	<para>
	  <xref linkend="fig_load_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>load</command> command. This maps to a call the the current
	  target's <function>to_load</function> function, which in most cases
	  will end up calling the current target's
	  <function>to_xfer_partial</function> function once for each section
	  of the image to load it into memory.
	</para>

	<figure id="fig_load_flow">
	  <title>
	    Sequence diagram for the &gdb; <command>load</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="load_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="load_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The load function will capture data from the loaded file, most
	  importantly its start address for execution.
	</para>

      </sect2>
	  
      <sect2>
	<title>
	  The &gdb; <command>break</command> Command
	</title>

	<para>
	  <xref linkend="fig_break_flow" /> shows the high level sequence
	  diagram for &gdb; in response to the <command>break</command>
	  command. This example is for the case where the target of the break
	  is a symbol (i.e. a function name) in the target executable.
	</para>

	<figure id="fig_break_flow">
	  <title>
	    Sequence diagram for the &gdb; <command>load</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="break_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="break_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Most of the action with breakpoints occurs when the program is set
	  running, at which any active breakpoints are installed. However for
	  any <command>break</command> command, the address for the break must
	  be set up in the breakpoint data structure.
	</para>

	<para>
	  For symbolic addresses, the start of the function can be obtained
	  from the line number information held for debugging purposes in the
	  symbol table (known as <emphasis>symbol-and-line</emphasis>
	  information, or &sal;). For a function, this will yield the start
	  address of the code. However the breakpoint must be set after the
	  function prologue. <function>gdbarch_skip_prolog</function> is used to
	  find that address in the code.
	</para>

      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>run</command> Command
	</title>

	<para>
	  <xref linkend="fig_run_hl_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>run</command> command.
	</para>

	<figure id="fig_run_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The <command>run</command> command must create the inferior, insert
	  any active breakpoints and watchpoints, and then start execution of
	  the inferior. Control does not return to &gdb; until the target
	  reports that it has stopped.
	</para>

	<para>
	  The top level function implementing the <command>run</command>
	  command is <function>run_command</function>. This creates the
	  inferior, but calling the current target's
	  <function>to_create_inferior</function> function. &gdb; supports
	  targets which can give a dynamic description of their architecture
	  (for example the number of registers available). This is achieved
	  through the <function>to_find_description</function> function of the
	  current target (which is an empty function by default).
	</para>

	<para>
	  Execution is started by the <function>proceed</function>. This must
	  first determine if the code is restarting on an instruction which
	  will need stepping through a delay slot (so that code never stops on
	  a delay slot). If this functionality is required, it is implemented
	  by the <function>gdbarch_single_sep_through_delay</function>
	  function.
	</para>

	<para>
	  Active breakpoints are inserted using the current target's
	  <function>to_insert_breakpoint</function> function. The code is then
	  run using the <function>to_resume</function> function of the current
	  target.
	</para>

	<para>
	  &gdb; then calls <function>wait_for_inferior</function>, which will
	  wait for the target to stop, and then determine the reason for the
	  stop. Finally <function>normal_stop</function> will remove the
	  breakpoints from the target code and report to the user the current
	  state of the target as appropriate.
	</para>

	<para>
	  Much of the detailed processing takes place in the
	  <function>wait_for_inferior</function> and
	  <function>normal_stop</function> functions (see also their use in
	  <xref linkend="sec_target_flow" />). These are important functions
	  and it is useful to look at their behavior in more detail.
	</para>

	<para>
	  <xref linkend="fig_run_wait_for_inferior_flow" /> shows the sequence
	  diagram for <function>wait_for_inferior</function> when handling the
	  &gdb; <command>run</command> command.
	</para>

	<figure id="fig_run_wait_for_inferior_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_wait_for_inferior_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_wait_for_inferior_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Once again the key work is in
	  <function>handle_inferior_event</function>. The code checks for
	  watchpoints using the <function>to_stopped_by_watchpoint</function>
	  function of the current target. The function also checks
	  breakpoints, but since it already knows the current program counter
	  (set by <function>target_wait</function> when control is returned),
	  it needs no further call to the target
	  operations. <function>target_wait</function> will have reported if
	  it stopped due to an exception that could be due to a
	  breakpoint. <function>handle_inferior_event</function> can then look
	  up the program counter in the list of active breakpoints, to
	  determine which breakpoint was encountered.
	</para>

	<para>
	  <xref linkend="fig_run_normal_stop_flow" /> shows the sequence
	  diagram for <function>normal_stop</function> when handling the
	  &gdb; <command>run</command> command. In this example the stop was
	  due to the target encountering a breakpoint.
	</para>

	<figure id="fig_run_normal_stop_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_normal_stop_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_normal_stop_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The first action is to remove breakpoints. This ensures that the
	  target executable is returned to its normal state, without any trap
	  or similar code inserted.
	</para>

	<para>
	  The frame sniffers for the target are identified, using the frame
	  sniffer for the architecture,
	  <function>&arch;_frame_sniffer</function>. The current stack frame
	  is then printed for the user. This requires use of the frame sniffer
	  to identify the ID (and hence all the other data) of &this; frame
	  from the &next; frame (<function>&arch;_frame_this_id</function>
	  here). <function>print_stack_frame</function> will start from the
	  sentinel frame and work inwards until it finds the stack frame
	  containing the current stack pointer and program counter.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Summary: Steps to Port a New Architecture to &gdb;
      </title>

      <para>
	Porting a new architecture to &gdb; can be broken into a number of
	steps.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Ensure a &bfd; exists for executables of the target architecture
	    in the <filename>bfd</filename> directory. If one does not exist,
	    create one by modifying an existing similar one.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Implement a disassembler for the target architecture in the
	    <filename>opcodes</filename> directory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Define the target architecture in the <filename>gdb</filename>
	    directory. Add the pattern for the new target to
	    <filename>configure.tgt</filename> with the names of the files
	    that contain the code. By convention the target architecture
	    definition for an architecture &arch; is placed
	    in <filename>&arch;-tdep.c</filename>.
	  </para>

	  <para>
	    Within <filename>&arch;-tdep.c</filename> define the function
	    <function>_initialize_&arch;_tdep</function> which calls
	    <function>gdbarch_register</function> to create the new &gdbarch;
	    for the architecture.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    If a new remote target is needed, consider adding a new remote
	    target by defining a function
	    <function>_initialize_remote_&arch;</function>.
	    However if at all possible use the <emphasis>Remote Serial
	    Protocol</emphasis> for this and implement the server side
	    protocol independently with the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    If desired implement a simulator in the <filename>sim</filename>
	    directory. This should create the library
	    <filename>libsim.a</filename> implementing the interface in
	    <filename>remote-sim.h</filename> (found in the
	    <filename>include</filename> directory).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Build and test. If desired lobby the &gdb; steering group to have
	    your new port included in the main distribution!
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Add a description of the new architecture to the "Configuration
	    Specific Information" section in the main &gdb; user guide
	    (<filename>gdb/doc/gdb.texinfo</filename> <xref
	    linkend="ref_gdb_ug" />).
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

  </chapter>

  <chapter>
    <title>
      The OpenRISC 1000 Architecture
    </title>

    <para>
      OpenRISC 1000 is architecture for a family of free, open source RISC
      processor cores. It is a 32 or 64-bit load and store RISC architecture
      designed with emphasis on performance, simplicity, low power
      requirements, scalability and versatility.
    </para>

    <para>
      The OpenRISC 1000 is fully documented in its Architecture Manual <xref
      linkend="ref_or1k" />.
    </para>

    <para>
      From a debugging perspective, there are three data areas that are
      manipulated by the instruction set.
    </para>

    <orderedlist>
      <listitem>
	<para>
	  Main memory. A uniform address space with 32 or 64-bit
	  addressing. Provision for separate or unified instruction and data
	  and instruction caches. Provision for separate or unified, 1 or
	  2-level data and instruction MMUs.
	</para>
      </listitem>

      <listitem>
	<para>
	  General Purpose Registers (&gpr;s). Up to 32 registers, 32 or 64-bit
	  in length.
	</para>
      </listitem>

      <listitem>
	<para>
	  Special Purpose Registers (&spr;s). Up to 32 groups each with up to
	  2048 registers, up to 32 or 64-bit in length. These registers
	  provide all the administrative functionality of the processor:
	  program counter, processor status, saved exception registers, debug
	  interface, MMU and cache interfaces, etc.
	</para>
      </listitem>
    </orderedlist>

    <para>
      The Special Purpose Registers (&spr;s) represent a
      challenge for &gdb;, since they represent neither addressable memory, nor
      have the characteristics of a register set (generally modest in number).
    </para>

    <para>
      A number of &spr;s are of particular significance to the &gdb;
      implementation.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Configuration registers</emphasis>. The Unit Present
	  register (&spr;&nbsp;1, <literal>UPR</literal>), CPU Configuration
	  register (&spr;&nbsp;2, <literal>CPUCFGR</literal>) and Debug
	  Configuration register (&spr;&nbsp;7, <literal>DCFGR</literal>)
	  identify the features available in the particular OpenRISC 1000
	  implementation. This includes the instruction set in use, number of
	  general purpose registers and configuration of the hardware debug
	  interface.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Program counters</emphasis>. The Previous Program Counter
	  (&spr;&nbsp;0x12, <literal>PPC</literal>) is the address of the
	  instruction just executed. The Next Program Counter (&spr;&nbsp;0x10,
	  <literal>NPC</literal>) is the address of the next instruction to be
	  executed. The <literal>NPC</literal> is the value reported by &gdb;s
	  <command>$pc</command> variable.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Supervision register</emphasis>. The supervision register
	  (&spr;&nbsp;0x11, <literal>SR</literal>) represents the current status
	  of the processor. It is the value reported by &gdb;s status register
	  variable, <command>$ps</command>.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Of particular importance are the &spr;s in group 6 controlling the debug
      unit (if present). The debug unit can trigger a trap exception in
      response to any one of up to 10
      <emphasis>watchpoints</emphasis>. Watchpoints are logical expressions
      built by combining <emphasis>matchpoints</emphasis>, which are simple
      point tests of particular behavior (has a specified address been
      accessed for example).
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Debug Value and Control registers</emphasis>. There are up
	  to 8 pairs of Debug Value (&spr;&nbsp;0x3000&ndash;0x3007,
	  <literal>DVR0</literal> through <literal>DVR7</literal>) and
	  Debug Control (&spr;&nbsp;0x3008&ndash;0x300f,
	  <literal>DCR0</literal> through <literal>DCR7</literal>)
	  registers. Each pair is associated with one hardware
	  <emphasis>matchpoint</emphasis>. The Debug Value register in each
	  pair gives a value to compare against. The Debug Control register
	  indicates whether the matchpoint is enabled, the type of value to
	  compare against (instruction fetch address, data load and/or store
	  address data load and/or store value) and the comparison to make
	  (equal, not equal, less than, less than or equal, greater than,
	  greater than or equal), both signed and unsigned. If the matchpoint
	  is enabled and the test met, the corresponding matchpoint is
	  triggered.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Watchpoint counters</emphasis>. There are two 16-bit
	  Debug Watchpoint Counter registers (&spr;&nbsp;0x3012&ndash;0x3013,
	  <literal>DWCR0</literal> and <literal>DWCR1</literal>), associated
	  with two further matchpoints. The upper 16 bits are a value to
	  match, the lower 16 bits a counter. The counter is incremented when
	  specified matchpoints are triggered (see Debug Mode register
	  1). When the count reaches the match value, the corresponding
	  matchpoint is triggered.
	</para>

	<caution>
	  <para>
	    There is potential ambiguity in that counters are incremented in
	    response to matchpoints and also generate their own
	    matchpoints. It is not good practice to set a counter to increment
	    on its own matchpoint!
	  </para>
	</caution>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Mode registers</emphasis>. There are two Debug Mode
	  registers to control the behavior of the the debug unit
	  (&spr;&nbsp;0x3010&ndash;0x3011, <literal>DMR1</literal> and
	  <literal>DMR2</literal>). <literal>DMR1</literal> provides a pair of
	  bits for each of the 10 matchpoints (8 associated with &dvr;/&dcr;
	  pairs, 2 associated with counters). These specify whether the
	  watchpoint is triggered by the associated matchpoint, by the
	  matchpoint AND-ed with the previous watchpoint or by the matchpoint
	  OR-ed with the previous watchpoint. By building chains of
	  watchpoints, complex logical tests of hardware behavior can be built
	  up.
	</para>

	<para>
	  Two further bits in <literal>DMR1</literal> enable single step
	  behavior (a trap exception occurs on completion of each instruction)
	  and branch step behavior (a trap exception occurs on completion of
	  each branch instruction).
	</para>

	<para>
	  <literal>DMR2</literal> contains an enable bit for each counter, 10
	  bits indicating which watchpoints are assigned to which counter and 10
	  bits indicating which watchpoints generate a trap exception. It also
	  contains 10 bits of output, indicating which watchpoints have
	  generated a trap exception.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Stop and Reason registers</emphasis>. In normal
	  operation, all OpenRISC 1000 exceptions are handled through the
	  exception vectors at locations 0x100 through 0xf00. The Debug Stop
	  register (&spr;&nbsp;0x3014, <literal>DSR</literal>) is used to
	  assign particular exceptions instead to the &jtag; interface. These
	  exceptions stall the processor, allowing the machine state to be
	  analyzed through the &jtag; interface. Typically a debugger will
	  enable this for trap exceptions used for breakpointing.
	</para>

	<para>
	  Where an exception has been diverted to the development interface,
	  the Debug Reason register (&spr;&nbsp;0x3021,
	  <literal>DRR</literal>) indicates which exception caused the
	  diversion. Note that although single stepping and branch stepping
	  cause a trap, if they are assigned to the &jtag; interface, they
	  <emphasis>do not</emphasis> set the <literal>TE</literal> bit in the
	  <literal>DRR</literal>. This allows an external debugger to
	  distinguish between breakpoint traps and single/branch step traps.
	</para>
      </listitem>
    </itemizedlist>

    <sect1>
      <title>
	The OpenRISC 1000 &jtag; Interface
      </title>

      <para>
	There are two variants of a &jtag; interface for use with the OpenRISC
	1000.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    The original &jtag; interface was created as part of the OpenRISC
	    SoC project, ORPSoC <xref linkend="ref_orpsoc" />. It provides
	    three scan chains: one to access to all the &spr;s, one to access
	    external memory and one providing control of the CPU. The control
	    scan chain reset, stall or trace the processor.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A new &jtag; interface was provided by Igor Mohor in 2004 <xref
	    linkend="ref_or1k_debug" />. It provide the same access to &spr;s
	    and external memory, but has a simpler control interface offering
	    only the ability to stall or reset the processor.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	At present the OpenRISC Architectural Simulator, &or1ksim;, (see <xref
	linkend="sec_or1ksim" />) supports the first of these
	interfaces.
      </para>

      <para>
	Three scan chains are provided by both interfaces
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    RISC_DEBUG (scan chain 1), providing read/write access to the
	    &spr;s.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    REGISTER (scan chain 4), providing control of the CPU. In the
	    ORPSoC interface, this provides multiple registers which are read
	    and written to control the CPU. Of these register 0,
	    <literal>MODER</literal>, which controls hardware trace, and
	    register 4, <literal>RISC_OP</literal>, which controls reset and
	    stall are the most important. Trace is enabled by setting, and
	    disabled by clearing bit&nbsp;1 in <literal>MODER</literal>. Reset
	    and processor stall are triggered and cleared by setting and
	    clearing respectively bit&nbsp;1 and bit&nbsp;0 in
	    <literal>RISC_OP</literal>. The stall state may be determined by
	    reading the stall bit in <literal>RISC_OP</literal>.
	  </para>

	  <para>
	    In Igor Mohor's debug interface, there is a single control
	    register which behaves identically to <literal>RISC_OP</literal>
	    in the original debug interface.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    WISHBONE (scan chain 5), providing read/write access to main
	    memory.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	Since the General Purpose Registers (&gpr;s) are mapped to
	&spr; group 0, this mechanism also allows &gpr;s to be read and
	written.
      </para>

    </sect1>

    <sect1>
      <title>
	The OpenRISC 1000 Remote &jtag; Protocol
      </title>

      <para>
	To facilitate remote debugging by &gdb;, the OpenRISC defines a
	software protocol describing &jtag; accesses, suitable for conveying
	over a TCP/IP via a socket interface.
      </para>

      <note>
	<para>
	  This protocol pre-dates the &gdb; Remote Serial Protocol (see <xref
	  linkend="sec_rsp" />). At some future date the OpenRISC 1000 Remote
	  &jtag; Protocol will be replaced by the &rsp;.
	</para>
      </note>

      <para>
	The OpenRISC 1000 Remote &jtag; Protocol is a simple message
	send/acknowledge protocol. The &jtag; request is packaged as a 32 bit
	command, 32-bit length and series of 32-bit data words. The &jtag;
	response is packaged as a 32-bit status and optionally a number of
	32-bit data words. The commands available are:
      </para>

      <para>
	Where Igor Mohor's version of the &jtag; interface is being used,
	addresses for read/write accesses to the <literal>REGISTER</literal>
	scan chain are ignored&mdash;there is only one control register.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_READ</constant> (1). Read a single
	    &jtag; register. A 32-bit address is provided in the request. The
	    response includes 64-bits of read data.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_WRITE</constant> (2). Write a single
	    &jtag; register. A 32-bit address is provided in the 
	    request and 64-bit data to be written.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_READ_BLOCK</constant> (3). Read
	    multiple 32-bit &jtag; registers. A 32-bit address of the first
	    register and number of registers to be read is provided in the
	    request. The response includes the number of registers read and
	    32-bits of data for each one read.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_WRITE_BLOCK</constant> (4). Write
	    multiple 32-bit &jtag; registers. A 32-bit address of the first
	    register and number of registers to be written is provided in the
	    request followed by 32-bits of data to be written for each
	    register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_CHAIN</constant> (5). Select the scan
	    chain. A 32-bit scan chain number is provided in the request.
	  </para>
	</listitem>
      </itemizedlist>

      <note>
	<para>
	  There is apparently a contradiction in this protocol. Provision is
	  made for individual registers to be read/written as 64 bits,
	  whereas block read/writes (provided for communication efficiency)
	  are only 32-bits.
	</para>
      </note>

      <para>
	<xref linkend="fig_remote_jtag_protocol" />
	shows the structures of all five requests and their corresponding
	(successful) responses. Note that if a request fails, the response
	will only contain the status word.
      </para>

      <figure id="fig_remote_jtag_protocol">
	<title>
	  The OpenRISC 1000 Remote &jtag; Protocol data structures
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The client side of this protocol (issuing the requests) is implemented
	by the &gdb; port for OpenRISC 1000.
      </para>

      <para>
	Server side applications may implement this protocol to drive either
	physical hardware (via its &jtag; port) or simulations, which include
	the &jtag; functionality. Examples of the former include &usb; &jtag;
	connectors. An example of the latter is the OpenRISC 1000
	Architectural Simulator, &or1ksim; (see <xref linkend="sec_or1ksim" />.
      </para>

    </sect1>

    <sect1 id="sec_or1k_abi">
      <title>
	Application Binary Interface (&abi;)
      </title>

      <para>
	The &abi; for the OpenRISC 1000 is described in Chapter 16 of the
	Architecture Manual (<xref linkend="ref_or1k" />). However the actual
	&gcc; compiler implementation differs very slightly from the documented
	&abi;. Since precise understanding of the &abi; is critical to &gdb;,
	those differences are documented here.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Register Usage: R12 is used as another callee-saved register. It
	    is never used to return the upper 32 bits of a 64-bit result on a
	    32-bit architecture. All values greater than 32-bits are returned
	    by a pointer.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Although the specification requires stack frames to be
	    <emphasis>double</emphasis> word aligned, the current &gcc;
	    compiler implements <emphasis>single</emphasis> word alignment.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Integral values more than 32 bits (64 bits on 64-bit
	    architectures), structures and unions are returned as pointers to
	    the location of the result. That location is provided the
	    <emphasis>calling</emphasis> function, which passes it as a first
	    argument in &gpr; 3. In other words, where a function returns a
	    result of this type, the first true argument to the function will
	    appear in R4 (or R5/R6 if it is a 64-bit argument on a 32-bit
	    architecture).
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="sec_or1ksim">
      <title>
	&or1ksim;: the OpenRISC 1000 Architectural Simulator
      </title>

      <para>
	&or1ksim; is an instruction set simulator (&iss;) for the OpenRISC 1000
	architecture. At present only the 32-bit architecture is modeled. In
	addition to modeling the core processor, &or1ksim; can model a number of
	peripherals, to provide the functionality of a complete System-on-Chip
	(&soc;).
      </para>

      <para>
	&or1ksim; models the OpenRISC 1000 &jtag; interface and implements the
	OpenRISC 1000 Remote &jtag; protocol server side. It was used as the
	testbed for the port of &gdb;
      </para>

      <para>
	The &jtag; interface models the behavior of the old ORPSoC (with
	support for multiple control registers and hardware trace). A future
	release will provide an option to support Igor Mohor's &jtag;
	interface.
      </para>

      <note>
	<para>
	  Porting &gdb; uncovered a number of bugs in &or1ksim;. The
	  implementation is now quite old, and predates the current OpenRISC
	  1000 specification. A patch (available from <ulink
	  url="http://www.embecosm.com/download.html" /> is available to fix
	  these bugs.
	</para>
      </note>

    </sect1>
    
  </chapter>

  <chapter>
    <title>
      Porting the OpenRISC 1000 Architecture
    </title>

    <para>
      This chapter describes the steps in porting the OpenRISC 1000
      architecture to &gdb;. It uses the information and data structures
      described in <xref linkend="chap_gdb_internals" />.
    </para>

    <para>
      Strictly speaking this was not a new port. An old port existed for &gdb;
      5.3. However &gdb; has changed substantially since that time, and an
      almost complete reimplementation was required.
    </para>

    <tip>
      <para>
	When working with any large code base a TAGS file is invaluable. This
	allows immediate lookup of any procedure or variable across the entire
	code base. Normally for any &gnu; project, this is achieved with the
	command <command>make tags</command>. However this does not work for
	&gdb;&mdash;there is a problem with the <literal>tags</literal> target
	in the <filename>opcodes</filename> directory.
      </para>

      <para>
	However tags building <emphasis>does</emphasis> work in the
	<filename>gdb</filename> directory, so a <filename>TAGS</filename>
	file can be built in that directory by:
      </para>

      <informalexample>
	<literallayout>
<command>cd gdb</command>
<command>make tags</command>
<command>cd ..</command>
	</literallayout>
      </informalexample>
	
    </tip>

    <sect1>
      <title>
	&bfd; Specification
      </title>

      <para>
	The &bfd; specification for OpenRISC 1000 already existed (it is part
	of binutils), so there was no need to implement this. The existing
	code is just reused.
      </para>

    </sect1>

    <sect1 id="sec_target_arch">
      <title>
	OpenRISC 1000 Architecture Specification
      </title>

      <para>
	The code resides in the <filename>gdb</filename> sub-directory. The
	main architectural specification is in
	<filename>or1k-tdep.c</filename>, with and OpenRISC 1000 wide header
	in <filename>or1k-tdep.h</filename>. Support for the OpenRISC 1000
	Remote &jtag; interface is in <filename>remote-or1k.c</filename> with
	the detailed protocol in <filename>or1k-jtag.c</filename> and a
	protocol header in <filename>or1k-jtag.h</filename>.
      </para>

      <para>
	There are several targets which can use the OpenRISC 1000
	architecture. These all begin <literal>or16</literal>,
	<literal>or32</literal> or <literal>or32</literal>. The
	<filename>configure.tgt</filename> is edited to add patterns for these
	that will pick up the binaries generated from these source files.
      </para>

      <informalexample>
	<programlisting>
or16* | or32* | or64*)
        # Target: OpenCores OpenRISC 1000 architecture
        gdb_target_obs="or1k-tdep.o remote-or1k.o or1k-jtag.o"
        ;;
	</programlisting>
      </informalexample>

      <caution>
	<para>
	  <filename>configure.tgt</filename> only specifies binaries, so
	  cannot show dependencies on headers. To correct this,
	  <filename>Makefile.in</filename> can be edited, so that <command>automake</command> and
	  configure will generate a <filename>Makefile</filename> with the
	  correct dependencies.
	</para>
      </caution>

      <para>
	The architecture definition is created from the
	<function>_initialize_or1k_tdep</function> by a call to
	<function>gdbarch_register</function>. That function also initializes
	the disassembler (<function>build_automata</function>) and adds two
	new commands: a sub-command to the <command>info</command> command to
	read &spr;s and a new top level support command,
	<command>spr</command> to set the value of &spr;s.
      </para>

      <sect2>
	<title>
	  Creating &gdbarch;
	</title>

	<para>
	  <function>gdbarch_register</function> is called for &bfd; type
	  <constant>bfd_arch_or32</constant> with the initialization function
	  <function>or1k_gdbarch_init</function> and the target specific dump
	  function, <function>or1k_dump_tdep</function>.
	</para>

	<para>
	  Future implementations may make additional calls to use the same
	  function to create a 64-bit version of the architecture.
	</para>

	<para>
	  <function>gdbarch_init</function> receives the &gdbarch_info;
	  created from the &bfd; entries and the list of existing
	  architectures. That list is first checked, using
	  <function>gdbarch_list_lookup_by_info</function> to see if there is
	  already an architecture defined suitable for the given
	  &gdbarch_info; and if so it is returned.
	</para>

	<para>
	  Otherwise a new &gdbarch; is created. For that a the target
	  dependencies are saved in an OpenRISC 1000 specific
	  <structname>struct&nbsp;gdbarch_tdep</structname>, defined in
	  <filename>or1k-tdep.h</filename>.
	</para>

	<informalexample>
	  <programlisting>
struct gdbarch_tdep
{
  unsigned int  num_matchpoints;
  unsigned int  num_gpr_regs;
  int           bytes_per_word;
  int           bytes_per_address;
};
	  </programlisting>
	</informalexample>
	  
	<para>
	  This is information beyond that which is held in the &gdbarch;. By
	  using this structure, the &gdb; implementation for OpenRISC 1000 can
	  be made flexible enough to deal with both 32 and 64-bit
	  implementations and with variable numbers of registers and
	  matchpoints.
	</para>

	<caution>
	  <para>
	    Although this flexibility is built in to the code, the current
	    implementation has only been tested with 32-bit OpenRISC without
	    floating point or vector support and with 32 registers.
	  </para>
	</caution>

	<para>
	  The new architecture is then created by
	  <function>gdbarch_alloc</function>, passing in the &gdbarch_info;
	  and the <structname>struct&nbsp;gdbarch_tdep</structname>. The
	  &gdbarch; is populated using the various
	  <literal>set_gdbarch_</literal> functions, and OpenRISC 1000 Frame
	  sniffers are associated with the architecture.
	</para>

	<para>
	  When creating a new &gdbarch; a function must be provided to dump
	  the target specific definitions in &gdbarch_tdep; to a file. This is
	  provided in <function>or1k_dump_tdep</function>. It is passed a
	  pointer to the &gdbarch; and a file handle and simply writes out the
	  fields in the &gdbarch_tdep; with suitable explanatory text.
	</para>
      </sect2>

      <sect2>
	<title>
	  OpenRISC 1000 Hardware Data Representation
	</title>

	<para>
	  The first entries in &gdbarch; initialize the size and format of all
	  the standard data types.
	</para>

        <informalexample>
	  <programlisting>
set_gdbarch_short_bit             (gdbarch, 16);
set_gdbarch_int_bit               (gdbarch, 32);
set_gdbarch_long_bit              (gdbarch, 32);
set_gdbarch_long_long_bit         (gdbarch, 64);
set_gdbarch_float_bit             (gdbarch, 32);
set_gdbarch_float_format          (gdbarch, floatformats_ieee_single);
set_gdbarch_double_bit            (gdbarch, 64);
set_gdbarch_double_format         (gdbarch, floatformats_ieee_double);
set_gdbarch_long_double_bit       (gdbarch, 64);
set_gdbarch_long_double_format    (gdbarch, floatformats_ieee_double);
set_gdbarch_ptr_bit               (gdbarch, binfo->bits_per_address);
set_gdbarch_addr_bit              (gdbarch, binfo->bits_per_address);
set_gdbarch_char_signed           (gdbarch, 1);
	  </programlisting>
	</informalexample>
      </sect2>

      <sect2>
	<title>
	  Information Functions for the OpenRISC 1000 Architecture
	</title>

	<para>
	  These &gdbarch; functions provide information about the architecture.
	</para>

        <informalexample>
	  <programlisting>
set_gdbarch_return_value          (gdbarch, or1k_return_value);
set_gdbarch_breakpoint_from_pc    (gdbarch, or1k_breakpoint_from_pc);
set_gdbarch_single_step_through_delay
                                  (gdbarch, or1k_single_step_through_delay);
set_gdbarch_have_nonsteppable_watchpoint
                                  (gdbarch, 1);
switch (gdbarch_byte_order (gdbarch))
  {
  case BFD_ENDIAN_BIG:
    set_gdbarch_print_insn        (gdbarch, print_insn_big_or32);
    break;

  case BFD_ENDIAN_LITTLE:
    set_gdbarch_print_insn        (gdbarch, print_insn_little_or32);
    break;

  case BFD_ENDIAN_UNKNOWN:
    error ("or1k_gdbarch_init: Unknown endianism");
    break;
    }
	  </programlisting>
	</informalexample>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_return_value</function>. This function tells
	      &gdb; how a value of a particular type would be returned by the
	      &abi;. Structures/unions and large scalars (> 4 bytes) are
	      placed in memory and returned by reference
	      (<constant>RETURN_VALUE_ABI_RETURNS_ADDRESS</constant>. Smaller
	      scalars are returned in &gpr;&nbsp;11
	      (<constant>RETURN_VALUE_REGISTER_CONVENTION</constant>).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_breakpoint_from_pc</function> returns the
	      breakpoint function to be used at a given program counter
	      address. Since all OpenRISC 1000 instructions are the same size,
	      this function always returns the same value, the instruction
	      sequence for a <literal>l.trap</literal> instruction.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_single_step_through_delay</function>. This
	      function is used to determine if a single stepped instruction is
	      actually executing a delay slot. This is the case if the current
	      instruction is a break instruction <emphasis>and</emphasis> it
	      is the same instruction we have just seen.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_insn_big_or32</function> and
	      <function>print_insn_little_or32</function>. There are two
	      variants of the disassembler, depending on the endianism. The
	      disassembler is discussed in more detail in <xref
	      linkend="sec_or1k_disasm" />.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_or1k_reg_funcs">
	<title>
	  OpenRISC 1000 Register Architecture
	</title>

	<para>
	  The register architecture is defined by two groups of &gdbarch;
	  functions. The first group specifies the number of registers (both
	  raw and pseudo) and the register numbers of some "special"
	  registers.
	</para>

        <informalexample>
	  <programlisting>
set_gdbarch_pseudo_register_read  (gdbarch, or1k_pseudo_register_read);
set_gdbarch_pseudo_register_write (gdbarch, or1k_pseudo_register_write);
set_gdbarch_num_regs              (gdbarch, OR1K_NUM_REGS);
set_gdbarch_num_pseudo_regs       (gdbarch, OR1K_NUM_PSEUDO_REGS);
set_gdbarch_sp_regnum             (gdbarch, OR1K_SP_REGNUM);
set_gdbarch_pc_regnum             (gdbarch, OR1K_PC_REGNUM);
set_gdbarch_ps_regnum             (gdbarch, OR1K_SR_REGNUM);
set_gdbarch_deprecated_fp_regnum  (gdbarch, OR1K_FP_REGNUM);
	  </programlisting>
	</informalexample>

	<para>
	  The second group of functions provides information about registers.
	</para>

        <informalexample>
	  <programlisting>
set_gdbarch_register_name         (gdbarch, or1k_register_name);
set_gdbarch_register_type         (gdbarch, or1k_register_type);
set_gdbarch_print_registers_info  (gdbarch, or1k_registers_info);
set_gdbarch_register_reggroup_p   (gdbarch, or1k_register_reggroup_p);
	  </programlisting>
	</informalexample>

	<para>
	  The representation of the <emphasis>raw</emphasis> registers (see
	  <xref linkend="sec_regcache" />) is: registers 0-31 are the
	  corresponding &gpr;s, register 32 is the program counter and
	  register 33 is the supervision register. For convenience, constants
	  are defined in the header, <filename>or1k_tdep.h</filename>, for all
	  the special registers.
	</para>

	<informalexample>
	  <programlisting>
#define OR1K_SP_REGNUM         1
#define OR1K_FP_REGNUM         2
#define OR1K_FIRST_ARG_REGNUM  3
#define OR1K_LAST_ARG_REGNUM   8
#define OR1K_LR_REGNUM         9
#define OR1K_RV_REGNUM        11
#define OR1K_PC_REGNUM       (OR1K_MAX_GPR_REGS + 0)
#define OR1K_SR_REGNUM       (OR1K_MAX_GPR_REGS + 1)
	  </programlisting>
	</informalexample>

	<para>
	  In this implementation there are no pseudo-registers. A set could
	  have been provided to represent the &gpr;s in floating point format
	  (for use with the floating point instructions), but this has not
	  been implemented. Constants are defined for the various totals
	</para>

	<informalexample>
	  <programlisting>
#define OR1K_MAX_GPR_REGS    32
#define OR1K_NUM_PSEUDO_REGS  0
#define OR1K_NUM_REGS        (OR1K_MAX_GPR_REGS + 2)
#define OR1K_TOTAL_NUM_REGS  (OR1K_NUM_REGS + OR1K_NUM_PSEUDO_REGS)
	  </programlisting>
	</informalexample>

	<caution>
	  <para>
	    These totals are currently hard-coded constants. They should
	    really draw on the data in the &gdbarch_tdep;, providing support
	    for architectures which have less than the full complement of 32
	    registers. This functionality will be provided in a future
	    implementation.
	  </para>
	</caution>
	  
	<para>
	  One consequence of providing no pseudo-registers is that the frame
	  pointer variable, <command>$fp</command> in &gdb; will not have its
	  correct value. The provision of this register as an intrinsic part
	  of &gdb; is no longer supported. If it is wanted then it should be
	  defined as a register or pseudo-register.
	</para>

	<para>
	  However if there is no register with this name, &gdb; will use
	  either the value of the <varname>deprecated_fp_regnum</varname>
	  value in &gdbarch; or the current frame base, as reported by the
	  frame base sniffer.
	</para>

	<para>
	  For the time being, the <varname>deprecated_fp_regnum</varname> is
	  set. However the longer term plan will be to represent the
	  frame-pointer as a pseudo-register, taking the value of
	  &gpr;&nbsp;2.
	</para>

	<para>
	  The register architecture is mostly a matter of setting the values
	  required in &gdbarch;. However two functions,
	  <function>or1k_pseudo_register_read</function> and
	  <function>or1k_pseudo_register_write</function> are defined to
	  provide access to any pseudo-register. These functions are defined
	  to provide hooks for the future, but in the absence of any
	  pseudo-registers they do nothing.
	</para>

	<para>
	  There are set of functions which yield information about the name
	  and type of registers and which provide the output for the &gdb;
	  <command>info&nbsp;registers</command> command.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_register_name</function>. This is a simple
	      table lookup to yield the register name from its number.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_type</function>. This function must
	      return the type as a
	      <structname>struct&nbsp;type</structname>. This &gdb; data
	      structure contains detailed information about each type and
	      its relationship to other types.
	    </para>

	    <para>
	      For the purposes of this function, a number of standard types
	      are predefined, with utility functions to construct other
	      types from them. For most registers the predefined
	      <constant>builtin_type_int32</constant> is suitable. The stack
	      pointer and frame pointer are pointers to arbitrary data, so
	      the equivalent of <type>void *</type> is required. This is
	      constructed by applying the function
	      <function>lookup_pointer_type</function> to the predefined
	      <constant>builtin_type_void</constant>. The program counter is
	      a pointer to code, so the equivalent of a pointer to a void
	      function is appropriate. This is constructed by applying
	      <function>lookup_pointer_type</function> and
	      <function>lookup_function_type</function> to
	      <constant>builtin_type</constant>.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_info</function>. This function is used
	      by the <command>info&nbsp;registers</command> command to
	      display information about one or more registers.
	    </para>

	    <para>
	      This function is not really needed. It is just a wrapper for
	      <function>default_print_registers_info</function>, which is
	      the default setting for this function anyway.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_reggroup_p</function>. This predicate
	      function returns 1 (true) if a given register is in a
	      particular group. This is used by the command
	      <command>info&nbsp;registers</command> when registers in a
	      particular category are requested.
	    </para>

	    <para>
	      The function as implemented is little different from the
	      default function
	      (<function>default_register_reggroup_p</function>), which is
	      called for any unknown cases anyway. However it does make use
	      of the target dependent data (&gdbarch_tdep;), thus providing
	      flexibility for different OpenRISC 1000 architectures.
	    </para>
	  </listitem>
	</itemizedlist>	
	    
      </sect2>

      <sect2 id="sec_or1k_frames">
	<title>
	  OpenRISC 1000 Frame Handling
	</title>

	<para>
	  The OpenRISC 1000 frame structure is described in its &abi; <xref
	  linkend="ref_or1k" />. Some of the detail is slightly different in
	  current OpenRISC implementations&mdash;this is described in <xref
	  linkend="sec_or1k_abi" />.
	</para>

	<para>
	  The key to frame handling is understanding the prologue (and
	  possibly epilogue) in each function which is responsible for
	  initializing the stack frame. For the OpenRISC 1000, &gpr;&nbsp;1 is
	  used as the stack pointer, &gpr;&nbsp;2 as the frame pointer and
	  &gpr;&nbsp;9 as the return address. The prologue sequence is:
	</para>

	<informalexample>
	  <literallayout><literal>l.addi  r1,r1,-</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>(r1),r2</literal>
<literal>l.addi  r2,r1,</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>-4(r1),r9</literal>
<literal>l.sw    </literal><emphasis>x</emphasis><literal>(r1),r</literal><emphasis>y</emphasis></literallayout>
	</informalexample>

	<para>
	  The OpenRISC 1000 stack frame accommodates any local (automatic)
	  variables and temporary values, then the return address, then the
	  old frame pointer and finally any stack based arguments to functions
	  called by this function. This last rule means that the return
	  address and old frame pointer are not necessarily at the end of the
	  stack frame - enough space will be left to build up any arguments
	  for called functions that must go on the stack. <xref
	  linkend="fig_prologue_frame" 
	  /> shows how the stack looks at the end of the prologue.
	</para>

	<figure id="fig_prologue_frame">
	  <title>
	    The OpenRISC 1000 stack frame at the end of the prologue
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Not all fields are always present. The function need not save its
	  return address to stack, and there may be no callee-saved registers
	  (i.e. &gpr;s 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30) which
	  require saving. Leaf functions are not required to set up a new
	  stack frame at all.
	</para>

	<para>
	  The epilogue is the inverse. Callee-saved registers are restored,
	  the return address placed in &gpr;&nbsp;9 and the stack and frame
	  pointers restored before jumping to the address in &gpr;&nbsp;9.
	</para>

	<informalexample>
	  <literallayout>
<literal>l.lwz   r</literal><emphasis>y</emphasis><literal>,</literal><emphasis>x</emphasis><literal>(r1)</literal>
<literal>l.lwz   r9,</literal><emphasis>save_loc</emphasis><literal>-4(r1)</literal>
<literal>l.lwz   r2,</literal><emphasis>save_loc</emphasis><literal>(r1)</literal>
<literal>l.jr    r9</literal>
<literal>l.addi  r1,r1,</literal><emphasis>frame_size</emphasis>
</literallayout>
	</informalexample>

	<para>
	  Only those parts of the epilogue which correspond to the prologue
	  need actually appear. The OpenRISC 1000 has a delay slot after
	  branch instructions, so for efficiency the stack restoration can be
	  placed after the <literal>l.jr</literal> instruction.
	</para>

	<sect3>
	  <title>
	    OpenRISC 1000 Functions Analyzing Frames
	  </title>

	  <para>
	    A group of &gdbarch; functions and a value provide information about
	    the current stack and how it is being processed by the target
	    program.
	  </para>

	  <informalexample>
	    <programlisting>
set_gdbarch_skip_prologue         (gdbarch, or1k_skip_prologue);
set_gdbarch_inner_than            (gdbarch, core_addr_lessthan);
set_gdbarch_frame_align           (gdbarch, or1k_frame_align);
set_gdbarch_frame_red_zone_size   (gdbarch, OR1K_FRAME_RED_ZONE_SIZE);
	    </programlisting>
	  </informalexample>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_skip_prologue</function>. This function returns
		the end of the function prologue, if the program counter is
		currently in a function prologue.
	      </para>

	      <para>
		The initial approach is to use the DWARF2 symbol-and-line
		(&sal;) information to identify the start of the function
		(<function>find_pc_partial_function</function> and hence the
		end of the prologue
		(<function>skip_prologue_using_sal</function>).
	      </para>

	      <para>
		If this information is not available,
		<function>or1k_skip_prologue</function> reuses the helper
		functions from the frame sniffer function,
		<function>or1k_frame_unwind_cache</function> (see <xref
		linkend="sec_or1k_frame_funcs" />) to step through code that
		appears to be function prologue.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>core_addr_lessthan</function>. This standard function
		returns 1 (true) if its first argument is a lower address than
		its second argument. It provides the functionality required by
		the &gdbarch; <function>inner_than</function> function for
		architectures like OpenRISC 1000, which have falling stack
		frames.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_align</function>. This function takes a
		stack pointer and returns a value (expanding the frame) which
		meets the stack alignment requirements of the &abi;. Since the
		OpenRISC 1000 &abi; uses a falling stack, this uses the
		built-in function, <function>align_down</function>. The
		alignment is specified in the constant
		<constant>OR1K_STACK_ALIGN</constant> defined in
		<filename>or1k-tdep.h</filename>.
	      </para>

	      <note>
		<para>
		  The OpenRISC 1000 &abi; specifies that frames should be
		  double-word aligned. However the version of &gcc; in the
		  current OpenRISC tool chain implements single-word
		  alignment. So the current &gdb; implementation specifies
		  <constant>OR1K_STACK_ALIGN</constant> to be 4, not 8.
		</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>
		<constant>OR1K_FRAME_RED_ZONE_SIZE</constant>. The OpenRISC 1000
		reserves the 2,560 bytes below the stack pointer for use by
		exception handlers and frameless functions. This is known as a
		<emphasis>red zone</emphasis> (an AMD term). This constant is
		recorded in the &gdbarch; <varname>frame_red_zone_size</varname>
		field. Any dummy stack frames (see <xref
		linkend="sec_dummy_frame" />) will be placed after this point.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    OpenRISC 1000 Functions for Accessing Frame Data
	  </title>

	  <informalexample>
	    <programlisting>
set_gdbarch_unwind_pc             (gdbarch, or1k_unwind_pc);
set_gdbarch_unwind_sp             (gdbarch, or1k_unwind_sp);
	    </programlisting>
	  </informalexample>

	  <para>
	    There are only two functions required here,
	    <function>or1k_unwind_pc</function> and
	    <function>or1k_unwind_sp</function>. Given a pointer to the &next;
	    frame, these functions return the value of respectively the program
	    counter and stack pointer in &this; frame.
	  </para>

	  <para>
	    Since the OpenRISC architecture defines standard frame sniffers, and
	    both these registers are raw registers, they can be implemented very
	    simply by a call to
	    <function>frame_unwind_register_unsigned</function>.
	  </para>

	</sect3>

	<sect3 id="sec_dummy_frame">
	  <title>
	    OpenRISC 1000 Functions to Create Dummy Stack Frames
	  </title>

	  <para>
	    Two &gdbarch; provide support for calling code in the target
	    inferior.
	  </para>

	  <informalexample>
	    <programlisting>
set_gdbarch_push_dummy_call       (gdbarch, or1k_push_dummy_call);
set_gdbarch_unwind_dummy_id       (gdbarch, or1k_unwind_dummy_id);
	    </programlisting>
	  </informalexample>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_push_dummy_call</function>. This function
		creates a dummy stack frame, so that &gdb; can evaluate a
		function within the target code (for example in a
		<command>call</command> command). The input arguments include
		all the parameters for the call, including the return address
		and an address where a structure should be returned.
	      </para>

	      <para>
		The return address for the function is always breakpointed (so
		&gdb; can trap the return). This return address is written
		into the link register (in the register cache) using
		<function>regcache_cooked_write_unsigned</function>).
	      </para>

	      <para>
		If the function is to return a structure, the address where
		the structure is to go is passed as a first argument, in
		&gpr;&nbsp;3.
	      </para>

	      <para>
		The next arguments are passed in the remaining argument
		registers (up to &gpr;&nbsp;8). Structures are passed by
		reference to their locating in memory. For 32-bit
		architectures passing 64-bit arguments, a pair of registers (3
		and 3, 5 and 6 or 7 and 8) are used.
	      </para>

	      <para>
		Any remaining arguments must be pushed on the end of the
		stack. There is a difficulty here, since pushing each argument
		may leave the stack misaligned (OpenRISC 1000 specifies
		double-word alignment). So the code first works out the space
		required, then adjusts the resulting stack pointer to the
		correct alignment. The arguments can then be written to the
		stack in the correct location.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_unwind_dummy_id</function>. This is the inverse
		of <function>or1k_push_dummy_call</function>. Given a pointer
		to the &next; stack frame (which will be the frame of the
		dummy call), it returns the frame ID (that is the stack
		pointer and function entry point address) of &this; frame.
	      </para>

	      <para>
		This is not completely trivial. For a dummy frame, the &next;
		frame information about &this; frame is not necessarily
		complete, so a simple call to
		<function>frame_unwind_id</function> recurses back to this
		function <emphasis>ad infinitum</emphasis>. Instead the frame
		information is built by unwind the stack pointer and program
		counter and attempting to use DWARF2 symbol-and-line (&sal;)
		information to find the start of the function from the &pc;
		with <function>find_pc_partial_function</function>. If that
		information is not available, the program counter is used as a
		proxy for the function start address.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    OpenRISC 1000 Frame Sniffers
	  </title>

	  <para>
	    The preceding functions all have a 1:1 relationship with
	    &gdbarch;. However for stack analysis (or "sniffing") more than one
	    approach may be appropriate, so a list of functions is
	    maintained.
	  </para>

	  <para>
	    The low level stack analysis functions are set by
	    <function>frame_unwind_append_sniffer</function>. The OpenRISC 1000
	    has its own sniffers for finding the ID of a frame and getting the
	    value of a register on the frame specified by
	    <function>or1k_frame_sniffer</function>. For all other sniffing
	    functions, the default DWARF2 frame sniffer is used,
	    <function>dwarf2_frame_sniffer</function>.
	  </para>

	  <para>
	    The high level sniffer finds the base of the stack frame. OpenRISC
	    defines its own base sniffer,
	    <structname>or1k_frame_base</structname> as default. It provides all
	    the functionality needed, so can be used as the default base
	    sniffer, set using <function>frame_base_set_default</function>. The
	    frame base is a structure, with entries pointing to the
	    corresponding frame sniffer and functions to give the base address
	    of the frame, the arguments on the frame and the local variables on
	    the frame. Since these are all the same for the OpenRISC 1000, the
	    same function, <function>or1k_frame_base_address</function> is used
	    for all three.
	  </para>
	</sect3>
  
	<sect3 id="sec_or1k_frame_funcs">
	  <title>
	    OpenRISC 1000 Frame Base Sniffer
	  </title>

	  <para>
	    The same function, <function>or1k_frame_base_address</function> is
	    used to provide all three base functions: for the frame itself,
	    the local variables and any arguments. In the OpenRISC 1000 these
	    are all the same value.
	  </para>

	  <informalexample>
	    <programlisting>
or1k_frame_base.unwind      = or1k_frame_sniffer (NULL);
or1k_frame_base.this_base   = or1k_frame_base_address;
or1k_frame_base.this_locals = or1k_frame_base_address;
or1k_frame_base.this_args   = or1k_frame_base_address;
frame_base_set_default            (gdbarch, &amp;or1k_frame_base);
	    </programlisting>
	  </informalexample>

	  <para>
	    The specification of this function requires the end of
	    the stack, i.e. the stack pointer. Rather confusingly the function
	    is also used to
	    determine the value of the <varname>$fp</varname> variable if
	    <varname>deprecated_fp_regnum</varname> has not been set and there
	    is no register with the name "fp". However, as noted earlier, &gdb;
	    is moving away from an intrinsic understanding of frame
	    pointers. For the OpenRISC 1000,
	    <varname>deprecated_fp_regnum</varname> is currently defined,
	    although in time a pseudo register will be defined, with the name
	    of <literal>fp</literal> and mapping to &gpr;&nbsp;2.
	  </para>

	  <para>
	    Like all the frame sniffers, this function is
	    passed the address of the &next; frame, and requires the value for
	    &this; frame, so the value of the stack pointer is unwound from
	    the stack by using the generic register unwinder,
	    <function>frame_unwind_register_unsigned</function>.
	  </para>
	</sect3>

	<sect3>
	  <title>
	    OpenRISC 1000 Low Level Frame Sniffers
	  </title>

	  <para>
	    The function <function>or1k_frame_sniffer</function> returns a
	    pointer to <structname>struct&nbsp;frame_unwind</structname> with
	    entries for the functions defined by this sniffer. For the
	    OpenRISC 1000, this defines a custom function to construct the
	    frame ID of &this; frame given a pointer to the &next; frame
	    (<function>or1k_frame_this_id</function>) and a custom function to
	    give the value of a register in &this; frame given a pointer to
	    the &next; frame (<function>or1k_frame_prev_register</function>).
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_frame_this_id</function>. This function's
		inputs are a pointer to the &next; frame and the prologue
		cache (if any exists) for &this; frame. It uses the main
		OpenRISC 1000 frame analyzer,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>

	      <para>
		From the cached data, the function returns the
		<emphasis>frame&nbsp;ID</emphasis>. This comprises two values,
		the stack pointer for this frame and the address of the code
		(typically the entry point) for the function using this stack
		frame<footnote>
		  <para>
		    Strictly speaking frame IDs can have a third value, the
		    <emphasis>special address</emphasis> for use with
		    architectures which have more complex frame
		    structures. However this is rarely used.
		  </para>
		</footnote>.
	      </para>

	      <para>
		The result is returned in a
		<structname>struct&nbsp;frame_id</structname> passed by
		reference as a third argument. Since the implementation uses
		the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_id</function> function to decode the
		frame ID from the cache.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_prev_register</function>. This function's
		inputs are a pointer to the &next; frame, the prologue cache
		(if any exists) for &this; frame and a register number. It
		uses the main OpenRISC 1000 frame analyzer,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>

	      <para>
		From the cached data, a flag is returned indicating if the
		register has been optimized out (this is never the case), what
		sort of l-value the register represents (a register, memory or
		not an l-value), the address where it is saved in memory (if
		it is saved in memory), the number of a different register
		which holds the value of this register (if that is the case)
		and if a buffer is provided the actual value as obtained from
		memory or the register cache.
	      </para>

	      <para>
		Since the implementation uses the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_register</function> function to
		decode all this information from the cache.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    The OpenRISC 1000 low level sniffers rely on
	    <function>or1k_frame_unwind_cache</function>. This is the heart of
	    the sniffer. It must determine the frame ID for &this; frame given
	    a pointer to the &next; frame and then the information in &this;
	    frame about the values of registers in the &prev; frame.
	  </para>

	  <para>
	    All this data is returned in a prologue cache (see <xref
	    linkend="sec_frames" />), a reference to which is passed as an
	    argument. If the cache already exists for &this; frame it can
	    be returned immediately as the result.
	  </para>

	  <para>
	    If the cache does not yet exist, it is allocated (using
	    <function>trad_frame_cache_zalloc</function>). The first step
	    is to unwind the start address of this function from the
	    &next; frame. The DWARF2 information in the object file can be
	    used to find the end of the prologue (using
	    <function>skip_prologue_using_sal</function>).
	  </para>

	  <para>
	    The code then works through each instruction of the prologue
	    to find the data required.
	  </para>

	  <caution>
	    <para>
	      The analysis must only consider prologue instructions that
	      have actually been executed. It is quite possible the
	      program counter is in the prologue code, and only
	      instructions that have actually been executed should be
	      analyzed.
	    </para>
	  </caution>

	  <para>
	    The stack pointer and program counter are found by simply
	    unwinding the &next; frame. The stack pointer is the base of
	    &this; frame, and is added to the cache data using
	    <function>trad_frame_set_this_base</function>.
	  </para>

	  <para>
	    <varname>end_iaddr</varname> marks the end of the code we
	    should analyze. Only instructions with addresses less than
	    this will be considered.
	  </para>

	  <para>
	    The <literal>l.addi</literal> instruction should be first and
	    its immediate constant field is the size of the stack. If it
	    is missing, then this is a frameless call to a function. If
	    the program counter is right at the start of the function,
	    before the stack and frame pointers are set up, then it will
	    also look like a frameless function.
	  </para>

	  <para>
	    Unless we subsequently find it was saved on the stack, the
	    program counter of the &prev; frame is the link register of
	    &this; frame and can be recorded in the register cache.
	  </para>

	  <tip>
	    <para>
	      It is essential to save the register data using the correct
	      function. Use
	      <function>trad_frame_set_reg_realreg</function> when a
	      register in the &prev; frame is obtained from a register in
	      &this; frame. Use
	      <function>trad_frame_set_reg_addr</function> when a register
	      in the &prev; frame is obtained from an address in &this;
	      frame. Use <function>trad_frame_set_reg_value</function>
	      when a register in the &prev; frame is a particular value in
	      &this; frame. The default entry for each register is that
	      its value in the &prev; frame is obtained from the same
	      register in &this; frame.
	    </para>
	  </tip>

	  <para>
	    For a frameless call, there is no more information to found,
	    so the rest of the code analysis only applies if the frame
	    size was non-zero.
	  </para>

	  <para>
	    The second instruction in the prologue is where the frame
	    pointer of the &prev; frame is saved. It is an error if this
	    is missing. The address where it is saved (the stack pointer
	    of &this; frame plus the offset in the <literal>l.sw</literal>
	    instruction) is saved in the cache using
	    <function>trad_frame_set_reg_addr</function>.
	  </para>

	  <para>
	    The third instruction should be an <literal>l.addi</literal>
	    instruction which sets the frame pointer. The frame size set
	    should match the frame size set in the first instruction. Once
	    this has been set up, the frame pointer can be used to yield
	    the stack pointer of the previous frame. This information is
	    recorded in the register cache.
	  </para>

	  <para>
	    The fourth instruction is optional and saves the return
	    address to the stack. If this instruction is found, the entry
	    in the register cache for the program counter in the &prev;
	    frame must be changed using
	    <function>trad_frame_set_reg_addr</function> to indicate it is
	    found at an address in this frame.
	  </para>

	  <para>
	    All the subsequent instructions in the prolong should be saves
	    of callee-savable registers. These are checked for until the
	    code address has reached the end of the prologue. For each
	    instruction that is found, the save location of the register
	    is recorded in the cache using
	    <function>trad_frame_set_reg_addr</function>.
	  </para>

	  <para>
	    The detailed analysis in
	    <function>or1k_frame_unwind_cache</function> uses a series of
	    helper functions: <function>or1k_frame_size</function>,
	    <function>or1k_frame_fp_loc</function>,
	    <function>or1k_frame_size_check</function>,
	    <function>or1k_link_address</function> and
	    <function>or1k_get_saved_reg</function>. These helper routines
	    check each of the instructions in the prologue. By breaking out
	    this code into separate functions, they can be reused by
	    <function>or1k_skip_prologue</function>.
	  </para>

	</sect3>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_remote_target">
      <title>
	OpenRISC 1000 &jtag; Remote Target Specification
      </title>

      <para>
	The code for the remote target specification for the OpenRISC Remote
	&jtag; protocol is found in the <filename>gdb</filename>
	sub-directory. <filename>remote-or1k.c</filename> contains the target
	definition. The low-level interface is found in
	<filename>or1k-jtag.c</filename> with a shared header in
	<filename>or1k-jtagh</filename>.
      </para>

      <para>
	The low-level interface is abstracted to a set of OpenRISC 1000
	specific functions relating to the behavior of the target. Two
	implementations are provided (in <filename>or1k-jtag.c</filename>),
	one for targets connected directly through the host's parallel port,
	and one for targets connected over TCP/IP using the OpenRISC 1000
	Remote JTAG Protocol.
      </para>

      <informalexample>
	<programlisting>
void      or1k_jtag_init (char *args);
void      or1k_jtag_close ();
ULONGEST  or1k_jtag_read_spr (unsigned int  sprnum);
void      or1k_jtag_write_spr (unsigned int  sprnum,
                               ULONGEST      data);
int       or1k_jtag_read_mem (CORE_ADDR  addr,
                              gdb_byte  *bdata,
                              int        len);
int       or1k_jtag_write_mem (CORE_ADDR       addr,
                               const gdb_byte *bdata,
                               int             len);
void      or1k_jtag_stall ();
void      or1k_jtag_unstall ();
void      or1k_jtag_wait (int  fast);
	</programlisting>
      </informalexample>

      <para>
	The choice of which implementation to use is determined by the
	argument to <function>or1k_jtag_init</function>.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>or1k_jtag_init</function> and
	    <function>or1k_jtag_close</function>. Initialize and close a
	    connection to the target. <function>or1k_jtag_init</function> is
	    passed an argument string with the address of the target (either a
	    local device or a remote TCP/IP port address). An optional second
	    argument, <literal>reset</literal> can be provided to indicate the
	    target should be reset once connected.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_read_spr</function> and
	    <function>or1k_jtag_write_spr</function>. Read or write a special
	    purpose register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_read_mem</function> and
	    <function>or1k_jtag_write_mem</function>. Read or write a block of
	    memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_stall</function> and
	    <function>or1k_jtag_unstall</function>. Stall or unstall the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_wait</function>. Wait for the target to stall.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The binaries for the remote target interface
	(<filename>remote-or1k.o</filename> and
	<filename>or1k-jtag.o</filename>) are added to the
	<filename>configure.tgt</filename> file for the OpenRISC targets. As
	noted in <xref linkend="sec_target_arch" />, this only specifies
	binaries, so dependencies on headers cannot be captured. To do this
	requires editing the <filename>Makefile.in</filename>.
      </para>

      <tip>
	<para>
	  As a shortcut for a simple port, editing
	  <filename>Makefile.in</filename> can be omitted. Instead,
	  <command>touch</command> the target specific C source files before
	  calling <command>make</command> to ensure they are rebuilt.
	</para>
      </tip>

      <sect2>
	<title>
	  Creating &target_ops; for OpenRISC 1000
	</title>

	<para>
	  The remote target is created by defining the function
	  <function>_initialize_remote_or1k</function>. A new &target_ops;,
	  <varname>or1k_jtag_target</varname> is populated and added as a
	  target by calling <function>add_target</function>.
	</para>

	<para>
	  The majority of the target operations are generic to OpenRISC 1000,
	  and independent of the actual low level interface. This is achieved
	  by abstracting the low level interface through the interface
	  functions described in <xref linkend="sec_or1k_remote_target" />.
	</para>

	<para>
	  Having established all the target functions, the target is added by
	  calling <function>add_target</function>
	</para>

	<para>
	  When a target is selected (with the &gdb;
	  <command>target&nbsp;jtag</command> command), the set of target
	  operations chosen for use with the OpenRISC 1000 architecture will
	  be referred to by the global variable,
	  <varname>or1k_target</varname>, defined in
	  <filename>or1k-tdep.c</filename>.
	</para>

	<note>
	  <para>
	    &gdb; has its own global variable,
	    <varname>current_target</varname>, which refers to the current set
	    of target operations. However this is not sufficient, since even
	    though a target may be connected via the OpenRISC remote
	    interface, it may not be the <emphasis>current</emphasis>
	    target. The use of strata by &gdb; means there could possibly be
	    another target which is active at the same time.
	  </para>
	</note>

	<para>
	  Much of the operation of the target interface involves manipulating
	  the debug &spr;s. Rather than continually writing them out to the
	  target, a cache of their values is maintained in
	  <varname>or1k_dbgcache</varname>, which is flushed prior to any
	  operation that will unstall the target (thus causing it to execute).
	</para>

      </sect2>

      <sect2>
	<title>
	  OpenRISC 1000 Target Functions and Variables Providing Information
	</title>

	<para>
	  OpenRISC remote targets are always executable, with full access to
	  memory, stack, registers etc once the connection is established.
	</para>

	<para>
	  The function <function>or1k_files_info</function> provides data on
	  the remote target for use by the
	  <command>info&nbsp;target</command> command.
	</para>

	<para>
	  The last group of functions are <emphasis>not</emphasis> generic to
	  the OpenRISC 1000&mdash;they differ for each target interface. The
	  function to open a connection for a &jtag; interface is
	  <function>or1k_jtag_open</function> (which will then call the
	  interface independent <function>or1k_open</function> function). The
	  name of the interface is <literal>"jtag"</literal> (this means the
	  command to establish the connection will be <command>target jtag
	  ...</command>). Long name and documentation is also specific to the
	  interface.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_shortname</varname>. This is the name of the target
	      for use when connecting in &gdb;. For the OpenRISC 1000, it is
	      <literal>"jtag"</literal>, so connection in &gdb; will be
	      established by using the command
	      <command>target&nbsp;jtag&nbsp;...</command>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_longname</varname>. A brief description of the
	      command for use by the &gdb; <command>info target</command>
	      command.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_doc</varname>. The help text for this target. The
	      first sentence is used for general help about all targets, the
	      full text for help specifically about this target. The text
	      explains how to connect both directly and over TCP/IP.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_files_info</function>. This function provides the
	      initial information for <command>info&nbsp;target</command>. For
	      the OpenRISC 1000 it provides the name of the program being run
	      on the target, if known.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_stratum</varname>. Since the OpenRISC 1000 target
	      can execute code, this field is set to
	      <constant>process_stratum</constant>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_all_memory</varname>,
	      <varname>to_has_memory</varname>,
	      <varname>to_has_stack</varname> and
	      <varname>to_has_registers</varname>. Once the OpenRISC 1000
	      target is connected, it has access to all its memory, a stack
	      and registers, so all these fields are set to 1 (true).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_execution</varname>. When the connection is
	      initially established, the OpenRISC 1000 processor will be
	      stalled, so is not actually executing. So this field is
	      initialized to 0 (false).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_have_steppable_watchpoint</varname> and
	      <varname>to_have_continuable_watchpoint</varname>. These flags
	      indicate whether the target can step through a watchpoint
	      immediately after it has been executed, or if the watchpoint can
	      be immediate continued without having any effect.
	    </para>

	    <para>
	      If the OpenRISC 1000 triggers a hardware watchpoint, the
	      instruction affected will not have completed execution, so must
	      be re-executed (we cannot continue). Furthermore the watchpoint
	      must be temporarily disabled while re-executing, or it will
	      trigger again (it is not steppable). Thus both these flags are
	      set to 0 (false).
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  OpenRISC 1000 Target Functions Controlling the Connection
	</title>

	<para>
	  These functions control the connection to the target. For remote
	  targets this involves setting up and closing down a TCP/IP socket
	  link to the server driving the hardware. For local targets it
	  involves opening and closing the device.
	</para>


	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_open</function>. This is passed the arguments
	      to the <command>target jtag</command> command and establishes
	      the connection to the target. The arguments are the address of
	      the target (either a local device, or a TCP/IP host/port
	      specification) and an optional second argument
	      <command>reset</command> indicating the target should be reset
	      on connection.
	    </para>

	    <para>
	      Any existing connections are tidied up by
	      <function>target_preopen</function> and any instances of this
	      target are removed from the target stack by
	      <function>unpush_target</function>.
	    </para>

	    <para>
	      Connection is then established through the low level interface
	      routine, <function>or1k_jtag_init</function>, which resets the
	      target if requested.
	    </para>

	    <para>
	      With the connection established, the target's Unit Present &spr;
	      is checked to verify it has a debug unit available. Data about
	      the number of &gpr;s and matchpoints is read from the CPU
	      Configuration &spr; and used to update &gdbarch_tdep;.
	    </para>

	    <para>
	      The target processor is then stalled, to prevent further
	      execution, with a 1000&mu;s wait to allow the stall to complete.
	    </para>

	    <para>
	      The debug cache is cleared, and the Debug Stop &spr; set to
	      trigger the &jtag; interface on trap exceptions (which are used
	      for debug breakpoints, watchpoints and single stepping). The
	      cache will be written out to the &spr;s before execution
	      recommences.
	    </para>

	    <para>
	      Having established a connection, the target is pushed on to
	      the stack. It is marked running, which sets all the flags
	      associated with a running process and updates the choice of
	      current target (which depending on the stratum could be this
	      target). However, the OpenRISC connection is established with
	      the target processor stalled, so the
	      <literal>to_has_execution</literal> flag is cleared by setting
	      the macro <literal>target_has_execution</literal> to 0. It
	      will be set when <function>or1k_resume</function> unstalls the
	      target.
	    </para>

	    <para>
	      As a matter of good housekeeping, any shared library symbols
	      are cleared using <function>no_shared_libraries</function>.
	    </para>

	    <para>
	      &gdb; identifies all inferior executables by their process and
	      thread ID. This port of the OpenRISC 1000 is for bare metal
	      debugging, so there is no concept of different processes that
	      may be executing. Consequently we use the
	      <literal>null_ptid</literal> and the process/thread ID for the
	      target. This is set in the &gdb; global variable
	      <varname>inferior_pid</varname>.
	    </para>

	    <note>
	      <para>
		It is important that the inferior process/thread ID is established at this
		early stage, so that the target can always be uniquely
		identified.
	      </para>
	    </note>

	    <para>
	      Finally the generic <function>start_remote</function> is
	      called to set up the new target ready for execution. It is
	      possible this could fail, so the call is wrapped in our own
	      function, <function>or1k_start_remote</function>, which has
	      the correct prototype to run using
	      <function>catch_exception</function>. If failure occurs, the
	      target can be popped, before the exception is thrown on to
	      the top level.
	    </para>

	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_close</function>. This closes the connection by
	      calling the low level interface function,
	      <function>to_done</function> if it exists. The target will
	      already have been unpushed and the inferior mourned (see <xref
	      linkend="sec_or1k_exec_funcs" />), so these
	      actions are not required.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_detach</function>. This just detaches from the
	      target being debugged, which is achieved by calling
	      <function>or1k_close</function>.
	    </para>

	    <para>
	      There is no explicit function
	      to reattach to the target, but a call to
	      <function>or1k_open</function> (by giving a
	      <command>target&nbsp;jtag&nbsp;...</command> command in &gdb;)
	      will achieve the same effect.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  OpenRISC 1000 Target Functions to Access Memory and Registers
	</title>

	<para>
	  There are a group of functions to access the state of the
	  target. <function>or1k_fetch_registers</function> and
	  <function>or1k_store_registers</function> read and write the raw
	  &gdb; registers (the &gpr;s, program counter and supervision
	  register), with <function>or1k_prepare_to_store</function> as a
	  function that can help
	  this. <function>or1k__xfer_partial</function> is used to read
	  and write main memory. Object file loading is achieved with the
	  generic loader, <function>generic_load</function>.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_fetch_registers</function>. This function
	      populates the register cache from the actual target
	      registers. The interface to the OpenRISC 1000 only provides
	      for reading of memory or &spr;s. However the &gpr;s are
	      mapped into the &spr; space, so can be read in this way.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_store_registers</function>. This is the inverse
	      of <function>or1k_fetch_registers</function>. It writes the
	      contents of the register cache back to the physical registers
	      on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_prepare_to_store</function>. &gdb; allows for
	      targets which need some preparatory work before storing, so
	      provides this function. It is not needed for the OpenRISC
	      1000, so just returns.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_xfer_partial</function>. This is the
	      generic function for reading and writing objects from and to
	      the target. However the only class of object which needs be
	      supported is read and write from memory. This is achieved
	      through the low-level interface routines
	      <function>or1k_read_mem</function> and
	      <function>or1k_write_mem</function>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>generic_load</function>. This generic function is used
	      for then <function>to_load</function> field of the target
	      operations. there is nothing special about loading OpenRISC 1000
	      images. This function will call the
	      <function>or1k_xfer_partial</function> function to transfer the
	      bytes of the image.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  OpenRISC 1000 Target Functions to Handle Breakpoints and Watchpoints
	</title>

	<para>
	  The OpenRISC 1000 can support hardware breakpoints and watchpoints,
	  if matchpoints are fee in the debug unit.
	</para>

	<note>
	  <para>
	    Beware of confusion over the term "watchpoint". It is used in
	    &gdb; to mean a location, being watched for read or write
	    activity. These may be implemented in hardware or software.
	  </para>

	  <para>
	    If implemented in hardware, they may make use of the OpenRISC 1000
	    Debug Unit mechanism, which also uses the term watchpoint. This
	    document uses the terms "&gdb; watchpoint" and "OpenRISC 1000
	    watchpoint" where there is any risk of confusion.
	  </para>
	</note>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_set_breakpoint</function>. This is the underlying
	      OpenRISC 1000 function which sets a hardware breakpoint if one
	      is available. This is controlled through the Debug Value
	      Register and Debug Control Register. This function is used by
	      the target operation functions
	      <function>or1k_insert_breakpoint</function> and
	      <function>or1k_insert_hw_breakpoint</function>.
	    </para>

	    <para>
	      The first free hardware matchpoint is found by searching
	      through the Debug Control Registers for a register without its
	      &dvr;/&dcr; Preset (DP) flag set using
	      <function>or1k_first_free_matchpoint</function>.
	    </para>

	    <para>
	      The Debug Value Register is set to the address of the breakpoint
	      and the Debug Control Register to trigger when the unsigned
	      effective address of the fetched instruction is equal to the
	      Debug Value Register. The corresponding OpenRISC 1000 watchpoint
	      is marked as unchained in Debug Mode Register&nbsp;1 and set to
	      trigger a trap exception in Debug Mode Register&nbsp;2.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_clear_breakpoint</function>. This is the
	      counterpart to <function>or1k_set_breakpoint</function>. It is
	      called by the target operation functions
	      <function>remove_breakpoint</function> and
	      <function>remove_hw_breakpoint</function>.
	    </para>

	    <para>
	      The Debug Control Registers are searched for an entry matching
	      the give address (using
	      <function>or1k_matchpoint_equal</function>). If a register is
	      found, its &dvr;/&dcr; Present flag is cleared, and the
	      matchpoint marked unused in Debug Mode Register&nbsp;2.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_breakpoint</function>. This function
	      inserts a breakpoint. It tries to insert a hardware breakpoint
	      using <function>or1k_set_breakpoint</function>. If this fails,
	      the generic <function>memory_insert_breakpoint</function> is
	      used to set a software breakpoint.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_remove_breakpoint</function>. This is the
	      counterpart to <function>or1k_insert_breakpoint</function>. It
	      tries to clear a hardware breakpoint, and if that fails tries
	      to clear a software breakpoint using the generic
	      <function>memory_remove_breakpoint</function>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_hw_breakpoint</function> and
	      <function>or1k_remove_hw_breakpoint</function>. These
	      functions are similar to
	      <function>or1k_insert_breakpoint</function> and
	      <function>or1k_remove_breakpoint</function>. However if a
	      hardware breakpoint is not available, they do not attempt to
	      use a software (memory) breakpoint instead.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_watchpoint</function>. This function
	      attempts to insert a &gdb; hardware watchpoint. For this it
	      requires a pair of OpenRISC 1000 watchpoints chained
	      together. The first will check for a memory access greater than
	      or equal to the start address of interest. The second will check
	      for a memory access less than or equal to the end address of
	      interest. If both criteria are met. The access type can be the
	      load effective address (for &gdb; <command>rwatch</command>
	      watchpoints), store effective address (for &gdb;
	      <command>watch</command> watchpoints) or both (for &gdb;
	      <command>awatch</command> watchpoints).
	    </para>

	    <para>
	      The pair of OpenRISC 1000 watchpoints must be adjacent (so they
	      can be chained together using Debug Mode Register 1), but it is
	      possible that successive breakpoints have fragmented the use of
	      OpenRISC 1000
	      watchpoints. <function>or1k_watchpoint_gc</function> is used to
	      shuffle up all the existing OpenRISC 1000 watchpoints which can
	      be moved, to find a pair if possible.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_remove_watchpoint</function>. This is the
	      counterpart of <function>or1k_insert_watchpoint</function>. It
	      searches for an adjacent pair of OpenRISC 1000 watchpoints that
	      match using <function>or1k_matchpoint_equal</function>. If found
	      both are marked unused in their Debug Control Register and
	      cleared from triggering in Debug Mode Register 2.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_stopped_by_watchpoint</function> and
	      <function>or1k_stopped_by_watchpoint</function>. These functions
	      are called to find out about &gdb; watchpoints which may have
	      triggered. Both make use of the utility function,
	      <function>or1k_stopped_watchpoint_info</function>, which
	      determines if a &gdb; watchpoint was triggered, if so which
	      matchpoint and for what
	      address. <function>or1k_stopped_watchpoint</function> just
	      returns a Boolean to indicate if a watchpoint was
	      triggered. <function>or1k_stopped_data_address</function> is
	      called once for each watchpoint that has triggered. It returns
	      the address that triggered the watchpoint and must also clear
	      the watchpoint (in Debug Mode Register 2).
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_or1k_exec_funcs">
	<title>
	  OpenRISC 1000 Target Functions to Control Execution
	</title>

	<para>
	  When the <command>run</command> is used to start execution with
	  &gdb; it needs to establish the executable on the inferior, and then
	  start execution. This is done using the
	  <function>to_create_inferior</function> and
	  <function>to_resume</function> functions of the target
	  respectively.
	</para>

	<para>
	  Once execution has started, &gdb; waits until the target
	  <function>to_wait</function> function returns control.
	</para>

	<para>
	  In addition the target provides operations to stop execution.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_resume</function>. This is the function which
	      causes the target program to run. It is called in response to
	      the <command>run</command>, <command>step</command>,
	      <command>stepi</command>, <command>next</command> and
	      <command>nexti</command> instructions.
	    </para>

	    <para>
	      The behavior of this function is far simpler than its
	      counterpart in &gdb; 5.3, which required complex logic to
	      re-execute instructions after a breakpoint or
	      watchpoint. &gdb;&nbsp;6.8 will sort out all the issues of
	      re-execution after a breakpoint or watchpoint has been
	      encountered (see <function>or1k_wait</function> below for more
	      on this).
	    </para>

	    <para>
	      The function clears the Debug Reason Register, clears any
	      watchpoint status bits in Debug Mode Register 2 and then
	      commits the debug registers.
	    </para>

	    <para>
	      If the caller has requested single stepping, this is set using
	      Debug Mode Register 1, otherwise this is cleared.
	    </para>

	    <para>
	      Finally the target can be marked as executing (the first time
	      <function>or1k_resume</function> is called it will not be marked
	      as executing), the debug registers written out, and the processor
	      unstalled.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_wait </function>. This function waits for the
	      target to stall, and analyzes the cause.  Information about why
	      the target stalled is returned to the caller via the
	      <varname>status</varname> argument. The function returns the
	      process/thread ID of the process which stalled, although for
	      the OpenRISC 1000 this will always be the same value.
	    </para>

	    <para>
	      While waiting for the target to stall (using
	      <function>or1k_jtag_wait</function>), a signal handler is
	      installed, so the user can interrupt execution with ctrl-C.
	    </para>

	    <para>
	      After the wait returns, all register and frame caches are
	      invalid, These are cleared by calling
	      <function>registers_changed</function> (which in turn clears
	      the frame caches).
	    </para>

	    <para>
	      When the processor stalls, the Debug Reason Register (a &spr;)
	      shows the reason for the stall. This will be due to any
	      exception set in the Debug Stop Register (currently only trap),
	      due to a single step, due to a reset (the debugger stalls the
	      processor on reset) or (when the target is the architectural
	      simulator, &or1ksim;) due to an exit
	      <literal>l.nop&nbsp;1</literal> being executed.
	    </para>

	    <para>
	      In all cases the previous program counter &spr;
	      points to the instruction just executed and the next program
	      counter &spr; to the instruction about to be executed. For
	      watchpoints and breakpoints, which generate a trap however the
	      instruction at the previous program counter will not have
	      completed execution. As a result, when the program resumes,
	      this instruction should be re-executed without the
	      breakpoint/watchpoint enabled.
	    </para>

	    <para>
	      &gdb; understands this. It is sufficient to set the program
	      counter to the previous program counter. &gdb; will realize
	      that the instruction corresponds to a breakpoint/watchpoint
	      that has just been encountered, lift the breakpoint, single
	      step past the instruction and reimpose the breakpoint. This is
	      achieved by a call to <function>write_pc</function> with the
	      previous program counter value.
	    </para>

	    <para>
	      The OpenRISC 1000 imposes a slight problem here. This approach
	      works fine, except if the breakpoint was in the delay slot of
	      a branch of jump instruction. In this case the re-execution
	      must be not just of the previous instruction, but the one
	      before that (restoring the link register as well if it was a
	      jump-and-link instruction). Furthermore this must only be in
	      the case where the branch was truly the preceding instruction,
	      rather than the delay slot having been the target of a
	      different branch instruction.
	    </para>

	    <para>
	      In the absence of a "previous previous" program counter, this
	      restart cannot be correct under all circumstances. For the
	      time being, breakpoints on delay slots are not expected to
	      work. However it is highly unlikely a source level debugger
	      would ever place a breakpoint in a delay slot.
	    </para>

	    <para>
	      Having sorted out the program counter readjustment, any single
	      step is marked as though it were a trap. Single step does not
	      set the trap exception, nor does it need re-executing, but by
	      setting the flag here, the exception will be correctly mapped
	      to the <constant>TARGET_SIGNAL_TRAP</constant> for return to
	      &gdb;
	    </para>

	    <para>
	      The response is marked as a a stopped processor
	      (<constant>TARGET_WAITKIND_STOPPED</constant>).  All
	      exceptions are mapped to their corresponding &gdb; signals. If
	      no exception has been raised, then the signal is set to the
	      default, unless the instruction just executed was
	      <literal>l.nop&nbsp;1</literal>, which is used by the
	      architectural simulator to indicate termination. In this case
	      the response is marked as
	      <constant>TARGET_WAITKIND_EXITED</constant>, and the associate
	      value set to the exit return code.
	    </para>

	    <para>
	      The debug reason register (which is sticky) can now be cleared
	      and the process/thread ID returned.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_stop</function>. This stops the processor
	      executing. To achieve this cleanly, the processor is stalled,
	      single step mode is set and the processor unstalled, so
	      execution will have stopped at the end of an instruction.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_kill</function>. This is a more dramatic
	      termination, when <function>or1k_stop</function> has failed to
	      give satisfaction. Communication with the target is assumed to
	      have broken down, so the target is then mourned, which will
	      close the connection.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_create_inferior</function>. This sets up a
	      program to run on the target, but does not actually start it
	      running. It is called in response to the &gdb;
	      <command>run</command> command and is passed any arguments to
	      that command. However the OpenRISC 1000 &jtag; protocol has no
	      way to send arguments to the target, so these are ignored.
	    </para>

	    <para>
	      Debugging is much easier if a local copy of the executable
	      symbol table has been loaded with the <command>file</command>
	      command. This is checked for and a warning issued. However if
	      it is not present, it is perfectly acceptable to debug code on
	      the OpenRISC 1000 target without symbol data.
	    </para>

	    <para>
	      All static data structures (breakpoint lists etc) are then
	      cleared within &gdb; by calling
	      <function>init_wait_for_inferior</function>.
	    </para>

	    <tip>
	      <para>
		If &gdb; for the OpenRISC 1000 is used with
		<command>ddd</command> the warning about passing arguments will
		often be triggered. This occurs when <command>ddd</command>
		is asked to run a program in a separate execution window,
		which it attempts to achieve by creating an
		<command>xterm</command> and redirecting I/O via pseudo-TTYs
		to that <command>xterm</command>. The redirections are
		arguments to the &gdb; <command>run</command> command.
	      </para>

	      <para>
		&gdb; for OpenRISC 1000 does not support this. The
		<parameter>run in separate window</parameter> option should be
		disabled with <command>ddd</command>.
	      </para>
	    </tip>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_mourn_inferior</function>. This is the
	      counterpart to <function>or1k_create_inferior</function>,
	      called after execution has completed. It tidies up by calling
	      the generic function
	      <function>generic_mourn_inferior</function>. If the target is
	      still shown as having execution, it is marked as exited, which
	      will cause the selection of a new current target.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_jtag_interface">
	<title>
	  The Low Level &jtag; Interface
	</title>

	<para>
	  The interface to the OpenRISC &jtag; system is found in
	  <filename>gdb/or1k-jtag.c</filename> and
	  <filename>gdb/or1k-jtag.h</filename>. The details are not directly
	  relevant to porting &gdb; so only an overview is given here. Full
	  details are found in the commenting within the source code.
	</para>

	<para>
	  The interface is layered, to maximize use. In particular much of the
	  functionality is the same whether the target is connected remotely
	  over TCP/IP or directly via a JP1 header connected to the parallel
	  port.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      The highest level is the public function interface, which
	      operate in terms of entities that are visible in &gdb;: open and
	      close the connection, read and write &spr;s, read and write
	      memory, stall, unstall and wait for the processor. These
	      functions always succeed and have function prefixes
	      <literal>or1k_jtag_</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is the abstraction provided by the OR1K &jtag;
	      protocol: read/write a &jtag; register, read/write a block of
	      &jtag; registers and select a scan chain. These functions may
	      encounter errors and will deal with them, but otherwise return
	      no error result. These are static functions (i.e. local to this
	      file), with prefixes <literal>or1k_jtag_</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is in two sets, one for use with a locally
	      connected (JP1) &jtag; and one for a remote connection over
	      TCP/IP corresponding to the functions in the previous
	      layer. These functions detect with errors and return an error
	      code to indicate an error has occurred. These are static
	      functions with prefixes: <literal>jp1_</literal> and
	      <literal>jtr_</literal> respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The final level comes in separate flavors for locally connected
	      &jtag; (low level routines to drive the JP1 interface) and
	      remote use (to build and send/receive packets over
	      TCP/IP). These functions detect errors and return an error code
	      to indicate an error has occurred. These are static function
	      with prefixes <literal>jp1_ll_</literal> and
	      <literal>jtr_ll_</literal> respectively.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Errors are either dealt with silently or (if fatal) via the &gdb;
	  error() function.
	</para>

	<caution>
	  <para>
	    Few people now use the JP1 direct connection, and there is no
	    confidence that this code works at all!
	  </para>
	</caution>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_disasm">
      <title>
	The OpenRISC 1000 Disassembler
      </title>

      <para>	
	The OpenRISC 1000 disassembler is part of the wider
	<command>binutils</command> utility set and is found in the
	<filename>opcodes</filename> sub-directory. It provides two versions of
	the disassembly function, <function>print_insn_big_or32</function> and
	<function>print_insn_little_or32</function> for use with big-endian
	and little-endian implementations of the architecture in
	<filename>or32-dis.c</filename>
      </para>

      <para>
	The instruction decode uses a finite state automaton (&fsa;) in
	<filename>or32-opc.c</filename>. This is constructed at start-up by
	the function <function>build_automata</function> from a table
	describing the instruction set. This function is invoked from the
	<function>_initialize_or1k_tdep</function> function immediately after
	the OpenRISC 1000 architecture has been defined.
      </para>

      <para>
	The disassembler takes advantage of any symbol table information to
	replace branch and jump targets by symbolic names where possible.
      </para>
    </sect1>

    <sect1>
      <title>
	OpenRISC 1000 Specific Commands for &gdb;
      </title>

      <para>
	<xref linkend="sec_adding_commands" /> describes how to extend the
	&gdb; command set. For the OpenRISC 1000 architecture, the
	<command>info</command> command is extended to show the value of
	&spr;s (<command>info&nbsp;spr</command>) and a new command,
	<command>spr</command> is added to set the value of a &spr;<footnote>
	<para>
	    There is a strong case for this being a new sub-command of the
	    <command>set</command>. However the <command>spr</command> command
	    was introduced in &gdb;&nbsp;5.0, and there is no point in
	    replacing it now.
	  </para>
	  </footnote>.
      </para>

      <para>
	Both these commands are added in
	<function>_initialize_or1k_tdep</function> after the architecture has
	been created and the disassembler automata initialized.
      </para>

      <sect2>
	<title>
	  The <command>info spr</command> Command
	</title>

	<para>
	  The new sub-command for <command>info</command> is added using
	  <function>add_info</function>
	</para>

	<informalexample>
	  <programlisting>
add_info ("spr", or1k_info_spr_command,
          "Show the value of a special purpose register");
	  </programlisting>
	</informalexample>

	<para>
	  The functionality is provided in
	  <function>or1k_info_spr_command</function>. The user can specify a
	  group by name or number (the value of all registers in that group is
	  displayed), or a register name (the value of that register is
	  displayed) or a group name/number and register name/number (the
	  value of that register in the group is displayed).
	</para>

	<para>
	  The arguments are broken out from the text of the command using
	  <function>or1k_parse_params</function>, which also handles any
	  errors in syntax or semantics. If the arguments are successfully
	  parsed the results are then printed out using the UI independent
	  function, <function>ui_out_field_fmt</function>.
	</para>
      </sect2>

      <sect2>
	<title>
	  The <command>spr</command> Command
	</title>

	<para>
	  This new top level command is added, classified as a support command
	  (<constant>class_support</constant>), using the
	  <function>add_com</function> command.
	</para>

	<para>
	  The functionality is provided in
	  <function>or1k_spr_command</function>. This also uses
	  <function>or1k_parse_spr_params</function> to parse the arguments,
	  although there is now one more (the value to set). The new value is
	  written into the relevant &spr; (using
	  <function>or1k_write_spr</function>) and the change recorded using
	  <function>ui_out_field_fmt</function>.
	</para>

      </sect2>

    </sect1>

  </chapter>

  <glossary id="sec_glossary">
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Big&#32;Endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>Little&#32;Endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Little&#32;Endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>Big&#32;Endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Binary File Descriptor</glossterm>
      <acronym>BFD</acronym>
      <glossdef>
	<para>
	  A package which allows applications to use the same routines to
	  operate on object files whatever the object file format <xref
	  linkend="ref_bfd" />. A new object file format can be supported
	  simply by creating a new &bfd; back end and adding it to the
	  library.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Frame Pointer</glossterm>
      <glossdef>
	<para>
	  In stack based languages, the stack pointer typically refers to the
	  end of the local frame. The frame pointer is a second register,
	  which refers to the beginning of the local frame. Not all
	  stack based architectures make use of a frame pointer.
	</para>
	<glossseealso>Stack Frame</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>General Purpose Register</glossterm>
      <acronym>GPR</acronym>
      <glossdef>
	<para>
	  In the OpenRISC 1000 architecture, one of between 16 and 32 general
	  purpose integer registers.
	</para>

	<para>
	  Although these registers are general purpose, some have specific
	  roles defined by the architecture and the &abi;. &gpr;&nbsp;0 is
	  always 0 and should not be written to. &gpr;&nbsp;1 is the stack
	  pointer, &gpr;&nbsp;2 the frame pointer and &gpr;&nbsp;9 the return
	  address set by <literal>l.jal</literal> and
	  <literal>l.jalr</literal> instructions. &gpr;&nbsp;3 through
	  &gpr;&nbsp;8 are used to pass arguments to functions, with scalar
	  results returned in &gpr;&nbsp;11.
	</para>

	<glossseealso>Application Binary Interface</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Joint Test Action Group</glossterm>
      <acronym>JTAG</acronym>
      <glossdef>
	<para>
	  &jtag; is the usual name used for the IEEE 1149.1 standard entitled
	  <emphasis>Standard Test Access Port and Boundary-Scan
	  Architecture</emphasis> for test access ports used for testing
	  printed circuit boards and chips using boundary scan.
	</para>

	<para>
	  This standard allows external reading of state within the board or
	  chip. It is thus a natural mechanism for debuggers to connect to
	  embedded systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Memory Management Unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Real Time Executive for Multiprocessor Systems</glossterm>
      <acronym>RTEMS</acronym>
      <glossdef>
	<para>
	  An operating system for real-time embedded systems offering a POSIX
	  interface. It offers no concept of processes or memory management.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Special Purpose Register</glossterm>
      <acronym>GPR</acronym>
      <glossdef>
	<para>
	  In the OpenRISC 1000 architecture, one of up to 65536 registers
	  controlling all aspects of the processor. The registers are arranged
	  in groups of 2048 registers. The present architecture defines 12
	  groups in total.
	</para>

	<para>
	  In general each group controls one component of the processor. Thus
	  there is a group to control the DMMU, the IMMU the data and
	  instruction caches and the debug unit. Group 0 is the system group
	  and includes all the system configuration registers, the next and
	  previous program counters, supervision register and saved exception
	  registers.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Stack Frame</glossterm>
      <glossdef>
	<para>
	  In procedural languages, a dynamic data structure used to hold the
	  values of local variables in a procedure at a particular point of
	  execution.
	</para>

	<para>
	  Typically successive stack frames are placed next to each other in a
	  linear data area. The last address of the current stack frame is
	  pointed to by a register, known as the <emphasis>stack
	  pointer</emphasis>. It will be the first address of the next stack
	  pointer.
	</para>

	<glossseealso>Frame Pointer</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_app_note_2">
      <title id="ref_app_note_2_xr">
	&embecosm; Application Note 2. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	June 2008.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_gdb_ug">
      <title id="ref_gdb_ug_xr">
	Debugging with &gdb;: The &gnu; Source-Level Debugger,
      </title>
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      <firstname>Roland</firstname> <surname>Pesch</surname>,
      <firstname>Stan</firstname> <surname>Shebbs</surname>, et al,
      issue <issuenum>9</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_gdb_int">
      <title id="ref_gdb_int_xr">
	&gdb; Internals: A guide to the internals of the &gnu; debugger,
      </title>
      <firstname>John</firstname> <surname>Gillmore</surname> and
      <firstname>Stan</firstname> <surname>Shebbs</surname>,
      issue <issuenum>2</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdbint_toc.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_bfd">
      <title id="ref_bfd_xr">
	libbfd: The Binary File Descriptor Library,
      </title>
      <firstname>Steve</firstname> <surname>Chamberlain</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
    </bibliomixed>

    <bibliomixed id="ref_or1k_gdb">
      <title id="ref_gdb_or1k_gdb_xr">
	Debugging the OpenRISC 1000 with &gdb;: Target Processor Manual,
      </title>
      <firstname>Jeremy</firstname> <surname>Bennett</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Embecosm Limited
	</publishername>
      </publisher>
      <pubdate>
	June 2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.embecosm.com/downloads/or1k/or1k.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_doxygen">
      <title id="ref_gdb_doxygen_xr">
	Doxygen: Source code documentation generator tool,
      </title>
      <firstname>Dimitri</firstname> <surname>van Heesch</surname>,
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.doxygen.org"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_or1k">
      <title id="ref_gdb_or1k_xr">
	OpenRISC 1000 Architectural Manual,
      </title>
      <firstname>Damjan</firstname> <surname>Lampret</surname>,
      <firstname>Chen-Min</firstname> <surname>Chen</surname>,
      <firstname>Marko</firstname> <surname>Mlinar</surname>,
      <firstname>Johan</firstname> <surname>Rydberg</surname>,
      <firstname>Matan</firstname> <surname>Ziv-Av</surname>,
      <firstname>Chris</firstname> <surname>Ziomkowski</surname>,
      <firstname>Greg</firstname> <surname>McGary</surname>,
      <firstname>Bob</firstname> <surname>Gardner</surname>,
      <firstname>Rohit</firstname> <surname>Mathur</surname> and
      <firstname>Maria</firstname> <surname>Bolado</surname>,
      <pubdate>
	November 2005
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.opencores.org/cvsget.cgi/or1k/docs/openrisc_arch.pdf"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_texinfo">
      <title id="ref_texinfo_xr">
	Texinfo: The &gnu; Documentation Format
      </title>
      <firstname>Robert</firstname> J <surname>Chassell</surname> and
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      issue <issuenum>4.12</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	9 April, 2008
      </pubdate>.
    </bibliomixed>

    <bibliomixed id="ref_orpsoc">
      <title>
	OpenRISC 1000: ORPSoC
      </title>
      <firstname>Damjan</firstname> <surname>Lampret</surname> et al.
      <publisher>
	<publishername>
	  OpenCores
	</publishername>
      </publisher>
      <bibliosource class="uri">
	<ulink
	    url="http://opencores.org/projects.cgi/web/or1k/orpsoc"/>
      </bibliosource>
    </bibliomixed>
	
    <bibliomixed id="ref_or1k_debug">
      <title>
	SoC Debug Interface
      </title>
      <firstname>Igor</firstname> <surname>Mohor</surname>,
      issue <issuenum>3.0</issuenum>.
      <publisher>
	<publishername>
	  OpenCores
	</publishername>
      </publisher>
      <pubdate>
	14 April, 2004
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://opencores.org/cvsweb.shtml/dbg_interface/doc/DbgSupp.pdf"/>
      </bibliosource>
    </bibliomixed>

  </bibliography>
</book>
