<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY abi   "<acronym>ABI</acronym>">
<!ENTITY bfd   "<acronym>BFD</acronym>">
<!ENTITY dcr   "<acronym>DCR</acronym>">
<!ENTITY dvr   "<acronym>DVR</acronym>">
<!ENTITY fp    "<acronym>FP</acronym>">
<!ENTITY fsa   "<acronym>FSA</acronym>">
<!ENTITY gcc   "<acronym>GCC</acronym>">
<!ENTITY gdb   "<acronym>GDB</acronym>">
<!ENTITY gnu   "<acronym>GNU</acronym>">
<!ENTITY gpr   "<acronym>GPR</acronym>">
<!ENTITY html  "<acronym>HTML</acronym>">
<!ENTITY iss   "<acronym>ISS</acronym>">
<!ENTITY jtag  "<acronym>JTAG</acronym>">
<!ENTITY pc    "<acronym>PC</acronym>">
<!ENTITY pdf   "<acronym>PDF</acronym>">
<!ENTITY rtems "<acronym>RTEMS</acronym>">
<!ENTITY rsp   "<acronym>RSP</acronym>">
<!ENTITY sal   "<acronym>SAL</acronym>">
<!ENTITY soc   "<acronym>SoC</acronym>">
<!ENTITY sp    "<acronym>SP</acronym>">
<!ENTITY spr   "<acronym>SPR</acronym>">
<!ENTITY usb   "<acronym>USB</acronym>">

<!-- ========== commonly used things ========== -->

<!ENTITY null         "<constant>NULL</constant>">
<!ENTITY this         "<emphasis>THIS</emphasis>">
<!ENTITY prev         "<emphasis>PREVIOUS</emphasis>">
<!ENTITY next         "<emphasis>NEXT</emphasis>">

<!ENTITY frame_info   "<structname>struct&nbsp;frame_info</structname>">
<!ENTITY gdbarch      "<structname>struct&nbsp;gdbarch</structname>">
<!ENTITY gdbarch_info "<structname>struct&nbsp;gdbarch_info</structname>">
<!ENTITY gdbarch_tdep "<structname>struct&nbsp;gdbarch_tdep</structname>">
<!ENTITY regcache     "<structname>struct&nbsp;regcache</structname>">
<!ENTITY target_ops   "<structname>struct&nbsp;target_ops</structname>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">

<!-- = Commands = -->

<!ENTITY xterm "<application>xterm</application>" >

<!-- = Libraries = -->

<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY lgpl "GNU Lesser General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2008 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing how to port GDB

$Id$

=========================================================================== -->

<book lang="en_GB">
  <title>
    Howto: Porting the &gnu; Debugger
  </title>
  <subtitle>
    Practical Experience with the OpenRISC 1000 Architecture
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      August 2008
    </pubdate>

    <releaseinfo>
      Application Note 3. Issue 1
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software for the port of the &gnu; Debugger written by &embecosm;
	and used in this document are licensed under the &gpl_www;. For
	detailed licensing information see the files
	<filename>COPYING</filename>, <filename>COPYING3</filename>,
	<filename>COPYING.LIB</filename> and <filename>COPYING3.LIB</filename>
	in the source code.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      This document complements the existing documentation for &gdb; (<xref
      linkend="ref_gdb_ug" />, <xref linkend="ref_gdb_int" />, <xref
      linkend="ref_bfd" />). It is intended to help software engineers porting
      &gdb; to a new architecture for the first time.
    </para>

    <para>
      This is a work in progress, capturing the author's experience to
      date. Suggestions for improvements are always welcome.
    </para>

    <sect1>
      <title>
	Rationale
      </title>

      <para>
	Although the &gdb; project includes a 100 page guide to its internals,
	that document suffers from three limitations.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    It tends to document at a low-level. Individual functions are
	    described well, but it is hard to get the <emphasis>big
	    picture</emphasis>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    It is incomplete. Many of the most useful sections (for example on
	    frame interpretation) are yet to be written.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Is tends to be out of date. For example the documentation of the
	    UI-Independent output describes a number of functions which no
	    longer exist.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Consequently the engineer faced with their first port of &gdb; to a new
	architecture is faced with discovering how &gdb; works by reading the
	source code and looking at how other architectures have been ported.
      </para>

      <para>
	The author of this paper went through that process when porting the
	OpenRISC 1000 architecture to &gdb;. This document captures the learning
	experience, in the hope that it will help others.
      </para>

    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>

      <para>
	If you are about to start a port of &gdb; to a new architecture, this
	document is for you. Hopefully this document will help you. If at the
	end of your endeavors you are better informed, please help by adding
	to this document.
      </para>

      <para>
	If you have already been through the porting process, please help
	others by adding to this document.
      </para>

    </sect1>

    <sect1>
      <title>
	Other Sources of Information
      </title>

      <para>
	The main user guide for &gdb; (<xref linkend="ref_gdb_ug" />) provides a
	great deal of context about how &gdb; is intended to work.
      </para>

      <para>
	The &gdb; Internals guide (<xref linkend="ref_gdb_int" />) is
	essential reading before and during any porting exercise. It is not
	complete, nor is it always up to date, but it provides the first place
	to look for explanation of what a particular function does.
      </para>

      <para>
	&gdb; relies on a separate specification of the Application Binary
	Interface (&abi;) for each architecture. That has its
	own comprehensive user guide (<xref linkend="ref_bfd" />).
      </para>

      <para>
	The main &gdb; code base is generally well commented, particularly in
	the headers for the major interfaces. Inevitably this must be the
	definitive place to find out exactly how a particular function
	behaves.
      </para>

      <para>
	The files making up the port for the OpenRISC 1000 are comprehensively
	commented, and can be processed with Doxygen (<xref
	linkend="ref_doxygen" />). Each function, its parameters and return
	value is described.
      </para>

    </sect1>

  </chapter>

  <chapter>
    <title>
      About the OpenRISC 1000 Architecture
    </title>

    <para>
      OpenRISC 1000 is architecture for a family of free, open source RISC
      processor cores. It is a 32 or 64-bit load and store RISC architecture
      designed with emphasis on performance, simplicity, low power
      requirements, scalability and versatility.
    </para>

    <para>
      The OpenRISC 1000 is fully documented in its Architecture Manual <xref
      linkend="ref_or1k" />.
    </para>

    <para>
      From a debugging perspective, there are three data areas that are
      manipulated by the instruction set.
    </para>

    <orderedlist>
      <listitem>
	<para>
	  Main memory. A uniform address space with 32 or 64-bit
	  addressing. Provision for separate or unified instruction and data
	  and instruction caches. Provision for separate or unified, 1 or
	  2-level data and instruction MMUs.
	</para>
      </listitem>

      <listitem>
	<para>
	  General Purpose Registers (&gpr;s). Up to 32 registers, 32 or 64-bit
	  in length.
	</para>
      </listitem>

      <listitem>
	<para>
	  Special Purpose Registers (&spr;s). Up to 32 groups each with up to
	  2048 registers, up to 32 or 64-bit in length. These registers
	  provide all the administrative functionality of the processor:
	  program counter, processor status, saved exception registers, debug
	  interface, MMU and cache interfaces, etc.
	</para>
      </listitem>
    </orderedlist>

    <para>
      The Special Purpose Registers (&spr;s) represent a
      challenge for &gdb;, since they represent neither addressable memory, nor
      have the characteristics of a register set (generally modest in number).
    </para>

    <para>
      A number of &spr;s are of particular significance to the &gdb;
      implementation.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Configuration registers</emphasis>. The Unit Present
	  register (&spr;&nbsp;1, <literal>UPR</literal>), CPU Configuration
	  register (&spr;&nbsp;2, <literal>CPUCFGR</literal>) and Debug
	  Configuration register (&spr;&nbsp;7, <literal>DCFGR</literal>)
	  identify the features available in the particular OpenRISC 1000
	  implementation. This includes the instruction set in use, number of
	  general purpose registers and configuration of the hardware debug
	  interface.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Program counters</emphasis>. The Previous Program Counter
	  (&spr;&nbsp;0x12, <literal>PPC</literal>) is the address of the
	  instruction just executed. The Next Program Counter (&spr;&nbsp;0x10,
	  <literal>NPC</literal>) is the address of the next instruction to be
	  executed. The <literal>NPC</literal> is the value reported by &gdb;s
	  <command>$pc</command> variable.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Supervision register</emphasis>. The supervision register
	  (&spr;&nbsp;0x11, <literal>SR</literal>) represents the current status
	  of the processor. It is the value reported by &gdb;s status register
	  variable, <command>$ps</command>.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Of particular importance are the &spr;s in group 6 controlling the debug
      unit (if present). The debug unit can trigger a trap exception in
      response to any one of up to 10
      <emphasis>watchpoints</emphasis>. Watchpoints are logical expressions
      built by combining <emphasis>matchpoints</emphasis>, which are simple
      point tests of particular behavior (has a specified address been
      accessed for example).
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Debug Value and Control registers</emphasis>. There are up
	  to 8 pairs of Debug Value (&spr;&nbsp;0x3000&ndash;0x3007,
	  <literal>DVR0</literal> through <literal>DVR7</literal>) and
	  Debug Control (&spr;&nbsp;0x3008&ndash;0x300f,
	  <literal>DCR0</literal> through <literal>DCR7</literal>)
	  registers. Each pair is associated with one hardware
	  <emphasis>matchpoint</emphasis>. The Debug Value register in each
	  pair gives a value to compare against. The Debug Control register
	  indicates whether the matchpoint is enabled, the type of value to
	  compare against (instruction fetch address, data load and/or store
	  address data load and/or store value) and the comparison to make
	  (equal, not equal, less than, less than or equal, greater than,
	  greater than or equal), both signed and unsigned. If the matchpoint
	  is enabled and the test met, the corresponding matchpoint is
	  triggered.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Watchpoint counters</emphasis>. There are two 16-bit
	  Debug Watchpoint Counter registers (&spr;&nbsp;0x3012&ndash;0x3013,
	  <literal>DWCR0</literal> and <literal>DWCR1</literal>), associated
	  with two further matchpoints. The upper 16 bits are a value to
	  match, the lower 16 bits a counter. The counter is incremented when
	  specified matchpoints are triggered (see Debug Mode register
	  1). When the count reaches the match value, the corresponding
	  matchpoint is triggered.
	</para>

	<caution>
	  <para>
	    There is potential ambiguity in that counters are incremented in
	    response to matchpoints and also generate their own
	    matchpoints. It is not good practice to set a counter to increment
	    on its own matchpoint!
	  </para>
	</caution>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Mode registers</emphasis>. There are two Debug Mode
	  registers to control the behavior of the the debug unit
	  (&spr;&nbsp;0x3010&ndash;0x3011, <literal>DMR1</literal> and
	  <literal>DMR2</literal>). <literal>DMR1</literal> provides a pair of
	  bits for each of the 10 matchpoints (8 associated with &dvr;/&dcr;
	  pairs, 2 associated with counters). These specify whether the
	  watchpoint is triggered by the associated matchpoint, by the
	  matchpoint AND-ed with the previous watchpoint or by the matchpoint
	  OR-ed with the previous watchpoint. By building chains of
	  watchpoints, complex logical tests of hardware behavior can be built
	  up.
	</para>

	<para>
	  Two further bits in <literal>DMR1</literal> enable single step
	  behavior (a trap exception occurs on completion of each instruction)
	  and branch step behavior (a trap exception occurs on completion of
	  each branch instruction).
	</para>

	<para>
	  <literal>DMR2</literal> contains an enable bit for each counter, 10
	  bits indicating which watchpoints are assigned to which counter and 10
	  bits indicating which watchpoints generate a trap exception. It also
	  contains 10 bits of output, indicating which watchpoints have
	  generated a trap exception.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Stop and Reason registers</emphasis>. In normal
	  operation, all OpenRISC 1000 exceptions are handled through the
	  exception vectors at locations 0x100 through 0xf00. The Debug Stop
	  register (&spr;&nbsp;0x3014, <literal>DSR</literal>) is used to
	  assign particular exceptions instead to the &jtag; interface. These
	  exceptions stall the processor, allowing the machine state to be
	  analyzed through the &jtag; interface. Typically a debugger will
	  enable this for trap exceptions used for breakpointing.
	</para>

	<para>
	  Where an exception has been diverted to the development interface,
	  the Debug Reason register (&spr;&nbsp;0x3021,
	  <literal>DRR</literal>) indicates which exception caused the
	  diversion. Note that although single stepping and branch stepping
	  cause a trap, if they are assigned to the &jtag; interface, they
	  <emphasis>do not</emphasis> set the <literal>TE</literal> bit in the
	  <literal>DRR</literal>. This allows an external debugger to
	  distinguish between breakpoint traps and single/branch step traps.
	</para>
      </listitem>
    </itemizedlist>

    <sect1>
      <title>
	&jtag; Interface
      </title>

      <para>
	The OpenRISC 1000 provides a &jtag; interface, which can be used for
	external control and debug of the processor. It provides a number of
	scan chains, of which the most important for debugging are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    RISC_DEBUG (scan chain 1), providing read/write access to the
	    &spr;s.
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    REGISTER (scan chain 4), providing read/write access to the
	    &jtag; control registers, allowing control of hardware trace and
	    stalling, unstalling and reset of the processor.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    WISHBONE (scan chain 5), providing read/write access to main
	    memory.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	Since the General Purpose Registers (&gpr;s) are mapped to one of the
	&spr; groups, this mechanism also allows &gpr;s to be read and
	written.
      </para>

      <sect2>
	<title>
	  The OpenRISC 1000 Remote &jtag; Protocol
	</title>

	<para>
	  To facilitate remote debugging by &gdb;, the OpenRISC defines a
	  software protocol describing &jtag; accesses, suitable for conveying
	  over a TCP/IP via a socket interface.
	</para>

	<note>
	  <para>
	    This protocol pre-dates the &gdb; Remote Serial Protocol (&rsp;). At
	    some future date the OpenRISC 1000 Remote &jtag; Protocol will be
	    replaced by the &rsp;.
	  </para>
	</note>

	<para>
	  The OpenRISC 1000 Remote &jtag; Protocol is a simple message
	  send/acknowledge protocol. The &jtag; request is packaged as a 32 bit
	  command, 32-bit length and series of 32-bit data words. The &jtag;
	  response is packaged as a 32-bit status and optionally a number of
	  32-bit data words. The commands available are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <constant>OR1K_JTAG_COMMAND_READ</constant> (1). Read a single
	      &jtag; register. A 32-bit address is provided in the request. The
	      response includes 64-bits of read data.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <constant>OR1K_JTAG_COMMAND_WRITE</constant> (2). Write a single
	      &jtag; register. A 32-bit address is provided in the 
	      request and 64-bit data to be written.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <constant>OR1K_JTAG_COMMAND_READ_BLOCK</constant> (3). Read
	      multiple 32-bit &jtag; registers. A 32-bit address of the first
	      register and number of registers to be read is provided in the
	      request. The response includes the number of registers read and
	      32-bits of data for each one read.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <constant>OR1K_JTAG_COMMAND_WRITE_BLOCK</constant> (4). Write
	      multiple 32-bit &jtag; registers. A 32-bit address of the first
	      register and number of registers to be written is provided in the
	      request followed by 32-bits of data to be written for each
	      register.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <constant>OR1K_JTAG_COMMAND_CHAIN</constant> (5). Select the scan
	      chain. A 32-bit scan chain number is provided in the request.
	    </para>
	  </listitem>
	</itemizedlist>

	<note>
	  <para>
	    There is apparently a contradiction in this protocol. Provision is
	    made for individual registers to be read/written as 64 bits,
	    whereas block read/writes (provided for communication efficiency)
	    are only 32-bits.
	  </para>
	</note>

	<para>
	  <xref linkend="fig_remote_jtag_protocol" />
	  shows the structures of all five requests and their corresponding
	  (successful) responses. Note that if a request fails, the response
	  will only contain the status word.
      </para>

      <figure id="fig_remote_jtag_protocol">
	<title>
	  The OpenRISC 1000 Remote &jtag; Protocol data structures
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The client side of this protocol (issuing the requests) is implemented
	by the &gdb; port for OpenRISC 1000.
      </para>

      <para>
	Server side applications may implement this protocol to drive either
	physical hardware (via its &jtag; port) or simulations, which include
	the &jtag; functionality. Examples of the former include &usb; &jtag;
	connectors. An example of the latter is the OpenRISC 1000
	Architectural Simulator, Or1ksim (see <xref linkend="sec_or1ksim" />.
      </para>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_abi">
      <title>
	Application Binary Interface (&abi;)
      </title>

      <para>
	The &abi; for the OpenRISC 1000 is described in Chapter 16 of the
	Architecture Manual (<xref linkend="ref_or1k" />). However the actual
	&gcc; compiler implementation differs very slightly from the documented
	&abi;. Since precise understanding of the &abi; is critical to &gdb;,
	those differences are documented here.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Register Usage: R12 is used as another callee-saved register. It
	    is never used to return the upper 32 bits of a 64-bit result on a
	    32-bit architecture. All values greater than 32-bits are returned
	    by a pointer.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Although the specification requires stack frames to be
	    <emphasis>double</emphasis> word aligned, the &gcc; implementation
	    implements <emphasis>single</emphasis> word alignment.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Integral values more than 32 bits (64 bits on 64-bit
	    architectures), structures and unions are returned as pointers to
	    the location of the result. That location is provided the
	    <emphasis>calling</emphasis> function, which passes it as a first
	    argument in &gpr; 3. In other words, where a function returns a
	    result of this type, the first true argument to the function will
	    appear in R4 (or R5/R6 if it is a 64-bit argument on a 32-bit
	    architecture).
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="sec_or1ksim">
      <title>
	Or1ksim: the OpenRISC 1000 Architectural Simulator
      </title>

      <para>
	Or1ksim is an instruction set simulator (&iss;) for the OpenRISC 1000
	architecture. At present only the 32-bit architecture is modeled. In
	addition to modeling the core processor, Or1ksim can model a number of
	peripherals, to provide the functionality of a complete System-on-Chip
	(&soc;).
      </para>

      <para>
	Or1ksim models the OpenRISC 1000 &jtag; interface and implements the
	OpenRISC 1000 Remote &jtag; protocol server side. It was used as the
	testbed for the port of &gdb;
      </para>

      <note>
	<para>
	  Porting &gdb; uncovered a number of bugs in &or1ksim;. The
	  implementation is now quite old, and predates the current OpenRISC
	  1000 specification. A patch (available from <ulink
	  url="http://www.embecosm.com/download.html" /> is available to fix
	  these bugs.
	</para>
      </note>

    </sect1>

  </chapter>

  <chapter id="chap_gdb_internals">
    <title>
      Overview of &gdb; Internals
    </title>

    <para>
      There are three major areas to &gdb;:
    </para>

    <orderedlist>
      <listitem>
	<para>
	  The user interface. How &gdb; communicates with the user
	</para>
      </listitem>

      <listitem>
	<para>
	  The <emphasis>symbol side</emphasis>. The analysis of object files,
	  and the mapping of the information contained to the corresponding
	  source files.
	</para>
      </listitem>

      <listitem>
	<para>
	  the <emphasis>target side</emphasis>. Executing programs and
	  analyzing their data.
	</para>
      </listitem>
    </orderedlist>

    <para>
      &gdb; has a very simple view of a processor. It has a block of memory
      and a block of registers. Executing code contains its state in the
      registers and in memory, statically allocated, dynamically allocated
      from the heap or in stack frames. &gdb; maps that information to the
      source level program being debugged.
    </para>

    <para>
      Porting a new architecture to &gdb; means providing a way to read
      executable files, a description of the &abi; a description of the
      physical architecture and operations to access the target being
      debugged.
    </para>

    <para>
      Arguably the most common use of &gdb; is to debug the architecture on
      which it is actually running. This is <emphasis>native</emphasis>
      debugging where the architecture of the host and target are the same.
    </para>

    <para>
      For the OpenRISC 1000 we will normally expect to run &gdb; on a host
      separate to the target (typically a workstation) connecting to the
      OpenRISC 1000 target via &jtag;, possibly using the OpenRISC 1000 Remote
      &jtag; Protocol.
    </para>

    <sect1>
      <title>
	Main Functional Areas
      </title>

      <sect2>
	<title>
	  Binary File Description (&bfd;)
	</title>

	<para>
	  &bfd; is a package which allows applications to use the same routines
	  to operate on object files whatever the object file format. A new
	  object file format can be supported simply by creating a new &bfd;
	  back end and adding it to the library.
	</para>

	<para>
	  &bfd; back ends already exist suitable for use with 32-bit OpenRISC
	  1000 images in <acronym>ELF</acronym> or <acronym>COFF</acronym>
	  format as used with either the &rtems; or Linux operating systems.
	</para>

      </sect2>

      <sect2 id="sec_arch_description">
	<title>
	  Architecture Description
	</title>

	<para>
	  Any architecture to be debugged by &gdb; is described in a
	  &gdbarch;. When an object file is to be debugged, &gdb; will select
	  the correct &gdbarch; using information about the object file
	  captured in its &bfd;.
	</para>

	<para>
	  The data in &gdbarch; facilitates both the <emphasis>symbol
	  side</emphasis> processing in (for which it also uses the
	  &bfd; information) and the <emphasis>target side</emphasis>
	  processing (in combination with the frame and target operation
	  information).
	</para>

	<para>
	  &gdbarch; is a mixture of data values (number of bytes in a word for
	  example) and functions to perform standard operations (e.g. to print
	  the registers). The major functional groups are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Details of the hardware architecture. For example the endianism
	      and the number of bits in an address and in a word. Much of this
	      data is captured in the &bfd;, to which there is a reference in
	      the &gdbarch;. There is also a structure to capture additional
	      target specific data, beyond that which is found in the &bfd;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Details of how all the standard high level scalar data
	      structures are represented (<type>char</type>,
	      <type>int</type>, <type>double</type> etc).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access and display registers. &gdb; includes the
	      concept of "pseudo-registers", those registers which do not
	      physically exist, but which have a meaning within the
	      architecture. For example in the OpenRISC 1000, floating point
	      registers are actually the same as the General Purpose
	      Registers. However a set of floating point pseudo-registers
	      could be defined, to allow the &gpr;s to be displayed in floating
	      point format.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access information on stack frames. This includes
	      setting up "dummy" frames to allow &gdb; to evaluate functions
	      (for example using the <command>call</command> command). One key
	      function is to skip the prologue of a compiled function in the
	      target&mdash;the initial code in a function which sets up the
	      stack frame before the main code executes.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  An architecture will need to specify most of the contents of
	  &gdbarch;, for which a set of functions (all starting
	  <literal>set_gdbarch_</literal>) are provided. Defaults are provided
	  for all entries, and in a small number of cases these will be
	  suitable.
	</para>

	<para>
	  The &gdbarch; is note quite sufficient to describe how to analyze an
	  executing program (the <emphasis>target side</emphasis>
	  functionality). In addition a set of functions are required which
	  understand stack frames for the target architecture, allowing &gdb; to
	  <emphasis>unwind</emphasis> them to discover the data for functions
	  which called the one currently executing.
	</para>

      </sect2>

      <sect2>
	<title>
	  Target Operations
	</title>

	<para>
	  A set of operations is required to access a program using the target
	  architecture described by &gdbarch; in order to implement the
	  <emphasis>target side</emphasis> functionality. For any given
	  architecture there may be multiple ways of connecting to the target,
	  specified using the &gdb; <command>target</command> command. For
	  example with the OpenRISC 1000 architecture, the connection may be
	  directly to a &jtag; interface connected through the host computer's
	  parallel port, or through a the OpenRISC 1000 Remote &jtag; protocol
	  over TCP/IP.
	</para>

	<para>
	  These target operations are described in a &target_ops;. As with
	  &gdbarch; this comprises a mixture of data and functions to be
	  called. The major functional groups are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Functions to establish and close down a connection to the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access registers and memory on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to insert and remote breakpoints and watchpoints on
	      the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to start and stop programs running on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A set of data describing the features of the target, and hence
	      what operations can be applied. For example when examining a
	      core dump, the data can be inspected, but the program cannot be
	      executed.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  As with &gdbarch;, defaults are provided for the &target_ops;
	  values. In many cases these are sufficient, so need not be
	  provided.
	</para>

      </sect2>

    </sect1>

    <sect1 id="sec_data_structures">
      <title>
	Key Data Structures
      </title>

      <para>
	A new architecture for &gdb; is created by defining a global function
	<literal>_initialize_</literal><emphasis>architecture</emphasis><literal>_tdep</literal>. In
	the case of the OpenRISC 1000, this function is called
	<function>_initialize_or1k_tdep</function> and is found in the file
	<filename>or1k-tdep.c</filename>.
      </para>

      <para>
	The source file(s) with the definition of the
	<literal>_initialize_</literal> function are specified in the
	&gdb; <filename>configure.tgt</filename> file, which includes a large
	case statement pattern matching against the
	<option>--target</option> option of the <command>configure</command>
	command.
      </para>

      <para>
	The new &gdbarch; is created within the
	<function>_initialize_</function> function by calling
	<function>gdbarch_register</function>:
      </para>

      <programlisting>void gdbarch_register (enum bfd_architecture    architecture,
                       gdbarch_init_ftype      *init_func,
                       gdbarch_dump_tdep_ftype *tdep_dump_func);</programlisting>

      <para>
	The <varname>architecture</varname> enumeration will identify the
	unique &bfd; for this architecture (see <xref linkend="sec_bfd"
	/>). The <function>init_func</function> is called to create and return
	the new &gdbarch; (see <xref linkend="sec_gdbarch" />). The
	<function>tdep_dump_func</function> is a function which will dump the
	target specific details associated with this architecture (also
	described in <xref linkend="sec_gdbarch" />).
      </para>

      <sect2 id="sec_bfd">
	<title>
	  Binary File Descriptor
	</title>

	<para>
	  The &bfd; library back end creates a number of data structures
	  describing the data held in a particular type of object
	  file. Ultimately a unique enumerated constant (of type
	  <type>enum&nbsp;bfd_architecture</type>) is defined for each
	  individual architecture. This constant is then used to access the
	  various data structures associated with the &bfd; of the particular
	  architecture.
	</para>
	<para>
	  In the case of the OpenRISC 1000, 32-bit implementation (which may
	  be a <acronym>COFF</acronym> or <acronym>ELF</acronym> binary), the
	  enumerated constant is <constant>bfd_arch_or32</constant>.
	</para>

      </sect2>

      <sect2 id="sec_gdbarch">
	<title>
	  &gdb; Architecture Specification
	</title>

	<para>
	  The call to <function>gdbarch_register</function> (see <xref
	  linkend="sec_data_structures" />) specifies a function which will
	  define a &gdbarch; for a particular &bfd; architecture.
	</para>

	<programlisting>struct gdbarch  gdbarch_init_func (struct gdbarch_info  info,
                                   struct gdbarch_list *arches);</programlisting>
	<para>
	  In the case of the OpenRISC 1000 architecture, the initialization
	  function is <function>or1k_gdbarch_init</function>.
	</para>

	<tip>
	  <para>
	    By convention all target specific functions and global variables
	    in &gdb; begin with a string unique to that architecture. This
	    helps to avoid namespace pollution when using C. Thus all the MIPS
	    specific functions begin <literal>mips_</literal>, the ARM specific
	    functions begin <literal>arm_</literal> etc.
	  </para>

	  <para>
	    For the OpenRISC 1000 all target specific functions and global
	    variables begin with <literal>or1k_</literal>.
	  </para>
	</tip>

	<para>
	  The first argument to the architecture initialization function is a
	  &gdbarch_info; containing all the known information about this
	  architecture (deduced from the &bfd; enumeration provided to
	  <function>gdbarch_register</function>). The second argument is a list
	  of the currently defined architectures within &gdb;.
	</para>

	<para>
	  The &gdbarch_info; has the following components:
	</para>

	<programlisting>struct gdbarch_info
{
  const struct bfd_arch_info *bfd_arch_info;
  int                         byte_order;
  bfd                        *abfd;
  struct gdbarch_tdep_info   *tdep_info;
  enum gdb_osabi              osabi;
  const struct target_desc   *target_desc;
};</programlisting>

	<para>
	  <varname>bfd_arch_info</varname> holds the key details about the
	  architecture. <varname>byte_order</varname> is an enumeration
	  indicating the endianism. <varname>abfd</varname> is a pointer to
	  the full &bfd;, <varname>tdep_info</varname> is additional target
	  specific information, <varname>gdb_osabi</varname> is an enumeration
	  identifying which (if any) of a number of operating specific &abi;s
	  are used by this architecture and <varname>target_desc</varname> is
	  a set of name-value pairs with information about register usage in
	  this target.
	</para>

	<para>
	  When the &gdbarch; initialization function is called, not all the
	  fields are provided&mdash;only those which can be deduced from the
	  &bfd;. The &gdbarch_info; is used as a look-up key with the list of
	  existing architectures (the second argument to the initialization
	  function) to see if a suitable architecture already exists. The
	  <varname>tdep_info</varname> <varname>osabi</varname> and
	  <varname>target_desc</varname> fields may be added before this
	  lookup to refine the search.
	</para>

	<para>
	  The lookup is done using
	  <function>gdbarch_lookup_by_arches</function>. It is passed the list
	  of existing architectures and the &gdbarch_info; (possibly updated)
	  and returns the first matching architecture it finds, or
	  &null; if none are found. If an architecture is found, the
	  initialization function can finish, returning the found architecture
	  as result.
	</para>

	<para>
	  If no architecture is found, then a new architecture is created, by
	  calling <function>gdbarch_alloc</function> using the supplied
	  &gdbarch_info; and and any additional target specific information in
	  a &gdbarch_tdep;.
	</para>

	<programlisting>struct gdbarch *gdbarch_alloc (const struct gdbarch_info *info,
                               struct gdbarch_tdep       *tdep);</programlisting>

	<para>
	  &gdbarch_tdep; is not part of standard &gdb;&mdash;it is up to the
	  user to define this struct if it is needed. If there is no
	  additional target specific information, it can be set to NULL.
	</para>

	<para>
	  The newly created &gdbarch; must then be populated. Although there
	  are default values, in most cases they are not what is required. For
	  each element, <emphasis>X</emphasis>, there is a corresponding
	  accessor function to set the value of that element,
	  <function>set_gdbarch_</function><emphasis>X</emphasis>. The most
	  important elements that can/should be set in this way are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>bits_big_endian</varname>. 1 (true) if the bits within
	      a byte are big-endian.
	    </para>

	    <note>
	      <para>
		This not the same as the endianism of the target (the order of
		bytes within a word). This element is about the ordering of
		bits within bytes.
	      </para>
	    </note>

	    <para>
	      The default value is 1 (true) if the target endianism (the order
	      of bytes within a word) is big-endian. That information is
	      specified in the &bfd;. In general the default value is what is
	      wanted.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>short_bit</varname>. Number of bits in a C/C++
	      <type>short</type> variable. Default is
	      <literal>2*TARGET_CHAR_BIT</literal>.
	      <constant>TARGET_CHAR_BIT</constant> is a defined constant, which
	      if not set explicitly defaults to 8.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>int_bit</varname>, <varname>long_bit</varname>,
	      <varname>long_long_bit</varname>, <varname>float_bit</varname>,
	      <varname>double_bit</varname>,
	      <varname>long_double_bit</varname>. These are analogous to
	      <varname>short</varname> and are the number of bits in a C/C++
	      variable of the corresponding time. Defaults are
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>int</type>,
	      <type>long</type> and <type>float</type> and
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>long long</type>,
	      <type>double</type> and <type>long double</type>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>ptr_bit</varname>. Number of bits in a C/C++
	      pointer. Default is <literal>4*TARGET_CHAR_BIT</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>float_format</varname>,
	      <varname>double_format</varname> and
	      <varname>long_double_format</varname>. These point to an array
	      of structs (one for each endianism), defining the format for
	      each of the floating point types. A number of these arrays are
	      predefined. They in turn are built on top of a set of standard
	      types defined by the library <literal>libiberty</literal>.
	    </para>
	  </listitem>
	    
	  <listitem>
	    <para>
	      <varname>char_signed</varname>. 1 if <type>char</type> to be
	      treated as signed, 0 if <type>char</type> is to be treated as
	      unsigned. The default is -1 (undefined), so this should always
	      be set.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>read_pc</function>. A function to read the program
	      counter. The default value is &null; (no function
	      available). However, if the program counter is just an ordinary
	      register, it can be specified in &gdbarch; instead (see
	      <varname>pc_regnum</varname> below) and it will be read using
	      the standard routines to read registers. Thus this function need
	      only be specified <emphasis>if</emphasis> the program counter is
	      not an ordinary register. See <xref linkend="sec_regcache" />
	      for more discussion of how registers are handled in &gdb;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>write_pc</function>. A function to write the program
	      counter. The default value is &null; (no function available). As
	      with <function>read_pc</function>, this function need only be
	      specified <emphasis>if</emphasis> the program counter is not an
	      ordinary register.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>virtual_frame_pointer</function>. A function to return
	      the "virtual" frame pointer. This is a register and offset which
	      together define the location of the start of the frame. The
	      default is the function
	      <function>legacy_virtual_frame_pointer</function> which returns
	      either the value <function>from deprecated_fp_regnum</function>
	      (which hopefully has <emphasis>not</emphasis> been used) or the
	      stack pointer. The role of this function is far from
	      clear&mdash;it is used in some code to evaluate agent
	      expressions and in some code to handle tracepoints in DWARF2. As
	      a precaution, if the frame pointer is not the same as the stack
	      pointer, this function should be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>pseudo_register_read</function> and
	      <function>pseudo_register_write</function>. These functions
	      should be defined if there are any pseudo-registers (see <xref
	      linkend="sec_arch_description" /> and <xref
	      linkend="sec_regcache" /> for more information on
	      pseudo-registers). The default value is &null;.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>num_regs</varname> and
	      <varname>num_pseudo_regs</varname>. These define the number of
	      real and pseudo-registers. They default to -1 (undefined) and
	      should always be explicitly defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>sp_regnum</varname>, <varname>pc_regnum</varname>,
	      <varname>ps_regnum</varname> and
	      <varname>fp0_regnum</varname>. These specify the register
	      holding the stack pointer, program counter, processor status and
	      first floating point register. All except the first
	      floating-point register (which defaults to 0) default to -1 (not
	      defined). They may be real or
	      pseudo-registers. <varname>sp_regnum</varname> must always be
	      defined. If <varname>pc_regnum</varname> is not defined, then
	      the functions <function>read_pc</function> and
	      <function>write_pc</function> (see above) must be defined. If
	      <varname>ps_regnum</varname> is not defined, then the
	      <varname>$ps</varname> variable will not be available to the &gdb;
	      user. <varname>fp0_regnum</varname> is not needed unless the
	      target offers support for floating point.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>register_name</function>. This function should convert
	      a register number to a register name (as a char *). This is used
	      both to determine the name of a register for output and to work
	      out what the meaning of any register names used as input. For
	      example with the OpenRISC 1000, &gdb; registers 0-31 are the
	      &gpr;s, register 32 is the program counter and register 33 is
	      the supervision register, which map to the strings
	      <literal>"gpr00"</literal> through <literal>"gpr31"</literal>,
	      <literal>"pc"</literal> and <literal>"sr"</literal>
	      respectively. This means that the &gdb; command <command>print
	      $gpr5</command> should print the value of the OR1K general
	      purpose register 5. The default value for this function is
	      &null;. It should always be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>register_type</function>. Given a register number,
	      this function identifies the type of data it may be holding,
	      specified as a <structname>struct&nbsp;type</structname>. &gdb;
	      allows creation of arbitrary types, but a number of built in
	      types are provided (<varname>builtin_type_void</varname>,
	      <varname>builtin_type_int32</varname> etc), together with
	      functions to derive types from these. Typically the program
	      counter will have a type of "pointer to function" (it points to
	      code), the frame pointer and stack pointer will have types of
	      "pointer to void" (they point to data on the stack) and all
	      other integer registers will have a type of 32-bit integer or
	      64-bit integer. This information is used to help when displaying
	      out register information. The default value is &null; meaning no
	      information is available to help when displaying registers.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>push_dummy_call</function>. &gdb; allows you to
	      execute parts of the program being debugger, either directly via
	      the <command>call</command> command or indirectly when function
	      calls form arguments to commands such as
	      <command>print</command>. &gdb; needs to make it look as though
	      these functions have been called from the existing point in the
	      code, with their own stack frame. This means if the function
	      hits a breakpoint, a stack backtrace will work correctly.
	    </para>

	    <para>
	      To make this work, &gdb; needs to set up a "dummy" stack frame
	      for the function about to be
	      called. <function>push_dummy_call</function> is given the
	      arguments to be passed and must copy them into registers or push
	      them on to the stack as appropriate for the &abi;. &gdb; will
	      then pass control to the target at the address of the function,
	      and it will find the stack and registers set up just as
	      expected.
	    </para>

	    <para>
	      The default value of this function is &null; (undefined). If the
	      function is not defined, then &gdb; will not allow the user to
	      call functions within the target being debugged.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>unwind_dummy_id</function>. This is the inverse of
	      <function>push_dummy_call</function> which restores the stack
	      and frame pointers after a call to evaluate a function using a
	      dummy stack frame. The default value is &null; (undefined). If
	      <function>push_dummy_call</function> is defined, then this
	      function should also be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>push_dummy_code</function>. If this function is not
	      defined (its default value is &null;), a dummy call will use the
	      entry point of the target as its return address. A temporary
	      breakpoint will be set there, so the location must be writable
	      and have room for a breakpoint.
	    </para>

	    <para>
	      It is possible that this default is not suitable. It might be
	      inheritable (in ROM possibly), or the &abi; might require
	      code to be executed on return from a call to unwind the stack
	      before the breakpoint is encountered.
	    </para>

	    <para>
	      If either of these is the case, then
	      <function>push_dummy_code</function> should be defined to push
	      an instruction sequence onto the end of the stack to which the
	      dummy call should return.
	    </para>

	    <note>
	      <para>
		This does require that code in the stack can be executed. Some
		Harvard architectures may not allow this.
	      </para>
	    </note>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_registers_info</function>. Define this function
	      to print out one or all of the registers for the &gdb;
	      <command>info&nbsp;registers</command> command. The default
	      value is the function
	      <function>default_print_registers_info</function> which uses the
	      type information (see <function>register_type</function> above)
	      to determine how each register should be printed. Define this
	      function for fuller controller over how the registers are
	      displayed.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_float_info</function> and
	      <function>print_vector_info</function>. Define this function to
	      provide output for the &gdb; <command>info&nbsp;float</command>
	      and <command>info&nbsp;vector</command> commands
	      respectively. The default value is &null; (not defined), meaning
	      no information will be provided. Define each function if the
	      target supports floating point or vector operations
	      respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>return_value</function>. Determines the return
	      convention for a particular type. For example on the OpenRISC
	      1000, structs/unions and large (>32 bit) scalars are returned as
	      references, while small scalars are returned in GPR&nbsp;11.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>skip_prologue</function>. The prologue of a function is
	      the code at the beginning of the function which sets up the
	      stack frame, saves the return address etc. The code representing
	      the behavior of the function starts after the prologue.
	    </para>

	    <para>
	      This function skips past the prologue of a function if the program
	      counter is within the prologue of a function. With modern
	      optimizing compilers, this may be a far from trivial
	      exercise. However the required information may be within the
	      binary as DWARF2 debugging information, making the job much
	      easier.
	    </para>

	    <para>
	      The default value is &null; (not defined). This function should
	      always may be provided, but can take advantage of DWARF2
	      debugging information if that is available.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>inner_than</function>. Given two frame or stack
	      pointers, return 1 (true) if the first represents the "inner"
	      stack frame and 0 (false) otherwise. This is used to determine
	      whether the target has a rising or a falling stack frame. See
	      <xref linkend="sec_frames" /> for an explanation of "inner"
	      frames.
	    </para>

	    <para>
	      The default value of this function is &null; and it should
	      always be defined. However for almost all architectures one of
	      the built-in functions <function>core_addr_lessthan</function>
	      (for falling stacks) or
	      <function>core_addr_greaterthan</function> (for rising stacks)
	      can be used.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>breakpoint_from_pc</function>. Returns the breakpoint
	      instruction to be used when the &pc; is at a particular location
	      in memory. For architectures with variable length instructions,
	      the choice of breakpoint instruction may depend on the length of
	      the instruction at the program counter. Returns the instruction
	      sequence and its length.
	    </para>

	    <para>
	      The default value is &null; (undefined). This function should
	      always be defined if &gdb; is to support breakpointing for this
	      architecture.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>adjust_breakpoint_address</function>. Some
	      architectures do not allow breakpoints to be placed at all
	      points. Given a program counter, this function returns an
	      address where a breakpoint <emphasis>can</emphasis> be
	      placed. Default value is &null; (undefined). The function need
	      only be defined for architectures which cannot accept a
	      breakpoint at all program counter locations.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>memory_insert_breakpoint</function> and
	      <function>memory_remove_breakpoint</function>. Insert or remove
	      memory based (a.k.a. soft) breakpoints. The default values
	      <function>default_memory_insert_breakpoint</function> and
	      <function>default_memory_remove_breakpoint</function> are
	      suitable for most architectures, so in most cases these
	      functions need note be defined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>decr_pc_after_break</function>. Some architectures
	      require the program counter to be decremented after a break, to
	      allow the broken instruction to be executed on resumption. This
	      function returns the number of bytes by which to decrement the
	      address. The default value is &null; (undefined) which means the
	      program counter is left unchanged. This function need only be
	      defined if the functionality is required.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>unwind_pc</function> and
	      <function>unwind_sp</function>. These functions are given a
	      stack frame (see <xref linkend="sec_frames" /> for how frames
	      are represented) and return the value of the program counter and
	      stack pointer respectively in the previous frame (i.e. the frame
	      of the function that called this one).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>frame_num_args</function>. Given a stack frame (see
	      <xref linkend="sec_frames" /> for how frames are represented),
	      return the number of arguments that are being passed, or -1 if
	      not known. The default value is -1 (undefined), in which case
	      the number of arguments passed on any stack frame is always
	      unknown. For many architectures this will be a suitable default.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>frame_align</function>. The architecture may have
	      constraints on how its frames are aligned. Given a proposed
	      address for the stack pointer, 
	      this function returns a suitably aligned address (by expanding
	      the stack frame). The default value is &null; (undefined). This
	      function should be defined for any architecture where it is
	      possible the stack could become misaligned. The utility functions
	      <function>align_down</function> (for falling stacks) and
	      <function>align_up</function> (for rising stacks) will
	      facilitate the implementation of this function.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>frame_red_zone_size</varname>. Some &abi;s reserve
	      space beyond the end of the stack for use by leaf functions
	      without prologue or epilogue or by exception handlers (OpenRISC
	      1000 is in this category). This is known as a <emphasis>red
	      zone</emphasis> (<acronym>AMD</acronym> terminology). Default
	      value is 0. Set this field if the architecture has such a red
	      zone.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>single_step_through_delay</function>. Returns 1 if the
	      target is executing a delay slot and a further single step is
	      needed before the instruction finishes. The default value is
	      &null; (not defined). This function should be implemented if the
	      target has delay slots.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>construct_inferior_arguments</function>. Used to
	      construct the argument string to be passed to the target when
	      execution is started. Should call <function>error</function> if
	      arguments are not permitted. The default value is the function
	      <function>construct_inferior_arguments</function> which provides
	      an argument string suitable for a Unix shell. This function need
	      only be implemented if the target requires a non-Unix style
	      argument string, or does not support command line arguments at
	      all.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_insn</function>. Disassemble an instruction and
	      print it. Default value is &null; (undefined). This function
	      should be defined if disassembly of code is to be supported.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>name_of_malloc</varname>. A string representing the
	      name of the <function>malloc</function> function on the
	      target. This may be needed if a function is evaluated with
	      constructed data on the target. For example using the &gdb;
	      <command>call</command> command on a function with a string
	      argument, viz <command>call printf( "Hello World!\n"
	      )</command>. The default value is <literal>"malloc"</literal>
	      and need only be changed if the target does not support
	      <function>malloc</function> (when it should be set to "").
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>register_reggroup</function>. &gdb; groups registers
	      into different categories (general, vector, floating point
	      etc). This function given a register and group returns 1 (true)
	      if the register is in the group and 0 otherwise. The default
	      value is the function
	      <function>default_register_reggroup_p</function> which will do a
	      reasonable job based on the type of the register (see the
	      function <function>register_type</function> above) and groups
	      for general purpose registers, floating point registers, vector
	      registers and real (i.e not pseudo) registers.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  This is not the complete list, but represents the functions and
	  elements that must commonly be specified for a new
	  architecture. Many of the functions are described in the header
	  file, <filename>gdbarch.h</filename> and many may be found in the
	  &gdb; internals manual <xref linkend="ref_gdb_int" />.
	</para>

      </sect2>

      <sect2 id="sec_frames">
	<title>
	  Frames and Prologue Caches
	</title>

	<para>
	  &gdb; needs to understand the stack on which local (automatic)
	  variables are stored. The area of the stack containing all the local
	  variables for a function invocation is known as the <emphasis>stack
	  frame</emphasis> for that function. In turn the function that called
	  the function will have its stack frame, and so on back through the
	  chain of functions that have been called.
	</para>

	<para>
	  Almost all architectures have one register dedicated to point to the
	  end of the stack (the <emphasis>stack pointer</emphasis>). Many have
	  a second register which points to the start of the currently active
	  stack frame (the <emphasis>frame pointer</emphasis>). The specific
	  arrangements for an architecture are a key part of the &abi;.
	</para>

	<para>
	  A diagram helps to explain this. Here is a simple program to compute
	  factorials:
	</para>

	<programlisting> 1:   #include &lt;stdio.h&gt;
 2:   
 3:   int fact( int  n )
 4:   {
 5:     if( 0 == n ) {
 6:       return 1;
 7:     }
 8:     else {
 9:       return n * fact( n - 1 );
10:     }
11:   }
12:   
13:   main()
14:   {
15:     int  i;
16:   
17:     for( i = 0 ; i &lt; 10 ; i++ ) {
18:       int   f = fact( i );
19:       printf( "%d! = %d\n", i, f );
20:     }
21:   }</programlisting>

        <para>
	  Consider the state of the stack when the code reaches line 6 after
	  the main program has called <function>fact&nbsp;(3)</function>. The
	  chain of function calls will be <function>main</function>,
	  <function>fact&nbsp;(3)</function>,
	  <function>fact&nbsp;(2)</function>,
	  <function>fact&nbsp;(1)</function> and
	  <function>fact&nbsp;(0)</function>. In this example the stack is
	  falling (as used by the OpenRISC 1000 &abi;). The stack pointer
	  (&sp;) is at the end of the stack (lowest address) and the frame
	  pointer (&fp;) is at the highest address in the current stack
	  frame. <xref linkend="fig_stack_frame" /> shows how the stack looks.
	</para>

	<figure id="fig_stack_frame">
	  <title>
	    An example stack frame
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  In each stack frame offset 0 from the stack pointer is the frame
	  pointer of the <emphasis>previous frame</emphasis> and offset 4
	  (this is illustrating a 32-bit architecture) from the stack pointer
	  is the return address. Local variables are indexed from the frame
	  pointer, with negative indexes. In the function
	  <function>fact</function>, offset -4 from the frame pointer is the
	  argument <varname>n</varname>. In the <function>main</function>
	  function, offset -4 from the frame pointer is the local variable
	  <varname>i</varname> and offset -8 from the frame pointer is the
	  local variable <varname>f</varname>.
	</para>

	<note>
	  <para>
	    This is a simplified example for illustrative purposes only. Good
	    optimizing compilers would not put anything on the stack for such
	    simple functions. Indeed they might eliminate the recursion and
	    use of the stack entirely!
	  </para>
	</note>

	<para>
	  It is very easy to get confused when examining stacks. &gdb; has
	  terminology it uses rigorously throughout. The stack frame of the
	  function currently executing, or where execution stopped is numbered
	  zero. In this example frame #0 is the stack frame of the call to
	  <function>fact&nbsp;(0)</function>. The stack frame of its calling
	  function (<function>fact(1)</function> in this case) is numbered #1 and
	  so on back through the chain of calls.
	</para>

	<para>
	  The main &gdb; data structure describing frames is &frame_info;. It
	  is not used directly, but only via its accessor
	  functions. &frame_info; includes information about the registers in
	  the frame and a pointer to the code of the function with which the
	  frame is associated. The entire stack is represented as a linked
	  list of &frame_info;.
	</para>

	<para>
	  It is easy to get confused when referencing stack frames. &gdb; uses
	  some precise terminology.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      &this; frame is the frame currently under consideration.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The &next; frame, also sometimes called the
	      <emphasis>inner</emphasis> or <emphasis>newer</emphasis> frame
	      is the frame of the function called by the function of &this;
	      frame.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The &prev; frame, also sometimes called the
	      <emphasis>outer</emphasis> or <emphasis>older</emphasis> frame
	      is the frame of the function which called the function of &this;
	      frame.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  So in the example of <xref linkend="fig_stack_frame" />, if
	  &this;frame is frame #3 (the call to
	  <function>fact&nbsp;(3)</function>), the &next; frame is frame #2 (the
	  call to <function>fact&nbsp;(2)</function>) and the &prev; frame is
	  frame #4 (the call to <function>main&nbsp;()</function>).
	</para>

	<para>
	  The <emphasis>innermost</emphasis> frame is the frame of the current
	  executing function, or where the program stopped, in this example,
	  in the middle of the call to <function>fact&nbsp;(0)</function>). It
	  is always numbered frame #0.
	</para>

	<para>
	  The <emphasis>base</emphasis> of a frame is the address immediately
	  before the start of the &next; frame. For a falling stack this will
	  be the lowest address and for a rising stack this will be the
	  highest address in the frame.
	</para>

	<para>
	  &gdb; functions to analyze the stack are typically given a pointer
	  to the &next; frame to determine information about &this;
	  frame. Information about &this; frame includes data on where the
	  registers of the &prev; frame are stored in this stack frame. In
	  this example the frame pointer of the &prev; frame is stored at
	  offset 0 from the stack pointer of &this; frame.
	</para>

	<para>
	  The process whereby a function is given a pointer to the &next;
	  frame to work out information about &this; frame is referred to as
	  <emphasis>unwinding</emphasis>. The &gdb; functions involved in this
	  typically include <literal>unwind</literal> in their name.
	</para>

	<para>
	  The process of analyzing a target to determine the information that
	  should go in &frame_info; is called
	  <emphasis>sniffing</emphasis>. The functions that carry this out are
	  called <emphasis>sniffers</emphasis> and typically include
	  <literal>sniffer</literal> in their name. More than one sniffer may
	  be required to extract all the information for a particular frame.
	</para>

	<para>
	  Because so many functions work using the &next; frame, there is an
	  issue about addressing the <emphasis>innermost</emphasis>
	  frame&mdash;it has no &next; frame. To solve this &gdb; creates a
	  dummy frame #-1, known as the <emphasis>sentinel</emphasis> frame.
	</para>

	<sect3>
	  <title>
	    Analyzing Stacks
	  </title>

	  <para>
	    When a program stops, &gdb; needs to construct the chain of
	    &frame_info; representing the state of the stack using appropriate
	    <emphasis>sniffers</emphasis>.
	  </para>

	  <para>
	    Each architecture requires appropriate sniffers, but they do not
	    form part of &gdbarch;, since more than one sniffer may be
	    required. Instead they are associated with the architecture using
	    the following functions.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>frame_unwind_append_sniffer</function> is used to
		add a new sniffer to analyze &this; frame when given a pointer
		to the &next; frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_append_sniffer</function> is used to add
		a new sniffer which can determine information about the base
		of a stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_set_default</function> is used to specify
		the default base sniffer.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    These functions all take a reference to &gdbarch;, so they are
	    associated with a specific architecture. They are usually called
	    in the &gdbarch; initialization function, after the &gdbarch; has
	    been set up. Unless a default has been set, the sniffers will be
	    tried most recently appended first.
	  </para>

	  <para>
	    The main frame unwinding sniffer (as set by
	    <function>frame_unwind_append_sniffer</function>) returns a
	    structure specifying a set of sniffing functions:
	  </para>

	  <programlisting>struct frame_unwind
{
  enum frame_type            type;
  frame_this_id_ftype       *this_id;
  frame_prev_register_ftype *prev_register;
  const struct frame_data   *unwind_data;
  frame_sniffer_ftype       *sniffer;
  frame_prev_pc_ftype       *prev_pc;
  frame_dealloc_cache_ftype *dealloc_cache;
};</programlisting>

	  <para>
	    The <varname>type</varname> field indicates the type of frame this
	    sniffer can handle: normal, dummy (see
	    <function>push_dummy_call</function> in <xref
	    linkend="sec_gdbarch" />), signal handler or sentinel. Signal
	    handlers sometimes have their own simplified stack structure for
	    efficiency, so may need their own handlers.
	  </para>

	  <para>
	    <varname>unwind_data</varname> holds additional information which
	    may be relevant to particular types of frame. For example it may
	    hold additional information for signal handler frames.
	  </para>

	  <para>
	    The remaining fields define functions that yield different types
	    of information when given a pointer to the &next; stack frame. Not
	    all functions need be provided. If an entry is &null;, the next
	    sniffer will be tried instead.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>this_id</function> determines the stack pointer and
		function (code entry point) for &this; stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_register</function> determines where the values
		of registers for the &prev; stack frame are stored in &this;
		stack frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>sniffer</function> takes a look at &this; frame's
		registers to determine if this is the appropriate unwinder.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_pc</function> determines the program counter
		for &this; frame. Only needed if the program counter is not an
		ordinary register (see <function>prev_pc</function> in <xref
		linkend="sec_gdbarch" />).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>dealloc_cache</function> frees any additional memory
		associated with the prologue cache for this frame (see <xref
		linkend="sec_prologue_cache" />).
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    In general it is only the <function>this_id</function> and
	    <function>prev_register</function> functions that need be defined
	    for most custom sniffers.
	  </para>

	  <para>
	    The frame base sniffer is much simpler. It is a
	    <structname>struct&nbsp;frame_base</structname>, which refers to the
	    corresponding <structname>struct&nbsp;frame_unwind</structname> and
	    provides functions yielding various addresses within the frame.
	  </para>

	  <programlisting>struct frame_base
{
  const struct frame_unwind *unwind;
  frame_this_base_ftype     *this_base;
  frame_this_locals_ftype   *this_locals;
  frame_this_args_ftype     *this_args;
};</programlisting>

	  <para>
	    All these functions take a pointer to the &next; frame as
	    argument. <function>this_base</function> returns the base address
	    of &this; frame, <function>this_locals</function> returns the base
	    address of local variables in &this; frame and
	    <function>this_args</function> returns the base address of the
	    function arguments in this frame.
	  </para>

	  <para>
	    As described above the <emphasis>base</emphasis> address of a
	    frame is the address immediately before the start of the &next;
	    frame. For a falling stack, this is the lowest address in the
	    frame and for a falling stack it is the highest address in the
	    frame. For most architectures the same address is also the base
	    address for local variables and arguments, in which case the same
	    function can be used for all three entries.
	  </para>

	  <para>
	    It is worth noting that if it cannot be determined in any other
	    way (for example by their being a register with the name
	    <literal>"fp"</literal>), then the result of the
	    <function>this_base</function> function will be used as the value
	    of the frame pointer variable <varname>$fp</varname> in &gdb;
	  </para>
	</sect3>

	<sect3 id="sec_prologue_cache">
	  <title>
	    Prologue Caches
	  </title>

	  <para>
	    All the frame sniffing functions typically examine the code at the
	    start of the corresponding function, to determine the state of
	    registers. The &abi; will save old values and set new values of
	    key registers at the start of each function in what is known as
	    the function <emphasis>prologue</emphasis>.
	  </para>

	  <para>
	    For any particular stack frame this data does not change, so all
	    the standard unwinding functions, in addition to receiving a
	    pointer to the &next; frame as their first argument, receive a
	    pointer to a <emphasis>prologue cache</emphasis> as their second
	    argument. This can be used to store values associated with a
	    particular frame, for reuse on subsequent calls involving the same
	    frame.
	  </para>

	  <para>
	    It is up to the user to define the structure used (it is a
	    <type>void&nbsp;*</type> pointer) and arrange allocation and
	    deallocation of storage. However for general use, &gdb;
	    provides <structname>struct&nbsp;trad_frame_cache</structname>, with a
	    set of accessor routines. This structure holds the stack and code
	    address of &this; frame, the base address of the frame, a pointer
	    to the &frame_info; for the &next; frame and details of where the
	    registers of the &prev; frame may be found in &this; frame.
	  </para>

	  <para>
	    Typically the first time any sniffer function is called with
	    &next; frame, the prologue sniffer for &this; frame will be
	    &null;. The sniffer will analyze the frame, allocate a prologue
	    cache structure and populate it. Subsequent calls using the same
	    &next; frame will pass in this prologue cache, so the data can be
	    returned with no additional analysis.
	  </para>

	</sect3>
	
      </sect2>

      <sect2 id="sec_regcache">
	<title>
	  Register Caches
	</title>

	<para>
	  For frames, a caching strategy was used, so that the target did not
	  need to be accessed and reanalyzed multiple times for the same
	  frame. Similarly a caching strategy is used to hold the values of
	  registers.
	</para>

	<para>
	  &gdb; considers registers to be a set with members numbered linearly
	  from 0 upwards. The first part of that set corresponds to real
	  physical registers, the second part to any
	  "pseudo-registers". Pseudo-registers have no independent physical
	  existence, but are useful representations of information within the
	  architecture. For example the OpenRISC 1000 architecture has up to
	  32 general purpose registers, which are typically represented as
	  32-bit (or 64-bit) integers. However it could be convenient to
	  define a set of pseudo-registers, to show the &gpr;s represented as
	  floating point registers.
	</para>

	<para>
	  For any architecture, the implementer will decide on a mapping from
	  hardware to &gdb; register numbers. The registers corresponding to
	  real hardware are referred to as <emphasis>raw</emphasis> registers,
	  the remaining registers are
	  <emphasis>pseudo-</emphasis>registers. The total register set (raw
	  and pseudo) is called the <emphasis>cooked</emphasis> register set.
	</para>

	<para>
	  &gdb; provides &regcache;, associated with a particular &gdbarch; to
	  hold the cached values of the raw registers. A set of functions are
	  provided to access both the raw registers (with
	  <literal>raw</literal> in their name) and the full set of cooked
	  registers (with <literal>cooked</literal> in their name). Functions
	  are provided to ensure the register cache is kept synchronized with
	  the values of the actual registers in the target.
	</para>

	<para>
	  Accessing registers through the &regcache; routines will ensure that
	  the appropriate &gdbarch; functions are called when necessary to
	  access the underlying target architecture. In general users should
	  use the "cooked" functions, since these will map to the "raw"
	  functions automatically as appropriate.
	</para>

	<para>
	  The two key functions are <function>regcache_cooked_read</function>
	  and <function>regcache_cooked_write</function> which read or write a
	  register to or from a byte buffer (type
	  <type>gdb_byte&nbsp;*</type>). For convenience the wrapper functions
	  <function>regcache_cooked_read_signed</function>,
	  <function>regcache_cooked_read_unsigned</function>,
	  <function>regcache_cooked_write_signed</function> and
	  <function>regcache_cooked_write_unsigned</function> are provided,
	  which read or write the value and convert to or from a value as
	  appropriate.
	</para>

      </sect2>

      <sect2>
	<title>
	  Target Operations
	</title>

	<para>
	  The communication with the target is down to a set of
	  <emphasis>target operations</emphasis>. These operations are
	  held in a &target_ops;, together with flags describing the behavior
	  of the target.
	</para>

	<para>
	  &gdb; has several different types of target: executable files, core
	  dumps, executing processes etc. At any time, &gdb; may have several
	  sets of target operations in use. For example target operations for
	  use with an executing process (which can run code) might be
	  different from the operations used when inspecting a core dump.
	</para>

	<para>
	  All the targets &gdb; knows about are held in a stack. &gdb; walks
	  down the stack to find the set of target operations suitable for
	  use. The stack is organized as a series of
	  <emphasis>strata</emphasis> or decreasing importance: target
	  operations for threads, then target operations suitable for
	  processes, target operations to download remote targets, target
	  operations for core dumps, target operations for executable files
	  and at the bottom target operations for dummy targets. So &gdb; when
	  debugging a running process will always select target operations
	  from the process_stratum if available, over target operations from
	  the file stratum, even if the target operations from the file
	  stratum were pushed onto the stack more recently.
	</para>

	<para>
	  At any particular time, there is a <emphasis>current</emphasis>
	  target, held in the global variable
	  <varname>current_target</varname>. This can never be &null;&mdash;if
	  there is no other target available, it will point to the dummy
	  target.
	</para>

	<para>
	  Some targets (sets of target operations in a &target_ops;) are set
	  up automatically by &gdb;&mdash;these include the operations to
	  drive simulators (see <xref linkend="ref_simulators" /> and the
	  operations to drive the &gdb; <emphasis>Remote Serial
	  Protocol</emphasis> (&rsp;) (see <xref linkend="ref_rsp" />).
	</para>

	<para>
	  Other targets must be set up explicitly by the implementer, using
	  the <function>add_target</function> function. By far the most common
	  is the <emphasis>native</emphasis> target for native debugging of the
	  host. Less common is to set up a non-native target, such as the
	  &jtag; target used with the OpenRISC 1000<footnote>
	    <para>
	      For a new remote target of any kind, the recommended approach is
	      to use the standard &gdb; Remote Serial Protocol and have the
	      target implement the server side of this interface. The only
	      remote targets remaining are historic legacy interfaces, such as
	      the OpenRISC 1000 Remote &jtag; Protocol.
	    </para>
	  </footnote>.
	</para>

	<para>
	  A new native target is created by defining a function
	  <literal>_initialize_</literal><emphasis>arch</emphasis><literal>_</literal><emphasis>os</emphasis><literal>_nat</literal>
	  for the architecture, <emphasis>arch</emphasis> and operating system
	  <emphasis>os</emphasis>, in the source file
	  <emphasis>arch-os</emphasis><filename>-nat.c</filename>. A fragment
	  of a makefile to create the binary from the source is created in the
	  file
	  <filename>config>/</filename><emphasis>arch</emphasis><filename>/</filename><emphasis>os</emphasis><filename>.mh</filename>
	  with a header giving any macro definitions etc in
	  <filename>config>/</filename><emphasis>arch</emphasis><filename>/nm-</filename><emphasis>os</emphasis><filename>.h</filename>
	  (which will be linked to <filename>nm.h</filename> at build time).
	</para>

	<para>
	  The <literal>_initialize_</literal> function should create a new
	  &target_ops; and call <function>add_target</function> to add this
	  target to the list of available targets.
	</para>

	<para>
	  For a new remote target, the procedure is a little simpler. The
	  source files should be added to <filename>configure.tgt</filename>,
	  just as for the architectural description (see <xref
	  linkend="sec_gdbarch" />). Within the source file, define a new
	  function
	  <function>_initialize_remote_</function><emphasis>arch</emphasis> to
	  implement a new remote target, <emphasis>arch</emphasis>.
	</para>

	<para>
	  For new native targets, most have standard implementations which can
	  be reused, with just one or two changes. For example the function
	  <function>linux_trad_target</function> will provide a set of target
	  operations suitable for most Linux native targets. It may prove
	  necessary only to alter the description field and the functions to
	  fetch and store registers.
	</para>

	<para>
	  For new remote targets, the definitions in
	  <filename>remote.c</filename> used to implement the &rsp; provide a
	  good starting point.
	</para>
  
	<para>
	  The main &target_ops; elements (which are defined in
	  <filename>target.h</filename>) are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_shortname</varname>. This string is the name of
	      target, for use with &gdb;s <command>target</command>. Setting
	      <varname>to_shortname</varname> to <emphasis>foo</emphasis>
	      means that <command>target </command><emphasis>foo</emphasis>
	      will connect to the target, invoking to
	      <function>to_open</function> for this target (see below).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_longname</varname>. A string giving a brief
	      description of the type of target. This is printed with the
	      <command>info target</command> information (see also
	      <function>to_files_info</function> below).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_doc</varname>. The help text for this target. If the
	      short name of the target is <emphasis>foo</emphasis>, then the
	      command <command>help&nbsp;target</command> will print
	      <literal>target </literal><emphasis>foo</emphasis> followed by
	      the first sentence of this help text. The command
	      <command>help&nbsp;target&nbsp;</command><emphasis>foo</emphasis>
	      will print out the complete text.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_open</function>. This function should establish the
	      communications with the target. It should establish the state of
	      the target (is it already running for example), and initialize
	      data structures appropriately. It should
	      <emphasis>not</emphasis> start the target running if it is not
	      currently running&mdash;that is the job of the &gdb;
	      <command>run</command> command.
	    </para>

	    <para>
	      <function>to_open</function> is invoked by the &gdb;
	      <command>target</command>. Any additional arguments (beyond the
	      name of the target being invoked) are passed to this function.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xclose</function> and
	      <function>to_close</function>. Both these functions should close
	      the remote connection. <function>to_close</function> is the
	      legacy function. New implementations should use
	      <function>to_xclose</function> which should also free any memory
	      allocated for this target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_attach</function>. For targets which can run
	      without a debugger connected, this function attaches the
	      debugger to a running target (which should first have been
	      opened).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_detach</function>. Function to detach from a
	      target, leaving it running.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_disconnect</function>. This is similar to
	      <function>to_detach</function>, but makes no effort to inform
	      the target that the debugger is detaching. It should just drop
	      the connection to the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_resume</function>. Function to tell the target to
	      start running again.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_wait</function>. Function to wait for the target to
	      return control to the debugger. Typically this will be when the
	      target finishes execution or hits a breakpoint. It could also
	      occur if the connection is interrupted (for example by ctrl-C).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_fetch_registers</function> and
	      <function>to_store_registers</function>. Functions to populate
	      the register cache with values from the target and to set target
	      registers with values in the register cache.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_prepare_to_store</function>. This function is
	      called prior to storing registers to set up any additional
	      information required. In most cases it will be an empty function.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_files_info</function>. This function provides
	      additional information for the <command>info target</command>
	      command.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_insert_breakpoint</function> and
	      <function>to_remove_breakpoint</function>. These functions
	      insert and remove breakpoints on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_can_use_hw_breakpoint</function>. This function
	      should return 1 (true) if the target can set a hardware
	      breakpoint or watchpoint and 0 otherwise. The function is passed
	      an enumeration to indicate whether watchpoints or breakpoints
	      are being queried, and should use information about the number
	      of hardware breakpoints/watchpoints currently in use to
	      determine if a breakpoint/watchpoint can be set.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_insert_hw_breakpoint</function> and
	      <function>to_remove_hw_breakpoint</function>. Functions to
	      insert and remove hardware breakpoints.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_remove_watchpoint</function> and
	      <function>to_insert_watchpoint</function>. Functions to remove
	      and insert watchpoints.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_by_watchpoint</function>. Function returns
	      1 (true) if the last stop was due to a watchpoint.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_data_address</function>. If the last stop
	      was due to a watchpoint, this function returns the address of
	      the data which triggered the watchpoint.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_terminal_inferior</function>. This function
	      connects the target's terminal I/O to our terminal.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_kill</function>. Kill the target. This should not
	      hang up if the connection to the terminal is not working.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_load</function>. Load a file into the target. Since
	      this is built on top of the other target operations the generic
	      function <function>generic_load</function> is suitable for most
	      implementations.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_create_inferior</function>. For targets can
	      execute, this starts a program running on the target. It is
	      invoked by the &gdb; <command>run</command> command.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_mourn_inferior</function>. Tidy up after execution
	      of the target has finished (for example after it has been
	      killed). Most implementations call the generic function,
	      <function>generic_mourn_inferior</function>, but may do some
	      additional tidying up.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_thread_alive</function>. Function which returns 1
	      (true) if a thread is alive on the target.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_find_new_threads</function>. Function which reports
	      all the threads on the target for the <command>info
	      threads</command> command.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_pid_to_str</function>. Converts a process ID on the
	      target to a string.
	    </para>

	    <note>
	      <para>
		The documentation of this in &gdb; is ambiguous. While it
		appears to get the process ID, it converts it to a string
		"Thread %d".
	      </para>
	    </note>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_extra_thread_info</function>Function which returns
	      a string giving additional information about a particular
	      thread. This function is optional.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stop</function>. Function to stop the target - used
	      whenever the target is to be interrupted (for example by ctrl-C).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_rcmd</function>. If the target is capable of
	      running commands, then this function requests that command to be
	      run on the target. This is of most relevance to remote targets.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_stratum</varname>. An enumerated constant indicating
	      to which stratum this &target_ops; belongs
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_all_memory</varname>. Boolean indicating if the
	      target includes all of memory, or only part of it. If only part,
	      then a failed memory request may be able to be satisfied by a
	      different target in the stack.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_memory</varname>. Boolean indicating if the
	      target has memory (dummy targets to not)
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_stack</varname>. Boolean indicating if the
	      target has a stack. Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_registers</varname>. Boolean indicating if the
	      target has registers.  Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_execution</varname>. Boolean indicating if the
	      target is currently executing. For some targets that is the same
	      as if they are capable of execution. However some remote targets
	      can be in the position where they are not executing until
	      <function>create_inferior</function> or
	      <function>attach</function> is called.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_thread_control</varname>. Boolean indicating if
	      the target can switch threads.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_can_async_p</function>. Function indicating if the
	      target can execute asynchronously. This is often true for remote
	      targets.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_is_async_p</function>. For targets which can
	      execute asynchronously, this function indicates if the target is
	      currently executing asynchronously.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_async</function>. Used to start asynchronous
	      execution, with a callback for use when the target wishes to
	      engage the debugger.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_async_mask_value</varname>. Asynchronous targets can
	      be a problem, when a function needs to be evaluated (for example
	      with the &gdb; <command>call</command> command). This is a patch
	      to put the target temporarily into synchronous mode while the
	      function is evaluated.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xfer_partial</function>. This function is a generic
	      function to transfer data to and from the target. Its most
	      important function (often the only one actually implemented) is
	      to load and store data from and to target memory.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_memory_map</function>. Function to return the
	      memory map for the target.
	    </para>
	  </listitem>

	</itemizedlist>
      </sect2>

    </sect1>

    <sect1 id="sec_adding_commands">
      <title>
	Adding Commands to &gdb;
      </title>

      <para>
	&gdb;'s command handling is intended to be extensible. A set of
	functions (defined in <filename>cli-decode.h</filename>) provide that
	extensibility.
      </para>

      <para>
	&gdb; groups its commands into a number of command lists (of
	<structname>struct&nbsp;cmd_list_element</structname>), pointed to by
	a number of global variables (defined in
	<filename>cli-cmds.h</filename>). Of these, <varname>cmdlist</varname>
	is the list of all defined commands. Separate lists defined
	sub-commands of various top level commands. For example
	<varname>infolist</varname> is the list of all <command>info</command>
	sub-commands.
      </para>

      <para>
	Commands are also classified according the the area they address, for
	example commands that provide support, commands that examine data,
	commands for file handling etc. These classes are specified by
	<type>enum&nbsp;command_class</type>, defined in
	<filename>command.h</filename>. These classes provide the top level
	categories in which help will be given.
      </para>

      <para>
	Each command (or sub-command) is associated with a callback function
	which implements the behavior of the functions. There are additional
	requirements for functions which set or show values within &gdb;. Each
	function also takes a documentation string (used by the help
	command). Functions for adding commands all return a pointer
	to the <structname>struct&nbsp;cmd_list_element</structname> for the
	command added (which is not necessarily the head of its command
	list). The most useful functions are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>add_cmd</function>. Add a function to a command list.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_com</function>. Add a function to the main command
	    list, <varname>cmdlist</varname>. This is a convenience wrapper
	    for <function>add_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_prefix_cmd</function>. Add a new prefix
	    command. This command should have its own function for use if it
	    is called on its own, and a global command list pointer specific
	    to the prefix command to which all its sub-commands will be
	    added. If a prefix command is called with an unknown sub-command,
	    it can either give an error or call the function of the prefix
	    command itself. Which of these is used is specified by a flag in
	    the call to <function>add_prefix_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_alias_cmd</function>. Add an alias for a command
	    already defined.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_info</function>. Add a sub-command to the
	    <command>info</command>. A convenience wrapper for
	    <function>add_cmd</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>add_cmd</function>. Add a function to a command list.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	New commands are usually added in the
	<literal>initialize_</literal><emphasis>arch</emphasis> function after
	the &gdbarch; has been defined.
      </para>
    </sect1>

    <sect1 id="ref_simulators">
      <title>
	Simulators
      </title>

      <para>
	&gdb; enables implementers to link gdb to a built-in simulator, so
	that a simulated target may be executed through use of the
	<command>target&nbsp;sim</command> command.
      </para>

      <para>
	The simulator should be built as a library,
	<filename>libsim.a</filename>, implementing the standard &gdb;
	simulator interface. The location of the library is specified by
	setting the <parameter>gdb_sim</parameter> parameter in
	<filename>configure.tgt</filename>.
      </para>

      <para>
	The interface consists of a set of functions which should be
	implemented. The detailed specification is found in the header
	<filename>remote-sim.h</filename> in the include directory.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>sim_open</function>. Initialize the simulator.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_close</function>. Destroy the simulator instance,
	    including freeing any memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_load</function>. Load a program into the simulator's
	    memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_create_inferior</function>. Prepare to run the
	    simulated program. Don't actually run it until
	    <function>sim_resume</function> (see below) is called.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_read</function> and
	    <function>sim_write</function>. Read and write bytes from and to
	    the simulator's memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_fetch_register</function> and
	    <function>sim_store_register</function>. Read and write the
	    simulator's registers.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_info</function>. Print information for the
	    <command>info sim</command> command.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_resume</function>. Resume (or start) execution of
	    the simulated program.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop</function>. Stop execution of the simulated
	    program.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop_reason</function>. Return the reason why the
	    program stopped.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_do_command</function>. Execute some arbitrary
	    command that the simulator supports.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="ref_rsp">
      <title>
	Remote Serial Protocol
      </title>

      <para>
	The &gdb; <emphasis>Remote Serial Protocol</emphasis> is a general
	purpose protocol for connecting to remote targets. It is invoked
	through the <command>target remote</command> command.
      </para>

      <para>
	The protocol is a simple text command-response protocol. Any remote
	target can communicate with &gdb; by implementing the server side of
	the &rsp;. A number of stub implementations are provided for various
	architectures, which can be used as the basis of new implementations.
      </para>
    </sect1>

    <sect1>
      <title>
	&gdb; File Organization
      </title>

      <para>
	The bulk of the &gdb; source code is in a small number of
	directories. Some components of &gdb; are libraries used elsewhere
	(for example &bfd; is used in &gnu; binutils), and these have their own
	directory. The main directories are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>include</filename>. Header files for information which
	    straddles major components. For example the main simulator
	    interface header is here (<filename>remote-sim.h</filename>),
	    because it links &gdb; (in directory <filename>gdb</filename>) to
	    the simulators (in directory <filename>sim</filename>). Headers
	    specific to a particular component reside in the directory of that
	    component.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>bfd</filename>. The Binary File Descriptor library. If a
	    new object file type must be recognized, it should be added here.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb</filename>. The main &gdb; directory. All source
	    files should include <filename>defs.h</filename> first and then
	    any other headers they reference. Headers should also include any
	    headers they reference, but may assume that
	    <filename>defs.h</filename> has been included.
	  </para>

	  <para>
	    The file <filename>configure.tgt</filename> contains a huge switch
	    statement to match targets specified to the main
	    <command>configure</command> command. Add a new target by
	    incorporating its pattern match in this file.
	  </para>

	  <para>
	    The sub-directory <filename>config</filename> contains target
	    specific configuration information for native targets.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>libiberty</filename>. Before POSIX and <application>glibc</application>, this was a
	    &gnu; project to provide a set of standard functions. It lives on in
	    &gnu;. Most valuable are its free store management and argument
	    parsing functions.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>opcodes</filename>. This contains disassemblers for use
	    by &gdb; (the <command>disassemble</command> command);. In a
	    directory of its own, because this code is also used in binutils.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>sim</filename>. The simulators for various targets. Each
	    target architecture simulator is built in its own sub-directory.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>
	Testing &gdb;
      </title>

      <para>
	Running the &gdb; test suite requires that the
	<application>DejaGNU</application> package is installed. The tests can
	then be run with:
      </para>

      <informalexample>
	<para>
	  <command>make check</command>
	</para>
      </informalexample>

      <para>
	On completion of the run, the summary results will be in the
	<filename>gdb/testsuite</filename> directory in
	<filename>gdb.sum</filename> with the detailed log in
	<filename>gdb.log</filename>
      </para>

      <para>
	For the most comprehensive tests in an environment where host and
	target differ, <application>DejaGNU</application> needs some additional configuration. This can be
	achieved by setting the <constant>DEJAGNU</constant> environment
	variable to refer to a suitable configuration file, and defining a
	custom board configuration file in the directory
	<filename>~/boards</filename>. These configuration files can be used
	to specify a suitable simulator and how to connect it when running
	tests.
      </para>
    </sect1>

    <sect1>
      <title>
	Documentation
      </title>

      <para>
	Some of &gdb; sub-directories in turn have <filename>doc</filename>
	sub-directories. The documentation is written in
	<application>texinfo</application> (<xref linkend="ref_texinfo" />),
	from which documents can be generated as &pdf;, <application>PostScript</application>, &html; or
	<command>info</command> files. The documentation is not built
	automatically with <command>make&nbsp;all</command>, nor with
	<command>make&nbsp;doc</command>.
      </para>

      <para>
	To create documentation, change to the individual documentation
	directory and use <command>make&nbsp;html</command>,
	<command>make&nbsp;pdf</command>, <command>make&nbsp;ps</command> or
	<command>make&nbsp;info</command> as required.
      </para>

      <para>
	The main documents of interest are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>bfd/doc/bfd.texinfo</filename>. This is the &bfd; manual.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdb.texinfo</filename>. This is the main &gdb;
	    user guide <xref linkend="ref_gdb_ug" />.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdbint.texinfo</filename>. This is the internals
	    user guide <xref linkend="ref_gdb_int" />. It is essential reading
	    for any developer porting the code.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The exception to automatic building is with
	<command>make&nbsp;install</command>. This will build
	<command>info</command> files for any documents in the
	<filename>gdb/doc</filename> directory and install them in the
	<filename>info</filename> sub-directory of the install directory.
      </para>

    </sect1>      

    <sect1>
      <title>
	Summary: Steps to Port a New Architecture to &gdb;
      </title>

      <para>
	Porting a new architecture to &gdb; can be broken into a number of
	steps.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Ensure a &bfd; exists for executables of the target architecture
	    in the <filename>bfd</filename> directory. If one does not exist,
	    create one by modifying an existing similar one.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Implement a disassembler for the target architecture in the
	    <filename>opcodes</filename> directory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Define the target architecture in the <filename>gdb</filename>
	    directory. Add the pattern for the new target to
	    <filename>configure.tgt</filename> with the names of the files
	    that contain the code. By convention the target architecture
	    definition for an architecture <emphasis>arch</emphasis> is placed
	    in <emphasis>arch</emphasis><literal>-tdep.c</literal>.
	  </para>

	  <para>
	    Within <emphasis>arch</emphasis><literal>-tdep.c</literal> define
	    the function
	    <literal>_initialize_</literal><emphasis>arch</emphasis><literal>_tdep</literal>
	    which calls <function>gdbarch_register</function> to create the
	    new &gdbarch; for the architecture.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    If a new remote target is needed, consider adding a new remote
	    target by defining a function
	    <literal>_initialize_remote_</literal><emphasis>arch</emphasis>.
	    However if at all possible use the <emphasis>Remote Serial
	    Protocol</emphasis> for this and implement the server side
	    protocol independently with the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    If desired implement a simulator in the <filename>sim</filename>
	    directory. This should create the library
	    <filename>libsim.a</filename> implementing the interface in
	    <filename>remote-sim.h</filename> (found in the
	    <filename>include</filename> directory).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Build and test. If desired lobby the &gdb; steering group to have
	    your new port included in the main distribution!
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Add a description of the new architecture to the "Configuration
	    Specific Information" section in the main &gdb; user guide
	    (<filename>gdb/doc/gdb.texinfo</filename> <xref
	    linkend="ref_gdb_ug" />).
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

  </chapter>

  <chapter>
    <title>
      Porting the OpenRISC 1000 Architecture
    </title>

    <para>
      This chapter describes the steps in porting the OpenRISC 1000
      architecture to &gdb;. It uses the information and data structures
      described in <xref linkend="chap_gdb_internals" />.
    </para>

    <para>
      Strictly speaking this was not a new port. An old port existed for &gdb;
      5.3. However &gdb; has changed substantially since that time, and an
      almost complete reimplementation was required.
    </para>

    <tip>
      <para>
	When working with any large code base a TAGS file is invaluable. This
	allows immediate lookup of any procedure or variable across the entire
	code base. Normally for any &gnu; project, this is achieved with the
	command <command>make tags</command>. However this does not work for
	&gdb;&mdash;there is a problem with the <literal>tags</literal> target
	in the <filename>opcodes</filename> directory.
      </para>

      <para>
	However tags building <emphasis>does</emphasis> work in the
	<filename>gdb</filename> directory, so a <filename>TAGS</filename>
	file can be built in that directory by:
      </para>

      <informalexample>
	<literallayout>
<command>cd gdb</command>
<command>make tags</command>
<command>cd ..</command>
	</literallayout>
      </informalexample>
	
    </tip>

    <sect1>
      <title>
	&bfd; Specification
      </title>

      <para>
	The &bfd; specification for OpenRISC 1000 already existed (it is part
	of binutils), so there was no need to implement this. The existing
	code is just reused.
      </para>

    </sect1>

    <sect1 id="sec_target_arch">
      <title>
	Target Architecture Specification
      </title>

      <para>
	The code resides in the <filename>gdb</filename> sub-directory. The
	main architectural specification is in
	<filename>or1k-tdep.c</filename>, with and OpenRISC 1000 wide header
	in <filename>or1k-tdep.h</filename>. Support for the OpenRISC 1000
	Remote &jtag; interface is in <filename>remote-or1k.c</filename> with
	the detailed protocol in <filename>or1k-jtag.c</filename> and a
	protocol header in <filename>or1k-jtag.h</filename>.
      </para>

      <para>
	There are several targets which can use the OpenRISC 1000
	architecture. These all begin <literal>or16</literal>,
	<literal>or32</literal> or <literal>or32</literal>. The
	<filename>configure.tgt</filename> is edited to add patterns for these
	that will pick up the binaries generated from these source files.
      </para>

      <programlisting>or16* | or32* | or64*)
        # Target: OpenCores OpenRISC 1000 architecture
        gdb_target_obs="or1k-tdep.o remote-or1k.o or1k-jtag.o"
        ;;</programlisting>

      <caution>
	<para>
	  <filename>configure.tgt</filename> only specifies binaries, so
	  cannot show dependencies on headers. To correct this,
	  <filename>Makefile.in</filename> can be edited, so that <command>automake</command> and
	  configure will generate a <filename>Makefile</filename> with the
	  correct dependencies.
	</para>
      </caution>

      <para>
	The architecture definition is created from the
	<function>_initialize_or1k_tdep</function> by a call to
	<function>gdbarch_register</function>. That function also initializes
	the disassembler (<function>build_automata</function>) and adds two
	new commands: a sub-command to the <command>info</command> command to
	read &spr;s and a new top level support command,
	<command>spr</command> to set the value of &spr;s.
      </para>

      <sect2>
	<title>
	  Creating &gdbarch;
	</title>

	<para>
	  <function>gdbarch_register</function> is called for &bfd; type
	  <constant>bfd_arch_or32</constant> with the initialization function
	  <function>or1k_gdbarch_init</function> and the target specific dump
	  function, <function>or1k_dump_tdep</function>.
	</para>

	<para>
	  Future implementations may make additional calls to use the same
	  function to create a 64-bit version of the architecture.
	</para>

	<para>
	  <function>gdbarch_init</function> receives the &gdbarch_info;
	  created from the &bfd; entries and the list of existing
	  architectures. That list is first checked, using
	  <function>gdbarch_list_lookup_by_info</function> to see if there is
	  already an architecture defined suitable for the given
	  &gdbarch_info; and if so it is returned.
	</para>

	<para>
	  Otherwise a new &gdbarch; is created. For that a the target
	  dependencies are saved in an OpenRISC 1000 specific
	  <structname>struct&nbsp;gdbarch_tdep</structname>, defined in
	  <filename>or1k-tdep.h</filename>.
	</para>

	<programlisting>struct gdbarch_tdep
{
  int           is_initialized;
  unsigned int  version;
  unsigned int  upr;
  unsigned int  num_matchpoints;
  unsigned int  num_gpr_regs;
  int           bytes_per_word;
  int           bytes_per_address;
};</programlisting>
	  
	<para>
	  This is information beyond that which is held in the &gdbarch;. By
	  using this structure, the &gdb; implementation for OpenRISC 1000 can
	  be made flexible enough to deal with both 32 and 64-bit
	  implementations and with variable numbers of registers and
	  matchpoints. The <varname>is_initialized</varname> flag is required,
	  because some of this data is obtained from the specific target on
	  connection, so is not available until that time.
	</para>

	<note>
	  <para>
	    Although this flexibility is built in to the code, the current
	    implementation has only been tested with 32-bit OpenRISC without
	    floating point or vector support and with 32 registers.
	  </para>
	</note>

	<para>
	  The new architecture is then created by
	  <function>gdbarch_alloc</function>, passing in the
	  &gdbarch_info; and the
	  <structname>struct&nbsp;gdbarch_tdep</structname>.
	</para>

	<para>
	  The &gdbarch; is populated using the various
	  <literal>set_gdbarch_</literal> functions. The first group of these
	  initialize the size and format of all the standard data types, for
	  example:
	</para>

        <programlisting>set_gdbarch_short_bit             (gdbarch, 16);</programlisting>

	<para>
	  The next group of functions set up register handling. The
	  representation of the <emphasis>raw</emphasis> registers (see <xref
	  linkend="sec_regcache" />) is: registers 0-31 are the corresponding
	  &gpr;s, register 32 is the program counter and register 33 is the
	  supervision register. For convenience, constants are defined in the
	  header, <filename>or1k_tdep.h</filename>, for all the special
	  registers.
	</para>

	<programlisting>#define OR1K_SP_REGNUM         1
#define OR1K_FP_REGNUM         2
#define OR1K_FIRST_ARG_REGNUM  3
#define OR1K_LAST_ARG_REGNUM   8
#define OR1K_LR_REGNUM         9
#define OR1K_RV_REGNUM        11
#define OR1K_PC_REGNUM       (OR1K_MAX_GPR_REGS + 0)
#define OR1K_SR_REGNUM       (OR1K_MAX_GPR_REGS + 1)</programlisting>

	<para>
	  In this implementation there are no pseudo-registers. A set could
	  have been provided to represent the &gpr;s in floating point format
	  (for use with the floating point instructions), but this has not
	  been implemented. Constants are defined for the various totals
	</para>

        <programlisting>#define OR1K_MAX_GPR_REGS    32
#define OR1K_NUM_PSEUDO_REGS  0
#define OR1K_NUM_REGS        (OR1K_MAX_GPR_REGS + 2)
#define OR1K_TOTAL_NUM_REGS  (OR1K_NUM_REGS + OR1K_NUM_PSEUDO_REGS)</programlisting>

        <caution>
	  <para>
	    These totals are currently hard-coded constants. They should
	    really draw on the data in the &gdbarch_tdep;, providing support
	    for architectures which have less than the full complement of 32
	    registers.
	  </para>

	  <para>
	    This functionality will be provided in a future implementation.
	  </para>
	</caution>
	    
	<para>
	  Although this architecture currently has no pseudo-registers, the
	  functions to read and write these registers are added as
	  place-holders, <function>or1k_pseudo_register_read</function> and
	  <function>or1k_pseudo_register_write</function>. The number of
	  registers and the specific values are set for stack pointer, program
	  counter and processor status. The virtual frame pointer is set by
	  <function>or1k_virtual_frame_pointer_function</function>.  Functions
	  provided to give the name, type and group of a register
	  (<function>or1k_register_name</function>,
	  <function>or1k_register_type</function> and
	  <function>or1k_register_reggroup_p</function>) and to provide the
	  output for the <command>info&nbsp;registers</command> command
	  (<function>or1k_registers_info</function>). The implementation of
	  these functions is discussed in more detail in <xref
	  linkend="sec_or1k_reg_funcs" />.
	</para>

	<para>
	  The next group of functions handle frames. These are functions to
	  set up and tear down a dummy stack frame
	  (<function>or1k_push_dummy_call</function> and
	  <function>or1k_unwind_dummy_id</function>), a function to determine
	  the type of a return value (<function>or1k_return_value</function>),
	  a function to skip the prologue of a function
	  (<function>or1k_skip_prologue</function>), a function to determine
	  whether the stack frame is rising or falling (the generic
	  <function>core_addr_lessthan</function>), a function to enforce the
	  frame alignment rules (<function>or1k_frame_align</function>), the
	  red zone size (<constant>OR1K_RED_ZONE_SIZE</constant>, see <xref
	  linkend="sec_gdbarch" />, a function to check for delay slots
	  (<function>or1k_single_step_through_delay</function> and functions
	  to unwind standard registers from the stack
	  (<function>or1k_unwind_pc</function> and
	  <function>or1k_unwind_sp</function>). The handling of OpenRISC 1000
	  frames is discussed in more detail in <xref
	  linkend="sec_or1k_frames" /> and the implementation of the frame
	  handling function in <xref linkend="sec_or1k_frame_funcs" />.
	</para>

	<para>
	  Finally two functions, which do not fit in the other
	  groups. <function>or1k_breakpoint_from_pc</function> returns the
	  breakpoint function to be used at a given program counter
	  address. Since all OpenRISC 1000 instructions are the same size,
	  this function always returns the same value, the instruction
	  sequence for a <literal>l.trap</literal> instruction.
	</para>

	<para>
	  The other function is the disassembler. There are two variants of
	  this, depending on the endianism. The disassembler is discussed in
	  more detail in <xref linkend="sec_or1k_disasm" />.
	</para>

	<para>
	  This completes the definition of the &gdbarch; for the OpenRISC
	  1000. However before the function returns, suitable frame sniffers
	  are set up for the architecture. These are described in <xref
	  linkend="sec_or1k_frames" />.
	</para>

	<para>
	  When creating a new &gdbarch; a function must be provided to dump
	  the target specific definitions in &gdbarch_tdep; to a file. This is
	  provided in <function>or1k_dump_tdep</function>. It is passed a
	  pointer to the &gdbarch; and a file handle and simply writes out the
	  fields in the &gdbarch_tdep; with suitable explanatory text.
	</para>

	<sect3 id="sec_or1k_reg_funcs">
	  <title>
	    OpenRISC 1000 Register Handling Functions
	  </title>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_virtual_frame_pointer</function>. &gdb;
		increasingly discards the concept of a the frame pointer being
		a "special" register&mdash;not all architectures have
		them. It is up to individual architectures to define a frame
		pointer as a raw or pseudo-register if desired. Thus the
		setting of a register number for the frame pointer in the
		&gdbarch; is now deprecated. However there appear to be a
		small number of places where a pointer to the start of the
		frame is required, which this function provides.
	      </para>

	      <para>
		The OpenRISC 1000 does have a frame pointer (&gpr; 2). With
		the falling stack frame, the stack pointer (&gpr; 1) points to
		the lowest address on the frame, and the frame pointer (&fp;)
		to the lowest address on the previous frame. Local variables
		have negative indexes on the &fp;. Function arguments that are
		on the stack (rather than in registers) have positive offsets
		from the &fp;, i.e. they are on the end of the previous stack
		frame.
	      </para>

	      <para>
		The implementation trivially returns the number of the frame
		pointer register and and offset from that register to the
		start of the frame.
	      </para>

	      <note>
		<para>
		  This function <emphasis>does not</emphasis> give the value
		  of the <varname>$fp</varname> variable in &gdb;. That is
		  provided from any register named <literal>"fp"</literal>,
		  from the deprecated &fp; register number if it has been set,
		  or from the base address returned by the frame sniffer.
		</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_pseudo_register_read</function> and
		<function>or1k_pseudo_register_write</function>. The functions
		are defined as hooks, but in the absence of any
		pseudo-registers they do nothing.
	      </para>
	    </listitem>
	
	    <listitem>
	      <para>
		<function>or1k_register_name</function>. This is a simple
		table lookup to yield the register name from its number.
	      </para>
	    </listitem>
	
	    <listitem>
	      <para>
		<function>or1k_register_type</function>. This function must
		return the type as a
		<structname>struct&nbsp;type</structname>. This &gdb; data
		structure contains detailed information about each type and
		its relationship to other types.
	      </para>

	      <para>
		For the purposes of this function, a number of standard types
		are predefined, with utility functions to construct other
		types from them. For most registers the predefined
		<constant>builtin_type_int32</constant> is suitable. The stack
		pointer and frame pointer are pointers to arbitrary data, so
		the equivalent of <type>void *</type> is required. This is
		constructed by applying the function
		<function>lookup_pointer_type</function> to the predefined
		<constant>builtin_type_void</constant>. The program counter is
		a pointer to code, so the equivalent of a pointer to a void
		function is appropriate. This is constructed by applying
		<function>lookup_pointer_type</function> and
		<function>lookup_function_type</function> to
		<constant>builtin_type</constant>.
	      </para>
	    </listitem>
	
	    <listitem>
	      <para>
		<function>or1k_register_info</function>. This function is used
		by the <command>info&nbsp;registers</command> command to
		display information about one or more registers.
	      </para>

	      <para>
		This function is not really needed. It is just a wrapper for
		<function>default_print_registers_info</function>, which is
		the default setting for this function anyway.
	      </para>
	    </listitem>
	
	    <listitem>
	      <para>
		<function>or1k_register_reggroup_p</function>. This predicate
		function returns 1 (true) if a given register is in a
		particular group. This is used by the command
		<command>info&nbsp;registers</command> when registers in a
		particular category are requested.
	      </para>

	      <para>
		The function as implemented is little different from the
		default function
		(<function>default_register_reggroup_p</function>), which is
		called for any unknown cases anyway. However it does make use
		of the target dependent data (&gdbarch_tdep;), thus providing
		flexibility for different OpenRISC 1000 architectures.
	      </para>
	    </listitem>
	  </itemizedlist>	
	    
	</sect3>

      </sect2>

      <sect2 id="sec_or1k_frames">
	<title>
	  Frame Handling
	</title>

	<para>
	  The OpenRISC 1000 frame structure is described in its &abi; <xref
	  linkend="ref_or1k" />. Some of the detail is slightly different in
	  current OpenRISC implementations&mdash;this is described in <xref
	  linkend="sec_or1k_abi" />.
	</para>

	<para>
	  The key to frame handling is understanding the prologue (and
	  possibly epilogue) in each function which is responsible for
	  initializing the stack frame. For the OpenRISC 1000, &gpr;&nbsp;1 is
	  used as the stack pointer, &gpr;&nbsp;2 as the frame pointer and
	  &gpr;&nbsp;9 as the return address. The prologue sequence is:
	</para>

	<informalexample>
	  <literallayout><literal>l.addi  r1,r1,-</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>(r1),r2</literal>
<literal>l.addi  r2,r1,</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>-4(r1),r9</literal>
<literal>l.sw    </literal><emphasis>x</emphasis><literal>(r1),r</literal><emphasis>y</emphasis></literallayout>
	</informalexample>

	<para>
	  The OpenRISC 1000 stack frame accommodates any local (automatic)
	  variables and temporary values, then the return address, then the
	  old frame pointer and finally any stack based arguments to functions
	  called by this function. This last rule means that the return
	  address and old frame pointer are not necessarily at the end of the
	  stack frame - enough space will be left to build up any arguments
	  for called functions that must go on the stack. <xref
	  linkend="fig_prologue_frame" 
	  /> shows how the stack looks at the end of the prologue.
	</para>

	<figure id="fig_prologue_frame">
	  <title>
	    The OpenRISC 1000 stack frame at the end of the prologue
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Not all fields are always present. The function need not save its
	  return address to stack, and there may be no callee-saved registers
	  (i.e. &gpr;s 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30) which
	  require saving. Leaf functions are not required to set up a new
	  stack frame at all.
	</para>

	<para>
	  The epilogue is the inverse. Callee-saved registers are restored,
	  the return address placed in &gpr;&nbsp;9 and the stack and frame
	  pointers restored before jumping to the address in &gpr;&nbsp;9.
	</para>

	<informalexample>
	  <literallayout>
<literal>l.lwz   r</literal><emphasis>y</emphasis><literal>,</literal><emphasis>x</emphasis><literal>(r1)</literal>
<literal>l.lwz   r9,</literal><emphasis>save_loc</emphasis><literal>-4(r1)</literal>
<literal>l.lwz   r2,</literal><emphasis>save_loc</emphasis><literal>(r1)</literal>
<literal>l.jr    r9</literal>
<literal>l.addi  r1,r1,</literal><emphasis>frame_size</emphasis>
</literallayout>
	</informalexample>

	<para>
	  Only those parts of the epilogue which correspond to the prologue
	  need actually appear. The OpenRISC 1000 has a delay slot after
	  branch instructions, so for efficiency the stack restoration can be
	  placed after the <literal>l.jr</literal> instruction.
	</para>

	<para>
	  The OpenRISC 1000 &gdbarch; requires custom functions to create and
	  remote dummy stack frames (<function>or1k_unwind_dummy_id</function>
	  and <function>or1k_push_dummy_call</function>). These allow &gdb; to
	  evaluate functions in the target, with a correct stack, so that
	  backtraces will work correctly.
	</para>

	<para>
	  There are a group of functions to return information about the
	  stack. <function>or1k_return_value</function> given a type returns
	  an <type>enum</type> for the style of return (via register, on the stack, by
	  reference). <function>or1k_skip_prolog</function> returns the address
	  at the end of a function
	  prologue. <function>core_addr_lessthan</function> tests two stack
	  addresses, so &gdb; can work out whether the stack rises or
	  falls. <function>or1k_frame_align</function> enforces the correct
	  alignment for stack
	  frames. <function>or1k_single_step_through_delay</function> tests if
	  the processor is executing a delay
	  slot. <function>or1k_unwind_pc</function> and
	  <function>or1k_unwind_sp</function> get the value of the program
	  counter and stack pointer respectively from &this; frame, given a
	  pointer to the &next; frame.
	</para>

	<para>
	  These functions all have a 1:1 relationship with &gdbarch;. However
	  for stack analysis (or "sniffing") more than one approach may be
	  appropriate, so a list of functions is maintained.
	</para>

	<para>
	  The low level stack analysis functions are set by
	  <function>frame_unwind_append_sniffer</function>. The OpenRISC 1000
	  has its own sniffers for finding the ID of a frame and getting the
	  value of a register on the frame specified by
	  <function>or1k_frame_sniffer</function>. For all other sniffing
	  functions, the default DWARF2 frame sniffer is used,
	  <function>dwarf2_frame_sniffer</function>.
	</para>

	<para>
	  The high level sniffer finds the base of the stack frame. OpenRISC
	  defines its own base sniffer,
	  <structname>or1k_frame_base</structname> as default, using
	  <function>frame_base_set_default</function> and adds the
	  DWARF2 frame sniffer,
	  <structname>dwarf2_frame_base_sniffer</structname> as an alternative
	  using <function>frame_base_append_sniffer</function>. The frame base
	  is a structure, with entries pointing to the corresponding frame
	  sniffer and functions to give the base address of the frame, the
	  arguments on the frame and the local variables on the frame. Since
	  these are all the same for the OpenRISC 1000, the same function,
	  <function>or1k_frame_base_address</function> is used for all three.
	</para>
  
	<sect3 id="sec_or1k_frame_funcs">
	  <title>
	    OpenRISC 1000 Frame Handling Functions
	  </title>

	  <para>
	    The first group of functions are the frame sniffers and their
	    support routines.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_frame_base_address</function>. The
		specification of this function
		appears to require the end of the stack, i.e. the stack
		pointer. However it is used by &gdb; to determine the value of
		the <varname>$fp</varname> variable (which makes sense from
		the name), so here it yields the value of the frame pointer
		(&gpr;&nbsp;2). Like all the frame sniffers, it is passed the
		address of the &next; frame, and requires the value for &this;
		frame, so the value of the frame pointer is unwound from the
		stack by using the generic register unwinder:
	      </para>

	      <programlisting>frame_unwind_register_unsigned (next_frame, OR1K_FP_REGNUM);</programlisting>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_sniffer</function>. This function just
		returns a pointer to
		<structname>struct&nbsp;frame_unwind</structname> with entries
		for the functions defined by this sniffer. For the OpenRISC
		1000, this structure is the global,
		<varname>or1k_frame_unwind</varname>. This defines a custom
		function to construct the frame ID of &this; frame given a
		pointer to the &next; frame
		(<function>or1k_frame_this_id</function>) and a custom
		function to give the value of a register in &this; frame given
		a pointer to the next frame.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_this_id</function>. This function's inputs
		are a pointer to the &next; frame and the prologue cache
		(if any exists) for &this; frame. It
		uses the main OpenRISC 1000 frame analyze,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>

	      <para>
		From the cached data, the function returns the
		<emphasis>frame&nbsp;ID</emphasis>. This comprises two values,
		the stack pointer for this frame and the address of the code
		(typically the entry point) for the function using this stack
		frame<footnote>
		  <para>
		    Strictly speaking frame IDs can have a third value, the
		    <emphasis>special address</emphasis> for use with
		    architectures which have more complex frame
		    structures. However this is rarely used.
		  </para>
		</footnote>.
	      </para>

	      <para>
		The result is returned in a
		<structname>struct&nbsp;frame_id</structname> passed by
		reference as a third argument. Since the implementation uses
		the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_id</function> function to decode the
		frame ID from the cache.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_prev_register</function>. This function's
		inputs are a pointer to the &next; frame, the prologue cache
		(if any exists) for &this; frame and a register number. It
		uses the main OpenRISC 1000 frame analyzer,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>

	      <para>
		From the cached data, a flag is returned indicating if the
		register has been optimized out (this is never the case), what
		sort of l-value the register represents (a register, memory or
		not an l-value), the address where it is saved in memory (if
		it is saved in memory), the number of a different register
		which holds the value of this register (if that is the case)
		and if a buffer is provided the actual value as obtained from
		memory or the register cache.
	      </para>

	      <para>
		Since the implementation uses the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_register</function> function to
		decode all this information from the cache.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_unwind_cache</function>. This is the
		heart of the sniffer. It must determine the frame ID for
		&this; frame given a pointer to the &next; frame and then the
		information in &this; frame about the values of registers in
		the &prev; frame.
	      </para>

	      <para>
		All this data is returned in a prologue cache (see <xref
		linkend="sec_frames" />), a reference to which is passed as an
		argument. If the cache already exists for &this; frame it can
		be returned immediately as the result.
	      </para>

	      <para>
		If the cache does not yet exist, it is allocated (using
		<function>trad_frame_cache_zalloc</function>). The first step
		is to unwind the start address of this function from the
		&next; frame. The DWARF2 information in the object file can be
		used to find the end of the prologue (using
		<function>skip_prologue_using_sale</function>).
	      </para>

	      <para>
		The code then works through each instruction of the prologue
		to find the data required.
	      </para>

	      <caution>
		<para>
		  The analysis must only consider prologue instructions that
		  have actually been executed. It is quite possible the
		  program counter is in the prologue code, and only
		  instructions that have actually been executed should be
		  analyzed.
		</para>
	      </caution>

	      <para>
		The stack pointer and program counter are found by simply
		unwinding the &next; frame. The stack pointer is the base of
		&this; frame, and is added to the cache data using
		<function>trad_frame_set_this_base</function>.
	      </para>

	      <para>
		<varname>end_iaddr</varname> marks the end of the code we
		should analyze. Only instructions with addresses less than
		this will be considered.
	      </para>

	      <para>
		The <literal>l.addi</literal> instruction should be first and
		its immediate constant field is the size of the stack. If it
		is missing, then this is a frameless call to a function. If
		the program counter is right at the start of the function,
		before the stack and frame pointers are set up, then it will
		also look like a frameless function.
	      </para>

	      <para>
		Unless we subsequently find it was saved on the stack, the
		program counter of the &prev; frame is the link register of
		&this; frame and can be recorded in the register cache.
	      </para>

	      <tip>
		<para>
		  It is essential to save the register data using the correct
		  function. Use
		  <function>trad_frame_set_reg_realreg</function> when a
		  register in the &prev; frame is obtained from a register in
		  &this; frame. Use
		  <function>trad_frame_set_reg_addr</function> when a register
		  in the &prev; frame is obtained from an address in &this;
		  frame. Use <function>trad_frame_set_reg_value</function>
		  when a register in the &prev; frame is a particular value in
		  &this; frame. The default entry for each register is that
		  its value in the &prev; frame is obtained from the same
		  register in &this; frame.
		</para>
	      </tip>

	      <para>
		For a frameless call, there is no more information to found,
		so the rest of the code analysis only applies if the frame
		size was non-zero.
	      </para>

	      <para>
		The second instruction in the prologue is where the frame
		pointer of the &prev; frame is saved. It is an error if this
		is missing. The address where it is saved (the stack pointer
		of &this; frame plus the offset in the <literal>l.sw</literal>
		instruction) is saved in the cache using
		<function>trad_frame_set_reg_addr</function>.
	      </para>

	      <para>
		The third instruction should be an <literal>l.addi</literal>
		instruction which sets the frame pointer. The frame size set
		should match the frame size set in the first instruction. Once
		this has been set up, the frame pointer can be used to yield
		the stack pointer of the previous frame. This information is
		recorded in the register cache.
	      </para>

	      <para>
		The fourth instruction is optional and saves the return
		address to the stack. If this instruction is found, the entry
		in the register cache for the program counter in the &prev;
		frame must be changed using
		<function>trad_frame_set_reg_addr</function> to indicate it is
		found at an address in this frame.
	      </para>

	      <para>
		All the subsequent instructions in the prolong should be saves
		of callee-savable registers. These are checked for until the
		code address has reached the end of the prologue. For each
		instruction that is found, the save location of the register
		is recorded in the cache using
		<function>trad_frame_set_reg_addr</function>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_size</function>,
		<function>or1k_frame_fp_loc</function>,
		<function>or1k_frame_size_check</function>,
		<function>or1k_link_address</function>,
		<function>or1k_get_saved_reg</function>. The analysis in
		<function>or1k_frame_unwind_cache</function> makes use of
		these helper routines to check each of the instructions in the
		prologue. By breaking out this code into separate functions,
		they can be reused by <function>or1k_skip_prologue</function>.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    The second group of functions are the &gdbarch; frame handling
	    functions.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_push_dummy_call</function>. This function
		creates a dummy stack frame, so that &gdb; can evaluate a
		function within the target code (for example in a
		<command>call</command> command). The input arguments include
		all the parameters for the call, including the return address
		and an address where a structure should be returned.
	      </para>

	      <para>
		The return address for the function is always breakpointed (so
		&gdb; can trap the return). This return address is written
		into the link register (in the register cache) using
		<function>regcache_cooked_write_unsigned</function>).
	      </para>

	      <para>
		If the function is to return a structure, the address where
		the structure is to go is passed as a first argument, in
		&gpr;&nbsp;3.
	      </para>

	      <para>
		The next arguments are passed in the remaining argument
		registers (up to &gpr;&nbsp;8). Structures are passed by
		reference to their locating in memory. For 32-bit
		architectures passing 64-bit arguments, a pair of registers (3
		and 3, 5 and 6 or 7 and 8) are used.
	      </para>

	      <para>
		Any remaining arguments must be pushed on the end of the
		stack. There is a difficulty here, since pushing each argument
		may leave the stack misaligned (OpenRISC 1000 specifies
		double-word alignment). So the code first works out the space
		required, then adjusts the resulting stack pointer to the
		correct alignment. The arguments can then be written to the
		stack in the correct location.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_unwind_dummy_id</function>. This is the inverse
		of <function>or1k_push_dummy_call</function>. Given a pointer
		to the &next; stack frame (which will be the frame of the
		dummy call), it returns the frame ID (that is the stack
		pointer and function entry point address) of &this; frame.
	      </para>

	      <para>
		This is not completely trivial. For a dummy frame, the &next;
		frame information about &this; frame is not necessarily
		complete, so a simple call to
		<function>frame_unwind_id</function> recurses back to this
		function <emphasis>ad infinitum</emphasis>. Instead the frame
		information is built by unwind the stack pointer and program
		counter and attempting to use DWARF2 symbol-and-line (&sal;)
		information to find the start of the function from the &pc;
		with <function>find_pc_partial_function</function>. If that
		information is not available, the program counter is used as a
		proxy for the function start address.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_return_value</function>. This function tells
		&gdb; how a value of a particular type would be returned by
		the &abi;. Structures/unions and large scalars (> 4 bytes) are
		placed in memory and returned by reference
		(<constant>RETURN_VALUE_ABI_RETURNS_ADDRESS</constant>. Smaller
		scalars are returned in &gpr;&nbsp;11
		(<constant>RETURN_VALUE_REGISTER_CONVENTION</constant>).
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_skip_prologue</function>. This function returns
		the end of the function prologue, if the program counter is
		currently in a function prologue.
	      </para>

	      <para>
		The initial approach is to use the DWARF2 symbol-and-line
		(&sal;) information to identify the start of the function
		(<function>find_pc_partial_function</function> and hence the
		end of the prologue
		(<function>skip_prologue_using_sal</function>).
	      </para>

	      <para>
		If this information is not reused,
		<function>or1k_skip_prologue</function> reuses the helper
		functions from the frame sniffer function,
		<function>or1k_frame_unwind_cache</function> (see <xref
		linkend="sec_or1k_frame_funcs" />) to step through code that
		appears to be function prologue.
	      </para>

	      <caution>
		<para>
		  There is some evidence that the &sal; information in
		  compiled OpenRISC 1000 programs is not always
		  correct. Occasionally code can be deemed to be in the
		  prologue, when it actually forms part of the body of the
		  function.
		</para>
	      </caution>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_align</function>. This function takes a
		stack pointer and returns a value (expanding the frame) which
		meets the stack alignment requirements of the &abi;. Since the
		OpenRISC 1000 &abi; uses a falling stack, this uses the
		built-in function, <function>align_down</function>. The
		alignment is specified in the constant
		<constant>OR1K_STACK_ALIGN</constant> defined in
		<filename>or1k-tdep.h</filename>.
	      </para>

	      <note>
		<para>
		  The OpenRISC 1000 &abi; specifies that frames should be
		  double-word aligned. However the version of &gcc; in the
		  current OpenRISC tool chain implements single-word
		  alignment. So the current &gdb; implementation specifies
		  <constant>OR1K_STACK_ALIGN</constant> to be 4, not 8.
		</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_single_step_through_delay</function>. This
		function is used to determine if a single stepped instruction
		is actually executing a delay slot. This is the case if the
		current instruction is a break instruction
		<emphasis>and</emphasis> it is the same instruction we have
		just seen.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_unwind_pc</function>,
		<function>or1k_unwind_sp</function>. Given the &next; frame,
		these functions return respectively the program counter and
		stack pointer. Since these are both ordinary registers, these
		functions map directly onto calls to
		<function>frame_unwind_register_unsigned</function>.
	      </para>
	    </listitem>
	  </itemizedlist>

	</sect3>

      </sect2>

    </sect1>

    <sect1>
      <title>
	OpenRISC 1000 &jtag; Remote Target Specification
      </title>

      <para>
	The code for the remote target specification for the OpenRISC Remote
	&jtag; protocol is found in the <filename>gdb</filename>
	sub-directory. <filename>remote-or1k.c</filename> contains the target
	definition. The low-level interface is found in
	<filename>or1k-jtag.c</filename> with a shared header in
	<filename>or1k-jtagh</filename>.
      </para>

      <para>
	The low-level interface is abstracted to a set of OpenRISC 1000
	specific functions relating to the behavior of the target, rather than
	the chosen interface. This allows alternatives to the &jtag; interface
	to be implemented in the future. The interface is captured as a set of
	functions in <structname>struct&nbsp;or1k_extra_ops</structname>.
      </para>

      <programlisting>struct or1k_extra_ops {
  void      (*to_init) (char *args);
  void      (*to_reset)();
  void      (*to_wait)();
  void      (*to_done)();
  ULONGEST  (*to_read_spr) (unsigned int  sprnum);
  void      (*to_write_spr) (unsigned int  sprnum,
                             ULONGEST      data);
  int       (*to_read_mem) (CORE_ADDR     addr,
                            gdb_byte     *buf,
                            int           len);
  int       (*to_write_mem) (CORE_ADDR       addr,
                             const gdb_byte *buf,
                             int             len);
  void      (*to_stall)();
  void      (*to_unstall)();
  void      (*to_trace)();
  void      (*to_untrace)();
};</programlisting>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>to_init</function>. Initialize a connection to the
	    target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_reset</function>. Reset the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_wait</function>. Wait for the target to stall.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_done</function>. Close the connection to the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_read_spr</function> and
	    <function>to_write_spr</function>. Read or write a special
	    purpose register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_read_mem</function> and
	    <function>to_write_mem</function>. Read or write a block of
	    memory.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_stall</function> and
	    <function>to_unstall</function>. Stall or unstall the target.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <function>to_trace</function> and
	    <function>to_untrace</function>. Turn hardware trace on or off for
	    the target.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The current set of OpenRISC 1000 specific operations is pointed to by
	<varname>or1k_extra_ops</varname>. This is defined in the main
	architecture file (<filename>or1k-tdep.c</filename>), since some of
	the functions implementing additional &gdb; commands, which are
	defined there use these functions.
      </para>

      <para>
	There is a wrapper for each of these OpenRISC 1000 specific extra
	operations. This tests if the operation is defined in the structure
	pointed to by <varname>extra_ops</varname>. If it is defined, the
	function is called, otherwise an error is raised.
      </para>

      <para>
	The binaries for the remote target interface
	(<filename>remote-or1k.o</filename> and
	<filename>or1k-jtag.o</filename>) are added to the
	<filename>configure.tgt</filename> file for the OpenRISC targets. As
	noted in <xref linkend="sec_target_arch" />, this only specifies
	binaries, so dependencies on headers cannot be captured. To do this
	requires editing the <filename>Makefile.in</filename>.
      </para>

      <tip>
	<para>
	  As a shortcut for a simple port, editing
	  <filename>Makefile.in</filename> can be omitted. Instead,
	  <command>touch</command> the target specific C source files before
	  calling <command>make</command> to ensure they are rebuilt.
	</para>
      </tip>

      <para>
	The remote target is created by defining the function
	<function>_initialize_remote_or1k</function>. A new &target_ops;,
	<varname>or1k_jtag_target</varname> is populated and added as a target
	by calling <function>add_target</function>.
      </para>

      <sect2>
	<title>
	  Creating &target_ops;
	</title>

	<para>
	  The majority of the target operations are generic to OpenRISC 1000,
	  and independent of the actual low level interface. This is achieved
	  by abstracting the low level interface through
	  <varname>or1k_extra_ops</varname>.
	</para>

	<para>
	  There are a group of operations which establish the link to the
	  target and get a program ready to
	  run. <function>or1k_open</function> and
	  <function>or1k_close</function> respectively open and close the
	  connection to the target. <function>or1k_create_inferior</function>
	  and <function>or1k_mourn_inferior</function> respectively set up a
	  program ready to run on the target, and tidy up after execution has
	  completed.
	</para>

	<para>
	  There are a two functions which control the execution of the program
	  on the target. <function>or1k_resume</function> requests execution
	  to resume (or start for the first
	  time). <function>or1k_wait</function> waits for execution on the
	  target to halt, for example due to a breakpoint, by watching for the
	  processor stalling.
	</para>

	<para>
	  A group of functions control the debugger's interaction with the
	  program on the target.  <function>or1k_detach</function> disconnects
	  the debugger from the target, while leaving the program
	  running. <function>or1k_stop</function> stops execution
	  of the target, while <function>or1k_kill</function> stops execution
	  of the target more forcefully.
	</para>

	<para>
	  There are a group of functions to access the state of the
	  target. <function>or1k_fetch_registers</function> and
	  <function>or1k_store_registers</function> read and write the raw
	  &gdb; registers (the &gpr;s, program counter and supervision
	  register), with <function>or1k_prepare_to_store</function> as a
	  function that can help
	  this. <function>or1k_jtag_xfer_partial</function> is used to read
	  and write main memory. Object file loading is achieved with the
	  generic loader, <function>generic_load</function>.
	</para>

	<para>
	  The function <function>or1k_files_info</function> provides data on
	  the remote target for use by the
	  <command>info&nbsp;target</command> command.
	</para>

	<para>
	  There are a group of functions to handle breakpoints and
	  watchpoints, <function>or1k_insert_breakpoint</function>,
	  <function>or1k_remove_breakpoint</function>,
	  <function>or1k_insert_hw_breakpoint</function>,
	  <function>or1k_remove_hw_breakpoint</function>,
	  <function>or1k_insert_watchpoint</function>,
	  <function>or1k_remove_watchpoint</function> and
	  <function>or1k_stopped_by_watchpoint</function>. &gdb; allows remote
	  targets to distinguish between software and hardware
	  breakpoints. The standard functions will use a hardware breakpoint
	  if available, but otherwise use a software breakpoint. The hardware
	  functions enforce use of a hardware breakpoint. Ordinary (write
	  access) watchpoints make use of a hardware watchpoint if available,
	  but otherwise can be implemented in software (with a big performance
	  penalty). Read and read/write watchpoints can only be implemented in
	  hardware.
	</para>

	<para>
	  Various data fields are then set up. This target controls executing
	  programs, so is in the <constant>process_stratum</constant>. Once
	  the target is connected, it has access to all its memory, a stack,
	  registers and can execute, although at the time of connection the
	  processor is stalled, so not actually executing.
	</para>

	<para>
	  The last group of functions are <emphasis>not</emphasis> generic to
	  the OpenRISC 1000&mdash;they differ for each target interface. The
	  function to open a connection for a &jtag; interface is
	  <function>or1k_jtag_open</function> (which will then call the
	  interface independent <function>or1k_open</function> function). The
	  name of the interface is <literal>"jtag"</literal> (this means the
	  command to establish the connection will be <command>target jtag
	  ...</command>). Long name and documentation is also specific to the
	  interface.
	</para>

	<para>
	  Having established all the target functions, the target is added by
	  calling <function>add_target</function>
	</para>

	<para>
	  When a target is selected (with the &gdb;
	  <command>target&nbsp;jtag</command> command), the set of target
	  operations chosen for use with the OpenRISC 1000 architecture will
	  be referred to by the global variable,
	  <varname>or1k_target</varname>, defined in
	  <filename>or1k-tdep.c</filename>.
	</para>

	<note>
	  <para>
	    &gdb; has its own global variable,
	    <varname>current_target</varname>, which refers to the current set
	    of target operations. However this is not sufficient, since even
	    though a target may be connected via the OpenRISC remote
	    interface, it may not be the <emphasis>current</emphasis>
	    target. The use of strata by &gdb; means there could possibly be
	    another target which is active at the same time.
	  </para>
	</note>

	<para>
	  Much of the operation of the target interface involves manipulating
	  the debug &spr;s. Rather than continually writing them out to the
	  target, a cache of their values is maintained in
	  <varname>or1k_dbgcache</varname>, which is flushed prior to any
	  operation that will unstall the target (thus causing it to execute).
	</para>

	<sect3>
	  <title>
	    OpenRISC 1000 Remote &jtag; Target Operation Functions
	  </title>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_jtag_open</function>. This is the interface
		specific open function for the OpenRISC &jtag; protocol. It
		initializes <varname>or1k_target</varname> with the
		&target_ops; for the OpenRISC &jtag; interface and 
		initializes <varname>or1k_extra_ops</varname> with the extra
		interface operations for the OpenRISC 1000 protocol. It then
		calls <function>or1k_open</function> which is interface
		independent.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_open</function>. This is passed the arguments
		to the <command>target jtag</command> command and establishes
		the connection to the target. Any existing connections are
		tidied up by <function>target_preopen</function> and any
		instances of this target are removed from the target stack by
		<function>unpush_target</function>. Connection is then
		established through the low level interface routine,
		<function>or1k_init</function>.
	      </para>

	      <para>
		Having established an interface, the target is pushed on to
		the stack. It is marked running, which sets all the flags
		associated with a running process and updates the choice of
		current target (which depending on the stratum could be this
		target). However, the OpenRISC connection is established with
		the target processor stalled, so the
		<literal>to_has_execution</literal> flag is cleared by setting
		the macro <literal>target_has_execution</literal> to 0. It
		will be set when <function>or1k_resume</function> unstalls the
		target.
	      </para>

	      <para>
		As a matter of good housekeeping, any shared library symbols
		are cleared using <function>no_shared_libraries</function>.
	      </para>

	      <para>
		Finally the generic <function>start_remote</function> is
		called to set up the new target ready for execution. It is
		possible this could fail, so the call is wrapped in our own
		function, <function>or1k_start_remote</function>, which has
		the correct prototype to run using
		<function>catch_exception</function>. If failure occurs, the
		target can be popped, before the exception is thrown on to
		the top level.
	      </para>

	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_close</function>. This closes the connection by
		calling the low level interface function,
		<function>to_done</function> if it exists. The target will
		already have been unpushed and the inferior mourned, so these
		actions are not required.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_create_inferior</function>. This sets up a
		program to run on the target, but does not actually start it
		running. It is called in response to the &gdb;
		<command>run</command> command and is passed any arguments to
		that command. However the OpenRISC 1000 &jtag; protocol has no
		way to send arguments to the target, so these are ignored.
	      </para>

	      <para>
		Debugging is much easier if a local copy of the executable
		symbol table has been loaded with the <command>file</command>
		command. This is checked for and a warning issued. However if
		it is not present, it is perfectly acceptable to debug code on
		the target without symbol data.
	      </para>

	      <para>
		A process/thread ID needs to be established for the
		target. However since we are debugging "bare metal", there is
		no concept of a target process, so the NULL process/thread ID
		is used.
	      </para>

	      <para>
		All static data structures (breakpoint lists etc) are then
		cleared within &gdb; by calling
		<function>init_wait_for_inferior</function>.
	      </para>

	      <tip>
		<para>
		  If &gdb; for the OpenRISC 1000 is used with
		  <command>ddd</command> the warning about passing arguments will
		  often be triggered. This occurs when <command>ddd</command>
		  is asked to run a program in a separate execution window,
		  which it attempts to achieve by creating an
		  <command>xterm</command> and redirecting I/O via pseudo-TTYs
		  to that <command>xterm</command>. The redirections are
		  arguments to the &gdb; <command>run</command> command.
		</para>

		<para>
		  &gdb; for OpenRISC 1000 does not support this. The run in
		  separate window option should be disabled with
		  <command>ddd</command>.
		</para>
	      </tip>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_mourn_inferior</function>. This is the
		counterpart to <function>or1k_create_inferior</function>,
		called after execution has completed. It tidies up by calling
		the generic function
		<function>generic_mourn_inferior</function>. If the target is
		still shown as having execution, it is marked as exited, which
		will cause the selection of a new current target.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_detach</function>. This just detaches from the
		target being debugged, which is achieved by calling
		<function>or1k_close</function>. There is no explicit function
		to reattach to the target, but a call to
		<function>or1k_open</function> will achieve the same effect.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_resume</function>. This is the function which
		causes the target program to run. It is called in response to
		the <command>run</command>, <command>step</command>,
		<command>stepi</command>, <command>next</command> and
		<command>nexti</command> instructions.
	      </para>

	      <para>
		The behavior of this function is far simpler than its
		counterpart in &gdb; 5.3. &gdb; will sort out all the issues
		of re-execution after a breakpoint or watchpoint has been
		encountered (see <function>or1k_wait</function> below for more
		on this).
	      </para>

	      <para>
		The function clears the Debug Reason Register, clears any
		watchpoint status bits in Debug Mode Register 2 and then
		commits the debug registers.
	      </para>

	      <para>
		If the caller has requested single stepping, this is set using
		Debug Mode Register 1, otherwise this is cleared.
	      </para>

	      <para>
		Finally the target can be marked as executing (the first time
		<function>or1k_resume</function> is called it will not be
		executing), the debug registers written out, and the processor
		unstalled.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_wait_with_interrupt</function>. This is a
		utility function for the <function>or1k_wait</function>. It
		establishes a signal handler for <constant>SIGINT</constant>,
		the signal sent by ctrl-C. This means an executing target can
		be interrupted by using ctrl-C. A single ctrl-C will cause the
		interrupt handler <function>or1k_interrupt</function> to be
		called, which requests passive interrupt by setting the &gdb;
		global, <varname>quit_flag</varname> and then stalls the
		processor by calling <function>or1k_stop</function>. A second
		ctrl-C triggers the <function>or1k_interrupt_twice</function>
		which forces will query the user to see if they want to kill
		the debugging by raising an exception.
	      </para>

	      <para>
		The function then calls the OpenRISC target operation to wait
		for the processor to stall. When this returns, the old signal
		handler is restored.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_wait </function>. This function waits for the
		target to stall, and analyzes the cause.  Information about why
		the target stalled is returned to the caller via the
		<varname>status</varname> argument. The function returns the
		process/thread ID of the process which stalled, although for
		the OpenRISC 1000 this will always be the same value.
	      </para>

	      <para>
		After the wait returns, all register and frame caches are
		invalid, These are cleared by calling
		<function>registers_changed</function> (which in turn clears
		the frame caches).  When the processor stalls, the Debug
		Reason Register (a &spr;) shows the reason for the stall. This
		will be due to any exception set in the Debug Stop Register
		(currently only trap), due to a single step, due to a reset
		(the debugger stalls the processor on reset) or (when the
		target is the architectural simulator, Or1ksim) due to an exit
		<literal>l.nop</literal> being executed.
	      </para>

	      <para>
		In all cases the previous program counter &spr;
		points to the instruction just executed and the next program
		counter &spr; to the instruction about to be executed. For
		watchpoints and breakpoints, which generate a trap however the
		instruction at the previous program counter will not have
		completed execution. As a result, when the program resumes,
		this instruction should be re-executed without the
		breakpoint/watchpoint enabled.
	      </para>

	      <para>
		&gdb; understands this. It is sufficient to set the program
		counter to the previous program counter. &gdb; will realize
		that the instruction corresponds to a breakpoint/watchpoint
		that has just been encountered, lift the breakpoint, single
		step past the instruction and reimpose the breakpoint. This is
		achieved by a call to <function>write_pc</function> with the
		previous program counter value.
	      </para>

	      <para>
		The OpenRISC 1000 imposes a slight problem here. This approach
		works fine, except if the breakpoint was in the delay slot of
		a branch of jump instruction. In this case the re-execution
		must be not just of the previous instruction, but the one
		before that (restoring the link register as well if it was a
		jump-and-link instruction). Furthermore this must only be in
		the case where the branch was truly the preceding instruction,
		rather than the delay slot having been the target of a
		different branch instruction.
	      </para>

	      <para>
		In the absence of a "previous previous" program counter, this
		restart cannot be correct under all circumstances. For the
		time being, breakpoints on delay slots are not expected to
		work. However it is highly unlikely a source level debugger
		would ever place a breakpoint in a delay slot.
	      </para>

	      <para>
		Having sorted out the program counter readjustment, any single
		step is marked as though it were a trap. Single step does not
		set the trap exception, nor does it need re-executing, but by
		setting the flag here, the exception will be correctly mapped
		to the <constant>TARGET_SIGNAL_TRAP</constant> for return to
		&gdb;
	      </para>

	      <para>
		The response is marked as a a stopped processor
		(<constant>TARGET_WAITKIND_STOPPED</constant>).  All
		exceptions are mapped to their corresponding &gdb; signals. If
		no exception has been raised, then the signal is set to the
		default, unless the instruction just executed was
		<literal>l.nop&nbsp;1</literal>, which is used by the
		architectural simulator to indicate termination. In this case
		the response is marked as
		<constant>TARGET_WAITKIND_EXITED</constant>, and the associate
		value set to the exit return code.
	      </para>

	      <para>
		The debug reason register (which is sticky) can now be cleared
		and the process/thread ID returned.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_stop</function>. This stops the processor
		executing. To achieve this cleanly, the processor is stalled,
		single step mode is set and the processor unstalled, so
		execution will have stopped at the end of an instruction.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_kill</function>. This stops the
		processor. Hardware trace is cleared, the processor is stalled
		then reset. The target is then mourned, which will close the
		connection.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_fetch_registers</function>. This function
		populates the register cache from the actual target
		registers. The interface to the OpenRISC 1000 only provides
		for reading of memory or &spr;s. However the &gpr;s are
		mapped into the &spr; space, so can be read in this way.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_store_registers</function>. This is the inverse
		of <function>or1k_fetch_registers</function>. It writes the
		contents of the register cache back to the physical registers
		on the target.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_prepare_to_store</function>. &gdb; allows for
		targets which need some preparatory work before storing, so
		provides this function. It is not needed for the OpenRISC
		1000, so just returns.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_jtag_xfer_partial</function>. This is the
		generic function for reading and writing objects from and to
		the target. However the only class of object which needs be
		supported is read and write from memory. This is achieved
		through the low-level interface routines
		<function>or1k_read_mem</function> and
		<function>or1k_write_mem</function>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_files_info</function>. This function provides
		the initial information for
		<command>info&nbsp;target</command>. The program being run is
		identified and the state of the simulation. Additional
		information about the executable will be provided
		automatically by &gdb;
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_insert_breakpoint</function>. This function
		inserts a breakpoint. It tries to insert a hardware breakpoint
		using <function>or1k_set_breakpoint</function>. If this fails,
		the generic <function>memory_insert_breakpoint</function> is
		used to set a software breakpoint.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_set_breakpoint</function>. This is the function
		which sets a hardware breakpoint if one is available. This is
		controlled through the Debug Value Register and Debug Control
		Register 
	      </para>

	      <para>
		The first free hardware matchpoint is found by searching
		through the Debug Control Registers for a register without its
		&dvr;/&dcr; Preset (DP) flag set using
		<function>or1k_first_free_matchpoint</function>.
	      </para>

	      <para>
		The Debug Value Register is set to the address of the
		breakpoint and the Debug Control Register to trigger the
		breakpoint when the unsigned effective address of the fetched
		instruction is equal to the Debug Value Register. The number
		of matchpoints used is incremented. The corresponding
		watchpoint is marked as unchained in Debug Mode
		Register&nbsp;1 and set to trigger a trap exception in Debug
		Mode Register&nbsp;2.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_remove_breakpoint</function>. This is the
		counterpart to <function>or1k_insert_breakpoint</function>. It
		tries to clear a hardware breakpoint, and if that fails tries
		to clear a software breakpoint instead.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_clear_breakpoint</function>. This is the
		counterpart to <function>or1k_set_breakpoint</function>. The
		Debug Control Registers are searched for an entry matching the
		give address (using <function>or1k_matchpoint_equal</function>).
	      </para>

	      <para>
		If a register is found, its &dvr;/&dcr; Present flag is cleared,
		and the matchpoint marked unused in Debug Mode
		Register&nbsp;2.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_insert_hw_breakpoint</function> and
		<function>or1k_remove_hw_breakpoint</function>. These
		functions are similar to
		<function>or1k_insert_breakpoint</function> and
		<function>or1k_remove_breakpoint</function>. However if a
		hardware breakpoint is not available, they do not attempt to
		use a software (memory) breakpoint instead.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_insert_watchpoint</function>. This function
		attempts to insert a hardware watchpoint. For this it requires
		a pair of OpenRISC 1000 watchpoints chained together. The
		first will check for a memory access greater than or equal to
		the start address of interest. The second will check for a
		memory access less than or equal to the end address of
		interest. If both criteria are met. The access type can be the
		load effective address (for <command>rwatch</command>
		watchpoints), store effective address (for
		<command>watch</command> watchpoints) or both (for
		<command>awatch</command> watchpoints).
	      </para>

	      <para>
		The pair of watchpoints must be adjacent (so they can be
		chained together using Debug Mode Register 1), but it is
		possible that successive breakpoints have fragmented the use
		of watchpoints. <function>or1k_watchpoint_gc</function> is
		used to shuffle up all the existing watchpoints which can be
		moved, to find a pair of free watchpoint if possible.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_remove_watchpoint</function>. This is the
		counterpart of <function>or1k_insert_watchpoint</function>. It
		searches for an adjacent pair of watchpoints that match using
		<function>or1k_matchpoint_equal</function>. If found both are
		marked unused in their Debug Control Register and cleared from
		triggering in Debug Mode Register 2.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_stopped_by_watchpoint</function> and
		<function>or1k_stopped_by_watchpoint</function>. These
		functions are called to find out about possible watchpoints
		that have triggered. Both may use of the utility function,
		<function>or1k_stopped_watchpoint_info</function>, which
		determines if a watchpoint was triggered, if so which
		matchpoint and for what
		address. <function>or1k_stopped_watchpoint</function> just
		returns a Boolean to indicate if a watchpoint was
		triggered. <function>or1k_stopped_data_address</function> is
		called once for each watchpoint that has triggered. It returns
		the address that triggered the watchpoint and must also clear
		the watchpoint (in Debug Mode Register 2).
	      </para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>
      
      <sect2>
	<title>
	  The &jtag; Interface
	</title>

	<para>
	  The interface to the OpenRISC &jtag; system is found in
	  <filename>gdb/or1k-jtag.c</filename> and
	  <filename>gdb/or1k-jtag.h</filename>. The details are not directly
	  relevant to porting &gdb; so only an overview is given here. Full
	  details are found in the commenting within the source code.
	</para>

	<para>
	  The interface is layered, to maximize use. In particular much of the
	  functionality is the same whether the target is connected remotely
	  over TCP/IP or directly via a JP1 header connected to the parallel
	  port.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      The highest level is the public function interface, which
	      operate in terms of entities that are visible in &gdb;: open and
	      close the connection, read and write &spr;s, read and write
	      memory, stall and unstall the processor, enable and disable
	      trace and reset the processor. These functions always succeed
	      and have function prefixes <literal>or1k_jtag_</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is the abstraction provided by the OR1K &jtag;
	      protocol: read/write a &jtag; register, read/write a block of
	      &jtag; registers and select a scan chain. These functions may
	      encounter errors and will deal with them, but otherwise return
	      no error result. These are static functions (i.e. local to this
	      file), with prefixes <literal>or1k_jtag_</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is in two sets, one for use with a locally
	      connected (JP1) &jtag; and one for a remote connection over
	      TCP/IP corresponding to the functions in the previous
	      layer. These functions detect with errors and return an error
	      code to indicate an error has occurred. These are static
	      functions with prefixes: <literal>jp1_</literal> and
	      <literal>jtr_</literal> respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The final level comes in separate flavors for locally connected
	      &jtag; (low level routines to drive the JP1 interface) and
	      remote use (to build and send/receive packets over
	      TCP/IP). These functions detect errors and return an error code
	      to indicate an error has occurred. These are static function
	      with prefixes <literal>jp1_ll_</literal> and
	      <literal>jtr_ll_</literal> respectively.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  Errors are either dealt with silently or (if fatal) via the &gdb;
	  error() function.
	</para>

	<caution>
	  <para>
	    Few people now use the JP1 direct connection, and there is no
	    confidence that this code works at all!
	  </para>
	</caution>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_disasm">
      <title>
	The OpenRISC 1000 Disassembler
      </title>

      <para>	
	The OpenRISC 1000 disassembler is part of the wider
	<command>binutils</command> utility set and is found in the
	<filename>opcodes</filename> sub-directory. It provides two versions of
	the disassembly function, <function>print_insn_big_or32</function> and
	<function>print_insn_little_or32</function> for use with big-endian
	and little-endian implementations of the architecture in
	<filename>or32-dis.c</filename>
      </para>

      <para>
	The instruction decode uses a finite state automaton (&fsa;) in
	<filename>or32-opc.c</filename>. This is constructed at start-up by
	the function <function>build_automata</function> from a table
	describing the instruction set. This function is invoked from the
	<function>_initialize_or1k_tdep</function> function immediately after
	the OpenRISC 1000 architecture has been defined.
      </para>

      <para>
	The disassembler takes advantage of any symbol table information to
	replace branch and jump targets by symbolic names where possible.
      </para>
    </sect1>

    <sect1>
      <title>
	OpenRISC 1000 Specific Commands for &gdb;
      </title>

      <para>
	<xref linkend="sec_adding_commands" /> describes how to extend the
	&gdb; command set. For the OpenRISC 1000 architecture, the
	<command>info</command> command is extended to show the value of
	&spr;s (<command>info&nbsp;spr</command>) and a new command,
	<command>spr</command> is added to set the value of a &spr;<footnote>
	<para>
	    There is a strong case for this being a new sub-command of the
	    <command>set</command>. However the <command>spr</command> was
	    introduced in &gdb;&nbsp;5.0, and there is no point in replacing
	    it now.
	  </para>
	  </footnote>.
      </para>

      <para>
	Both these commands are added in
	<function>_initialize_or1k_tdep</function> after the architecture has
	been created and the disassembler automata initialized.
      </para>

      <sect2>
	<title>
	  The <command>info spr</command> Command
	</title>

	<para>
	  The new sub-command for <command>info</command> is added using
	  <function>add_info</function>
	</para>

	<programlisting>add_info ("spr", or1k_info_spr_command,
          "Show the value of a special purpose register");</programlisting>

	<para>
	  The functionality is provided in
	  <function>or1k_info_spr_command</function>. The user can specify a
	  group by name or number (the value of all registers in that group is
	  displayed), or a register name (the value of that register is
	  displayed) or a group name/number and register name/number (the
	  value of that register in the group is displayed).
	</para>

	<para>
	  The arguments are broken out from the text of the command using
	  <function>or1k_parse_params</function>, which also handles any
	  errors in syntax or semantics. If the arguments are successfully
	  parsed the results are then printed out using the UI independent
	  function, <function>ui_out_field_fmt</function>.
	</para>
      </sect2>

      <sect2>
	<title>
	  The <command>spr</command> Command
	</title>

	<para>
	  This new top level command is added, classified as a support command
	  (<constant>class_support</constant>), using the
	  <function>add_com</function> command.
	</para>

	<para>
	  The functionality is provided in
	  <function>or1k_spr_command</function>. This also uses
	  <function>or1k_parse_spr_params</function> to parse the arguments,
	  although there is now one more (the value to set). The new value is
	  written into the relevant &spr; (using
	  <function>or1k_write_spr</function>) and the change recorded using
	  <function>ui_out_field_fmt</function>.
	</para>

      </sect2>

    </sect1>

  </chapter>

  <glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>memory management unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>programmable interrupt controller</glossterm>
      <acronym>PIC</acronym>
      <glossdef>
	<para>
	  A hardware component which provides a large number of interrupt
	  ports, which are mapped onto one or two interrupt ports on an actual
	  processor. The <acronym>PIC</acronym> will provide a lookup table of
	  interrupt service functions for its interrupts, which the interrupt
	  service function on the processor can use to identify the correct
	  handler to use.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_app_note_2">
      <title id="ref_app_note_2_xr">
	&embecosm; Application Note 2. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	June 2008.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_gdb_ug">
      <title id="ref_gdb_ug_xr">
	Debugging with &gdb;: The &gnu; Source-Level Debugger,
      </title>
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      <firstname>Roland</firstname> <surname>Pesch</surname>,
      <firstname>Stan</firstname> <surname>Shebbs</surname>, et al,
      issue <issuenum>9</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_gdb_int">
      <title id="ref_gdb_int_xr">
	&gdb; Internals: A guide to the internals of the &gnu; debugger,
      </title>
      <firstname>John</firstname> <surname>Gillmore</surname> and
      <firstname>Stan</firstname> <surname>Shebbs</surname>,
      issue <issuenum>2</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdbint_toc.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_bfd">
      <title id="ref_bfd_xr">
	libbfd: The Binary File Descriptor Library,
      </title>
      <firstname>Steve</firstname> <surname>Chamberlain</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
    </bibliomixed>

    <bibliomixed id="ref_or1k_gdb">
      <title id="ref_gdb_or1k_gdb_xr">
	Debugging the OpenRISC 1000 with &gdb;: Target Processor Manual,
      </title>
      <firstname>Jeremy</firstname> <surname>Bennett</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Embecosm Limited
	</publishername>
      </publisher>
      <pubdate>
	June 2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.embecosm.com/downloads/or1k/or1k.html"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_doxygen">
      <title id="ref_gdb_doxygen_xr">
	Doxygen: Source code documentation generator tool,
      </title>
      <firstname>Dimitri</firstname> <surname>van Heesch</surname>,
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.doxygen.org"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_or1k">
      <title id="ref_gdb_or1k_xr">
	OpenRISC 1000 Architectural Manual,
      </title>
      <firstname>Damjan</firstname> <surname>Lampret</surname>,
      <firstname>Chen-Min</firstname> <surname>Chen</surname>,
      <firstname>Marko</firstname> <surname>Mlinar</surname>,
      <firstname>Johan</firstname> <surname>Rydberg</surname>,
      <firstname>Matan</firstname> <surname>Ziv-Av</surname>,
      <firstname>Chris</firstname> <surname>Ziomkowski</surname>,
      <firstname>Greg</firstname> <surname>McGary</surname>,
      <firstname>Bob</firstname> <surname>Gardner</surname>,
      <firstname>Rohit</firstname> <surname>Mathur</surname> and
      <firstname>Maria</firstname> <surname>Bolado</surname>,
      <pubdate>
	November 2005
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.opencores.org/cvsget.cgi/or1k/docs/openrisc_arch.pdf"/>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_texinfo">
      <title id="ref_texinfo_xr">
	Texinfo: The &gnu; Documentation Format
      </title>
      <firstname>Robert</firstname> J <surname>Chassell</surname> and
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      issue <issuenum>4.12</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	9 April, 2008
      </pubdate>.
    </bibliomixed>

  </bibliography>
</book>
