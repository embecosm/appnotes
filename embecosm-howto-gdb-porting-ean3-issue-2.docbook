<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY abi   "<acronym>ABI</acronym>">
<!ENTITY bfd   "<acronym>BFD</acronym>">
<!ENTITY coff  "<acronym>COFF</acronym>">
<!ENTITY dcr   "<acronym>DCR</acronym>">
<!ENTITY dvr   "<acronym>DVR</acronym>">
<!ENTITY elf   "<acronym>ELF</acronym>">
<!ENTITY fp    "<acronym>FP</acronym>">
<!ENTITY fsa   "<acronym>FSA</acronym>">
<!ENTITY gcc   "<acronym>GCC</acronym>">
<!ENTITY gdb   "<acronym>GDB</acronym>">
<!ENTITY gnu   "<acronym>GNU</acronym>">
<!ENTITY gpr   "<acronym>GPR</acronym>">
<!ENTITY html  "<acronym>HTML</acronym>">
<!ENTITY iss   "<acronym>ISS</acronym>">
<!ENTITY jtag  "<acronym>JTAG</acronym>">
<!ENTITY pc    "<acronym>PC</acronym>">
<!ENTITY pdf   "<acronym>PDF</acronym>">
<!ENTITY rtems "<acronym>RTEMS</acronym>">
<!ENTITY rsp   "<acronym>RSP</acronym>">
<!ENTITY sal   "<acronym>SAL</acronym>">
<!ENTITY soc   "<acronym>SoC</acronym>">
<!ENTITY sp    "<acronym>SP</acronym>">
<!ENTITY spr   "<acronym>SPR</acronym>">
<!ENTITY usb   "<acronym>USB</acronym>">

<!-- ========== commonly used things ========== -->

<!ENTITY or1k         "OpenRISC&nbsp;1000">
<!ENTITY null         "<constant>NULL</constant>">
<!ENTITY this         "<emphasis>THIS</emphasis>">
<!ENTITY prev         "<emphasis>PREVIOUS</emphasis>">
<!ENTITY next         "<emphasis>NEXT</emphasis>">
<!ENTITY arch         "<emphasis>arch</emphasis>">
<!ENTITY os           "<emphasis>os</emphasis>">

<!ENTITY frame_info   "<structname>struct&nbsp;frame_info</structname>">
<!ENTITY gdbarch      "<structname>struct&nbsp;gdbarch</structname>">
<!ENTITY gdbarch_info "<structname>struct&nbsp;gdbarch_info</structname>">
<!ENTITY gdbarch_tdep "<structname>struct&nbsp;gdbarch_tdep</structname>">
<!ENTITY regcache     "<structname>struct&nbsp;regcache</structname>">
<!ENTITY target_ops   "<structname>struct&nbsp;target_ops</structname>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY binutils "<application class='software'>binutils</application>">
<!ENTITY linux    "<application class='software'>Linux</application>">
<!ENTITY or1ksim  "<application class='software'>Or1ksim</application>">
<!ENTITY systemc  "<application class='software'>SystemC</application>" >

<!-- = Hardware applications = -->

<!-- = Commands = -->

<!ENTITY xterm "<application>xterm</application>" >

<!-- = Libraries = -->

<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY lgpl "GNU Lesser General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2008 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing how to port GDB

$Id$

=========================================================================== -->

<book lang="en_GB">
  <title>
    Howto: Porting the &gnu; Debugger
  </title>
  <subtitle>
    Practical Experience with the &or1k; Architecture
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      November 2008
    </pubdate>

    <releaseinfo>
      Application Note 3. Issue 2
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, Jeremy Bennett of &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software for &gnu; Debugger, including the code to support the
	&or1k; written by &embecosm; and used in this document is licensed
	under the &gpl_www;. For detailed licensing information see the files
	<filename>COPYING</filename>, <filename>COPYING3</filename>,
	<filename>COPYING.LIB</filename> and <filename>COPYING3.LIB</filename>
	in the source code.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      This document complements the existing documentation for &gdb; (<xref
      linkend="ref_gdb_ug" />, <xref linkend="ref_gdb_int" />, <xref
      linkend="ref_bfd" />). It is intended to help software engineers porting
      &gdb; to a new architecture for the first time.
    </para>

    <para>
      This application note is based on the author's experience to date. It
      will be updated in future issues. Suggestions for improvements are
      always welcome.
    </para>

    <sect1>
      <title>
	Rationale
      </title>

      <para>
	Although the &gdb; project includes a 100 page guide to its internals,
	that document is aimed primarily at those wishing to develop &gdb;
	itself. The document also suffers from three limitations.
      </para>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>Internals document</secondary>
      </indexterm>

      <orderedlist>
	<listitem>
	  <para>
	    It tends to document at a detailed level. Individual functions are
	    described well, but it is hard to get the <emphasis>big
	    picture</emphasis>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    It is incomplete. Many of the most useful sections (for example on
	    frame interpretation) are yet to be written.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Is tends to be out of date. For example the documentation of the
	    UI-Independent output describes a number of functions which no
	    longer exist.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Consequently the engineer faced with their first port of &gdb; to a new
	architecture is faced with discovering how &gdb; works by reading the
	source code and looking at how other architectures have been ported.
      </para>

      <para>
	The author of this application note went through that process when
	porting the &or1k; architecture to &gdb;. This document captures the
	learning experience, with the intention of helping others.
      </para>

    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>

      <para>
	If you are about to start a port of &gdb; to a new architecture, this
	document is for you. If at the end of your endeavors you are better
	informed, please help by adding to this document.
      </para>

      <para>
	If you have already been through the porting process, please help
	others by adding to this document.
      </para>

    </sect1>

    <sect1>
      <title>
	Further Sources of Information
      </title>

      <sect2>
	<title>
	  Written Documentation
	</title>

	<para>
	  The main user guide for &gdb; <xref linkend="ref_gdb_ug"
	  /> provides a great deal of context about how &gdb; is intended to
	  work.
	</para>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>User Guide</secondary>
	</indexterm>

	<para>
	  The &gdb; Internals document <xref linkend="ref_gdb_int" /> is
	  essential reading before and during any porting exercise. It is not
	  complete, nor is it always up to date, but it provides the first
	  place to look for explanation of what a particular function does.
	</para>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>Internals document</secondary>
	</indexterm>

	<para>
	  &gdb; relies on a separate specification of the Binary
	  file format; for each architecture. That has its own comprehensive
	  user guide <xref linkend="ref_bfd" />.
	</para>
	<indexterm>
	  <primary>&bfd;</primary>
	  <secondary>User Guide</secondary>
	</indexterm>
	<indexterm>
	  <primary>Binary File Descriptor</primary>
	  <see>&bfd;</see>
	</indexterm>

	<para>
	  The main &gdb; code base is generally well commented, particularly
	  in the headers for the major interfaces. Inevitably this must be the
	  definitive place to find out exactly how a particular function
	  behaves.
	</para>

	<para>
	  The files making up the port for the &or1k; are comprehensively
	  commented, and can be processed with Doxygen <xref
	  linkend="ref_doxygen" />. Each function's behavior, its parameters
	  and any return value is described.
	</para>
	<indexterm>
	  <primary>Doxygen</primary>
	  <secondary>use with &gdb; for &or1k;</secondary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  Other Information Channels
	</title>

	<para>
	  The main GDB website is at <ulink
	  url="http://sourceware.org/gdb/">sourceware.org/gdb/</ulink>. It is
	  supplemented by the less formal &gdb; Wiki at <ulink
	  url="http://sourceware.org/gdb/wiki/">sourceware.org/gdb/wiki/</ulink>. 
	</para>

	<para>
	  The &gdb; developer community communicate through the &gdb; mailing
	  lists and using <acronym>IRC</acronym> chat. These are always good
	  places to find solutions to problems.
	</para>

	<para>
	  The main mailing list for discussion is gdb@sourceware.org, although
	  for detailed understanding, the patches mailing list,
	  gdb-patches@sourceware.org. See the main &gdb; website for details
	  of subscribing to these mailing lists.
	</para>

	<para>
	  <acronym>IRC</acronym> is channel <literal>#gdb</literal> on
	  <literal>irc.freenode.net</literal>.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	About &embecosm;
      </title>

      <para>
	&embecosm; is a consultancy specializing in open source tools, models
	and training for the embedded software community. All &embecosm;
	products are freely available under open source licenses.
      </para>
      <indexterm>
	<primary>&embecosm;</primary>
      </indexterm>

      <para>
	&embecosm; offers a range of commercial services.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Customization of open source tools and software, including porting
	    to new architectures.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Support, tutorials and training for open source tools and software.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Custom software development for the embedded market, including
	    bespoke software models of hardware.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Independent evaluation of software tools.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	For further information, visit the &embecosm; website at <ulink
	url="http://www.embecosm.com/">www.embecosm.com</ulink>.
      </para>

    </sect1>

  </chapter>

  <chapter id="chap_gdb_internals">
    <title>
      Overview of &gdb; Internals
    </title>

    <para>
      There are three major areas to &gdb;:
    </para>

    <orderedlist>
      <listitem>
	<para>
	  The
	  <emphasis>user interface</emphasis>. How &gdb; communicates with the
	  user.
	</para>
	<indexterm>
	  <primary>user interface</primary>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  The
	  <emphasis>symbol side</emphasis>. The analysis of object files, and
	  the mapping of the information contained to the corresponding source
	  files.
	</para>
	<indexterm>
	  <primary>symbol side</primary>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  The
	  <emphasis>target side</emphasis>. Executing programs and analyzing
	  their data.
	</para>
	<indexterm>
	  <primary>target side</primary>
	</indexterm>
      </listitem>
    </orderedlist>

    <para>
      &gdb; has a very simple view of a processor. It has a block of memory
      and a block of registers. Executing code contains its state in the
      registers and in memory. &gdb; maps that information to the source level
      program being debugged.
    </para>

    <para>
      Porting a new architecture to &gdb; means providing a way to read
      executable files, a description of the &abi;, a description of the
      physical architecture and operations to access the target being
      debugged.
    </para>

    <para>
      Probably the most common use of &gdb; is to debug the architecture on
      which it is actually running. This is <emphasis>native</emphasis>
      debugging where the architecture of the host and target are the same.
    </para>
    <indexterm>
      <primary>native debugging</primary>
    </indexterm>

    <para>
      For the &or1k; &gdb; is normally run on a host separate to the target
      (typically a workstation) connecting to the &or1k; target via &jtag;,
      using the &or1k; Remote &jtag; Protocol. <emphasis>Remote</emphasis>
      debugging in this way is the most common method of working for embedded
      systems.
    </para>
    <indexterm>
      <primary>remote debugging</primary>
    </indexterm>

    <sect1>
      <title>
	&gdb; Nomenclature
      </title>

      <para>
	A full <xref linkend="sec_glossary" /> is provided at the end of this
	document. However a number of key concepts are worth explaining up
	front.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Exec</emphasis> or <emphasis>program</emphasis>. An
	    executable program, i.e. a binary file which may be run
	    independently of other programs. Commonly the term
	    <emphasis>program</emphasis> is found in user documentation, and
	    <emphasis>exec</emphasis> in comments and &gdb; internal
	    documentation.
	  </para>
	  <indexterm>
	    <primary>exec</primary>
	    <seealso>program</seealso>
	  </indexterm>
	  <indexterm>
	    <primary>executable</primary>
	    <see>exec</see>
	  </indexterm>
	  <indexterm>
	    <primary>program</primary>
	    <seealso>exec</seealso>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Inferior</emphasis>. A &gdb; entity representing a
	    program or exec which has run, is running, or will run in the
	    future. An inferior corresponds to a process or a core dump file.
	  </para>
	  <indexterm>
	    <primary>inferior</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Address space</emphasis>. A &gdb; entity which can
	    interpret addresses (that is values of type
	    <type>CORE_ADDR</type>). Inferiors must have at least one address
	    space and inferiors may share an address space.
	  </para>
	  <indexterm>
	    <primary>address space</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Thread</emphasis>. A single thread of control within an
	    inferior.
	  </para>
	  <indexterm>
	    <primary>thread</primary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	The &or1k; port for &gdb; is
	designed for "bare metal" debugging, so will have only a single
	address space and inferiors with a single thread.
      </para>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>bare metal debugging</secondary>
      </indexterm>

    </sect1>

    <sect1 id="sec_main_areas">
      <title>
	Main Functional Areas and Data Structures
      </title>

      <sect2 id="sec_bfd">
	<title>
	  Binary File Description (&bfd;)
	</title>

	<para>
	  &bfd; is a package which allows applications to use the same
	  routines to operate on object files whatever the object file
	  format. A new object file format can be supported simply by creating
	  a new &bfd; back end and adding it to the library.
	</para>
	<indexterm>
	  <primary>&bfd;</primary>
	</indexterm>

	<para>
	  The &bfd; library back end creates a
	  number of data structures describing the data held in a particular
	  type of object file. Ultimately a unique enumerated constant (of
	  type <type>enum&nbsp;bfd_architecture</type>) is defined for
	  each individual architecture. This constant is then used to access
	  the various data structures associated with the &bfd; of the
	  particular architecture.
	</para>
	<indexterm>
	  <primary>&bfd;</primary>
	  <secondary>back end</secondary>
	</indexterm>
	<indexterm>
	  <primary><type>enum bfd_architecture</type></primary>
	</indexterm>

	<para>
	  In the case of the &or1k;, 32-bit implementation (which may
	  be a &coff; or &elf; binary), the
	  enumerated constant is <constant>bfd_arch_or32</constant>.
	</para>
	<indexterm>
	  <primary>&coff;</primary>
	</indexterm>
	<indexterm>
	  <primary>&elf;</primary>
	</indexterm>
	<indexterm>
	  <primary><constant>bfd_arch_or32</constant></primary>
	</indexterm>

	<para>
	  &bfd; is part of the &binutils; package. A &binutils; implementation
	  must be provided for any architecture intending to support the &gnu;
	  tool chain.
	</para>
	<indexterm>
	  <primary>&binutils;</primary>
	</indexterm>

	<para>
	  The &or1k; is supported by the &gnu; tool chain. &bfd; back ends
	  already exist which are suitable for use with 32-bit &or1k; images
	  in &elf; or &coff; format as used with either the &rtems; or &linux;
	  operating systems.
	</para>
	<indexterm>
	  <primary>&linux;</primary>
	  <secondary>and &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&coff;</primary>
	  <secondary>and &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&elf;</primary>
	  <secondary>and &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>tool chain</secondary>
	</indexterm>

      </sect2>

      <sect2 id="sec_arch_description">
	<title>
	  Architecture Description
	</title>

	<para>
	  Any architecture to be debugged by &gdb; is described in a
	  &gdbarch;. When an object file is to be debugged, &gdb; will select
	  the correct &gdbarch; using information about the object file
	  captured in its &bfd;.
	</para>
	<indexterm>
	  <primary>&gdbarch;</primary>
	</indexterm>

	<para>
	  The data in &gdbarch; facilitates both the <emphasis>symbol
	  side</emphasis> processing (for which it also uses the &bfd;
	  information) and the <emphasis>target side</emphasis> processing (in
	  combination with the frame and target operation information).
	</para>
	<indexterm>
	  <primary>symbol side</primary>
	</indexterm>
	<indexterm>
	  <primary>target side</primary>
	</indexterm>

	<para>
	  &gdbarch; is a mixture of data values (number of bytes in an integer
	  for example) and functions to perform standard operations (e.g. to
	  print the registers). The major functional groups are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Data values capturing details of the hardware architecture. For
	      example the endianism and the number of bits in an address and
	      in a word. Some of this data is captured in the &bfd;, to which
	      there is a reference in the &gdbarch;. There is also a
	      structure, &gdbarch_tdep; to capture additional target specific
	      data, beyond that which is covered by the standard &gdbarch;.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>reference to &bfd;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Data values describing how
	      all the standard high level scalar data structures are
	      represented (<type>char</type>, <type>int</type>,
	      <type>double</type> etc).
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>data representation</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access and display registers. &gdb; includes the
	      concept of "pseudo-registers", those registers which do not
	      physically exist, but which have a meaning within the
	      architecture. For example in the &or1k;, floating point
	      registers are actually the same as the General Purpose
	      Registers. However a set of floating point pseudo-registers
	      could be defined, to allow the &gpr;s to be displayed in
	      floating point format.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>register handling</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>pseudo-register</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access information on stack frames. This includes
	      setting up "dummy" frames to allow &gdb; to evaluate functions
	      (for example using the <command>call</command> command).
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>stack frame handling</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>call</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary><function>set_gdbarch</function> functions</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

	
	<para>
	  An architecture will need to specify most of the contents of
	  &gdbarch;, for which a set of functions (all starting
	  <literal>set_gdbarch_</literal>) are provided. Defaults are provided
	  for all entries, and in a small number of cases these will be
	  suitable.
	</para>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary><function>set_gdbarch</function> functions</secondary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>default values</secondary>
	</indexterm>

	<para>
	  Analysis of the stack frames of executing programs is complex with
	  different approaches needed for different circumstances. A set of
	  functions to identify stack frames and analyze their contents is
	  associated with each &gdbarch;.
	</para>

	<para>
	  A set of utility functions are provided to access the members of
	  &gdbarch;. Element <literal>xyz</literal> of a &gdbarch; pointed to
	  by <varname>g</varname> may be accessed by using
	  <function>gdbarch_xyz&nbsp;(g, ...)</function>. This will check,
	  using <function>gdb_assert</function> that <varname>g</varname> is
	  defined, and in the case of functions that <function>g->x</function>
	  is not &null; and return either the value <literal>g->xyz</literal>
	  (for values) or the result of calling
	  <literal>g->xyz&nbsp;(...)</literal> (for functions). This saves the
	  user testing for existence before each function call, and ensures
	  any errors are handled cleanly.
	</para>
	<indexterm>
	  <primary>accessor functions</primary>
	  <secondary>&gdbarch;</secondary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  Target Operations
	</title>

	<para>
	  A set of operations is required to access a program using the target
	  architecture described by &gdbarch; in order to implement the
	  <emphasis>target side</emphasis> functionality. For any given
	  architecture there may be multiple ways of connecting to the target,
	  specified using the &gdb; <command>target</command> command. For
	  example with the &or1k; architecture, the connection may be
	  directly to a &jtag; interface connected through the host computer's
	  parallel port, or through the &or1k; Remote &jtag; Protocol
	  over TCP/IP.
	</para>
	<indexterm>
	  <primary>Remote &jtag; Protocol</primary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>Remote &jtag; Protocol</secondary>
	  <see>Remote &jtag; Protocol</see>
	</indexterm>

	<para>
	  These target operations are described in a &target_ops;. As with
	  &gdbarch; this comprises a mixture of data and functions. The major
	  functional groups are:
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>
	      Functions to establish and close down a connection to the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>opening and closing a connection</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to access registers and memory on the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>register access</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to insert and remote breakpoints and watchpoints on
	      the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>breakpoint handling</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      Functions to start and stop programs running on the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>starting and stopping programs</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      A set of data describing the features of the target, and hence
	      what operations can be applied. For example when examining a
	      core dump, the data can be inspected, but the program cannot be
	      executed.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>state information</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

	<para>
	  As with &gdbarch;, defaults are provided for the &target_ops;
	  values. In many cases these are sufficient, so need not be
	  provided.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>default values</secondary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  Adding Commands to &gdb;
	</title>

	<para>
	  &gdb;'s command handling is intended to be extensible. A set of
	  functions (defined in <filename>cli-decode.h</filename>) provide
	  that extensibility.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary>adding new commands</secondary>
	</indexterm>

	<para>
	  &gdb; groups its commands into a number of command lists (of
	  <structname>struct&nbsp;cmd_list_element</structname>), pointed to by
	  a number of global variables (defined in
	  <filename>cli-cmds.h</filename>). Of these, <varname>cmdlist</varname>
	  is the list of all defined commands. Separate lists define
	  sub-commands of various top level commands. For example
	  <varname>infolist</varname> is the list of all <command>info</command>
	  sub-commands.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary>internal representation</secondary>
	</indexterm>

	<para>
	  Commands are also classified according the the area they address, for
	  example commands that provide support, commands that examine data,
	  commands for file handling etc. These classes are specified by
	  <type>enum&nbsp;command_class</type>, defined in
	  <filename>command.h</filename>. These classes provide the top level
	  categories in which help will be given.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary>classification</secondary>
	</indexterm>
	<indexterm>
	  <primary><type>enum command_class</type></primary>
	</indexterm>

      </sect2>

    </sect1>

    <sect1 id="sec_gdbarch">
      <title>
	&gdb; Architecture Specification
      </title>

      <para>
	A &gdb; description for a new architecture, &arch; is created by
	defining a global function
	<function>_initialize_&arch;_tdep</function>, by
	convention in the source file <filename>&arch;-tdep.c</filename>. In the
	case of the &or1k;, this function is called
	<function>_initialize_or1k_tdep</function> and is found in the file
	<filename>or1k-tdep.c</filename>.
      </para>
      <indexterm>
	<primary><function>_initialize_&arch;_tdep</function></primary>
      </indexterm>
      <indexterm>
	<primary><function>_initialize_or1k_tdep</function></primary>
      </indexterm>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>new architecture description</secondary>
      </indexterm>

      <para>
	The resulting object files containing the implementation of the
	<function>_initialize_&arch;_tdep</function> function are specified in
	the &gdb; <filename>configure.tgt</filename> file, which includes a
	large case statement pattern matching against the
	<option>--target</option> option of the <command>configure</command>
	command.
      </para>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>configuration</secondary>
	<seealso><filename>configure.tgt</filename> file</seealso>
      </indexterm>
      <indexterm>
	<primary><filename>configure.tgt</filename> file</primary>
	<seealso>&gdb; configuration</seealso>
      </indexterm>

      <para>
	The new &gdbarch; is created within the
	<function>_initialize_&arch;_tdep</function> function by calling
	<function>gdbarch_register</function>:
      </para>
      <indexterm>
	<primary>&gdbarch;</primary>
	<secondary>creating new instance</secondary>
      </indexterm>
      <indexterm>
	<primary><function>gdbarch_register</function></primary>
      </indexterm>

      <informalexample>
	<programlisting>
void gdbarch_register (enum bfd_architecture    architecture,
                       gdbarch_init_ftype      *init_func,
                       gdbarch_dump_tdep_ftype *tdep_dump_func);
	</programlisting>
      </informalexample>

      <para>
	For example the <function>_initialize_or1k_tdep</function> creates
	its architecture for 32-bit &or1k; architectures by calling.
      </para>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>creating new &gdbarch; for</secondary>
      </indexterm>
      <indexterm>
	<primary><function>_initialize_or1k_tdep</function></primary>
      </indexterm>

      <informalexample>
	<programlisting>
gdbarch_register (bfd_arch_or32, or1k_gdbarch_init, or1k_dump_tdep);
	</programlisting>
      </informalexample>

      <para>
	The <varname>architecture</varname> enumeration will identify the
	unique &bfd; for this architecture (see <xref linkend="sec_bfd"
	/>). The <function>init_func</function> is called to create and return
	the new &gdbarch; (see <xref linkend="sec_gdbarch" />). The
	<function>tdep_dump_func</function> is a function which will dump the
	target specific details associated with this architecture (also
	described in <xref linkend="sec_gdbarch" />).
      </para>
      <indexterm>
	<primary>&gdbarch;</primary>
	<secondary>reference to &bfd;</secondary>
      </indexterm>

      <para>
	The call to <function>gdbarch_register</function> (see <xref
	linkend="sec_main_areas" />) specifies a function which will
	define a &gdbarch; for a particular &bfd; architecture.
      </para>
      <indexterm>
	<primary><function>gdbarch_register</function></primary>
      </indexterm>

      <informalexample>
	<programlisting>
struct gdbarch  gdbarch_init_func (struct gdbarch_info  info,
                                   struct gdbarch_list *arches);
	</programlisting>
      </informalexample>

      <para>
	For example, in the case of the &or1k; architecture, the
	initialization function is <function>or1k_gdbarch_init</function>.
      </para>
      <indexterm>
	<primary><function>or1k_gdbarch_init</function></primary>
      </indexterm>

      <tip>
	<para>
	  By convention all target specific functions and global variables
	  in &gdb; begin with a string unique to that architecture. This
	  helps to avoid namespace pollution when using C. Thus all the MIPS
	  specific functions begin <literal>mips_</literal>, the ARM specific
	  functions begin <literal>arm_</literal> etc.
	</para>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>naming conventions</secondary>
	</indexterm>

	<para>
	  For the &or1k; all target specific functions and global
	  variables begin with <literal>or1k_</literal>.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>naming conventions</secondary>
	</indexterm>
      </tip>

      <sect2>
	<title>
	  Looking up an Existing Architecture
	</title>

	<para>
	  The first argument to the architecture initialization function is a
	  &gdbarch_info; containing all the known information about this
	  architecture (deduced from the &bfd; enumeration provided to
	  <function>gdbarch_register</function>). The second argument is a list
	  of the currently defined architectures within &gdb;.
	</para>
	<indexterm>
	  <primary>&gdbarch_info;</primary>
	</indexterm>

	<para>
	  The lookup is done using
	  <function>gdbarch_list_lookup_by_info</function>. It is passed the
	  list of existing architectures and the &gdbarch_info; (possibly
	  updated) and returns the first matching architecture it finds, or
	  &null; if none are found. If an architecture is found, the
	  initialization function can finish, returning the found architecture
	  as result.
	</para>
	<indexterm>
	  <primary><function>gdbarch_list_lookup_by_info</function></primary>
	</indexterm>

	<sect3>
	  <title>
	    &gdbarch_info;
	  </title>

	  <para>
	    The &gdbarch_info; has the following components:
	  </para>
	  <indexterm>
	    <primary>&gdbarch_info;</primary>
	    <secondary>fields in the structure</secondary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
struct gdbarch_info
{
  const struct bfd_arch_info *bfd_arch_info;
  int                         byte_order;
  bfd                        *abfd;
  struct gdbarch_tdep_info   *tdep_info;
  enum gdb_osabi              osabi;
  const struct target_desc   *target_desc;
};
	    </programlisting>
	  </informalexample>

	  <para>
	    <varname>bfd_arch_info</varname> holds the key details about the
	    architecture. <varname>byte_order</varname> is an enumeration
	    indicating the endianism. <varname>abfd</varname> is a pointer to
	    the full &bfd;, <varname>tdep_info</varname> is additional custom
	    target specific information, <varname>gdb_osabi</varname> is an
	    enumeration identifying which (if any) of a number of operating
	    specific &abi;s are used by this architecture and
	    <varname>target_desc</varname> is a set of name-value pairs with
	    information about register usage in this target.
	  </para>
	  <indexterm>
	    <primary>&gdbarch_info;</primary>
	    <secondary>byte order</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>byte order</primary>
	  </indexterm>

	  <para>
	    When the &gdbarch; initialization function is called, not all the
	    fields are provided&mdash;only those which can be deduced from the
	    &bfd;. The &gdbarch_info; is used as a look-up key with the list of
	    existing architectures (the second argument to the initialization
	    function) to see if a suitable architecture already exists. The
	    <varname>tdep_info</varname> <varname>osabi</varname> and
	    <varname>target_desc</varname> fields may be added before this
	    lookup to refine the search.
	  </para>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>architecture lookup</secondary>
	    <seealso><function>gdbarch_list_lookup_by_info</function></seealso>
	  </indexterm>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  Creating a New Architecture
	</title>

	<para>
	  If no architecture is found, then a new architecture must be
	  created, by calling <function>gdbarch_alloc</function> using the
	  supplied &gdbarch_info; and and any additional custom target specific
	  information in a &gdbarch_tdep;.
	</para>
	<indexterm>
	  <primary><function>gdbarch_alloc</function></primary>
	</indexterm>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>creating new instance</secondary>
	  </indexterm>

	<para>
	  The newly created &gdbarch; must then be populated. Although there are
	  default values, in most cases they are not what is required. For each
	  element, <emphasis>X</emphasis>, there is a corresponding accessor
	  function to set the value of that element,
	  <function>set_gdbarch_X</function>.
	</para>

	<para>
	  The following sections identify the main elements that should be set
	  in this way. This is not the complete list, but represents the
	  functions and elements that must commonly be specified for a new
	  architecture. Many of the functions are described in the header file,
	  <filename>gdbarch.h</filename> and many may be found in the &gdb;
	  Internals document <xref linkend="ref_gdb_int" />.
	</para>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>Internals document</secondary>
	</indexterm>
	<indexterm>
	  <primary><filename>gdbarch.h</filename> file</primary>
	</indexterm>

	<sect3>
	  <title>
	    &gdbarch_tdep;
	  </title>

	  <informalexample>
	    <programlisting>
struct gdbarch *gdbarch_alloc (const struct gdbarch_info *info,
                               struct gdbarch_tdep       *tdep);
	    </programlisting>
	  </informalexample>

	  <para>
	    &gdbarch_tdep; is not defined within &gdb;&mdash;it is up to the
	    user to define this <literal>struct</literal> if it is needed to
	    hold custom target information that is not covered by the standard
	    &gdbarch;. For example with the &or1k; architecture it is
	    used to hold the number of matchpoints available in the target
	    (along with other information). If there is no additional target
	    specific information, it can be set to &null;.
	  </para>
	  <indexterm>
	    <primary>&gdbarch_tdep;</primary>
	  </indexterm>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  Specifying the Hardware Data Representation
	</title>

	<para>
	  A set of values in &gdbarch; define how different data types are
	  represented within the architecture.
	</para>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>data representation</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>short_bit</varname>. Number of bits in a C/C++
	      <type>short</type> variable. Default is
	      <literal>2*TARGET_CHAR_BIT</literal>.
	      <constant>TARGET_CHAR_BIT</constant> is a defined constant, which
	      if not set explicitly defaults to 8.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields and functions</secondary>
	      <tertiary><varname>short_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><constant>TARGET_CHAR_BIT</constant></primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>int_bit</varname>, <varname>long_bit</varname>,
	      <varname>long_long_bit</varname>, <varname>float_bit</varname>,
	      <varname>double_bit</varname>,
	      <varname>long_double_bit</varname>. These are analogous to
	      <varname>short</varname> and are the number of bits in a C/C++
	      variable of the corresponding time. Defaults are
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>int</type>,
	      <type>long</type> and <type>float</type> and
	      <literal>4*TARGET_CHAR_BIT</literal> for <type>long long</type>,
	      <type>double</type> and <type>long double</type>.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>int_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>long_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>long_long_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>float_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>double_bit</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>long_double_bit</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>ptr_bit</varname>. Number of bits in a C/C++
	      pointer. Default is <literal>4*TARGET_CHAR_BIT</literal>.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>ptr_bit</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>addr_bit</varname>. Number of bits in a C/C++
	      address. Almost always this is the same as the number of bits in
	      a pointer, but there are a small number of architectures for
	      which pointers cannot reach all addresses. Default is
	      <literal>4*TARGET_CHAR_BIT</literal>.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>addr_bit</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>float_format</varname>,
	      <varname>double_format</varname> and
	      <varname>long_double_format</varname>. These point to an array
	      of C&nbsp;<literal>struct</literal>s (one for each endianism),
	      defining the format for each of the floating point types. A
	      number of these arrays are predefined. They in turn are built on
	      top of a set of standard types defined by the library
	      <application>libiberty</application>.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>float_format</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>double_format</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>long_double_format</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><application>libiberty</application></primary>
	      <secondary>floating point formats</secondary>
	    </indexterm>
	  </listitem>
	    
	  <listitem>
	    <para>
	      <varname>char_signed</varname>. 1 if <type>char</type> to be
	      treated as signed, 0 if <type>char</type> is to be treated as
	      unsigned. The default is -1 (undefined), so this should always
	      be set.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>char_signed</varname></tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  Specifying the Hardware Architecture and &abi;
	</title>

	<para>
	  A set of function members of &gdbarch; define aspects of the
	  architecture and its &abi;. For some of these functions, defaults
	  are provided which will be suitable for most architectures.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>return_value</function>. This function determines the
	      return convention for a given data type. For example on the
	      &or1k;, structs/unions and large (>32 bit) scalars are
	      returned as references, while small scalars are returned in
	      &gpr;&nbsp;11. This function should always be defined.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>return_value</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>&abi;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Application Binary Interface</primary>
	      <see>&abi;</see>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>breakpoint_from_pc</function>. Returns the breakpoint
	      instruction to be used when the &pc; is at a particular location
	      in memory. For architectures with variable length instructions,
	      the choice of breakpoint instruction may depend on the length of
	      the instruction at the program counter. Returns the instruction
	      sequence and its length.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>breakpoint_from_pc</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &gdbarch;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>instruction</secondary>
	      <tertiary>size</tertiary>
	    </indexterm>

	    <para>
	      The default value is &null; (undefined). This function should
	      always be defined if &gdb; is to support breakpointing for this
	      architecture.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>adjust_breakpoint_address</function>. Some
	      architectures do not allow breakpoints to be placed at all
	      points. Given a program counter, this function returns an
	      address where a breakpoint <emphasis>can</emphasis> be
	      placed. Default value is &null; (undefined). The function need
	      only be defined for architectures which cannot accept a
	      breakpoint at all program counter locations.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary>
		<function>adjust_breakpoint_address</function>
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &gdbarch;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>instruction</secondary>
	      <tertiary>restriction on location</tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>memory_insert_breakpoint</function> and
	      <function>memory_remove_breakpoint</function>. These functions
	      insert or remove memory based (a.k.a. soft) breakpoints. The
	      default values
	      <function>default_memory_insert_breakpoint</function> and
	      <function>default_memory_remove_breakpoint</function> are
	      suitable for most architectures, so in most cases these
	      functions need not be defined.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>memory_insert_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>memory_remove_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &gdbarch;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>insertion and removal</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>
		<function>default_memory_insert_breakpoint</function>
	      </primary>
	    </indexterm>
	    <indexterm>
	      <primary>
		<function>default_memory_remove_breakpoint</function>
	      </primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>decr_pc_after_break</function>. Some architectures
	      require the program counter to be decremented after a break, to
	      allow the broken instruction to be executed on resumption. This
	      function returns the number of bytes by which to decrement the
	      address. The default value is &null; (undefined) which means the
	      program counter is left unchanged. This function need only be
	      defined if the functionality is required.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>decr_pc_after_break</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &gdbarch;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>program counter adjustment after</secondary>
	    </indexterm>

	    <para>
	      In practice this function is only of use for the very simplest
	      architectures. It applies only to software breakpoints, not
	      watchpoints or hardware breakpoints. It is more usual to adjust
	      the program counter as required in the target
	      <function>to_wait</function> and <function>to_resume</function>
	      functions (see <xref linkend="sec_target_ops" />).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_wait</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_resume</function></tertiary>
	    </indexterm>
	    
	  </listitem>

	  <listitem>
	    <para>
	      <function>single_step_through_delay</function>. Returns 1 if the
	      target is executing a delay slot and a further single step is
	      needed before the instruction finishes. The default value is
	      &null; (not defined). This function should be implemented if the
	      target has delay slots.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary>
		<function>single_step_through_delay</function>
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>delay slot</primary>
	      <secondary>&gdbarch; functions to handle</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_insn</function>. Disassemble an instruction and
	      print it. Default value is &null; (undefined). This function
	      should be defined if disassembly of code is to be supported.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>print_insn</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>disassembly</primary>
	    </indexterm>

	    <para>
	      Disassembly is a function required by the
	      &binutils; library. This function is
	      defined in the <filename>opcodes</filename> sub-directory. A
	      suitable implementation may already exist if
	      &binutils; has already been ported.
	    </para>
	    <indexterm>
	      <primary>&binutils;</primary>
	      <secondary>disassembly function</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>
      </sect2>

      <sect2>
	<title>
	  Specifying the Register Architecture
	</title>

	<para>
	  &gdb; considers registers to be a set with members numbered linearly
	  from 0 upwards. The first part of that set corresponds to real
	  physical registers, the second part to any
	  "pseudo-registers". Pseudo-registers have no independent physical
	  existence, but are useful representations of information within the
	  architecture. For example the &or1k; architecture has up to
	  32 general purpose registers, which are typically represented as
	  32-bit (or 64-bit) integers. However it could be convenient to
	  define a set of pseudo-registers, to show the &gpr;s represented as
	  floating point registers.
	</para>
	<indexterm>
	  <primary>pseudo-register</primary>
	</indexterm>

	<para>
	  For any architecture, the implementer will decide on a mapping from
	  hardware to &gdb; register numbers. The registers corresponding to
	  real hardware are referred to as <emphasis>raw</emphasis> registers,
	  the remaining registers are
	  <emphasis>pseudo-</emphasis>registers. The total register set (raw
	  and pseudo) is called the <emphasis>cooked</emphasis> register set.
	</para>
	<indexterm>
	  <primary>register</primary>
	  <secondary>cooked</secondary>
	</indexterm>
	<indexterm>
	  <primary>register</primary>
	  <secondary>pseudo-</secondary>
	  <see>pseudo-register</see>
	</indexterm>
	<indexterm>
	  <primary>register</primary>
	  <secondary>raw</secondary>
	</indexterm>

	<sect3>
	  <title>
	    &gdbarch; Functions Specifying the Register Architecture
	  </title>

	  <para>
	    These functions specify the number and type of registers in the
	    architecture.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>read_pc</function> and
		<function>write_pc</function>. Functions to read the program
		counter. The default value is &null; (no function
		available). However, if the program counter is just an ordinary
		register, it can be specified in &gdbarch; instead (see
		<varname>pc_regnum</varname> below) and it will be read or
		written using the standard routines to access registers. Thus
		this function need only be specified <emphasis>if</emphasis> the
		program counter is not an ordinary register.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>read_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>write_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>program counter</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>pc_regnum</varname></tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>pseudo_register_read</function> and
		<function>pseudo_register_write</function>. These functions
		should be defined if there are any pseudo-registers (see <xref
		linkend="sec_arch_description" /> and <xref
		linkend="sec_regcache" /> for more information on
		pseudo-registers). The default value is &null;.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>pseudo_register_read</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary>pseudo_register_write</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<varname>num_regs</varname> and
		<varname>num_pseudo_regs</varname>. These define the number of
		real and pseudo-registers. They default to -1 (undefined) and
		should always be explicitly defined.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>num_regs</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>num_pseudo_regs</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>fields in &gdbarch;</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<varname>sp_regnum</varname>, <varname>pc_regnum</varname>,
		<varname>ps_regnum</varname> and
		<varname>fp0_regnum</varname>. These specify the register
		holding the stack pointer, program counter, processor status
		and first floating point register. All except the first
		floating-point register (which defaults to 0) default to -1
		(not defined). They may be real or
		pseudo-registers. <varname>sp_regnum</varname> must always be
		defined. If <varname>pc_regnum</varname> is not defined, then
		the functions <function>read_pc</function> and
		<function>write_pc</function> (see above) must be defined. If
		<varname>ps_regnum</varname> is not defined, then the
		<varname>$ps</varname> variable will not be available to the
		&gdb; user. <varname>fp0_regnum</varname> is not needed unless
		the target offers support for floating point.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>sp_regnum</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>pc_regnum</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>ps_regnum</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>fp0_regnum</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>fields in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>read_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>write_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdb;</primary>
		<secondary>built in variables</secondary>
		<tertiary><command>$ps</command></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>status register</primary>
		<see>&gdb;</see>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions Giving Register Information
	  </title>

	  <para>
	    These functions return information about registers.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>register_name</function>. This function should
		convert a register number (raw or pseudo) to a register name
		(as a C&nbsp;<type>char *</type>). This is used both to
		determine the name of a register for output and to work out
		the meaning of any register names used as input. For example
		with the &or1k;, &gdb; registers 0-31 are the General Purpose
		Registers, register 32 is the program counter and register 33
		is the supervision register, which map to the strings
		<literal>"gpr00"</literal> through <literal>"gpr31"</literal>,
		<literal>"pc"</literal> and <literal>"sr"</literal>
		respectively. This means that the &gdb; command <command>print
		$gpr5</command> should print the value of the OR1K general
		purpose register 5. The default value for this function is
		&null;. It should always be defined.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>register_name</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>&or1k;</primary>
		<secondary>register assignment in &gdb;</secondary>
	      </indexterm>

	      <para>
		Historically, &gdb; always had a concept of a <emphasis>frame
		pointer</emphasis> register, which could be accessed via the
		&gdb; variable, <command>$fp</command>. That concept is now
		deprecated, recognizing that not all architectures have a
		frame pointer. However if an architecture does have a frame
		pointer register, and defines a register or pseudo-register
		with the name <literal>"fp"</literal>, then that register will
		be used as the value of the <command>$fp</command> variable.
	      </para>
	      <indexterm>
		<primary>&gdb;</primary>
		<secondary>built in variables</secondary>
		<tertiary><command>$fp</command></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>frame pointer</primary>
		<secondary>value in <command>$fp</command></secondary>
		<see>&gdb;</see>
	      </indexterm>

	    </listitem>

	    <listitem>
	      <para>
		<function>register_type</function>. Given a register number,
		this function identifies the type of data it may be holding,
		specified as a
		<structname>struct&nbsp;type</structname>. &gdb; allows
		creation of arbitrary types, but a number of built in types
		are provided (<varname>builtin_type_void</varname>,
		<varname>builtin_type_int32</varname> etc), together with
		functions to derive types from these. Typically the program
		counter will have a type of "pointer to function" (it points
		to code), the frame pointer and stack pointer will have types
		of "pointer to void" (they point to data on the stack) and all
		other integer registers will have a type of 32-bit integer or
		64-bit integer. This information guides the formatting when
		displaying out register information. The default value is
		&null; meaning no information is available to guide formatting
		when displaying registers.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>register_type</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>struct&nbsp;type</primary>
		<secondary>built in types</secondary>
		<tertiary><varname>builtin_type_void</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>struct&nbsp;type</primary>
		<secondary>built in types</secondary>
		<tertiary><varname>builtin_type_int32</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdb;</primary>
		<secondary>value types</secondary>
		<see><structname>struct&nbsp;type</structname></see>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>print_registers_info</function>. Define this function
		to print out one or all of the registers for the &gdb;
		<command>info&nbsp;registers</command> command. The default
		value is the function
		<function>default_print_registers_info</function> which uses the
		type information (see <function>register_type</function> above)
		to determine how each register should be printed. Define this
		function for fuller control over how the registers are
		displayed.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>print_registers_info</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>
		  <function>default_print_registers_info</function>
		</primary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>print_float_info</function> and
		<function>print_vector_info</function>. Define this function to
		provide output for the &gdb; <command>info&nbsp;float</command>
		and <command>info&nbsp;vector</command> commands
		respectively. The default value is &null; (not defined), meaning
		no information will be provided. Define each function if the
		target supports floating point or vector operations
		respectively.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>print_float_info</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>print_vector_info</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>floating point</secondary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>vector</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>register_reggroup_p</function>. &gdb; groups
		registers into different categories (general, vector, floating
		point etc). This function given a register and group returns 1
		(true) if the register is in the group and 0 otherwise. The
		default value is the function
		<function>default_register_reggroup_p</function> which will do
		a reasonable job based on the type of the register (see the
		function <function>register_type</function> above), with
		groups for general purpose registers, floating point
		registers, vector registers and raw (i.e not pseudo)
		registers.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>register_reggroup_p</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>register_type</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>
		  <function>default_register_reggroup_p</function>
		</primary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3 id="sec_regcache">
	  <title>
	    Register Caching
	  </title>

	  <para>
	    Caching of registers is used, so that the target does not need to
	    be accessed and reanalyzed multiple times for each register in
	    circumstances where the register value cannot have changed.
	  </para>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>cache</secondary>
	  </indexterm>

	  <para>
	    &gdb; provides &regcache;, associated with a particular &gdbarch; to
	    hold the cached values of the raw registers. A set of functions is
	    provided to access both the raw registers (with
	    <literal>raw</literal> in their name) and the full set of cooked
	    registers (with <literal>cooked</literal> in their name). Functions
	    are provided to ensure the register cache is kept synchronized with
	    the values of the actual registers in the target.
	  </para>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>raw</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>cooked</secondary>
	  </indexterm>

	  <para>
	    Accessing registers through the &regcache; routines will ensure that
	    the appropriate &gdbarch; functions are called when necessary to
	    access the underlying target architecture. In general users should
	    use the "cooked" functions, since these will map to the "raw"
	    functions automatically as appropriate.
	  </para>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>cache access functions</secondary>
	  </indexterm>

	  <para>
	    The two key functions are <function>regcache_cooked_read</function>
	    and <function>regcache_cooked_write</function> which read or write a
	    register to or from a byte buffer (type
	    <type>gdb_byte&nbsp;*</type>). For convenience the wrapper functions
	    <function>regcache_cooked_read_signed</function>,
	    <function>regcache_cooked_read_unsigned</function>,
	    <function>regcache_cooked_write_signed</function> and
	    <function>regcache_cooked_write_unsigned</function> are provided,
	    which read or write the value and convert to or from a value as
	    appropriate.
	  </para>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>cache access functions</secondary>
	  </indexterm>
	  <indexterm>
	    <primary><function>regcache_cooked_read</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>regcache_cooked_write</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>regcache_cooked_read_signed</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>
	      <function>regcache_cooked_read_unsigned</function>
	    </primary>
	  </indexterm>
	  <indexterm>
	    <primary>
	      <function>regcache_cooked_write_signed</function>
	    </primary>
	  </indexterm>
	  <indexterm>
	    <primary>
	      <function>regcache_cooked_write_unsigned</function>
	    </primary>
	  </indexterm>
	  <indexterm>
	    <primary><type>gdb_byte</type></primary>
	  </indexterm>

	</sect3>

      </sect2>

      <sect2 id="sec_frames">
	<title>
	  Specifying Frame Handling
	</title>

	<para>
	  &gdb; needs to understand the stack on which local (automatic)
	  variables are stored. The area of the stack containing all the local
	  variables for a function invocation is known as the <emphasis>stack
	  frame</emphasis> for that function (or colloquially just as the
	  "frame"). In turn the function that called the function will have
	  its stack frame, and so on back through the chain of functions that
	  have been called.
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	</indexterm>
	<indexterm>
	  <primary>frame</primary>
	  <see>stack frame</see>
	</indexterm>

	<para>
	  Almost all architectures have one register dedicated to point to the
	  end of the stack (the <emphasis>stack pointer</emphasis>). Many have
	  a second register which points to the start of the currently active
	  stack frame (the <emphasis>frame pointer</emphasis>). The specific
	  arrangements for an architecture are a key part of the &abi;.
	</para>
	<indexterm>
	  <primary>stack pointer</primary>
	</indexterm>
	<indexterm>
	  <primary>frame pointer</primary>
	</indexterm>

	<para>
	  A diagram helps to explain this. Here is a simple program to compute
	  factorials:
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>example</secondary>
	</indexterm>

	<informalexample>
	  <programlisting>
 1:   #include &lt;stdio.h&gt;
 2:   
 3:   int fact( int  n )
 4:   {
 5:     if( 0 == n ) {
 6:       return 1;
 7:     }
 8:     else {
 9:       return n * fact( n - 1 );
10:     }
11:   }
12:   
13:   main()
14:   {
15:     int  i;
16:   
17:     for( i = 0 ; i &lt; 10 ; i++ ) {
18:       int   f = fact( i );
19:       printf( "%d! = %d\n", i, f );
20:     }
21:   }
	  </programlisting>
	</informalexample>

        <para>
	  Consider the state of the stack when the code reaches line 6 after
	  the main program has called <function>fact&nbsp;(3)</function>. The
	  chain of function calls will be <function>main</function>,
	  <function>fact&nbsp;(3)</function>,
	  <function>fact&nbsp;(2)</function>,
	  <function>fact&nbsp;(1)</function> and
	  <function>fact&nbsp;(0)</function>. In this example the stack is
	  falling (as used by the &or1k; &abi;). The stack pointer
	  (&sp;) is at the end of the stack (lowest address) and the frame
	  pointer (&fp;) is at the highest address in the current stack
	  frame. <xref linkend="fig_stack_frame" /> shows how the stack looks.
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>red zone</secondary>
	</indexterm>
	<indexterm>
	  <primary>stack pointer</primary>
	</indexterm>
	<indexterm>
	  <primary>frame pointer</primary>
	</indexterm>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>frame number</secondary>
	</indexterm>
	<indexterm>
	  <primary>frame number</primary>
	  <see>stack frame</see>
	</indexterm>
	<indexterm>
	  <primary>red zone</primary>
	  <see>stack frame</see>
	</indexterm>

	<figure id="fig_stack_frame">
	  <title>
	    An example stack frame
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="stack_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  In each stack frame, offset 0 from the stack pointer is the frame
	  pointer of the <emphasis>previous frame</emphasis> and offset 4
	  (this is illustrating a 32-bit architecture) from the stack pointer
	  is the return address. Local variables are indexed from the frame
	  pointer, with negative indexes. In the function
	  <function>fact</function>, offset -4 from the frame pointer is the
	  argument <varname>n</varname>. In the <function>main</function>
	  function, offset -4 from the frame pointer is the local variable
	  <varname>i</varname> and offset -8 from the frame pointer is the
	  local variable <varname>f</varname>.
	</para>

	<note>
	  <para>
	    This is a simplified example for illustrative purposes only. Good
	    optimizing compilers would not put anything on the stack for such
	    simple functions. Indeed they might eliminate the recursion and
	    use of the stack entirely!
	  </para>
	</note>

	<para>
	  It is very easy to get confused when examining stacks. &gdb; has
	  terminology it uses rigorously throughout. The stack frame of the
	  function currently executing, or where execution stopped is numbered
	  zero. In this example frame #0 is the stack frame of the call to
	  <function>fact&nbsp;(0)</function>. The stack frame of its calling
	  function (<function>fact(1)</function> in this case) is numbered #1
	  and so on back through the chain of calls.
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>terminology</secondary>
	</indexterm>

	<para>
	  The main &gdb; data structure describing frames is &frame_info;. It
	  is not used directly, but only via its accessor
	  functions. &frame_info; includes information about the registers in
	  the frame and a pointer to the code of the function with which the
	  frame is associated. The entire stack is represented as a linked
	  list of &frame_info;.
	</para>
	<indexterm>
	  <primary>&frame_info;</primary>
	</indexterm>

	<sect3>
	  <title>
	    Frame Handling Terminology
	  </title>

	  <para>
	    It is easy to get confused when referencing stack frames. &gdb; uses
	    some precise terminology.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		&this; frame is the frame currently under consideration.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>this frame</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>this frame</primary>
		<see>stack frame</see>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		The &next; frame, also sometimes called the
		<emphasis>inner</emphasis> or <emphasis>newer</emphasis> frame
		is the frame of the function called by the function of &this;
		frame.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>next frame</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>inner frame</tertiary>
		<see>next frame</see>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>newer frame</tertiary>
		<see>next frame</see>
	      </indexterm>
	      <indexterm>
		<primary>next frame</primary>
		<see>stack frame</see>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		The &prev; frame, also sometimes called the
		<emphasis>outer</emphasis> or <emphasis>older</emphasis> frame
		is the frame of the function which called the function of &this;
		frame.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>previous frame</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>outer frame</tertiary>
		<see>previous frame</see>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>terminology</secondary>
		<tertiary>older frame</tertiary>
		<see>previous frame</see>
	      </indexterm>
	      <indexterm>
		<primary>previous frame</primary>
		<see>stack frame</see>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	  <para>
	    So in the example of <xref linkend="fig_stack_frame" />, if &this;
	    frame is #3 (the call to <function>fact&nbsp;(3)</function>), the
	    &next; frame is frame #2 (the call to
	    <function>fact&nbsp;(2)</function>) and the &prev; frame is frame
	    #4 (the call to <function>main&nbsp;()</function>).
	  </para>

	  <para>
	    The <emphasis>innermost</emphasis> frame is the frame of the current
	    executing function, or where the program stopped, in this example,
	    in the middle of the call to <function>fact&nbsp;(0)</function>). It
	    is always numbered frame #0.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>terminology</secondary>
	    <tertiary>innermost frame</tertiary>
	  </indexterm>

	  <para>
	    The <emphasis>base</emphasis> of a frame is the address immediately
	    before the start of the &next; frame. For a falling stack this will
	    be the lowest address and for a rising stack this will be the
	    highest address in the frame.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>terminology</secondary>
	    <tertiary>frame base</tertiary>
	  </indexterm>

	  <para>
	    &gdb; functions to analyze the stack are typically given a pointer
	    to the &next; frame to determine information about &this;
	    frame. Information about &this; frame includes data on where the
	    registers of the &prev; frame are stored in this stack frame. In
	    this example the frame pointer of the &prev; frame is stored at
	    offset 0 from the stack pointer of &this; frame.
	  </para>

	  <para>
	    The process whereby a function is given a pointer to the &next;
	    frame to work out information about &this; frame is referred to as
	    <emphasis>unwinding</emphasis>. The &gdb; functions involved in this
	    typically include <literal>unwind</literal> in their name.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>unwinder</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>unwinder</primary>
	    <see>stack frame</see>
	  </indexterm>

	  <para>
	    The process of analyzing a target to determine the information that
	    should go in &frame_info; is called
	    <emphasis>sniffing</emphasis>. The functions that carry this out are
	    called <emphasis>sniffers</emphasis> and typically include
	    <literal>sniffer</literal> in their name. More than one sniffer may
	    be required to extract all the information for a particular frame.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>sniffer</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>sniffer</primary>
	    <see>stack frame</see>
	  </indexterm>

	  <para>
	    Because so many functions work using the &next; frame, there is an
	    issue about addressing the <emphasis>innermost</emphasis>
	    frame&mdash;it has no &next; frame. To solve this &gdb; creates a
	    dummy frame #-1, known as the <emphasis>sentinel</emphasis> frame.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>sentinel frame</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>frame #-1</secondary>
	    <see>stack frame</see>
	  </indexterm>
	  <indexterm>
	    <primary>sentinel frame</primary>
	    <see>stack frame</see>
	  </indexterm>
	</sect3>

	<sect3 id="sec_prologue_cache">
	  <title>
	    Prologue Caches
	  </title>

	  <para>
	    All the frame sniffing functions typically examine the code at the
	    start of the corresponding function, to determine the state of
	    registers. The &abi; will save old values and set new values of
	    key registers at the start of each function in what is known as
	    the function <emphasis>prologue</emphasis>.
	  </para>
	  <indexterm>
	    <primary>function prologue</primary>
	  </indexterm>
	  <indexterm>
	    <primary>&abi;</primary>
	    <secondary>and function prologue</secondary>
	  </indexterm>

	  <para>
	    For any particular stack frame this data does not change, so all
	    the standard unwinding functions, in addition to receiving a
	    pointer to the &next; frame as their first argument, receive a
	    pointer to a <emphasis>prologue cache</emphasis> as their second
	    argument. This can be used to store values associated with a
	    particular frame, for reuse on subsequent calls involving the same
	    frame.
	  </para>
	  <indexterm>
	    <primary>prologue cache</primary>
	  </indexterm>
	  <indexterm>
	    <primary>function prologue</primary>
	    <secondary>cache</secondary>
	    <see>prologue cache</see>
	  </indexterm>

	  <para>
	    It is up to the user to define the structure used (it is a
	    <type>void&nbsp;*</type> pointer) and arrange allocation and
	    deallocation of storage. However for general use, &gdb; provides
	    <structname>struct&nbsp;trad_frame_cache</structname>, with a set
	    of accessor routines. This structure holds the stack and code
	    address of &this; frame, the base address of the frame, a pointer
	    to the &frame_info; for the &next; frame and details of where the
	    registers of the &prev; frame may be found in &this; frame.
	  </para>
	  <indexterm>
	    <primary>
	      <structname>struct&nbsp;trad_frame_cache</structname>
	    </primary>
	  </indexterm>
	  
	  <para>
	    Typically the first time any sniffer function is called with
	    &next; frame, the prologue sniffer for &this; frame will be
	    &null;. The sniffer will analyze the frame, allocate a prologue
	    cache structure and populate it. Subsequent calls using the same
	    &next; frame will pass in this prologue cache, so the data can be
	    returned with no additional analysis.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>sniffer</secondary>
	    <tertiary>and prologue cache</tertiary>
	    <see>prologue cache</see>
	  </indexterm>
	  <indexterm>
	    <primary>prologue cache</primary>
	    <secondary>and stack frame sniffer</secondary>
	  </indexterm>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions to Analyze Frames
	  </title>

	  <para>
	    These &gdbarch; functions and value provide analysis of the stack
	    frame and allow it to be adjusted as required.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>analysis</secondary>
	  </indexterm>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>skip_prologue</function>. The prologue of a function
		is the code at the beginning of the function which sets up the
		stack frame, saves the return address etc. The code
		representing the behavior of the function starts after the
		prologue.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>skip_prologue</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>

	      <para>
		This function skips past the prologue of a function if the
		program counter is within the prologue of a function. With
		modern optimizing compilers, this may be a far from trivial
		exercise. However the required information may be within the
		binary as DWARF2 debugging information, making the job much
		easier.
	      </para>

	      <para>
		The default value is &null; (not defined). This function
		should always be provided, but can take advantage of DWARF2
		debugging information, if that is available.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>inner_than</function>. Given two frame or stack
		pointers, return 1 (true) if the first represents the "inner"
		stack frame and 0 (false) otherwise. This is used to determine
		whether the target has a rising or a falling stack frame. See
		<xref linkend="sec_frames" /> for an explanation of "inner"
		frames.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>inner_than</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>falling</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>rising</secondary>
	      </indexterm>

	      <para>
		The default value of this function is &null; and it should
		always be defined. However for almost all architectures one of
		the built-in functions can be used:
		<function>core_addr_lessthan</function> (for falling stacks)
		or <function>core_addr_greaterthan</function> (for rising
		stacks).
	      </para>
	      <indexterm>
		<primary><function>core_addr_lessthan</function></primary>
	      </indexterm>
	      <indexterm>
		<primary><function>core_addr_greaterthan</function></primary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_align</function>. The architecture may have
		constraints on how its frames are aligned. Given a proposed
		address for the stack pointer, this function returns a
		suitably aligned address (by expanding the stack frame). The
		default value is &null; (undefined). This function should be
		defined for any architecture where it is possible the stack
		could become misaligned. The utility functions
		<function>align_down</function> (for falling stacks) and
		<function>align_up</function> (for rising stacks) will
		facilitate the implementation of this function.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>frame_align</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>alignment</secondary>
	      </indexterm>
	      <indexterm>
		<primary><function>align_up</function></primary>
	      </indexterm>
	      <indexterm>
		<primary><function>align_down</function></primary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<varname>frame_red_zone_size</varname>. Some &abi;s reserve
		space beyond the end of the stack for use by leaf functions
		without prologue or epilogue or by exception handlers
		(&or1k; is in this category). This is known as a
		<emphasis>red zone</emphasis> (<acronym>AMD</acronym>
		terminology). The default value is 0. Set this field if the
		architecture has such a red zone.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>frame_red_zone_size</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>fields in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>red zone</secondary>
	      </indexterm>
	      <indexterm>
		<primary>&or1k;</primary>
		<secondary>red zone</secondary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions to Access Frame Data
	  </title>

	  <para>
	    These functions provide access to key registers and arguments in
	    the stack frame.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>unwind_pc</function> and
		<function>unwind_sp</function>. These functions are given a
		pointer to &this; stack frame (see <xref linkend="sec_frames"
		/> for how frames are represented) and return the value of the
		program counter and stack pointer respectively in the &prev;
		frame (i.e. the frame of the function that called this one).
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>unwind_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>unwind_sp</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>unwinder</secondary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>program counter</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack pointer</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_num_args</function>. Given a pointer to &this;
		stack frame (see <xref linkend="sec_frames" /> for how frames
		are represented), return the number of arguments that are
		being passed, or -1 if not known. The default value is &null;
		(undefined), in which case the number of arguments passed on
		any stack frame is always unknown. For many architectures this
		will be a suitable default.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>frame_num_args</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &gdbarch; Functions Creating Dummy Frames
	  </title>

	  <para>
	    &gdb; can call functions in the target code (for example by using
	    the <command>call</command> or <command>print</command>
	    commands). These functions may be breakpointed, and it is
	    essential that if a function does hit a breakpoint, commands like
	    <command>backtrace</command> work correctly.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary><command>call</command></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary><command>print</command></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary><command>backtrace</command></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>dummy</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dummy frame</primary>
	    <see>stack frame</see>
	  </indexterm>

	  <para>
	    This is achieved by making the stack look as though the function
	    had been called from the point where &gdb; had previously
	    stopped. This requires that &gdb; can set up stack frames
	    appropriate for such function calls.
	  </para>

	  <para>
	    The following functions provide the functionality to set up such
	    "dummy" stack frames.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>push_dummy_call</function>. This function sets up a
		dummy stack frame for the function about to be
		called. <function>push_dummy_call</function> is given the
		arguments to be passed and must copy them into registers or
		push them on to the stack as appropriate for the &abi;. &gdb;
		will then pass control to the target at the address of the
		function, and it will find the stack and registers set up just
		as expected.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>push_dummy_call</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>dummy</secondary>
		<tertiary>functions in &gdbarch;</tertiary>
	      </indexterm>

	      <para>
		The default value of this function is &null; (undefined). If the
		function is not defined, then &gdb; will not allow the user to
		call functions within the target being debugged.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>unwind_dummy_id</function>. This is the inverse of
		<function>push_dummy_call</function> which restores the stack
		and frame pointers after a call to evaluate a function using a
		dummy stack frame. The default value is &null; (undefined). If
		<function>push_dummy_call</function> is defined, then this
		function should also be defined.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>unwind_dummy_id</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>dummy</secondary>
		<tertiary>functions in &gdbarch;</tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>push_dummy_code</function>. If this function is not
		defined (its default value is &null;), a dummy call will use the
		entry point of the target as its return address. A temporary
		breakpoint will be set there, so the location must be writable
		and have room for a breakpoint.
	      </para>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>push_dummy_code</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>functions in &gdbarch;</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>dummy</secondary>
		<tertiary>functions in &gdbarch;</tertiary>
	      </indexterm>

	      <para>
		It is possible that this default is not suitable. It might not
		be writable (in ROM possibly), or the &abi; might require code
		to be executed on return from a call to unwind the stack before
		the breakpoint is encountered.
	      </para>

	      <para>
		If either of these is the case, then
		<function>push_dummy_code</function> should be defined to push
		an instruction sequence onto the end of the stack to which the
		dummy call should return.
	      </para>

	      <note>
		<para>
		  This does require that code in the stack can be
		  executed. Some Harvard architectures may not allow this.
		</para>
		<indexterm>
		  <primary>Harvard architecture</primary>
		</indexterm>
	      </note>
	    </listitem>
	  </itemizedlist>
	</sect3>

	<sect3>
	  <title>
	    Analyzing Stacks: Frame Sniffers
	  </title>

	  <para>
	    When a program stops, &gdb; needs to construct the chain of
	    &frame_info; representing the state of the stack using appropriate
	    <emphasis>sniffers</emphasis>.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>sniffer</secondary>
	  </indexterm>

	  <para>
	    Each architecture requires appropriate sniffers, but they do not
	    form entries in &gdbarch;, since more than one sniffer may be
	    required and a sniffer may be suitable for more than one
	    &gdbarch;. Instead sniffers are associated with architectures using
	    the following functions.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>frame_unwind_append_sniffer</function> is used to
		add a new sniffer to analyze &this; frame when given a pointer
		to the &next; frame.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>sniffer</secondary>
		<tertiary>functions</tertiary>
	      </indexterm>
	      <indexterm>
		<primary><function>frame_unwind_append_sniffer</function></primary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_append_sniffer</function> is used to add
		a new sniffer which can determine information about the base
		of a stack frame.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>sniffer</secondary>
		<tertiary>functions</tertiary>
	      </indexterm>
	      <indexterm>
		<primary><function>frame_base_append_sniffer</function></primary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>frame_base_set_default</function> is used to specify
		the default base sniffer.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>sniffer</secondary>
		<tertiary>functions</tertiary>
	      </indexterm>
	      <indexterm>
		<primary><function>frame_base_set_default</function></primary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	  <para>
	    These functions all take a reference to &gdbarch;, so they are
	    associated with a specific architecture. They are usually called
	    in the &gdbarch; initialization function, after the &gdbarch; has
	    been set up. Unless a default has been set, the most recently
	    appended sniffer will be tried first.
	  </para>

	  <para>
	    The main frame unwinding sniffer (as set by
	    <function>frame_unwind_append_sniffer</function>) returns a
	    structure specifying a set of sniffing functions:
	  </para>
	  <indexterm>
	    <primary><function>frame_unwind_append_sniffer</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct frame_unwind</structname></primary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
struct frame_unwind
{
  enum frame_type            type;
  frame_this_id_ftype       *this_id;
  frame_prev_register_ftype *prev_register;
  const struct frame_data   *unwind_data;
  frame_sniffer_ftype       *sniffer;
  frame_prev_pc_ftype       *prev_pc;
  frame_dealloc_cache_ftype *dealloc_cache;
};
	    </programlisting>
	  </informalexample>

	  <para>
	    The <varname>type</varname> field indicates the type of frame this
	    sniffer can handle: normal, dummy (see
	    <function>push_dummy_call</function> in <xref
	    linkend="sec_gdbarch" />), signal handler or sentinel. Signal
	    handlers sometimes have their own simplified stack structure for
	    efficiency, so may need their own handlers.
	  </para>
	  <indexterm>
	    <primary><structname>struct frame_unwind</structname></primary>
	    <secondary>fields</secondary>
	    <tertiary><varname>type</varname></tertiary>
	  </indexterm>

	  <para>
	    <varname>unwind_data</varname> holds additional information which
	    may be relevant to particular types of frame. For example it may
	    hold additional information for signal handler frames.
	  </para>
	  <indexterm>
	    <primary><structname>struct frame_unwind</structname></primary>
	    <secondary>fields</secondary>
	    <tertiary><varname>unwind_data</varname></tertiary>
	  </indexterm>

	  <para>
	    The remaining fields define functions that yield different types
	    of information when given a pointer to the &next; stack frame. Not
	    all functions need be provided. If an entry is &null;, the next
	    sniffer will be tried instead.
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>this_id</function> determines the stack pointer and
		function (code entry point) for &this; stack frame.
	      </para>
	      <indexterm>
		<primary><structname>struct frame_unwind</structname></primary>
		<secondary>functions</secondary>
		<tertiary><function>this_id</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary><structname>stack frame</structname></primary>
		<secondary>stack pointer value in</secondary>
	      </indexterm>
	      <indexterm>
		<primary><structname>stack pointer</structname></primary>
		<secondary>value in stack frame</secondary>
		<see>stack frame</see>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_register</function> determines where the values
		of registers for the &prev; stack frame are stored in &this;
		stack frame.
	      </para>
	      <indexterm>
		<primary><structname>struct frame_unwind</structname></primary>
		<secondary>functions</secondary>
		<tertiary><function>prev_register</function></tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>sniffer</function> takes a look at &this; frame's
		registers to determine if this is the appropriate unwinder.
	      </para>
	      <indexterm>
		<primary><structname>struct frame_unwind</structname></primary>
		<secondary>functions</secondary>
		<tertiary><function>sniffer</function></tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>prev_pc</function> determines the program counter
		for &this; frame. Only needed if the program counter is not an
		ordinary register (see <function>prev_pc</function> in <xref
		linkend="sec_gdbarch" />).
	      </para>
	      <indexterm>
		<primary><structname>struct frame_unwind</structname></primary>
		<secondary>functions</secondary>
		<tertiary><function>prev_pc</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>program counter</primary>
		<secondary>value in stack frame</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>dealloc_cache</function> frees any additional memory
		associated with the prologue cache for this frame (see <xref
		linkend="sec_prologue_cache" />).
	      </para>
	      <indexterm>
		<primary><structname>struct frame_unwind</structname></primary>
		<secondary>functions</secondary>
		<tertiary><function>dealloc_cache</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary><structname>prologue cache</structname></primary>
		<secondary>and stack frame sniffer</secondary>
		<tertiary>memory management</tertiary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	  <para>
	    In general it is only the <function>this_id</function> and
	    <function>prev_register</function> functions that need be defined
	    for custom sniffers.
	  </para>

	  <para>
	    The frame base sniffer is much simpler. It is a
	    <structname>struct&nbsp;frame_base</structname>, which refers to the
	    corresponding <structname>struct&nbsp;frame_unwind</structname> and
	    provides functions yielding various addresses within the frame.
	  </para>
	  <indexterm>
	    <primary>frame base sniffer</primary>
	    <see><structname>struct&nbsp;frame_base</structname></see>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>fields</secondary>
	    <tertiary><varname>unwind</varname></tertiary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
struct frame_base
{
  const struct frame_unwind *unwind;
  frame_this_base_ftype     *this_base;
  frame_this_locals_ftype   *this_locals;
  frame_this_args_ftype     *this_args;
};
	    </programlisting>
	  </informalexample>

	  <para>
	    All these functions take a pointer to the &next; frame as
	    argument. <function>this_base</function> returns the base address
	    of &this; frame, <function>this_locals</function> returns the base
	    address of local variables in &this; frame and
	    <function>this_args</function> returns the base address of the
	    function arguments in this frame.
	  </para>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_base</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_locals</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_args</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>base address</secondary>
	  </indexterm>

	  <para>
	    As described above the <emphasis>base</emphasis> address of a
	    frame is the address immediately before the start of the &next;
	    frame. For a falling stack, this is the lowest address in the
	    frame and for a rising stack it is the highest address in the
	    frame. For most architectures the same address is also the base
	    address for local variables and arguments, in which case the same
	    function can be used for all three entries.
	  </para>

	  <para>
	    It is worth noting that if it cannot be determined in any other
	    way (for example by there being a register with the name
	    <literal>"fp"</literal>), then the result of the
	    <function>this_base</function> function will be used as the value
	    of the frame pointer variable <varname>$fp</varname> in &gdb;
	  </para>
	  <indexterm>
	    <primary>&gdb;</primary>
	    <secondary>built in variables</secondary>
	    <tertiary><command>$fp</command></tertiary>
	  </indexterm>

	</sect3>

      </sect2>

    </sect1>

    <sect1 id="sec_target_ops">
      <title>
	Target Operations
      </title>

      <para>
	The communication with the target is down to a set of <emphasis>target
	operations</emphasis>. These operations are held in a &target_ops;,
	together with flags describing the behavior of the target. The
	&target_ops; elements are defined and documented in
	<filename>target.h</filename>. The sections following describe the
	most important of these functions.
	<indexterm>
	  <primary>&target_ops;</primary>
	</indexterm>
	<indexterm>
	  <primary><filename>target.h</filename></primary>
	</indexterm>
	<indexterm>
	  <primary>target operations</primary>
	  <seealso>&target_ops;</seealso>
	</indexterm>
      </para>

      <sect2>
	<title>
	  Target Strata
	</title>

	<para>
	  &gdb; has several different types of target: executable files, core
	  dumps, executing processes etc. At any time, &gdb; may have several
	  sets of target operations in use. For example target operations for
	  use with an executing process (which can run code) might be
	  different from the operations used when inspecting a core dump.
	</para>
	<indexterm>
	  <primary>target strata</primary>
	</indexterm>
	<indexterm>
	  <primary>strata</primary>
	  <see>target strata</see>
	</indexterm>

	<para>
	  All the targets &gdb; knows about are held in a stack. &gdb; walks
	  down the stack to find the set of target operations suitable for
	  use. The stack is organized as a series of <emphasis>strata</emphasis>
	  of decreasing importance: target operations for threads, then target
	  operations suitable for processes, target operations to download
	  remote targets, target operations for core dumps, target operations
	  for executable files and at the bottom target operations for dummy
	  targets. So &gdb; when debugging a running process will always select
	  target operations from the process_stratum if available, over target
	  operations from the file stratum, even if the target operations from
	  the file stratum were pushed onto the stack more recently.
	</para>

	<para>
	  At any particular time, there is a <emphasis>current</emphasis>
	  target, held in the global variable
	  <varname>current_target</varname>. This can never be &null;&mdash;if
	  there is no other target available, it will point to the dummy target.
	</para>
	<indexterm>
	  <primary>target operations</primary>
	  <secondary>current target</secondary>
	</indexterm>
	<indexterm>
	  <primary><varname>current_target</varname></primary>
	</indexterm>
	<indexterm>
	  <primary>current target</primary>
	  <see>target operations</see>
	</indexterm>
	<indexterm>
	  <primary>target operations</primary>
	  <secondary>dummy target</secondary>
	</indexterm>
	<indexterm>
	  <primary>dummy target</primary>
	  <see>target operations</see>
	</indexterm>

	<para>
	  <filename>target.h</filename> defines a set of convenience macros to
	  access functions and values in the
	  <varname>current_target</varname>. Thus
	  <function>current_target->to_xyz</function> can be accessed as
	  <function>target_xyz</function>.
	</para>
	<indexterm>
	  <primary><filename>target.h</filename> file</primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>convenience macros</secondary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary>convenience macros</primary>
	  <secondary>for &target_ops;</secondary>
	</indexterm>
	<indexterm>
	  <primary>target operations</primary>
	  <secondary>macros</secondary>
	  <see>convenience macros</see>
	</indexterm>
      </sect2>

      <sect2>
	<title>
	  Specifying a New Target
	</title>

	<para>
	  Some targets (sets of target operations in a &target_ops;) are set up
	  automatically by &gdb;&mdash;these include the operations to drive
	  simulators (see <xref linkend="ref_simulators" /> and the operations
	  to drive the &gdb; <emphasis>Remote Serial Protocol</emphasis> (&rsp;)
	  (see <xref linkend="sec_rsp" />).
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>creation</secondary>
	</indexterm>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>target creation</secondary>
	</indexterm>

	<para>
	  Other targets must be set up explicitly by the implementer, using
	  the <function>add_target</function> function. By far the most common
	  is the <emphasis>native</emphasis> target for native debugging of the
	  host. Less common is to set up a non-native target, such as the
	  &jtag; target used with the &or1k;<footnote>
	  <para>
	    For a new remote target of any kind, the recommended approach is
	    to use the standard &gdb; Remote Serial Protocol (&rsp;) and have
	    the target implement the server side of this interface. The only
	    remote targets remaining are historic legacy interfaces, such as
	    the &or1k; Remote &jtag; Protocol.
	  </para>
	  </footnote>.
	</para>
	<indexterm>
	  <primary>native debugging</primary>
	  <secondary>target creation</secondary>
	</indexterm>
	<indexterm>
	  <primary>remote debugging</primary>
	  <secondary>target creation</secondary>
	</indexterm>
	<indexterm>
	  <primary>remote debugging</primary>
	  <secondary>Remote Serial Protocol</secondary>
	  <see>Remote Serial Protocol</see>
	</indexterm>
	<indexterm>
	  <primary>Remote Serial Protocol</primary>
	</indexterm>

	<sect3>
	  <title>
	    Native Targets
	  </title>

	  <para>
	    A new native target is created by defining a function
	    <function>_initialize_&arch;_&os;_nat</function> for the
	    architecture, &arch; and operating system &os;, in the source file
	    <filename>&arch;-&os;-nat.c</filename>. A fragment of a makefile
	    to create the binary from the source is created in the file
	    <filename>config/&arch;/&os;.mh</filename> with a header giving
	    any macro definitions etc in
	    <filename>config/&arch;/nm-&os;.h</filename> (which will be linked
	    to <filename>nm.h</filename> at build time).
	  </para>
	  <indexterm>
	    <primary>native debugging</primary>
	    <secondary>target creation</secondary>
	  </indexterm>
	  <indexterm>
	    <primary><function>_initialize_&arch;_&os;_nat</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>&arch;-&os;-nat.c</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>config/&arch;/&os;.mh</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>config/&arch;/nm-&os;.h</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>nm.h</filename> file</primary>
	  </indexterm>

	  <para>
	    The <literal>_initialize_</literal> function should create a new
	    &target_ops; and call <function>add_target</function> to add this
	    target to the list of available targets.
	  </para>
	  <indexterm>
	    <primary>&target_ops;</primary>
	    <secondary>creation</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>add_target</primary>
	  </indexterm>

	  <para>
	    For new native targets there are standard implementations which
	    can be reused, with just one or two changes. For example the
	    function <function>linux_trad_target</function> returns a
	    &target_ops; suitable for most &linux; native targets. It may prove
	    necessary only to alter the description field and the functions to
	    fetch and store registers.
	  </para>
	  <indexterm>
	    <primary><function>linux_trad_target</function></primary>
	  </indexterm>

	</sect3>

	<sect3>
	  <title>
	    Remote Targets
	  </title>

	  <para>
	    For a new remote target, the procedure is a little simpler. The
	    source files should be added to <filename>configure.tgt</filename>,
	    just as for the architectural description (see <xref
	    linkend="sec_gdbarch" />). Within the source file, define a new
	    function
	    <function>_initialize_remote_&arch;</function> to
	    implement a new remote target, &arch;.
	  </para>
	  <indexterm>
	    <primary>remote debugging</primary>
	    <secondary>target creation</secondary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>configure.tgt</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>_initialize_remote_&arch;</function></primary>
	  </indexterm>

	  <para>
	    For new remote targets, the definitions in
	    <filename>remote.c</filename> used to implement the &rsp; provide a
	    good starting point.
	  </para>
	  <indexterm>
	    <primary><filename>remote.c</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>Remote Serial Protocol</primary>
	  </indexterm>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions and Variables Providing Information
	</title>

	<para>
	  These functions and variables provide information about the
	  target. The first group identifies the name of the target and
	  provides help information for the user.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_shortname</varname>. This string is the name of
	      target, for use with &gdb;s <command>target</command>. Setting
	      <varname>to_shortname</varname> to <emphasis>foo</emphasis>
	      means that
	      <command>target&nbsp;</command><emphasis>foo</emphasis> will
	      connect to the target, invoking <function>to_open</function> for
	      this target (see below).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_shortname</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><varname>to_open</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>target</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_longname</varname>. A string giving a brief
	      description of the type of target. This is printed with the
	      <command>info target</command> information (see also
	      <function>to_files_info</function> below).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_longname</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><varname>to_files_info</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>info target</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_doc</varname>. The help text for this target. If the
	      short name of the target is <emphasis>foo</emphasis>, then the
	      command <command>help&nbsp;target</command> will print
	      <literal>target </literal><emphasis>foo</emphasis> followed by
	      the first sentence of this help text. The command
	      <command>help&nbsp;target&nbsp;</command><emphasis>foo</emphasis>
	      will print out the complete text.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_doc</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>help target</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_files_info</function>. This function provides
	      additional information for the <command>info target</command>
	      command.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><varname>to_files_info</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>info target</command></secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

	<para>
	  The second group of variables provides information about the current
	  state of the target.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_stratum</varname>. An enumerated constant indicating
	      to which stratum this &target_ops; belongs
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_stratum</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>target strata</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_all_memory</varname>. Boolean indicating if the
	      target includes all of memory, or only part of it. If only part,
	      then a failed memory request may be able to be satisfied by a
	      different target in the stack.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_all_memory</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_memory</varname>. Boolean indicating if the
	      target has memory (dummy targets do not)
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_memory</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_stack</varname>. Boolean indicating if the
	      target has a stack. Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_stack</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_registers</varname>. Boolean indicating if the
	      target has registers.  Object files do not, core dumps and
	      executable threads/processes do.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_registers</varname></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_execution</varname>. Boolean indicating if the
	      target is currently executing. For some targets that is the same
	      as if they are capable of execution. However some remote targets
	      can be in the position where they are not executing until
	      <function>create_inferior</function> or
	      <function>attach</function> is called.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_execution</varname></tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions Controlling the Target Connection
	</title>

	<para>
	  These functions control the connection to the target. For remote
	  targets this may mean establishing and tearing down links using
	  protocols such as <acronym>TCP/IP</acronym>. For native targets,
	  these functions will be more concerned with setting flags describing
	  the state.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_open</function>. This function is invoked by the
	      &gdb; <command>target</command> command. Any additional
	      arguments (beyond the name of the target being invoked) are
	      passed to this function. <function>to_open</function> should
	      establish the communications with the target. It should
	      establish the state of the target (is it already running for
	      example), and initialize data structures appropriately.
	    </para>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>target</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_open</function></tertiary>
	    </indexterm>

	    <para>
	      This function should <emphasis>not</emphasis> start the target
	      running if it is not currently running&mdash;that is the job of
	      the functions (<function>to_create_inferior</function> and
	      <function>to_resume</function>) invoked by the &gdb;
	      <command>run</command> command.
	    </para>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>run</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xclose</function> and
	      <function>to_close</function>. Both these functions should close
	      the remote connection. <function>to_close</function> is the
	      legacy function. New implementations should use
	      <function>to_xclose</function> which should also free any memory
	      allocated for this target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_close</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_xclose</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>memory management</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_attach</function>. For targets which can run
	      without a debugger connected, this function attaches the
	      debugger to a running target (which should first have been
	      opened).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_attach</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_detach</function>. Function to detach from a
	      target, leaving it running.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_detach</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_disconnect</function>. This is similar to
	      <function>to_detach</function>, but makes no effort to inform
	      the target that the debugger is detaching. It should just drop
	      the connection to the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_disconnect</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_detach</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_terminal_inferior</function>. This function
	      connects the target's terminal I/O to the local terminal. This
	      functionality is not always available with remote targets.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_terminal_inferior</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>remote debugging</primary>
	      <secondary>remote terminal access</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_rcmd</function>. If the target is capable of
	      running commands, then this function requests that command to be
	      run on the target. This is of most relevance to remote targets.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_rcmd</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>remote debugging</primary>
	      <secondary>remote command execution</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Access Memory and Registers
	</title>

	<para>
	  These functions transfer data to and from the target registers and
	  memory.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_fetch_registers</function> and
	      <function>to_store_registers</function>. Functions to populate
	      the register cache with values from the target and to set target
	      registers with values in the register cache.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_fetch_registers</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_store_registers</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>cache</secondary>
	      <tertiary>synchronization with target</tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_prepare_to_store</function>. This function is
	      called prior to storing registers to set up any additional
	      information required. In most cases it will be an empty function.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_prepare_to_store</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_load</function>. Load a file into the target. For
	      most implementations, the generic function,
	      <function>generic_load</function>, which is reuses the other
	      target operations for memory access is suitable.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_load</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_xfer_partial</function>. This function is a generic
	      function to transfer data to and from the target. Its most
	      important function (often the only one actually implemented) is
	      to load and store data from and to target memory.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_xfer_partial</function></tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Handle Breakpoints and Watchpoints
	</title>

	<para>
	  For all targets, &gdb; can implement breakpoints and write access
	  watchpoints in software, by inserting code in the target. However
	  many targets provide hardware assistance for these functions which
	  is far more efficient, and in addition may implement read access
	  watchpoints.
	</para>

	<para>
	  These functions in &target_ops; provide a mechanism to access such
	  functionality if it is available.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_insert_breakpoint</function> and
	      <function>to_remove_breakpoint</function>. These functions
	      insert and remove breakpoints on the target. They can choose to
	      use either hardware or software breakpoints. However if the
	      insert function allows use of hardware breakpoints, then the
	      &gdb; command
	      <command>set&nbsp;breakpoint&nbsp;auto-hw&nbsp;off</command>
	      will have no effect.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary>
		<command>set&nbsp;breakpoint&nbsp;auto-hw&nbsp;off</command>
	      </secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_can_use_hw_breakpoint</function>. This function
	      should return 1 (true) if the target can set a hardware
	      breakpoint or watchpoint and 0 otherwise. The function is passed
	      an enumeration to indicate whether watchpoints or breakpoints
	      are being queried, and should use information about the number
	      of hardware breakpoints/watchpoints currently in use to
	      determine if a breakpoint/watchpoint can be set.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_can_use_hw_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>in hardware</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>hardware breakpoint</primary>
	      <see>breakpoint</see>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>in hardware</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>hardware watchpoint</primary>
	      <see>watchpoint</see>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_insert_hw_breakpoint</function> and
	      <function>to_remove_hw_breakpoint</function>. Functions to
	      insert and remove hardware breakpoints. Return a failure result
	      if no hardware breakpoint is available.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_hw_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_hw_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>in hardware</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_insert_watchpoint</function> and
	      <function>to_remove_watchpoint</function>. Functions to insert
	      and remove watchpoints.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_watchpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_watchpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_by_watchpoint</function>. Function returns
	      1 (true) if the last stop was due to a watchpoint.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_stopped_by_watchpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stopped_data_address</function>. If the last stop
	      was due to a watchpoint, this function returns the address of
	      the data which triggered the watchpoint.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_stopped_data_address</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>functions in &target_ops;</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &target_ops; Functions to Control Execution
	</title>

	<para>
	  for targets capable of execution, these functions provide the
	  mechanisms to start and stop execution.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>to_resume</function>. Function to tell the target to
	      start running again (or for the first time).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_resume</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_wait</function>. Function to wait for the target to
	      return control to the debugger. Typically control returns when
	      the target finishes execution or hits a breakpoint. It could
	      also occur if the connection is interrupted (for example by
	      ctrl-C).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_wait</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_stop</function>. Function to stop the
	      target&mdash;used whenever the target is to be interrupted (for
	      example by ctrl-C).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_stop</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_kill</function>. Kill the connection to the
	      target. This should work, even if the connection to the target
	      is broken.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_kill</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_create_inferior</function>. For targets which can
	      execute, this initializes a program to run, ready for it to
	      start executing. It is invoked by the &gdb;
	      <command>run</command> command, which will subsequently call
	      <function>to_resume</function> to start execution.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_create_inferior</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>remote creation</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>remote inferior</primary>
	      <see>inferior</see>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>to_mourn_inferior</function>. Tidy up after execution
	      of the target has finished (for example after it has exited or
	      been killed). Most implementations call the generic function,
	      <function>generic_mourn_inferior</function>, but may do some
	      additional tidying up.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_mourn_inferior</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>remote destruction (mourning)</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

    </sect1>

    <sect1 id="sec_adding_commands">
      <title>
	Adding Commands to &gdb;
      </title>

      <para>
	As noted in <xref linkend="sec_main_areas" />, &gdb;'s command
	handling is extensible. Commands are grouped into a number of command
	lists (of type <structname>struct&nbsp;cmd_list_element</structname>),
	pointed to by a number of global variables (defined in
	<filename>cli-cmds.h</filename>). Of these, <varname>cmdlist</varname>
	is the list of all defined commands, with separate lists defined for
	sub-commands of various top level commands. For example
	<varname>infolist</varname> is the list of all <command>info</command>
	sub-commands.
      </para>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary>adding new commands</secondary>
      </indexterm>
      <indexterm>
	<primary><structname>struct&nbsp;cmd_list_element</structname></primary>
      </indexterm>
      <indexterm>
	<primary><filename>cli-cmds.h</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><varname>cmdlist</varname></primary>
      </indexterm>
      <indexterm>
	<primary><varname>infolist</varname></primary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>info</command></secondary>
      </indexterm>

      <para>
	Each command (or sub-command) is associated with a callback function
	which implements the behavior of the functions. There are additional
	requirements for functions which set or show values within &gdb;. Each
	function also takes a documentation string (used by the help
	command). Functions for adding commands all return a pointer
	to the <structname>struct&nbsp;cmd_list_element</structname> for the
	command added (which is not necessarily the head of its command
	list). The most useful functions are:
      </para>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary>implementation functions</secondary>
	<tertiary>callback functions</tertiary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>help</command></secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>add_cmd</function>. Add a function to a command list.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary>implementation functions</secondary>
	    <tertiary><function>add_cmd</function></tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>add_com</function>. Add a function to the main command
	    list, <varname>cmdlist</varname>. This is a convenience wrapper
	    for <function>add_cmd</function>.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary>implementation functions</secondary>
	    <tertiary><function>add_com</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><varname>cmdlist</varname></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>add_prefix_cmd</function>. Add a new prefix
	    command. This command should have its own function for use if it
	    is called on its own, and a global command list pointer specific
	    to the prefix command to which all its sub-commands will be
	    added. If a prefix command is called with an unknown sub-command,
	    it can either give an error or call the function of the prefix
	    command itself. Which of these is used is specified by a flag in
	    the call to <function>add_prefix_cmd</function>.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary>implementation functions</secondary>
	    <tertiary><function>add_prefix_cmd</function></tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>add_alias_cmd</function>. Add an alias for a command
	    already defined.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary>implementation functions</secondary>
	    <tertiary><function>add_alias_cmd</function></tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>add_info</function>. Add a sub-command to the
	    <command>info</command>. A convenience wrapper for
	    <function>add_cmd</function>.
	  </para>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary>implementation functions</secondary>
	    <tertiary><function>add_info</function></tertiary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	New commands are usually added in the
	<function>_initialize_&arch;</function> function after the &gdbarch;
	has been defined.
      </para>
      <indexterm>
	<primary><function>_initialize</function> functions</primary>
      </indexterm>
    </sect1>

    <sect1 id="ref_simulators">
      <title>
	Simulators
      </title>

      <para>
	&gdb; enables implementers to link gdb to a built-in simulator, so
	that a simulated target may be executed through use of the
	<command>target&nbsp;sim</command> command.
      </para>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>target&nbsp;sim</command></secondary>
      </indexterm>

      <para>
	The simulator should be built as a library,
	<filename>libsim.a</filename>, implementing the standard &gdb;
	simulator interface. The location of the library is specified by
	setting the <parameter>gdb_sim</parameter> parameter in
	<filename>configure.tgt</filename>.
      </para>
      <indexterm>
	<primary>simulator library</primary>
      </indexterm>
      <indexterm>
	<primary><filename>libsim.a</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>configure.tgt</filename> file</primary>
	<secondary><parameter>gdb_sim</parameter> parameter</secondary>
      </indexterm>

      <para>
	The interface consists of a set of functions which should be
	implemented. The detailed specification is found in the header
	<filename>remote-sim.h</filename> in the include directory.
      </para>
      <indexterm>
	<primary><filename>remote-sim.a</filename> file</primary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>sim_open</function>. Initialize the simulator.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_open</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_open</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_close</function>. Destroy the simulator instance,
	    including freeing any memory.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_close</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_close</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_load</function>. Load a program into the simulator's
	    memory.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_load</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_load</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_create_inferior</function>. Prepare to run the
	    simulated program. Don't actually run it until
	    <function>sim_resume</function> (see below) is called.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_create_inferior</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_create_inferior</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_read</function> and
	    <function>sim_write</function>. Read and write bytes from and to
	    the simulator's memory.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_read</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_read</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_write</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_write</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_fetch_register</function> and
	    <function>sim_store_register</function>. Read and write the
	    simulator's registers.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_fetch_register</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_fetch_register</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_store_register</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_store_register</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>simulator functions</secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_info</function>. Print information for the
	    <command>info sim</command> command.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_info</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_info</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary><command>info sim</command></secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_resume</function>. Resume (or start) execution of
	    the simulated program.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_resume</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_resume</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop</function>. Stop execution of the simulated
	    program.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_stop</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_stop</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_stop_reason</function>. Return the reason why the
	    program stopped.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_stop_reason</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_stop_reason</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>sim_do_command</function>. Execute some arbitrary
	    command that the simulator supports.
	  </para>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>sim_do_command</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>sim_do_command</function></primary>
	    <see>simulator library</see>
	  </indexterm>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="sec_rsp">
      <title>
	Remote Serial Protocol (&rsp;)
      </title>

      <para>
	The &gdb; <emphasis>Remote Serial Protocol</emphasis> is a general
	purpose protocol for connecting to remote targets. It is invoked
	through the <command>target&nbsp;remote</command> and
	<command>target&nbsp;extended-remote</command> commands.
      </para>
      <indexterm>
	<primary>Remote Serial Protocol</primary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>target remote</command></secondary>
      </indexterm>

      <para>
	The protocol is a simple text command-response protocol.  The &gdb;
	session acts as the client to the protocol. It issues commands to the
	server, which in turn must be implemented by the target.  Any remote
	target can communicate with &gdb; by implementing the server side of
	the &rsp;. A number of stub implementations are provided for various
	architectures, which can be used as the basis of new
	implementations. The protocol is fully documented as an appendix
	within the main &gdb; User Guide <xref linkend="ref_gdb_ug"/>.
      </para>
      <indexterm>
	<primary>Remote Serial Protocol</primary>
	<secondary>server side implementation</secondary>
      </indexterm>

      <para>
	It is strongly recommended that any new remote target should be
	implemented using the &rsp;, rather than by creating a new remote
	target protocol.
      </para>

      <sect2>
	<title>
	  &rsp; Client Implementation
	</title>

	<para>
	  The client implementation can be found in the source files
	  <filename>remote.h</filename> and <filename>remote.c</filename> in
	  the <filename>gdb</filename> subdirectory. These implement a set of
	  target operations, as described in <xref
	  linkend="sec_target_ops"/>. Each of the standard operations is
	  mapped into a sequence of &rsp; interactions with the server on the
	  target.
	</para>

      </sect2>

      <sect2>
	<title>
	  &rsp; Server Implementation
	</title>

	<para>
	  &rsp; server implementation is a large subject in its own right, and
	  does not form a direct part of the &gdb; implementation (since it is
	  part of the target, not the debugger).
	</para>

	<para>
	  A comprehensive "Howto" has been written by Embecosm, describing the
	  implementation techniques for &rsp; servers, illustrated by examples
	  using the &or1k; architectural simulator, &or1ksim; as &rsp; target
	  <xref linkend="ref_app_note_4"/>.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	&gdb; File Organization
      </title>

      <para>
	The bulk of the &gdb; source code is in a small number of
	directories. Some components of &gdb; are libraries used elsewhere
	(for example &bfd; is used in &gnu;
	&binutils;), and these have their own
	directory. The main directories are:
      </para>
      <indexterm>
	<primary>&binutils;</primary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>include</filename>. Header files for information which
	    straddles major components. For example the main simulator
	    interface header is here (<filename>remote-sim.h</filename>),
	    because it links &gdb; (in directory <filename>gdb</filename>) to
	    the simulators (in directory <filename>sim</filename>). Other
	    headers, specific to a particular component reside in the
	    directory of that component.
	  </para>
	  <indexterm>
	    <primary><filename>include</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>remote-sim.h</filename> file</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>bfd</filename>. The Binary File Descriptor library. If a
	    new object file type must be recognized, it should be added here.
	  </para>
	  <indexterm>
	    <primary><filename>bfd</filename> directory</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb</filename>. The main &gdb; directory. All source
	    files should include <filename>defs.h</filename> first and then
	    any other headers they reference. Headers should also include any
	    headers they reference, but may assume that
	    <filename>defs.h</filename> has been included.
	  </para>
	  <indexterm>
	    <primary><filename>gdb</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>defs.h</filename> file</primary>
	  </indexterm>

	  <para>
	    The file <filename>configure.tgt</filename> contains a huge switch
	    statement to match targets specified to the main
	    <command>configure</command> command. Add a new target by
	    incorporating its pattern match in this file.
	  </para>
	  <indexterm>
	    <primary><filename>configure.tgt</filename> file</primary>
	    <secondary>target matching</secondary>
	  </indexterm>
	  <indexterm>
	    <primary><command>configure</command> command</primary>
	  </indexterm>

	  <para>
	    The sub-directory <filename>config</filename> contains target
	    specific configuration information for native targets.
	  </para>
	  <indexterm>
	    <primary><filename>config</filename> sub-directory</primary>
	    <seealso><filename>gdb</filename> directory</seealso>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <application>libiberty</application>. Before POSIX and
	    <application>glibc</application>, this was a &gnu; project to
	    provide a set of standard functions. It lives on in &gdb;. Most
	    valuable are its free store management and argument parsing
	    functions.
	  </para>
	  <indexterm>
	    <primary><application>libiberty</application></primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>POSIX</filename></primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>glibc</filename></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>opcodes</filename>. This contains disassemblers for use
	    by &gdb; (the <command>disassemble</command> command);. In a
	    directory of its own, because this code is also used in
	    &binutils;.
	  </para>
	  <indexterm>
	    <primary><filename>opcodes</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb; commands</primary>
	    <secondary><command>disassemble</command></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>disassembly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>&binutils;</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>sim</filename>. The simulators for various targets. Each
	    target architecture simulator is built in its own sub-directory.
	  </para>
	  <indexterm>
	    <primary><filename>sim</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>directory for code</secondary>
	  </indexterm>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>
	Testing &gdb;
      </title>

      <para>
	Running the &gdb; test suite requires that the
	<application>DejaGNU</application> package is installed. The tests can
	then be run with:
      </para>
      <indexterm>
	<primary><application>DejaGNU</application></primary>
      </indexterm>
      <indexterm>
	<primary>testing</primary>
	<secondary>running tests</secondary>
      </indexterm>

      <informalexample>
	<programlisting>
	  <command>make check</command>
	</programlisting>
      </informalexample>

      <para>
	On completion of the run, the summary results will be in the
	<filename>gdb/testsuite</filename> directory in
	<filename>gdb.sum</filename> with the detailed log in
	<filename>gdb.log</filename>
      </para>
      <indexterm>
	<primary>testing</primary>
	<secondary>test results</secondary>
      </indexterm>
      <indexterm>
	<primary><filename>gdb/testsuite</filename> sub-directory</primary>
      </indexterm>
      <indexterm>
	<primary><filename>gdb.sum</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>gdb.log</filename> file</primary>
      </indexterm>

      <para>
	For the most comprehensive tests in an environment where host and
	target differ, <application>DejaGNU</application> needs some
	additional configuration. This can be achieved by setting the
	<constant>DEJAGNU</constant> environment variable to refer to a
	suitable configuration file, and defining a custom board configuration
	file in the directory <filename>~/boards</filename>. These
	configuration files can be used to specify a suitable simulator and
	how to connect it when running tests.
      </para>
    </sect1>

    <sect1>
      <title>
	Documentation
      </title>

      <para>
	Some of &gdb; sub-directories in turn have <filename>doc</filename>
	sub-directories. The documentation is written in
	<application>texinfo</application> <xref linkend="ref_texinfo" />,
	from which documents can be generated as &pdf;, <application>PostScript</application>, &html; or
	<command>info</command> files. The documentation is not built
	automatically with <command>make&nbsp;all</command>, nor with
	<command>make&nbsp;doc</command>.
      </para>
      <indexterm>
	<primary>documentation</primary>
	<secondary>source</secondary>
      </indexterm>
      <indexterm>
	<primary>documentation</primary>
	<secondary>building</secondary>
      </indexterm>
      <indexterm>
	<primary>documentation</primary>
	<secondary>&pdf; output format</secondary>
      </indexterm>
      <indexterm>
	<primary>documentation</primary>
	<secondary><application>PostScript</application> output format</secondary>
      </indexterm>
      <indexterm>
	<primary>documentation</primary>
	<secondary>&html; output format</secondary>
      </indexterm>
      <indexterm>
	<primary>documentation</primary>
	<secondary><command>info</command> output format</secondary>
      </indexterm>

      <para>
	To create documentation, change to the individual documentation
	directory and use <command>make&nbsp;html</command>,
	<command>make&nbsp;pdf</command>, <command>make&nbsp;ps</command> or
	<command>make&nbsp;info</command> as required.
      </para>

      <para>
	The main documents of interest are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>bfd/doc/bfd.texinfo</filename>. This is the &bfd; manual.
	  </para>
	  <indexterm>
	    <primary>documentation</primary>
	    <secondary>source</secondary>
	    <tertiary>&bfd; User Guide</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>&bfd;</primary>
	    <secondary>User Guide</secondary>
	    <tertiary>source</tertiary>
	    <see>documentation</see>
	  </indexterm>
	  <indexterm>
	    <primary><filename>bfd.texinfo</filename> file</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdb.texinfo</filename>. This is the main &gdb;
	    user guide <xref linkend="ref_gdb_ug" />.
	  </para>
	  <indexterm>
	    <primary>documentation</primary>
	    <secondary>source</secondary>
	    <tertiary>&gdb; User Guide</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb;</primary>
	    <secondary>User Guide</secondary>
	    <tertiary>source</tertiary>
	    <see>documentation</see>
	  </indexterm>
	  <indexterm>
	    <primary><filename>gdb.texinfo</filename> file</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <filename>gdb/doc/gdbint.texinfo</filename>. This is the internals
	    user guide <xref linkend="ref_gdb_int" />. It is essential reading
	    for any developer porting the code.
	  </para>
	  <indexterm>
	    <primary>documentation</primary>
	    <secondary>source</secondary>
	    <tertiary>&gdb; Internals document</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb;</primary>
	    <secondary>Internals document</secondary>
	    <tertiary>source</tertiary>
	    <see>documentation</see>
	  </indexterm>
	  <indexterm>
	    <primary><filename>gdbint.texinfo</filename> file</primary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	The exception to automatic building is with
	<command>make&nbsp;install</command>. This will build
	<command>info</command> files for any documents in the
	<filename>gdb/doc</filename> directory and install them in the
	<filename>info</filename> sub-directory of the install directory.
      </para>
      <indexterm>
	<primary>documentation</primary>
	<secondary>building</secondary>
	<tertiary>automatic</tertiary>
      </indexterm>

    </sect1>      

    <sect1>
      <title>
	Example Procedure Flows in &gdb;
      </title>

      <para>
	It is instructive to see how the architecture specification functions
	and target operations are invoked in response to various &gdb;
	commands. This gives useful points for debugging a new architecture
	port.
      </para>
      <indexterm>
	<primary>procedure flows</primary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary>procedure flows</secondary>
	<see>procedure flows</see>
      </indexterm>

      <para>
	In the following sections, several procedure flows are illustrated by
	sequence diagrams. These show the calling chain for procedures. Only
	the key functions are shown - the actual calls usually involve several
	intermediate function calls.
      </para>

      <sect2>
	<title>
	  Initial Start Up
	</title>

	<para>
	  <xref linkend="fig_startup_flow" /> shows the sequence diagram for
	  &gdb; start up.
	</para>
	<indexterm>
	  <primary>procedure flows</primary>
	  <secondary>initial start up</secondary>
	</indexterm>

	<figure id="fig_startup_flow">
	  <title>
	    Sequence diagram for &gdb; start up
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="startup_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="startup_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  On start up, the &gdb; initialization function,
	  <function>gdb_init</function> calls all the
	  <function>_initialize</function> functions, including those for any
	  architectures or remote targets.
	</para>
	<indexterm>
	  <primary><function>gdb_init</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>_initialize</function> functions</primary>
	</indexterm>
	<indexterm>
	  <primary><function>_initialize_&arch;_tdep</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>_initialize_&arch;_remote</function></primary>
	</indexterm>

	<para>
	  Having initialized all the architectures, the first alphabetically
	  is selected as the default architecture by
	  <function>initialize_current_architecture</function>, and its
	  initialization function, (by convention
	  <function>&arch;_gdbarch_init</function>) is called.
	</para>
	<indexterm>
	  <primary><function>initialize_current_architecture</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>&arch;_gdbarch_init</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>

	<para>
	  Control returns to <function>gdb_main</function>, which sits in the
	  command interpreter, waiting for commands to execute.
	</para>
	<indexterm>
	  <primary><function>gdb_main</function></primary>
	</indexterm>

      </sect2>

      <sect2 id="sec_target_flow">
	<title>
	  The &gdb; <command>target</command> Command
	</title>

	<para>
	  <xref linkend="fig_target_hl_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>target</command> command.
	</para>
	<indexterm>
	  <primary>procedure flows</primary>
	  <secondary><command>target</command> command</secondary>
	</indexterm>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>target</command></secondary>
	</indexterm>

	<figure id="fig_target_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>target</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="target_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="target_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>
	  
	<para>
	  The <command>target</command> command maps directly on to the
	  current target <function>to_open</function>. A typical
	  implementation establishes physical connection to the target (for
	  example by opening a TCP/IP link to a remote target). For a remote
	  target, it then typically calls <function>start_remote</function>,
	  which waits for the target to stop (using the current target
	  <function>to_wait</function> function), determines the reason for
	  stopping (<function>handle_inferior_event</function>) and then marks
	  this as a normal stop (<function>normal_stop</function>).
	</para>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_open</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_open</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary><function>start_remote</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_wait</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_wait</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary><function>wait_for_inferior</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>handle_inferior_event</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>normal_stop</function></primary>
	</indexterm>

	<para>
	  <function>handle_inferior_event</function> is a central function in
	  &gdb;. Whenever control is returned to &gdb;, via the target
	  <function>to_wait</function> function, it must determine what has
	  happened and how it should be handled. <xref
	  linkend="fig_target_handle_inferior_flow" /> shows the behavior of
	  <function>handle_inferior_event</function> in response to the
	  <command>target</command> command.
	</para>

	<figure id="fig_target_handle_inferior_flow">
	  <title>
	    <function>handle_inferior_event</function> sequence diagram in
	    response to the &gdb; <command>target</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="target_handle_inferior_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="target_handle_inferior_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  <function>handle_inferior_event</function> needs to establish the
	  program counter at which execution stopped, so calls
	  <function>read_pc_pid</function>. Since the program counter is a
	  register, this causes creation of a register cache, for which the
	  type of each register must be determined by
	  <function>gdbarch_register_type</function> (a one-off exercise,
	  since this never changes). Having determined register types, the
	  register cache is populated with the value of the program counter by
	  calling the current target <function>to_fetch_registers</function>
	  for the relevant register.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_fetch_registers</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_fetch_registers</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary><function>read_pc_pid</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_register_type</function></primary>
	  <see>accessor functions</see>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>register_type</function></tertiary>
	</indexterm>
	
	<para>
	  <function>handle_inferior_event</function> then determines if the
	  stop was due to a breakpoint or watchpoint. The function
	  <function>watchpoints_triggered</function> uses the target
	  <function>target_stopped_by_watchpoint</function> to determine if it
	  was a watchpoint which triggered the stop.
	</para>
	<indexterm>
	  <primary><function>watchpoints_triggered</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_stopped_by_watchpoint</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_stopped_by_watchpoint</function></primary>
	  <see>convenience macros</see>
	</indexterm>

	<para>
	  The call to <function>normal_stop</function> also invokes the
	  &gdbarch; functions, calling <function>gdbarch_unwind_pc</function>
	  to establish the current program counter and and frame sniffer
	  functions to establish the frame sniffer stack.
	</para>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>unwind_pc</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_unwind_pc</function></primary>
	  <see>accessor_functions</see>
	</indexterm>
      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>load</command> Command
	</title>

	<para>
	  <xref linkend="fig_load_flow" /> shows the high level sequence
	  diagram for &gdb; in response to the <command>load</command>
	  command. This maps to the current target's
	  <function>to_load</function> function, which in most cases will end
	  up calling the current target's <function>to_xfer_partial</function>
	  function once for each section of the image to load it into memory.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>target</command></secondary>
	</indexterm>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_load</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_load</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_xfer_partial</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_xfer_partial</function></primary>
	  <see>convenience macros</see>
	</indexterm>

	<figure id="fig_load_flow">
	  <title>
	    Sequence diagram for the &gdb; <command>load</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="load_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="load_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The load function will capture data from the loaded file, most
	  importantly its start address for execution.
	</para>

      </sect2>
	  
      <sect2>
	<title>
	  The &gdb; <command>break</command> Command
	</title>

	<para>
	  <xref linkend="fig_break_flow" /> shows the high level sequence
	  diagram for &gdb; in response to the <command>break</command>
	  command. This example is for the case where the target of the break
	  is a symbol (i.e. a function name) in the target executable.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>break</command></secondary>
	</indexterm>

	<figure id="fig_break_flow">
	  <title>
	    Sequence diagram for the &gdb; <command>break</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="break_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="break_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Most of the action with breakpoints occurs when the program is set
	  running, at which any active breakpoints are installed. However for
	  any <command>break</command> command, the address for the break must
	  be set up in the breakpoint data structure.
	</para>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>break_command</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>parse_breakpoint_sals</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>skip_prologue</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_skip_prologue</function></primary>
	  <see>accessor functions</see>
	</indexterm>

	<para>
	  For symbolic addresses, the start of the function can be obtained
	  from the line number information held for debugging purposes in the
	  symbol table (known as <emphasis>symbol-and-line</emphasis>
	  information, or &sal;). For a function, this will yield the start
	  address of the code. However the breakpoint must be set after the
	  function prologue. <function>gdbarch_skip_prolog</function> is used to
	  find that address in the code.
	</para>
	<indexterm>
	  <primary>symbol-and-line (SAL) information</primary>
	</indexterm>

      </sect2>

      <sect2 id="sec_run_flow">
	<title>
	  The &gdb; <command>run</command> Command
	</title>

	<para>
	  <xref linkend="fig_run_hl_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>run</command> command.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>run</command></secondary>
	</indexterm>

	<figure id="fig_run_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The <command>run</command> command must create the inferior, insert
	  any active breakpoints and watchpoints, and then start execution of
	  the inferior. Control does not return to &gdb; until the target
	  reports that it has stopped.
	</para>

	<para>
	  The top level function implementing the <command>run</command>
	  command is <function>run_command</function>. This creates the
	  inferior, but calling the current target's
	  <function>to_create_inferior</function> function. &gdb; supports
	  targets which can give a dynamic description of their architecture
	  (for example the number of registers available). This is achieved
	  through the <function>to_find_description</function> function of the
	  current target (which is an empty function by default).
	</para>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>run_command</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_create_inferior</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_create_inferior</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_find_description</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_find_description</function></primary>
	  <see>convenience macros</see>
	</indexterm>

	<para>
	  Execution is started by the <function>proceed</function>. This must
	  first determine if the code is restarting on an instruction which
	  will need stepping through a delay slot (so that code never stops on
	  a delay slot). If this functionality is required, it is implemented
	  by the <function>gdbarch_single_sep_through_delay</function>
	  function.
	</para>
	<indexterm>
	  <primary><function>proceed</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>single_step_through_delay</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_single_step_through_delay</function></primary>
	  <see>accessor functions</see>
	</indexterm>

	<para>
	  Active breakpoints are inserted using the current target's
	  <function>to_insert_breakpoint</function> function. The code is then
	  run using the <function>to_resume</function> function of the current
	  target.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_insert_breakpoint</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_insert_breakpoint</function></primary>
	  <see>convenience macros</see>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_resume</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_resume</function></primary>
	  <see>convenience macros</see>
	</indexterm>

	<para>
	  &gdb; then calls <function>wait_for_inferior</function>, which will
	  wait for the target to stop, and then determine the reason for the
	  stop. Finally <function>normal_stop</function> will remove the
	  breakpoints from the target code and report to the user the current
	  state of the target as appropriate.
	</para>
	<indexterm>
	  <primary><function>wait_for_inferior</function></primary>
	</indexterm>

	<para>
	  Much of the detailed processing takes place in the
	  <function>wait_for_inferior</function> and
	  <function>normal_stop</function> functions (see also their use in
	  <xref linkend="sec_target_flow" />). These are important functions
	  and it is useful to look at their behavior in more detail.
	</para>
	<indexterm>
	  <primary><function>normal_stop</function></primary>
	</indexterm>

	<para>
	  <xref linkend="fig_run_wait_for_inferior_flow" /> shows the sequence
	  diagram for <function>wait_for_inferior</function> when handling the
	  &gdb; <command>run</command> command.
	</para>

	<figure id="fig_run_wait_for_inferior_flow">
	  <title>
	    Sequence diagram for the &gdb;
	    <function>wait_for_inferior</function> function as used by the
	    <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_wait_for_inferior_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_wait_for_inferior_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Once again the key work is in
	  <function>handle_inferior_event</function>. The code checks for
	  watchpoints using the <function>to_stopped_by_watchpoint</function>
	  function of the current target. The function also checks
	  breakpoints, but since it already knows the current program counter
	  (set by <function>target_wait</function> when control is returned),
	  it needs no further call to the target
	  operations. <function>target_wait</function> will have reported if
	  it stopped due to an exception that could be due to a
	  breakpoint. <function>handle_inferior_event</function> can then look
	  up the program counter in the list of active breakpoints, to
	  determine which breakpoint was encountered.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_wait</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>handle_inferior_event</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>watchpoints_triggered</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_stopped_by_watchpoint</function></tertiary>
	</indexterm>

	<para>
	  <xref linkend="fig_run_normal_stop_flow" /> shows the sequence
	  diagram for <function>normal_stop</function> when handling the
	  &gdb; <command>run</command> command. In this example the stop was
	  due to the target encountering a breakpoint.
	</para>
	<indexterm>
	  <primary><function>normal_stop</function></primary>
	</indexterm>

	<figure id="fig_run_normal_stop_flow">
	  <title>
	    Sequence diagram for the &gdb; <function>normal_stop</function>
	    function as used by the <command>run</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="run_normal_stop_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="run_normal_stop_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The first action is to remove breakpoints. This ensures that the
	  target executable is returned to its normal state, without any trap
	  or similar code inserted.
	</para>
	<indexterm>
	  <primary><function>remove_breakpoints</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_remove_breakpoint</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>target_remove_breakpoint</function></primary>
	  <see>convenience macros</see>
	</indexterm>

	<para>
	  The frame sniffers for the target are identified, using the frame
	  sniffer for the architecture,
	  <function>&arch;_frame_sniffer</function>. The current stack frame
	  is then printed for the user. This requires use of the frame sniffer
	  to identify the ID (and hence all the other data) of &this; frame
	  from the &next; frame (<function>&arch;_frame_this_id</function>
	  here). <function>print_stack_frame</function> will start from the
	  sentinel frame and work inwards until it finds the stack frame
	  containing the current stack pointer and program counter.
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>sniffer</secondary>
	</indexterm>
	<indexterm>
	  <primary><function>&arch;_frame_sniffer</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>print_stack_frame</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>&arch;_frame_this_id</function></primary>
	</indexterm>
	<indexterm>
	  <primary><structname>struct&nbsp;frame_unwind</structname></primary>
	  <secondary>functions</secondary>
	  <tertiary>this_id</tertiary>
	</indexterm>
	<indexterm>
	  <primary>program counter</primary>
	  <secondary>value in stack frame</secondary>
	</indexterm>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>stack pointer value in</secondary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>backtrace</command> Command
	</title>

	<para>
	  <xref linkend="fig_bt_hl_flow" /> shows the high level
	  sequence diagram for &gdb; in response to the
	  <command>backtrace</command> command. This sequence shows the
	  behavior for the first call to backtrace after control has returned
	  to &gdb;.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>backtrace</command></secondary>
	</indexterm>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>backtrace</secondary>
	</indexterm>

	<figure id="fig_bt_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>backtrace</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="bt_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="bt_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The main command function is <function>backtrace_command</function>,
	  which uses <function>print_frame_info</function> to print the name
	  of each function on the stack with its arguments.
	</para>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>backtrace_command</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>print_frame_info</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>print_frame</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>print_frame_args</function></primary>
	</indexterm>

	<para>
	  The first frame is already known from the program counter and stack
	  pointer of the stopped target, so is printed out by
	  <function>print_frame</function>. That will ultimately use the
	  current target's <function>to_xfer_partial</function> function to
	  get the local argument values.
	</para>

	<para>
	  Since this is the first <command>backtrace</command> after the
	  program stopped, the stack pointer and program counter are each
	  obtained from the sentinel frame using
	  <function>get_func_type</function>. <function>print_frame</function>
	  is then called for each frame in turn as the stack is unwound until
	  there are no more stack frames. The information in each frame is
	  built up using the architecture's frame sniffers.
	</para>
	<indexterm>
	  <primary><function>get_func_type</function></primary>
	</indexterm>

	<para>
	  It is useful to look at <function>print_frame</function> in more
	  detail. <xref linkend="fig_bt_print_frame_flow" /> shows the
	  sequence diagram for the second series of calls to the
	  <function>print_frame</function> function when handling the &gdb;
	  <command>backtrace</command> command, used to print out the stack
	  frame.
	</para>

	<figure id="fig_bt_print_frame_flow">
	  <title>
	    Sequence diagram for the &gdb; <function>print_frame</function>
	    function used by the <command>backtrace</command> command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="bt_print_frame_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="bt_print_frame_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The information about the function on the stack frame can be
	  obtained from the program counter and stack pointer associated with
	  the stack frame. These are obtained by calls to the
	  <function>gdbarch_unwind_pc</function> and
	  <function>gdbarch_unwind_sp</function> functions.
	</para>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>unwind_pc</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>unwind_sp</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_unwind_sp</function></primary>
	  <see>accessor_functions</see>
	</indexterm>
	<indexterm>
	  <primary><function>read_var_value</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>&arch;_frame_prev_sniffer</function></primary>
	</indexterm>
	<indexterm>
	  <primary>stack frame</primary>
	  <secondary>sniffer</secondary>
	</indexterm>

	<para>
	  Then for each argument, its value must be printed out. The symbol
	  table debug data will identify the arguments, and enough information
	  for &gdb; to work out if the value is on the stack or in a
	  register. The frame sniffer function to get registers from the stack
	  frame (in this example
	  <function>&arch;_frame_prev_register</function>) is used to get the
	  values of any registers as appropriate.
	</para>
	<indexterm>
	  <primary><function>&arch;_frame_prev_register</function></primary>
	</indexterm>

	<para>
	  The precise sequence of calls depends on the functions in the stack
	  frame, the arguments they have, and whether those arguments are in
	  registers or on the stack.
	</para>

      </sect2>

      <sect2>
	<title>
	  The &gdb; <command>continue</command> Command after a Breakpoint
	</title>

	<para>
	  The final sequence shows the behavior when execution is resumed
	  after a breakpoint with the <command>continue</command> command.
	  <xref linkend="fig_cont_hl_flow" /> shows the high level sequence
	  diagram for &gdb; in response to the <command>continue</command>
	  command. This sequence shows the behavior for the first call to
	  continue after a run stopped due to a breakpoint.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>continue</command></secondary>
	</indexterm>

	<figure id="fig_cont_hl_flow">
	  <title>
	    High level sequence diagram for the &gdb;
	    <command>continue</command> command after a breakpoint
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="cont_hl_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="cont_hl_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The command functionality is provided by the
	  <function>continue_command</function>, which calls the
	  <function>proceed</function> function for much of its behavior.
	</para>
	<indexterm>
	  <primary><function>current_interp_command_loop</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>continue_command</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>proceed</function></primary>
	</indexterm>

	<para>
	  <function>proceed</function> calls the
	  <function>to_resume</function> function of the current target to
	  resume execution. For this first call, the breakpoint(s) removed
	  when execution completed after the <command>run</command> command
	  are <emphasis>not</emphasis> replaced and the target resumption is
	  only for a single instruction step. This allows the target to be
	  stepped past the breakpoint without triggering an exception.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_resume</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>breakpoint</primary>
	  <secondary>reinsertion when continuing</secondary>
	</indexterm>

	<para>
	  <function>proceed</function> then uses
	  <function>wait_for_inferior</function> to wait for control to return
	  after the single step and diagnose the next action. Waiting uses the
	  <function>to_wait</function> function of the current target, then
	  calls <function>handle_inferior_event</function> to analyze the
	  result. In this case, <function>handle_inferior_event</function>
	  determines that a target has just stepped past a breakpoint. It
	  reinserts the breakpoints and calls the target
	  <function>to_resume</function> function again, this time to run
	  continuously.
	</para>
	<indexterm>
	  <primary><function>wait_for_inferior</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_wait</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>handle_inferior_event</function></primary>
	</indexterm>

	<para>
	  <function>wait_for_inferior</function> will use the current target
	  <function>to_wait</function> function again to wait for the target
	  to stop executing, then again call the
	  <function>handle_inferior_event</function> to process the
	  result. This time, control should return to &gdb;, so breakpoints
	  are removed, and <function>handle_inferior_event</function> and
	  <function>wait_for_inferior</function>
	  return. <function>proceed</function> calls
	  <function>normal_stop</function> to tidy up and print out a message
	  about the current stack frame location where execution has stopped
	  (see <xref linkend="sec_run_flow" />.).
	</para>
	<indexterm>
	  <primary><function>normal_stop</function></primary>
	</indexterm>

	<para>
	  It is useful to examine the behavior of the first call to
	  <function>handle_inferior_event</function>, to see the sequence for
	  completing the single step and resuming continuous execution. <xref
	  linkend="fig_cont_handle_inferior_flow" /> shows the sequence
	  diagram for the first call to
	  <function>handle_inferior_event</function>.
	</para>

	<figure id="fig_cont_handle_inferior_flow">
	  <title>
	    Sequence diagram for the &gdb;
	    <function>handle_inferior_event</function> function after single
	    stepping an instruction for the <command>continue</command>
	    command
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="cont_handle_inferior_flow.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="cont_handle_inferior_flow.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  <function>handle_inferior_event</function> first determines if a
	  watchpoint has now been triggered. If this is not the case, it
	  checks if the processor is now in the delay slot of an instruction
	  (requiring another single-step immediately). Having determined that
	  continuous execution is appropriate, it calls the function
	  <function>keep_going</function> to reinsert active breakpoints
	  (using the <function>to_insert_breakpoint</function> function of the
	  current target). Finally it calls the <function>to_resume</function>
	  function of the current target <emphasis>without the single-step
	  flag set</emphasis> to resume continuous execution.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_stopped_by_watchpoint</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>single_step_through_delay</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary><function>keep_going</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>to_insert_breakpoint</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>breakpoint</primary>
	  <secondary>reinsertion when continuing</secondary>
	</indexterm>
	<indexterm>
	  <primary>watchpoint</primary>
	  <secondary>reinsertion when continuing</secondary>
	</indexterm>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Summary: Steps to Port a New Architecture to &gdb;
      </title>

      <para>
	Porting a new architecture to &gdb; can be broken into a number of
	steps.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Ensure a &bfd; exists for executables of the target architecture
	    in the <filename>bfd</filename> directory. If one does not exist,
	    create one by modifying an existing similar one.
	  </para>
	  <indexterm>
	    <primary>&bfd;</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Implement a disassembler for the target architecture in the
	    <filename>opcodes</filename> directory.
	  </para>
	  <indexterm>
	    <primary>disassembly</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Define the target architecture in the <filename>gdb</filename>
	    directory. Add the pattern for the new target to
	    <filename>configure.tgt</filename> with the names of the files
	    that contain the code. By convention the target architecture
	    definition for an architecture &arch; is placed
	    in <filename>&arch;-tdep.c</filename>.
	  </para>
	  <indexterm>
	    <primary><filename>gdb</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>configure.tgt</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>&arch;-tdep.c</filename> file</primary>
	  </indexterm>
	  

	  <para>
	    Within <filename>&arch;-tdep.c</filename> define the function
	    <function>_initialize_&arch;_tdep</function> which calls
	    <function>gdbarch_register</function> to create the new &gdbarch;
	    for the architecture.
	  </para>
	  <indexterm>
	    <primary><function>_initialize_&arch;_tdep</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>gdbarch_register</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>&gdbarch;</function></primary>
	    <secondary>creating new instance</secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    If a new remote target is needed, consider adding a new remote
	    target by defining a function
	    <function>_initialize_remote_&arch;</function>.
	    However if at all possible use the <emphasis>Remote Serial
	    Protocol</emphasis> for this and implement the server side
	    protocol independently with the target.
	  </para>
	  <indexterm>
	    <primary><function>_initialize_remote_&arch;</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>Remote Serial Protocol</primary>
	  </indexterm>
	  <indexterm>
	    <primary>&target_ops;</primary>
	    <secondary>creation></secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    If desired implement a simulator in the <filename>sim</filename>
	    directory. This should create the library
	    <filename>libsim.a</filename> implementing the interface in
	    <filename>remote-sim.h</filename> (found in the
	    <filename>include</filename> directory).
	  </para>
	  <indexterm>
	    <primary><filename>libsim.a</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>remote-sim.h</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary><filename>include</filename> directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>simulator library</primary>
	    <secondary>creation</secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Build and test. If desired, lobby the &gdb; steering group to have
	    the new port included in the main distribution!
	  </para>
	  <indexterm>
	    <primary>testing</primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Add a description of the new architecture to the "Configuration
	    Specific Information" section in the main &gdb; user guide
	    (<filename>gdb/doc/gdb.texinfo</filename> <xref
	    linkend="ref_gdb_ug" />).
	  </para>
	  <indexterm>
	    <primary><filename>gdb.texinfo</filename> file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>documentation</primary>
	  </indexterm>
	  <indexterm>
	    <primary>documentation</primary>
	    <secondary>source</secondary>
	    <tertiary>&gdb; User Guide</tertiary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	The remainder of this document shows how this process was used to port
	&gdb; to the &or1k; architecture.
      </para>

    </sect1>

  </chapter>

  <chapter>
    <title>
      The &or1k; Architecture
    </title>

    <para>
      The &or1k; architecture defines a family of free, open source RISC
      processor cores. It is a 32 or 64-bit load and store RISC architecture
      designed with emphasis on performance, simplicity, low power
      requirements, scalability and versatility.
    </para>
    <indexterm>
      <primary>&or1k;</primary>
      <secondary>architecture</secondary>
    </indexterm>

    <para>
      The &or1k; is fully documented in its Architecture Manual <xref
      linkend="ref_or1k" />.
    </para>

    <para>
      From a debugging perspective, there are three data areas that are
      manipulated by the instruction set.
    </para>

    <orderedlist>
      <listitem>
	<para>
	  Main memory. A uniform address space with 32 or 64-bit
	  addressing. Provision for separate or unified instruction and data
	  and instruction caches. Provision for separate or unified, 1 or
	  2-level data and instruction MMUs.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>architecture</secondary>
	  <tertiary>main memory</tertiary>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  General Purpose Registers (&gpr;s). Up to 32 registers, 32 or 64-bit
	  in length.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>architecture</secondary>
	  <tertiary>&gpr;s</tertiary>
	  <see>General Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>General Purpose Register</primary>
	</indexterm>
	<indexterm>
	  <primary>&gpr;s</primary>
	  <see>General Purpose Register</see>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  Special Purpose Registers (&spr;s). Up to 32 groups each with up to
	  2048 registers, up to 32 or 64-bit in length. These registers
	  provide all the administrative functionality of the processor:
	  program counter, processor status, saved exception registers, debug
	  interface, MMU and cache interfaces, etc.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>architecture</secondary>
	  <tertiary>&spr;s</tertiary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	</indexterm>
	<indexterm>
	  <primary>&spr;s</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
      </listitem>
    </orderedlist>

    <para>
      The Special Purpose Registers (&spr;s) represent a
      challenge for &gdb;, since they represent neither addressable memory, nor
      have the characteristics of a register set (generally modest in number).
    </para>

    <para>
      A number of &spr;s are of particular significance to the &gdb;
      implementation.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Configuration registers</emphasis>. The Unit Present
	  register (&spr;&nbsp;1, <literal>UPR</literal>), CPU Configuration
	  register (&spr;&nbsp;2, <literal>CPUCFGR</literal>) and Debug
	  Configuration register (&spr;&nbsp;7, <literal>DCFGR</literal>)
	  identify the features available in the particular &or1k; 
	  implementation. This includes the instruction set in use, number of
	  general purpose registers and configuration of the hardware debug
	  interface.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>configuration registers</secondary>
	  <tertiary>
	    CPU Configuration Register
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>configuration registers</secondary>
	  <tertiary>
	    Debug Configuration Register
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary><acronym>DCFGR</acronym></primary>
	  <see>Debug Configuration Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Configuration Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>configuration registers</secondary>
	  <tertiary>
	    Unit Present Register
	  </tertiary>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Program counters</emphasis>. The Previous Program Counter
	  (&spr;&nbsp;0x12, <literal>PPC</literal>) is the address of the
	  instruction just executed. The Next Program Counter (&spr;&nbsp;0x10,
	  <literal>NPC</literal>) is the address of the next instruction to be
	  executed. The <literal>NPC</literal> is the value reported by &gdb;s
	  <command>$pc</command> variable.
	</para>
	  <indexterm>
	    <primary>&gdb;</primary>
	    <secondary>built in variables</secondary>
	    <tertiary><command>$pc</command></tertiary>
	  </indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>program counters</secondary>
	  <tertiary>Previous Program Counter</tertiary>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>program counters</secondary>
	  <tertiary>Next Program Counter</tertiary>
	</indexterm>
	<indexterm>
	  <primary>program counter</primary>
	  <secondary>as Special Purpose Register</secondary>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Supervision Register</emphasis>. The supervision register
	  (&spr;&nbsp;0x11, <literal>SR</literal>) represents the current status
	  of the processor. It is the value reported by &gdb;s status register
	  variable, <command>$ps</command>.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Supervision Register</secondary>
	</indexterm>
	<indexterm>
	  <primary><acronym>SR</acronym></primary>
	  <see>Supervision Register</see>
	</indexterm>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>built in variables</secondary>
	  <tertiary><command>$ps</command></tertiary>
	</indexterm>
	<indexterm>
	  <primary>Supervision Register</primary>
	  <see>
	    Special Purpose Register
	  </see>
	</indexterm>
      </listitem>
    </itemizedlist>

    <para>
      Of particular importance are the &spr;s in group 6 controlling the debug
      unit (if present). The debug unit can trigger a
      <emphasis>trap</emphasis> exception in response to any one of up to 10
      <emphasis>watchpoints</emphasis>. Watchpoints are logical expressions
      built by combining <emphasis>matchpoints</emphasis>, which are simple
      point tests of particular behavior (has a specified address been
      accessed for example).
    </para>
    <indexterm>
      <primary>Debug Unit</primary>
    </indexterm>

    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Debug Value and Control registers</emphasis>. There are up
	  to 8 pairs of Debug Value (&spr;&nbsp;0x3000&ndash;0x3007,
	  <literal>DVR0</literal> through <literal>DVR7</literal>) and
	  Debug Control (&spr;&nbsp;0x3008&ndash;0x300f,
	  <literal>DCR0</literal> through <literal>DCR7</literal>)
	  registers. Each pair is associated with one hardware
	  <emphasis>matchpoint</emphasis>. The Debug Value register in each
	  pair gives a value to compare against. The Debug Control register
	  indicates whether the matchpoint is enabled, the type of value to
	  compare against (instruction fetch address, data load and/or store
	  address data load and/or store value) and the comparison to make
	  (equal, not equal, less than, less than or equal, greater than,
	  greater than or equal), both signed and unsigned. If the matchpoint
	  is enabled and the test met, the corresponding matchpoint is
	  triggered.
	</para>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>registers</secondary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Value Registers
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary>&dvr;</primary>
	  <see>Debug Value Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Value Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Control Registers
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary>Debug Control Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>&dcr;</primary>
	  <see>Debug Control Register</see>
	</indexterm>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Watchpoint counters</emphasis>. There are two 16-bit
	  Debug Watchpoint Counter registers (&spr;&nbsp;0x3012&ndash;0x3013,
	  <literal>DWCR0</literal> and <literal>DWCR1</literal>), associated
	  with two further matchpoints. The upper 16 bits are a value to
	  match, the lower 16 bits a counter. The counter is incremented when
	  specified matchpoints are triggered (see Debug Mode register
	  1). When the count reaches the match value, the corresponding
	  matchpoint is triggered.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Watchpoint Counter Registers
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary><acronym>DWCR</acronym></primary>
	  <see>Debug Watchpoint Counter Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Watchpoint Counter Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>watchpoint counter</secondary>
	</indexterm>

	<caution>
	  <para>
	    There is potential ambiguity in that counters are incremented in
	    response to matchpoints and also generate their own
	    matchpoints. It is not good practice to set a counter to increment
	    on its own matchpoint!
	  </para>
	</caution>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Mode registers</emphasis>. There are two Debug Mode
	  registers to control the behavior of the the debug unit
	  (&spr;&nbsp;0x3010&ndash;0x3011, <literal>DMR1</literal> and
	  <literal>DMR2</literal>). <literal>DMR1</literal> provides a pair of
	  bits for each of the 10 matchpoints (8 associated with &dvr;/&dcr;
	  pairs, 2 associated with counters). These specify whether the
	  watchpoint is triggered by the associated matchpoint, by the
	  matchpoint AND-ed with the previous watchpoint or by the matchpoint
	  OR-ed with the previous watchpoint. By building chains of
	  watchpoints, complex logical tests of hardware behavior can be built
	  up.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Mode Registers
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary><acronym>DMR</acronym></primary>
	  <see>Debug Mode Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Mode Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>matchpoint</secondary>
	</indexterm>
	<indexterm>
	  <primary>matchpoint</primary>
	  <see>Debug Unit</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>watchpoint</secondary>
	</indexterm>
	<indexterm>
	  <primary>watchpoint</primary>
	  <secondary>in &or1k;</secondary>
	  <see>Debug Unit</see>
	</indexterm>

	<para>
	  Two further bits in <literal>DMR1</literal> enable single step
	  behavior (a trap exception occurs on completion of each instruction)
	  and branch step behavior (a trap exception occurs on completion of
	  each branch instruction).
	</para>

	<para>
	  <literal>DMR2</literal> contains an enable bit for each counter, 10
	  bits indicating which watchpoints are assigned to which counter and 10
	  bits indicating which watchpoints generate a trap exception. It also
	  contains 10 bits of output, indicating which watchpoints have
	  generated a trap exception.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>Debug Stop and Reason registers</emphasis>. In normal
	  operation, all &or1k; exceptions are handled through the
	  exception vectors at locations 0x100 through 0xf00. The Debug Stop
	  register (&spr;&nbsp;0x3014, <literal>DSR</literal>) is used to
	  assign particular exceptions instead to the &jtag; interface. These
	  exceptions stall the processor, allowing the machine state to be
	  analyzed through the &jtag; interface. Typically a debugger will
	  enable this for trap exceptions used for breakpointing.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Stop Register
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary><acronym>DSR</acronym></primary>
	  <see>Debug Stop Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Stop Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>

	<para>
	  Where an exception has been diverted to the development interface,
	  the Debug Reason register (&spr;&nbsp;0x3021,
	  <literal>DRR</literal>) indicates which exception caused the
	  diversion. Note that although single stepping and branch stepping
	  cause a trap, if they are assigned to the &jtag; interface, they
	  <emphasis>do not</emphasis> set the <literal>TE</literal> bit in the
	  <literal>DRR</literal>. This allows an external debugger to
	  distinguish between breakpoint traps and single/branch step traps.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>
	    Debug Reason Register
	  </tertiary>
	</indexterm>
	<indexterm>
	  <primary><acronym>DRR</acronym></primary>
	  <see>Debug Reason Register</see>
	</indexterm>
	<indexterm>
	  <primary>Debug Reason Register</primary>
	  <see>Special Purpose Register</see>
	</indexterm>
      </listitem>
    </itemizedlist>

    <sect1>
      <title>
	The &or1k; &jtag; Interface
      </title>

      <para>
	There are two variants of the &jtag; interface for use with the
	&or1k;.
      </para>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>&jtag; interface</secondary>
	</indexterm>
	<indexterm>
	  <primary>&jtag;</primary>
	  <see>Debug Unit</see>
	</indexterm>


      <orderedlist>
	<listitem>
	  <para>
	    The original &jtag; interface was created as part of the OpenRISC
	    SoC project, ORPSoC <xref linkend="ref_orpsoc" />. It provides
	    three scan chains: one to access to all the &spr;s, one to access
	    external memory and one providing control of the CPU. The control
	    scan chain reset, stall or trace the processor.
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>ORPSoC version</tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    A new &jtag; interface was provided by Igor Mohor in 2004 <xref
	    linkend="ref_or1k_debug" />. It provides the same access to &spr;s
	    and external memory, but offers a simpler control interface
	    offering only the ability to stall or reset the processor.
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>Igor Mohor version</tertiary>
	  </indexterm>
	</listitem>
      </orderedlist>

      <para>
	At present the OpenRISC Architectural Simulator, &or1ksim;, (see <xref
	linkend="sec_or1ksim" />) supports the first of these
	interfaces.
      </para>

      <para>
	Three scan chains are provided by both interfaces
      </para>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>scan chains</tertiary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    RISC_DEBUG (scan chain 1), providing read/write access to the
	    &spr;s.
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>access to Special Purpose Registers</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>Special Purpose Register</primary>
	    <secondary>access via &jtag; interface</secondary>
	    <see>
	      Debug Unit, &jtag; interface, access to Special
	      Purpose Registers
	    </see>
	  </indexterm>
	</listitem>
	
	<listitem>
	  <para>
	    REGISTER (scan chain 4), providing control of the CPU. In the
	    ORPSoC interface, this provides multiple registers which are read
	    and written to control the CPU. Of these register 0,
	    <literal>MODER</literal>, which controls hardware trace, and
	    register 4, <literal>RISC_OP</literal>, which controls reset and
	    stall are the most important. Trace is enabled by setting, and
	    disabled by clearing bit&nbsp;1 in <literal>MODER</literal>. Reset
	    and processor stall are triggered and cleared by setting and
	    clearing respectively bit&nbsp;1 and bit&nbsp;0 in
	    <literal>RISC_OP</literal>. The stall state may be determined by
	    reading the stall bit in <literal>RISC_OP</literal>.
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>CPU control</tertiary>
	  </indexterm>

	  <para>
	    In the Mohor interface, there is a single control register which
	    behaves identically to <literal>RISC_OP</literal> in the original
	    debug interface.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    WISHBONE (scan chain 5), providing read/write access to main
	    memory.
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>access to main memory</tertiary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	Since the General Purpose Registers (&gpr;s) are mapped to
	&spr; group 0, this mechanism also allows &gpr;s to be read and
	written.
      </para>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>access to General Purpose Registers</tertiary>
      </indexterm>
      <indexterm>
	<primary>General Purpose Register</primary>
	<secondary>access via &jtag; interface</secondary>
	<see>
	  Debug Unit, &jtag; interface, access to General
	  Purpose Registers
	</see>
      </indexterm>

    </sect1>

    <sect1>
      <title>
	The &or1k; Remote &jtag; Protocol
      </title>

      <important>
	<para>
	  The latest version of &gdb; for &or1k; implements the &gdb; Remote
	  Serial Protocol, which is the preferred mechanism for connecting to
	  remote targets <xref linkend="ref_app_note_4"/>.
	</para>

	<para>
	  However the protocol described here is retained for backward
	  compatibility. It is used here as a tutorial vehicle to illustrate
	  how a custom debugging protocol can be used within &gdb;
	</para>
      </important>

      <para>
	To facilitate remote debugging by &gdb;, the OpenRISC defines a
	software protocol describing &jtag; accesses, suitable for transport
	over TCP/IP via a socket interface.
      </para>
      <indexterm>
	<primary>Remote &jtag; Protocol</primary>
	<secondary>implementation over TCP/IP</secondary>
      </indexterm>

      <note>
	<para>
	  This protocol pre-dates the &gdb; Remote Serial Protocol (see <xref
	  linkend="sec_rsp" />). At some future date the &or1k; Remote
	  &jtag; Protocol will be replaced by the &rsp;.
	</para>
	<indexterm>
	  <primary>Remote &jtag; Protocol</primary>
	  <secondary>replacement by Remote Serial Protocol</secondary>
	</indexterm>
      </note>

      <para>
	The &or1k; Remote &jtag; Protocol is a simple message
	send/acknowledge protocol. The &jtag; request is packaged as a 32 bit
	command, 32-bit length and series of 32-bit data words. The &jtag;
	response is packaged as a 32-bit status and optionally a number of
	32-bit data words. The commands available are:
      </para>
      <indexterm>
	<primary>Remote &jtag; Protocol</primary>
	<secondary>packet format</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_READ</constant> (1). Read a single
	    &jtag; register. A 32-bit address is provided in the request. The
	    response includes 64-bits of read data.
	  </para>
	  <indexterm>
	    <primary>Remote &jtag; Protocol</primary>
	    <secondary>commands</secondary>
	    <tertiary>read register</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><constant>OR1K_JTAG_COMMAND_READ</constant></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_WRITE</constant> (2). Write a single
	    &jtag; register. A 32-bit address is provided in the 
	    request and 64-bit data to be written.
	  </para>
	  <indexterm>
	    <primary>Remote &jtag; Protocol</primary>
	    <secondary>commands</secondary>
	    <tertiary>write register</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><constant>OR1K_JTAG_COMMAND_WRITE</constant></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_READ_BLOCK</constant> (3). Read
	    multiple 32-bit &jtag; registers. A 32-bit address of the first
	    register and number of registers to be read is provided in the
	    request. The response includes the number of registers read and
	    32-bits of data for each one read.
	  </para>
	  <indexterm>
	    <primary>Remote &jtag; Protocol</primary>
	    <secondary>commands</secondary>
	    <tertiary>block read registers</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><constant>OR1K_JTAG_COMMAND_READ_BLOCK</constant></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_WRITE_BLOCK</constant> (4). Write
	    multiple 32-bit &jtag; registers. A 32-bit address of the first
	    register and number of registers to be written is provided in the
	    request followed by 32-bits of data to be written for each
	    register.
	  </para>
	  <indexterm>
	    <primary>Remote &jtag; Protocol</primary>
	    <secondary>commands</secondary>
	    <tertiary>block write registers</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>
	      <constant>OR1K_JTAG_COMMAND_WRITE_BLOCK</constant>
	    </primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <constant>OR1K_JTAG_COMMAND_CHAIN</constant> (5). Select the scan
	    chain. A 32-bit scan chain number is provided in the request.
	  </para>
	  <indexterm>
	    <primary>Remote &jtag; Protocol</primary>
	    <secondary>commands</secondary>
	    <tertiary><constant>setting scan chain</constant></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><constant>OR1K_JTAG_COMMAND_CHAIN</constant></primary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	Where the Mohor version of the &jtag; interface is being used,
	addresses for read/write accesses to the <literal>REGISTER</literal>
	scan chain are ignored&mdash;there is only one control register.
      </para>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>Igor Mohor version</tertiary>
      </indexterm>

      <note>
	<para>
	  There is apparently a contradiction in this protocol. Provision is
	  made for individual registers to be read/written as 64 bits,
	  whereas block read/writes (provided for communication efficiency)
	  are only 32-bits.
	</para>
      </note>

      <para>
	<xref linkend="fig_remote_jtag_protocol" />
	shows the structures of all five requests and their corresponding
	(successful) responses. Note that if a request fails, the response
	will only contain the status word.
      </para>

      <figure id="fig_remote_jtag_protocol">
	<title>
	  The &or1k; Remote &jtag; Protocol data structures
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="remote_jtag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The client side of this protocol (issuing the requests) is implemented
	by the &gdb; port for &or1k;.
      </para>

      <para>
	Server side applications may implement this protocol to drive either
	physical hardware (via its &jtag; port) or simulations, which include
	the &jtag; functionality. Examples of the former include &usb; &jtag;
	connectors, such as those produced by <trademark>ORSoC</trademark>
	AB. An example of the latter is the &or1k; Architectural Simulator,
	&or1ksim; (see <xref linkend="sec_or1ksim" />).
      </para>
      <indexterm>
	<primary>Remote &jtag; Protocol</primary>
	<secondary>server side</secondary>
      </indexterm>

    </sect1>

    <sect1 id="sec_or1k_abi">
      <title>
	Application Binary Interface (&abi;)
      </title>

      <para>
	The &abi; for the &or1k; is described in Chapter 16 of the
	Architecture Manual <xref linkend="ref_or1k" />. However the actual
	&gcc; compiler implementation differs very slightly from the
	documented &abi;. Since precise understanding of the &abi; is critical
	to &gdb;, those differences are documented here.
      </para>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>&abi;</secondary>
	<tertiary>variations from documented standard</tertiary>
      </indexterm>
      <indexterm>
	<primary>&abi;</primary>
	<secondary>&or1k;</secondary>
	<see>&or1k;</see>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    Register Usage: R12 is used as another callee-saved register. It
	    is never used to return the upper 32 bits of a 64-bit result on a
	    32-bit architecture. All values greater than 32-bits are returned
	    by a pointer.
	  </para>
	  <indexterm>
	    <primary>&or1k;</primary>
	    <secondary>&abi;</secondary>
	    <tertiary>result return register</tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Although the specification requires stack frames to be
	    <emphasis>double</emphasis> word aligned, the current &gcc;
	    compiler implements <emphasis>single</emphasis> word alignment.
	  </para>
	  <indexterm>
	    <primary>&or1k;</primary>
	    <secondary>&abi;</secondary>
	    <tertiary>stack frame alignment</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>alignment</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    Integral values more than 32 bits (64 bits on 64-bit
	    architectures), structures and unions are returned as pointers to
	    the location of the result. That location is provided by the
	    <emphasis>calling</emphasis> function, which passes it as a first
	    argument in &gpr; 3. In other words, where a function returns a
	    result of this type, the first true argument to the function will
	    appear in R4 (or R5/R6 if it is a 64-bit argument on a 32-bit
	    architecture).
	  </para>
	  <indexterm>
	    <primary>&or1k;</primary>
	    <secondary>&abi;</secondary>
	    <tertiary>argument passing</tertiary>
	  </indexterm>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1 id="sec_or1ksim">
      <title>
	&or1ksim;: the &or1k; Architectural Simulator
      </title>

      <para>
	&or1ksim; is an instruction set simulator (&iss;) for the &or1k; 
	architecture. At present only the 32-bit architecture is modeled. In
	addition to modeling the core processor, &or1ksim; can model a number of
	peripherals, to provide the functionality of a complete System-on-Chip
	(&soc;).
      </para>
      <indexterm>
	<primary>&or1ksim;</primary>
      </indexterm>

      <para>
	&or1ksim; models the &or1k; &jtag; interface and implements the
	&or1k; Remote &jtag; protocol server side. It was used as the
	testbed for this port of &gdb;
      </para>

      <para>
	The &jtag; interface models the behavior of the old ORPSoC (with
	support for multiple control registers and hardware trace). A future
	release will provide an option to support Igor Mohor's &jtag;
	interface.
      </para>
      <indexterm>
	<primary>&or1ksim;</primary>
	<secondary>debug interface variants</secondary>
      </indexterm>

      <note>
	<para>
	  Porting &gdb; uncovered a number of bugs in &or1ksim;. The
	  implementation is now quite old, and predates the current &or1k;
	  specification. A patch (available from <ulink
	  url="http://www.embecosm.com/download.html">www.embecosm.com/download.html</ulink>)
	  is available to fix these bugs.
	</para>
	<indexterm>
	  <primary>&or1ksim;</primary>
	  <secondary>bug fixes</secondary>
	</indexterm>
      </note>

    </sect1>
    
  </chapter>

  <chapter>
    <title>
      Porting the &or1k; Architecture
    </title>

    <para>
      This chapter describes the steps in porting the &or1k; 
      architecture to &gdb;. It uses the information and data structures
      described in <xref linkend="chap_gdb_internals" />.
    </para>
    <indexterm>
      <primary>&gdb;</primary>
      <secondary>Internals document</secondary>
    </indexterm>

    <para>
      The &or1k; version of &gdb; is documented briefly in the &gdb;
      User Guide <xref linkend="ref_gdb_ug" />. A more comprehensive
      tutorial <xref linkend="ref_or1k_gdb" /> is provided within the
      <filename>gdb/doc</filename> sub-directory in the file
      <filename>or1k.texinfo</filename>.
    </para>
    <indexterm>
      <primary>documentation</primary>
      <secondary>source</secondary>
      <tertiary>&or1k; Target &gdb; User Guide</tertiary>
    </indexterm>

    <para>
      Strictly speaking this was not a new port. An old port existed for &gdb;
      5.3. However &gdb; has changed substantially since that time, and an
      almost complete reimplementation was required.
    </para>
    <indexterm>
      <primary>&or1k;</primary>
      <secondary>legacy &gdb;&nbsp;5.3 port</secondary>
    </indexterm>

    <tip>
      <para>
	When working with any large code base a TAGS file is invaluable. This
	allows immediate lookup of any procedure or variable across the entire
	code base. Normally for any &gnu; project, this is achieved with the
	command <command>make tags</command>. However this does not work for
	&gdb;&mdash;there is a problem with the <literal>tags</literal> target
	in the <filename>opcodes</filename> directory.
      </para>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>TAGS file</secondary>
      </indexterm>
      <indexterm>
	<primary>TAGS file</primary>
	<see>&gdb;</see>
      </indexterm>

      <para>
	However tags building <emphasis>does</emphasis> work in the
	<filename>gdb</filename> directory, so a <filename>TAGS</filename>
	file can be built in that directory by:
      </para>

      <informalexample>
	<literallayout>
<command>cd gdb</command>
<command>make tags</command>
<command>cd ..</command>
	</literallayout>
      </informalexample>
	
    </tip>

    <sect1>
      <title>
	&bfd; Specification
      </title>

      <para>
	The &bfd; specification for &or1k; already existed (it is part
	of &binutils;), so there was no need to implement this. The existing
	code is just reused.
      </para>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>&bfd;</secondary>
	<tertiary>variations from documented standard</tertiary>
      </indexterm>
      <indexterm>
	<primary>&bfd;</primary>
	<secondary>&or1k;</secondary>
	<see>&or1k;</see>
      </indexterm>

    </sect1>

    <sect1 id="sec_target_arch">
      <title>
	&or1k; Architecture Specification
      </title>

      <para>
	The code resides in the <filename>gdb</filename> sub-directory. The
	main architectural specification is in
	<filename>or1k-tdep.c</filename>, with and &or1k; wide header
	in <filename>or1k-tdep.h</filename>. Support for the &or1k; 
	Remote &jtag; interface is in <filename>remote-or1k.c</filename> with
	the detailed protocol in <filename>or1k-jtag.c</filename> and a
	protocol header in <filename>or1k-jtag.h</filename>.
      </para>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>source files for &gdb; port</secondary>
      </indexterm>
      <indexterm>
	<primary><filename>gdb</filename> directory</primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-tdep.c</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-tdep.h</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>remote-or1k.c</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-jtag.c</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-jtag.h</filename></primary>
      </indexterm>

      <para>
	There are several targets which can use the &or1k; 
	architecture. These all begin <literal>or16</literal>,
	<literal>or32</literal> or <literal>or32</literal>. The
	<filename>configure.tgt</filename> is edited to add patterns for these
	that will pick up the binaries generated from these source files.
      </para>
      <indexterm>
	<primary><filename>configure.tgt</filename></primary>
	<secondary>&or1k; targets supported</secondary>
      </indexterm>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>supported targets in &gdb;</secondary>
      </indexterm>

      <informalexample>
	<programlisting>
or16* | or32* | or64*)
        # Target: OpenCores &or1k; architecture
        gdb_target_obs="or1k-tdep.o remote-or1k.o or1k-jtag.o"
        ;;
	</programlisting>
      </informalexample>

      <caution>
	<para>
	  <filename>configure.tgt</filename> only specifies binaries, so
	  cannot show dependencies on headers. To correct this,
	  <filename>Makefile.in</filename> can be edited, so that <command>automake</command> and
	  configure will generate a <filename>Makefile</filename> with the
	  correct dependencies.
	</para>
	<indexterm>
	  <primary><filename>configure.tgt</filename></primary>
	  <secondary>header file dependencies</secondary>
	</indexterm>
      </caution>

      <para>
	The architecture definition is created from the
	<function>_initialize_or1k_tdep</function> by a call to
	<function>gdbarch_register</function>. That function also initializes
	the disassembler (<function>build_automata</function>) and adds two
	new commands: a sub-command to the <command>info</command> command to
	read &spr;s and a new top level support command,
	<command>spr</command> to set the value of &spr;s.
      </para>
      <indexterm>
	<primary><function>_initialize_or1k_tdep</function></primary>
      </indexterm>
      <indexterm>
	<primary><function>gdbarch_register</function></primary>
      </indexterm>
      <indexterm>
	<primary><function>build_automata</function></primary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>info spr</command></secondary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>spr</command></secondary>
      </indexterm>
      <indexterm>
	<primary><command>info spr</command></primary>
	<see>&gdb; commands</see>
      </indexterm>
      <indexterm>
	<primary><command>spr</command></primary>
	<see>&gdb; commands</see>
      </indexterm>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>additional &gdb; commands</secondary>
      </indexterm>

      <sect2>
	<title>
	  Creating &gdbarch;
	</title>

	<para>
	  <function>gdbarch_register</function> is called for &bfd; type
	  <constant>bfd_arch_or32</constant> with the initialization function
	  <function>or1k_gdbarch_init</function> and the target specific dump
	  function, <function>or1k_dump_tdep</function>.
	</para>
	<indexterm>
	  <primary><function>gdbarch_register</function></primary>
	</indexterm>
	<indexterm>
	  <primary><constant>bfd_arch_or32</constant></primary>
	</indexterm>
	<indexterm>
	  <primary><function>or1k_gdbarch_init</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>or1k_dump_tdep</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>&bfd;</secondary>
	</indexterm>

	<para>
	  Future implementations may make additional calls to use the same
	  function to create a 64-bit version of the architecture.
	</para>

	<para>
	  <function>gdbarch_init</function> receives the &gdbarch_info;
	  created from the &bfd; entries and the list of existing
	  architectures. That list is first checked, using
	  <function>gdbarch_list_lookup_by_info</function> to see if there is
	  already an architecture defined suitable for the given
	  &gdbarch_info; and if so it is returned.
	</para>
	<indexterm>
	  <primary>&gdbarch_info;</primary>
	  <secondary>for &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary><function>gdbarch_list_lookup_by_info</function></primary>
	</indexterm>

	<para>
	  Otherwise a new &gdbarch; is created. For that the target
	  dependencies are saved in an &or1k; specific
	  <structname>struct&nbsp;gdbarch_tdep</structname>, defined in
	  <filename>or1k-tdep.h</filename>.
	</para>
	<indexterm>
	  <primary><structname>struct&nbsp;gdbarch_tdep</structname></primary>
	  <secondary>for &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary><filename>or1k-tdep.h</filename> file</primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>creating new instance</secondary>
	  <tertiary>for &or1k;</tertiary>
	</indexterm>

	<informalexample>
	  <programlisting>
struct gdbarch_tdep
{
  unsigned int  num_matchpoints;
  unsigned int  num_gpr_regs;
  int           bytes_per_word;
  int           bytes_per_address;
};
	  </programlisting>
	</informalexample>
	  
	<para>
	  This is information beyond that which is held in the &gdbarch;. By
	  using this structure, the &gdb; implementation for &or1k; can
	  be made flexible enough to deal with both 32 and 64-bit
	  implementations and with variable numbers of registers and
	  matchpoints.
	</para>

	<caution>
	  <para>
	    Although this flexibility is built in to the code, the current
	    implementation has only been tested with 32-bit OpenRISC 32
	    registers.
	  </para>
	</caution>

	<para>
	  The new architecture is then created by
	  <function>gdbarch_alloc</function>, passing in the &gdbarch_info;
	  and the <structname>struct&nbsp;gdbarch_tdep</structname>. The
	  &gdbarch; is populated using the various
	  <literal>set_gdbarch_</literal> functions, and &or1k; Frame
	  sniffers are associated with the architecture.
	</para>
	<indexterm>
	  <primary><function>gdbarch_alloc</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary><function>set_gdbarch</function> functions</secondary>
	</indexterm>

	<para>
	  When creating a new &gdbarch; a function must be provided to dump
	  the target specific definitions in &gdbarch_tdep; to a file. This is
	  provided in <function>or1k_dump_tdep</function>. It is passed a
	  pointer to the &gdbarch; and a file handle and simply writes out the
	  fields in the &gdbarch_tdep; with suitable explanatory text.
	</para>
	<indexterm>
	  <primary><function>or1k_dump_tdep</function></primary>
	</indexterm>
      </sect2>

      <sect2>
	<title>
	  &or1k; Hardware Data Representation
	</title>

	<para>
	  The first entries in &gdbarch; initialize the size and format of all
	  the standard data types.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>hardware data representation</secondary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary>values for &or1k;</tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>short_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>int_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>long_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>long_long_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>float_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>float_format</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>double_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>double_format</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>long_double_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>long_double_format</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>ptr_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>addr_bit</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>char_signed</varname></tertiary>
	</indexterm>

        <informalexample>
	  <programlisting>
set_gdbarch_short_bit             (gdbarch, 16);
set_gdbarch_int_bit               (gdbarch, 32);
set_gdbarch_long_bit              (gdbarch, 32);
set_gdbarch_long_long_bit         (gdbarch, 64);
set_gdbarch_float_bit             (gdbarch, 32);
set_gdbarch_float_format          (gdbarch, floatformats_ieee_single);
set_gdbarch_double_bit            (gdbarch, 64);
set_gdbarch_double_format         (gdbarch, floatformats_ieee_double);
set_gdbarch_long_double_bit       (gdbarch, 64);
set_gdbarch_long_double_format    (gdbarch, floatformats_ieee_double);
set_gdbarch_ptr_bit               (gdbarch, binfo->bits_per_address);
set_gdbarch_addr_bit              (gdbarch, binfo->bits_per_address);
set_gdbarch_char_signed           (gdbarch, 1);
	  </programlisting>
	</informalexample>
      </sect2>

      <sect2>
	<title>
	  Information Functions for the &or1k; Architecture
	</title>

	<para>
	  These &gdbarch; functions provide information about the architecture.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>architecture</secondary>
	  <tertiary> information functions</tertiary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary>implementations for &or1k;</tertiary>
	</indexterm>

        <informalexample>
	  <programlisting>
set_gdbarch_return_value          (gdbarch, or1k_return_value);
set_gdbarch_breakpoint_from_pc    (gdbarch, or1k_breakpoint_from_pc);
set_gdbarch_single_step_through_delay
                                  (gdbarch, or1k_single_step_through_delay);
set_gdbarch_have_nonsteppable_watchpoint
                                  (gdbarch, 1);
switch (gdbarch_byte_order (gdbarch))
  {
  case BFD_ENDIAN_BIG:
    set_gdbarch_print_insn        (gdbarch, print_insn_big_or32);
    break;

  case BFD_ENDIAN_LITTLE:
    set_gdbarch_print_insn        (gdbarch, print_insn_little_or32);
    break;

  case BFD_ENDIAN_UNKNOWN:
    error ("or1k_gdbarch_init: Unknown endianism");
    break;
    }
	  </programlisting>
	</informalexample>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_return_value</function>. This function tells
	      &gdb; how a value of a particular type would be returned by the
	      &abi;. Structures/unions and large scalars (> 4 bytes) are
	      placed in memory and returned by reference
	      (<constant>RETURN_VALUE_ABI_RETURNS_ADDRESS</constant>. Smaller
	      scalars are returned in &gpr;&nbsp;11
	      (<constant>RETURN_VALUE_REGISTER_CONVENTION</constant>).
	    </para>
	    <indexterm>
	      <primary><function>or1k_return_value</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>return_value</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_breakpoint_from_pc</function> returns the
	      breakpoint function to be used at a given program counter
	      address. Since all &or1k; instructions are the same size,
	      this function always returns the same value, the instruction
	      sequence for a <literal>l.trap</literal> instruction.
	    </para>
	    <indexterm>
	      <primary><function>or1k_breakpoint_from_pc</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>breakpoint_from_pc</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>breakpoint instruction</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>instruction</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_single_step_through_delay</function>. This
	      function is used to determine if a single stepped instruction is
	      actually executing a delay slot. This is the case if the
	      previously executed instruction was a branch or jump.
	    </para>
	    <indexterm>
	      <primary>
		<function>or1k_single_step_through_delay</function>
	      </primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary>
		<function>single_step_through_delay</function>
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>delay slot</primary>
	      <secondary>in &or1k;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>print_insn_big_or32</function> and
	      <function>print_insn_little_or32</function>. There are two
	      variants of the disassembler, depending on the endianism. The
	      disassembler is discussed in more detail in <xref
	      linkend="sec_or1k_disasm" />.
	    </para>
	    <indexterm>
	      <primary><function>print_insn_big_or32</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>print_insn_little_or32</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>print_insn</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>disassembly</primary>
	      <secondary>for &or1k;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>endianism</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_or1k_reg_funcs">
	<title>
	  &or1k; Register Architecture
	</title>

	<para>
	  The register architecture is defined by two groups of &gdbarch;
	  functions and fields. The first group specifies the number of
	  registers (both raw and pseudo) and the register numbers of some
	  "special" registers.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>register assignment in &gdb;</secondary>
	</indexterm>
	<indexterm>
	  <primary>register</primary>
	  <secondary>architecture for &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_NUM_REGS</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>num_regs</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_NUM_PSEUDO_REGS</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>num_pseudo_regs</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_SP_REGNUM</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>sp_regnum</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>stack pointer</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_PC_REGNUM</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>pc_regnum</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>program counter</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_SR_REGNUM</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>ps_regnum</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Supervision Register</secondary>
	</indexterm>
	<indexterm>
	  <primary><constant>OR1K_FP_REGNUM</constant></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>fields</secondary>
	  <tertiary><varname>deprecated_fp_regnum</varname></tertiary>
	</indexterm>
	<indexterm>
	  <primary>frame pointer</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>

        <informalexample>
	  <programlisting>
set_gdbarch_pseudo_register_read  (gdbarch, or1k_pseudo_register_read);
set_gdbarch_pseudo_register_write (gdbarch, or1k_pseudo_register_write);
set_gdbarch_num_regs              (gdbarch, OR1K_NUM_REGS);
set_gdbarch_num_pseudo_regs       (gdbarch, OR1K_NUM_PSEUDO_REGS);
set_gdbarch_sp_regnum             (gdbarch, OR1K_SP_REGNUM);
set_gdbarch_pc_regnum             (gdbarch, OR1K_PC_REGNUM);
set_gdbarch_ps_regnum             (gdbarch, OR1K_SR_REGNUM);
set_gdbarch_deprecated_fp_regnum  (gdbarch, OR1K_FP_REGNUM);
	  </programlisting>
	</informalexample>

	<para>
	  The second group of functions provides information about registers.
	</para>

        <informalexample>
	  <programlisting>
set_gdbarch_register_name         (gdbarch, or1k_register_name);
set_gdbarch_register_type         (gdbarch, or1k_register_type);
set_gdbarch_print_registers_info  (gdbarch, or1k_registers_info);
set_gdbarch_register_reggroup_p   (gdbarch, or1k_register_reggroup_p);
	  </programlisting>
	</informalexample>

	<para>
	  The representation of the <emphasis>raw</emphasis> registers (see
	  <xref linkend="sec_regcache" />) is: registers 0-31 are the
	  corresponding &gpr;s, register 32 is the previous program counter,
	  33 is the next program counter (often just called
	  <emphasis>the</emphasis> program counter) and register 34 is the
	  supervision register. For convenience, constants are defined in the
	  header, <filename>or1k_tdep.h</filename>, for all the special
	  registers.
	</para>

	<informalexample>
	  <programlisting>
#define OR1K_SP_REGNUM         1
#define OR1K_FP_REGNUM         2
#define OR1K_FIRST_ARG_REGNUM  3
#define OR1K_LAST_ARG_REGNUM   8
#define OR1K_LR_REGNUM         9
#define OR1K_RV_REGNUM        11
#define OR1K_PC_REGNUM       (OR1K_MAX_GPR_REGS + 0)
#define OR1K_SR_REGNUM       (OR1K_MAX_GPR_REGS + 1)
	  </programlisting>
	</informalexample>

	<para>
	  In this implementation there are no pseudo-registers. A set could
	  have been provided to represent the &gpr;s in floating point format
	  (for use with the floating point instructions), but this has not
	  been implemented. Constants are defined for the various totals
	</para>

	<informalexample>
	  <programlisting>
#define OR1K_MAX_GPR_REGS    32
#define OR1K_NUM_PSEUDO_REGS  0
#define OR1K_NUM_REGS        (OR1K_MAX_GPR_REGS + 3)
#define OR1K_TOTAL_NUM_REGS  (OR1K_NUM_REGS + OR1K_NUM_PSEUDO_REGS)
	  </programlisting>
	</informalexample>

	<caution>
	  <para>
	    These totals are currently hard-coded constants. They should
	    really draw on the data in the &gdbarch_tdep;, providing support
	    for architectures which have less than the full complement of 32
	    registers. This functionality will be provided in a future
	    implementation.
	  </para>
	</caution>
	  
	<para>
	  One consequence of providing no pseudo-registers is that the frame
	  pointer variable, <command>$fp</command> in &gdb; will not have its
	  correct value. The provision of this register as an intrinsic part
	  of &gdb; is no longer supported. If it is wanted then it should be
	  defined as a register or pseudo-register.
	</para>

	<para>
	  However if there is no register with this name, &gdb; will use
	  either the value of the <varname>deprecated_fp_regnum</varname>
	  value in &gdbarch; or the current frame base, as reported by the
	  frame base sniffer.
	</para>

	<para>
	  For the time being, the <varname>deprecated_fp_regnum</varname> is
	  set. However the longer term plan will be to represent the
	  frame-pointer as a pseudo-register, taking the value of
	  &gpr;&nbsp;2.
	</para>

	<para>
	  The register architecture is mostly a matter of setting the values
	  required in &gdbarch;. However two functions,
	  <function>or1k_pseudo_register_read</function> and
	  <function>or1k_pseudo_register_write</function> are defined to
	  provide access to any pseudo-register. These functions are defined
	  to provide hooks for the future, but in the absence of any
	  pseudo-registers they do nothing.
	</para>
	<indexterm>
	  <primary>or1k_pseudo_register_read</primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>pseudo_register_read</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>or1k_pseudo_register_write</primary>
	</indexterm>
	<indexterm>
	  <primary>&gdbarch;</primary>
	  <secondary>functions</secondary>
	  <tertiary><function>pseudo_register_write</function></tertiary>
	</indexterm>

	<para>
	  There are set of functions which yield information about the name
	  and type of registers and which provide the output for the &gdb;
	  <command>info&nbsp;registers</command> command.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_register_name</function>. This is a simple
	      table lookup to yield the register name from its number.
	    </para>
	    <indexterm>
	      <primary>or1k_register_name</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>register_name</function></tertiary>
	    </indexterm>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_type</function>. This function must
	      return the type as a
	      <structname>struct&nbsp;type</structname>. This &gdb; data
	      structure contains detailed information about each type and
	      its relationship to other types.
	    </para>
	    <indexterm>
	      <primary>or1k_register_type</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>register_type</function></tertiary>
	    </indexterm>

	    <para>
	      For the purposes of this function, a number of standard types
	      are predefined, with utility functions to construct other
	      types from them. For most registers the predefined
	      <constant>builtin_type_int32</constant> is suitable. The stack
	      pointer and frame pointer are pointers to arbitrary data, so
	      the equivalent of <type>void *</type> is required. This is
	      constructed by applying the function
	      <function>lookup_pointer_type</function> to the predefined
	      <constant>builtin_type_void</constant>. The program counter is
	      a pointer to code, so the equivalent of a pointer to a void
	      function is appropriate. This is constructed by applying
	      <function>lookup_pointer_type</function> and
	      <function>lookup_function_type</function> to
	      <constant>builtin_type</constant>.
	    </para>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>register types in &gdb;</secondary>
	    </indexterm>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_info</function>. This function is used
	      by the <command>info&nbsp;registers</command> command to
	      display information about one or more registers.
	    </para>
	    <indexterm>
	      <primary>or1k_register_info</primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>register_info</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>info&nbsp;registers</command></secondary>
	    </indexterm>

	    <para>
	      This function is not really needed. It is just a wrapper for
	      <function>default_print_registers_info</function>, which is
	      the default setting for this function anyway.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <function>or1k_register_reggroup_p</function>. This predicate
	      function returns 1 (true) if a given register is in a
	      particular group. This is used by the command
	      <command>info&nbsp;registers</command> when registers in a
	      particular category are requested.
	    </para>
	    <indexterm>
	      <primary><function>or1k_register_reggroup_p</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>register_reggroup_p</function></tertiary>
	    </indexterm>
	    <para>
	      The function as implemented is little different from the
	      default function
	      (<function>default_register_reggroup_p</function>), which is
	      called for any unknown cases anyway. However it does make use
	      of the target dependent data (&gdbarch_tdep;), thus providing
	      flexibility for different &or1k; architectures.
	    </para>
	    <indexterm>
	      <primary>&gdbarch_tdep;</primary>
	      <secondary>for &or1k;</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>	
	    
      </sect2>

      <sect2 id="sec_or1k_frames">
	<title>
	  &or1k; Frame Handling
	</title>

	<para>
	  The &or1k; frame structure is described in its &abi; <xref
	  linkend="ref_or1k" />. Some of the detail is slightly different in
	  current OpenRISC implementations&mdash;this is described in <xref
	  linkend="sec_or1k_abi" />.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>&abi;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>frame handling</secondary>
	</indexterm>

	<para>
	  The key to frame handling is understanding the prologue (and
	  possibly epilogue) in each function which is responsible for
	  initializing the stack frame. For the &or1k;, &gpr;&nbsp;1 is
	  used as the stack pointer, &gpr;&nbsp;2 as the frame pointer and
	  &gpr;&nbsp;9 as the return address. The prologue sequence is:
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>register assignment in &gdb;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>function prologue</secondary>
	</indexterm>
	<indexterm>
	  <primary>function prologue</primary>
	  <see>&or1k;</see>
	</indexterm>

	<informalexample>
	  <literallayout><literal>l.addi  r1,r1,-</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>(r1),r2</literal>
<literal>l.addi  r2,r1,</literal><emphasis>frame_size</emphasis>
<literal>l.sw    </literal><emphasis>save_loc</emphasis><literal>-4(r1),r9</literal>
<literal>l.sw    </literal><emphasis>x</emphasis><literal>(r1),r</literal><emphasis>y</emphasis></literallayout>
	</informalexample>

	<para>
	  The &or1k; stack frame accommodates any local (automatic)
	  variables and temporary values, then the return address, then the
	  old frame pointer and finally any stack based arguments to functions
	  called by this function. This last rule means that the return
	  address and old frame pointer are not necessarily at the end of the
	  stack frame - enough space will be left to build up any arguments
	  for called functions that must go on the stack. <xref
	  linkend="fig_prologue_frame" 
	  /> shows how the stack looks at the end of the prologue.
	</para>

	<figure id="fig_prologue_frame">
	  <title>
	    The &or1k; stack frame at the end of the prologue
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="prologue_frame.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Not all fields are always present. The function need not save its
	  return address to stack, and there may be no callee-saved registers
	  (i.e. &gpr;s 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30) which
	  require saving. Leaf functions are not required to set up a new
	  stack frame at all.
	</para>

	<para>
	  The epilogue is the inverse. Callee-saved registers are restored,
	  the return address placed in &gpr;&nbsp;9 and the stack and frame
	  pointers restored before jumping to the address in &gpr;&nbsp;9.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>function epilogue</secondary>
	</indexterm>
	<indexterm>
	  <primary>function epilogue</primary>
	  <see>&or1k;</see>
	</indexterm>

	<informalexample>
	  <literallayout>
<literal>l.lwz   r</literal><emphasis>y</emphasis><literal>,</literal><emphasis>x</emphasis><literal>(r1)</literal>
<literal>l.lwz   r9,</literal><emphasis>save_loc</emphasis><literal>-4(r1)</literal>
<literal>l.lwz   r2,</literal><emphasis>save_loc</emphasis><literal>(r1)</literal>
<literal>l.jr    r9</literal>
<literal>l.addi  r1,r1,</literal><emphasis>frame_size</emphasis>
</literallayout>
	</informalexample>

	<para>
	  Only those parts of the epilogue which correspond to the prologue
	  need actually appear. The &or1k; has a delay slot after
	  branch instructions, so for efficiency the stack restoration can be
	  placed after the <literal>l.jr</literal> instruction.
	</para>
	<indexterm>
	  <primary>delay slot</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>

	<sect3>
	  <title>
	    &or1k; Functions Analyzing Frames
	  </title>

	  <para>
	    A group of &gdbarch; functions and a value provide information about
	    the current stack and how it is being processed by the target
	    program.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>functions for &or1k;</secondary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
set_gdbarch_skip_prologue         (gdbarch, or1k_skip_prologue);
set_gdbarch_inner_than            (gdbarch, core_addr_lessthan);
set_gdbarch_frame_align           (gdbarch, or1k_frame_align);
set_gdbarch_frame_red_zone_size   (gdbarch, OR1K_FRAME_RED_ZONE_SIZE);
	    </programlisting>
	  </informalexample>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_skip_prologue</function>. This function returns
		the end of the function prologue, if the program counter is
		currently in a function prologue.
	      </para>
	      <indexterm>
		<primary><function>or1k_skip_prologue</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>skip_prologue</function></tertiary>
	      </indexterm>

	      <para>
		The initial approach is to use the DWARF2 symbol-and-line
		(&sal;) information to identify the start of the function
		(<function>find_pc_partial_function</function> and hence the
		end of the prologue
		(<function>skip_prologue_using_sal</function>).
	      </para>
	      <indexterm>
		<primary><function>find_pc_partial_function</function></primary>
	      </indexterm>
	      <indexterm>
		<primary><function>skip_prologue_using_sal</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>symbol-and-line (SAL) information</primary>
	      </indexterm>

	      <para>
		If this information is not available,
		<function>or1k_skip_prologue</function> reuses the helper
		functions from the frame sniffer function,
		<function>or1k_frame_unwind_cache</function> (see <xref
		linkend="sec_or1k_frame_funcs" />) to step through code that
		appears to be function prologue.
	      </para>
	      <indexterm>
		<primary><function>or1k_frame_unwind_cache</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>unwinder</secondary>
		<tertiary>for &or1k;</tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>core_addr_lessthan</function>. This standard function
		returns 1 (true) if its first argument is a lower address than
		its second argument. It provides the functionality required by
		the &gdbarch; <function>inner_than</function> function for
		architectures like &or1k;, which have falling stack
		frames.
	      </para>
	      <indexterm>
		<primary><function>core_addr_lessthan</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>inner_than</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>falling</secondary>
		<tertiary>&or1k; as example</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>rising</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_align</function>. This function takes a
		stack pointer and returns a value (expanding the frame) which
		meets the stack alignment requirements of the &abi;. Since the
		&or1k; &abi; uses a falling stack, this uses the
		built-in function, <function>align_down</function>. The
		alignment is specified in the constant
		<constant>OR1K_STACK_ALIGN</constant> defined in
		<filename>or1k-tdep.h</filename>.
	      </para>
	      <indexterm>
		<primary><function>or1k_frame_align</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>frame_align</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>alignment</secondary>
		<tertiary>for &or1k;</tertiary>
	      </indexterm>
	      <indexterm>
		<primary><constant>OR1K_STACK_ALIGN</constant></primary>
	      </indexterm>

	      <note>
		<para>
		  The &or1k; &abi; specifies that frames should be
		  double-word aligned. However the version of &gcc; in the
		  current OpenRISC tool chain implements single-word
		  alignment. So the current &gdb; implementation specifies
		  <constant>OR1K_STACK_ALIGN</constant> to be 4, not 8.
		</para>
		<indexterm>
		  <primary>&or1k;</primary>
		  <secondary>&abi;</secondary>
		  <tertiary>variations from documented standard</tertiary>
		</indexterm>
		<indexterm>
		  <primary>&or1k;</primary>
		  <secondary>&abi;</secondary>
		  <tertiary>stack frame alignment</tertiary>
		</indexterm>
	      </note>
	    </listitem>

	    <listitem>
	      <para>
		<constant>OR1K_FRAME_RED_ZONE_SIZE</constant>. The &or1k; 
		reserves the 2,560 bytes below the stack pointer for use by
		exception handlers and frameless functions. This is known as a
		<emphasis>red zone</emphasis> (an AMD term). This constant is
		recorded in the &gdbarch; <varname>frame_red_zone_size</varname>
		field. Any dummy stack frames (see <xref
		linkend="sec_dummy_frame" />) will be placed after this point.
	      </para>
	      <indexterm>
		<primary><constant>OR1K_FRAME_RED_ZONE_SIZE</constant></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>fields</secondary>
		<tertiary><varname>frame_red_zone_size</varname></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&or1k;</primary>
		<secondary>red zone</secondary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>frameless function</secondary>
		<tertiary>for &or1k;</tertiary>
	      </indexterm>
	      <indexterm>
		<primary>frameless function</primary>
		<see>stack frame</see>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &or1k; Functions for Accessing Frame Data
	  </title>

	  <informalexample>
	    <programlisting>
set_gdbarch_unwind_pc             (gdbarch, or1k_unwind_pc);
set_gdbarch_unwind_sp             (gdbarch, or1k_unwind_sp);
	    </programlisting>
	  </informalexample>

	  <para>
	    There are only two functions required here,
	    <function>or1k_unwind_pc</function> and
	    <function>or1k_unwind_sp</function>. Given a pointer to the &next;
	    frame, these functions return the value of respectively the program
	    counter and stack pointer in &this; frame.
	  </para>
	  <indexterm>
	    <primary><function>or1k_unwind_pc</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>unwind_pc</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_unwind_sp</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>unwind_sp</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>functions for &or1k;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>register</primary>
	    <secondary>functions for &or1k;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>program_counter</primary>
	    <secondary>value in stack frame</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>stack pointer value in</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>

	  <para>
	    Since the OpenRISC architecture defines standard frame sniffers,
	    and both these registers are raw registers, the functions can be
	    implemented very simply by a call to
	    <function>frame_unwind_register_unsigned</function>.
	  </para>
	  <indexterm>
	    <primary>
	      <function>frame_unwind_register_unsigned</function>
	    </primary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>unwinder</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>

	</sect3>

	<sect3 id="sec_dummy_frame">
	  <title>
	    &or1k; Functions to Create Dummy Stack Frames
	  </title>

	  <para>
	    Two &gdbarch; provide support for calling code in the target
	    inferior.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>dummy</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
set_gdbarch_push_dummy_call       (gdbarch, or1k_push_dummy_call);
set_gdbarch_unwind_dummy_id       (gdbarch, or1k_unwind_dummy_id);
	    </programlisting>
	  </informalexample>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_push_dummy_call</function>. This function
		creates a dummy stack frame, so that &gdb; can evaluate a
		function within the target code (for example in a
		<command>call</command> command). The input arguments include
		all the parameters for the call, including the return address
		and an address where a structure should be returned.
	      </para>
	      <indexterm>
		<primary><function>or1k_push_dummy_call</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>push_dummy_call</function></tertiary>
	      </indexterm>
	      <indexterm>
		<primary>&gdb; commands</primary>
		<secondary><command>call</command></secondary>
	      </indexterm>

	      <para>
		The return address for the function is always breakpointed (so
		&gdb; can trap the return). This return address is written
		into the link register (in the register cache) using
		<function>regcache_cooked_write_unsigned</function>).
	      </para>
	      <indexterm>
		<primary>
		  <function>regcache_cooked_write_unsigned</function>
		</primary>
	      </indexterm>
	      <indexterm>
		<primary>&or1k;</primary>
		<secondary>link register</secondary>
	      </indexterm>

	      <para>
		If the function is to return a structure, the address where
		the structure is to go is passed as a first argument, in
		&gpr;&nbsp;3.
	      </para>
	      <indexterm>
		<primary>&or1k;</primary>
		<secondary>&abi;</secondary>
	      </indexterm>

	      <para>
		The next arguments are passed in the remaining argument
		registers (up to &gpr;&nbsp;8). Structures are passed by
		reference to their locating in memory. For 32-bit
		architectures passing 64-bit arguments, a pair of registers (3
		and 4, 5 and 6 or 7 and 8) are used.
	      </para>

	      <para>
		Any remaining arguments must be pushed on the end of the
		stack. There is a difficulty here, since pushing each argument
		may leave the stack misaligned (&or1k; specifies
		double-word alignment). So the code first works out the space
		required, then adjusts the resulting stack pointer to the
		correct alignment. The arguments can then be written to the
		stack in the correct location.
	      </para>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>alignment</secondary>
		<tertiary>for &or1k;</tertiary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_unwind_dummy_id</function>. This is the inverse
		of <function>or1k_push_dummy_call</function>. Given a pointer
		to the &next; stack frame (which will be the frame of the
		dummy call), it returns the frame ID (that is the stack
		pointer and function entry point address) of &this; frame.
	      </para>
	      <indexterm>
		<primary><function>or1k_unwind_dummy_id</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>&gdbarch;</primary>
		<secondary>functions</secondary>
		<tertiary><function>unwind_dummy_id</function></tertiary>
	      </indexterm>

	      <para>
		This is not completely trivial. For a dummy frame, the &next;
		frame information about &this; frame is not necessarily
		complete, so a simple call to
		<function>frame_unwind_id</function> recurses back to this
		function <emphasis>ad infinitum</emphasis>. Instead the frame
		information is built by unwind the stack pointer and program
		counter and attempting to use DWARF2 symbol-and-line (&sal;)
		information to find the start of the function from the &pc;
		with <function>find_pc_partial_function</function>. If that
		information is not available, the program counter is used as a
		proxy for the function start address.
	      </para>
	      <indexterm>
		<primary><function>frame_unwind_id</function></primary>
	      </indexterm>
	      <indexterm>
		<primary><function>find_pc_partial_function</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>unwinder</secondary>
		<tertiary>for &or1k;</tertiary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	</sect3>

	<sect3>
	  <title>
	    &or1k; Frame Sniffers
	  </title>

	  <para>
	    The preceding functions all have a 1:1 relationship with
	    &gdbarch;. However for stack analysis (or "sniffing") more than one
	    approach may be appropriate, so a list of functions is
	    maintained.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>functions for &or1k;</secondary>
	  </indexterm>

	  <para>
	    The low level stack analysis functions are set by
	    <function>frame_unwind_append_sniffer</function>. The &or1k; 
	    has its own sniffers for finding the ID of a frame and getting the
	    value of a register on the frame specified by
	    <function>or1k_frame_sniffer</function>. For all other sniffing
	    functions, the default DWARF2 frame sniffer is used,
	    <function>dwarf2_frame_sniffer</function>.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>sniffer</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><function>frame_unwind_append_sniffer</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_sniffer</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>DWARF2</primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>dwarf2_frame_sniffer</function></primary>
	  </indexterm>

	  <para>
	    The high level sniffer finds the base of the stack frame. OpenRISC
	    defines its own base sniffer,
	    <structname>or1k_frame_base</structname> as default. It provides all
	    the functionality needed, so can be used as the default base
	    sniffer, set using <function>frame_base_set_default</function>. The
	    frame base is a structure, with entries pointing to the
	    corresponding frame sniffer and functions to give the base address
	    of the frame, the arguments on the frame and the local variables on
	    the frame. Since these are all the same for the &or1k;, the
	    same function, <function>or1k_frame_base_address</function> is used
	    for all three.
	  </para>
	  <indexterm>
	    <primary><structname>or1k_frame_base</structname></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>frame_base_set_default</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_base_address</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>for &or1k;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>base address</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>

	</sect3>
  
	<sect3 id="sec_or1k_frame_funcs">
	  <title>
	    &or1k; Frame Base Sniffer
	  </title>

	  <para>
	    The same function, <function>or1k_frame_base_address</function> is
	    used to provide all three base functions: for the frame itself,
	    the local variables and any arguments. In the &or1k; these
	    are all the same value.
	  </para>
	  <indexterm>
	    <primary><function>or1k_frame_base_address</function></primary>
	  </indexterm>

	  <informalexample>
	    <programlisting>
or1k_frame_base.unwind      = or1k_frame_sniffer (NULL);
or1k_frame_base.this_base   = or1k_frame_base_address;
or1k_frame_base.this_locals = or1k_frame_base_address;
or1k_frame_base.this_args   = or1k_frame_base_address;
frame_base_set_default            (gdbarch, &amp;or1k_frame_base);
	    </programlisting>
	  </informalexample>
	  <indexterm>
	    <primary><function>or1k_frame_sniffer</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>for &or1k;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_base</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_locals</function></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_base</structname></primary>
	    <secondary>functions</secondary>
	    <tertiary><function>this_args</function></tertiary>
	  </indexterm>

	  <para>
	    The specification of this function requires the end of
	    the stack, i.e. the stack pointer. Rather confusingly the function
	    is also used to
	    determine the value of the <varname>$fp</varname> variable if
	    <varname>deprecated_fp_regnum</varname> has not been set and there
	    is no register with the name "fp". However, as noted earlier, &gdb;
	    is moving away from an intrinsic understanding of frame
	    pointers. For the &or1k;,
	    <varname>deprecated_fp_regnum</varname> is currently defined,
	    although in time a pseudo register will be defined, with the name
	    of <literal>fp</literal> and mapping to &gpr;&nbsp;2.
	  </para>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>fields</secondary>
	    <tertiary><varname>deprecated_fp_regnum</varname></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdb;</primary>
	    <secondary>built in variables</secondary>
	    <tertiary><command>$fp</command></tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>frame_pointer</primary>
	    <secondary>in &or1k;</secondary>
	  </indexterm>

	  <para>
	    Like all the frame sniffers, this function is
	    passed the address of the &next; frame, and requires the value for
	    &this; frame, so the value of the stack pointer is unwound from
	    the stack by using the generic register unwinder,
	    <function>frame_unwind_register_unsigned</function>.
	    <indexterm>
	      <primary>
		<function>frame_unwind_register_unsigned</function>
	      </primary>
	    </indexterm>
	  </para>
	</sect3>

	<sect3>
	  <title>
	    &or1k; Low Level Frame Sniffers
	  </title>

	  <para>
	    The function <function>or1k_frame_sniffer</function> returns a
	    pointer to <structname>struct&nbsp;frame_unwind</structname> with
	    entries for the functions defined by this sniffer. For the
	    &or1k;, this defines a custom function to construct the
	    frame ID of &this; frame given a pointer to the &next; frame
	    (<function>or1k_frame_this_id</function>) and a custom function to
	    give the value of a register in &this; frame given a pointer to
	    the &next; frame (<function>or1k_frame_prev_register</function>).
	  </para>
	  <indexterm>
	    <primary><function>or1k_frame_sniffer</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_this_id</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_prev_register</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><structname>struct&nbsp;frame_unwind</structname></primary>
	    <secondary>for &or1k;</secondary>
	  </indexterm>

	  <itemizedlist>
	    <listitem>
	      <para>
		<function>or1k_frame_this_id</function>. This function's
		inputs are a pointer to the &next; frame and the prologue
		cache (if any exists) for &this; frame. It uses the main
		&or1k; frame analyzer,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>
	      <indexterm>
		<primary><function>or1k_frame_unwind_cache</function></primary>
	      </indexterm>

	      <para>
		From the cached data, the function returns the
		<emphasis>frame&nbsp;ID</emphasis>. This comprises two values,
		the stack pointer for this frame and the address of the code
		(typically the entry point) for the function using this stack
		frame
	      </para>

	      <note>
		<para>
		  Strictly speaking frame IDs can have a third value, the
		  <emphasis>special address</emphasis> for use with
		  architectures which have more complex frame
		  structures. However this is rarely used.
		</para>
	      </note>
	      <indexterm>
		<primary>frame&nbsp;ID</primary>
		<see>stack frame</see>
	      </indexterm>
	      <indexterm>
		<primary>stack frame</primary>
		<secondary>frame ID</secondary>
		<seealso><structname>struct&nbsp;frame_id</structname></seealso>
	      </indexterm>

	      <para>
		The result is returned in a
		<structname>struct&nbsp;frame_id</structname> passed by
		reference as a third argument. Since the implementation uses
		the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_id</function> function to decode the
		frame ID from the cache.
	      </para>
	      <indexterm>
		<primary><structname>struct&nbsp;frame_id</structname></primary>
	      </indexterm>
	      <indexterm>
		<primary>
		  <structname>struct&nbsp;trad_frame_cache</structname>
		</primary>
	      </indexterm>
	      <indexterm>
		<primary><function>trad_frame_get_id</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>prologue cache</primary>
		<secondary>for &or1k;</secondary>
	      </indexterm>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1k_frame_prev_register</function>. This function's
		inputs are a pointer to the &next; frame, the prologue cache
		(if any exists) for &this; frame and a register number. It
		uses the main &or1k; frame analyzer,
		<function>or1k_frame_unwind_cache</function> to generate the
		prologue cache if it does not exist (see below).
	      </para>
	      <indexterm>
		<primary><function>or1k_frame_prev_register</function></primary>
	      </indexterm>
	      <indexterm>
		<primary><function>or1k_frame_unwind_cache</function></primary>
	      </indexterm>

	      <para>
		From the cached data, a flag is returned indicating if the
		register has been optimized out (this is never the case), what
		sort of l-value the register represents (a register, memory or
		not an l-value), the address where it is saved in memory (if
		it is saved in memory), the number of a different register
		which holds the value of this register (if that is the case)
		and if a buffer is provided the actual value as obtained from
		memory or the register cache.
	      </para>
	      <indexterm>
		<primary>
		  <structname>struct&nbsp;trad_frame_cache</structname>
		</primary>
		<secondary>meaning of cached data fields</secondary>
	      </indexterm>

	      <para>
		Since the implementation uses the built in
		<structname>struct&nbsp;trad_frame_cache</structname> for its
		register cache, the code can use the
		<function>trad_frame_get_register</function> function to
		decode all this information from the cache.
	      </para>
	      <indexterm>
		<primary><function>trad_frame_get_register</function></primary>
	      </indexterm>
	      <indexterm>
		<primary>register</primary>
		<secondary>functions for &or1k;</secondary>
	      </indexterm>
	    </listitem>
	  </itemizedlist>

	  <para>
	    The &or1k; low level sniffers rely on
	    <function>or1k_frame_unwind_cache</function>. This is the heart of
	    the sniffer. It must determine the frame ID for &this; frame given
	    a pointer to the &next; frame and then the information in &this;
	    frame about the values of registers in the &prev; frame.
	  </para>

	  <para>
	    All this data is returned in a prologue cache (see <xref
	    linkend="sec_frames" />), a reference to which is passed as an
	    argument. If the cache already exists for &this; frame it can
	    be returned immediately as the result.
	  </para>

	  <para>
	    If the cache does not yet exist, it is allocated (using
	    <function>trad_frame_cache_zalloc</function>). The first step
	    is to unwind the start address of this function from the
	    &next; frame. The DWARF2 information in the object file can be
	    used to find the end of the prologue (using
	    <function>skip_prologue_using_sal</function>).
	  </para>
	  <indexterm>
	    <primary><function>trad_frame_cache_zalloc</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>DWARF2</primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>skip_prologue_using_sal</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>symbol-and-line (SAL) information</primary>
	  </indexterm>

	  <para>
	    The code then works through each instruction of the prologue
	    to find the data required.
	  </para>

	  <caution>
	    <para>
	      The analysis must only consider prologue instructions that
	      have actually been executed. It is quite possible the
	      program counter is in the prologue code, and only
	      instructions that have actually been executed should be
	      analyzed.
	    </para>
	  </caution>

	  <para>
	    The stack pointer and program counter are found by simply
	    unwinding the &next; frame. The stack pointer is the base of
	    &this; frame, and is added to the cache data using
	    <function>trad_frame_set_this_base</function>.
	  </para>
	  <indexterm>
	    <primary><function>trad_frame_set_this_base</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>stack pointer value in</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>program_counter</primary>
	    <secondary>value in stack frame</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>

	  <para>
	    <varname>end_iaddr</varname> marks the end of the code we
	    should analyze. Only instructions with addresses less than
	    this will be considered.
	  </para>

	  <para>
	    The <literal>l.addi</literal> instruction should be first and
	    its immediate constant field is the size of the stack. If it
	    is missing, then this is a frameless call to a function. If
	    the program counter is right at the start of the function,
	    before the stack and frame pointers are set up, then it will
	    also look like a frameless function.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>frameless function</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	    
	  <para>
	    Unless it is subsequently found to have been saved on the stack,
	    the program counter of the &prev; frame is the link register of
	    &this; frame and can be recorded in the register cache.
	  </para>
	  <indexterm>
	    <primary>&or1k;</primary>
	    <secondary>link register</secondary>
	  </indexterm>

	  <tip>
	    <para>
	      It is essential to save the register data using the correct
	      function.
	    </para>
	    <indexterm>
	      <primary>
		<structname>struct&nbsp;trad_frame_cache</structname>
	      </primary>
	      <secondary>choice of register data function</secondary>
	    </indexterm>

	    <itemizedlist>
	      <listitem>
		<para>
		  Use <function>trad_frame_set_reg_realreg</function> when a
		  register in the &prev; frame is obtained from a register in
		  &this; frame.
		</para>
		<indexterm>
		  <primary>
		    <function>trad_frame_set_reg_realreg</function>
		  </primary>
		</indexterm>
	      </listitem>

	      <listitem>
		<para>
		  Use <function>trad_frame_set_reg_addr</function> when a
		  register in the &prev; frame is obtained from an address in
		  &this; frame.
		</para>
		<indexterm>
		  <primary>
		    <function>trad_frame_set_reg_addr</function>
		  </primary>
		</indexterm>
	      </listitem>

	      <listitem>
		<para>
		  Use <function>trad_frame_set_reg_value</function> when a
		  register in the &prev; frame is a particular value in &this;
		  frame.
		</para>
		<indexterm>
		  <primary>
		    <function>trad_frame_set_reg_value</function>
		  </primary>
		</indexterm>
	      </listitem>
	    </itemizedlist>

	    <para>
	      The default entry for each register is that its value in the
	      &prev; frame is obtained from the same register in &this; frame.
	    </para>
	  </tip>

	  <para>
	    For a frameless call, there is no more information to be found, so
	    the rest of the code analysis only applies if the frame size was
	    non-zero.
	  </para>

	  <para>
	    The second instruction in the prologue is where the frame
	    pointer of the &prev; frame is saved. It is an error if this
	    is missing. The address where it is saved (the stack pointer
	    of &this; frame plus the offset in the <literal>l.sw</literal>
	    instruction) is saved in the cache using
	    <function>trad_frame_set_reg_addr</function>.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>frame pointer value in</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>frame pointer</primary>
	    <secondary>value in stack frame</secondary>
	    <see>stack frame</see>
	  </indexterm>

	  <para>
	    The third instruction should be an <literal>l.addi</literal>
	    instruction which sets the frame pointer. The frame size set in
	    this instruction should match the frame size set in the first
	    instruction. Once this has been set up, the frame pointer can be
	    used to yield the stack pointer of the previous frame. This
	    information is recorded in the register cache.
	  </para>

	  <para>
	    The fourth instruction is optional and saves the return
	    address to the stack. If this instruction is found, the entry
	    in the register cache for the program counter in the &prev;
	    frame must be changed using
	    <function>trad_frame_set_reg_addr</function> to indicate it is
	    found at an address in this frame.
	  </para>
	  <indexterm>
	    <primary>stack frame</primary>
	    <secondary>return address</secondary>
	    <tertiary>for &or1k;</tertiary>
	  </indexterm>
	  <indexterm>
	    <primary>&or1k;</primary>
	    <secondary>link register</secondary>
	  </indexterm>

	  <para>
	    All the subsequent instructions in the prolong should be saves
	    of callee-savable registers. These are checked for until the
	    code address has reached the end of the prologue. For each
	    instruction that is found, the save location of the register
	    is recorded in the cache using
	    <function>trad_frame_set_reg_addr</function>.
	  </para>

	  <para>
	    The detailed analysis in
	    <function>or1k_frame_unwind_cache</function> uses a series of
	    helper functions: <function>or1k_frame_size</function>,
	    <function>or1k_frame_fp_loc</function>,
	    <function>or1k_frame_size_check</function>,
	    <function>or1k_link_address</function> and
	    <function>or1k_get_saved_reg</function>. These helper routines
	    check each of the instructions in the prologue. By breaking out
	    this code into separate functions, they can be reused by
	    <function>or1k_skip_prologue</function>.
	  </para>
	  <indexterm>
	    <primary><function>or1k_frame_size</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_fp_loc</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_frame_size_check</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_link_address</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_get_saved_reg</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_skip_prologue</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>&gdbarch;</primary>
	    <secondary>functions</secondary>
	    <tertiary><function>skip_prologue</function></tertiary>
	  </indexterm>

	</sect3>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_remote_target">
      <title>
	&or1k; &jtag; Remote Target Specification
      </title>

      <para>
	The code for the remote target specification for the OpenRISC Remote
	&jtag; protocol is found in the <filename>gdb</filename>
	sub-directory. <filename>remote-or1k.c</filename> contains the target
	definition. The low-level interface is found in
	<filename>or1k-jtag.c</filename> with a shared header in
	<filename>or1k-jtagh</filename>.
      </para>
      <indexterm>
	<primary>target operations</primary>
	<secondary>for &or1k;</secondary>
      </indexterm>
      <indexterm>
	<primary><filename>gdb</filename> directory</primary>
      </indexterm>
      <indexterm>
	<primary><filename>remote-or1k.c</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-jtag.c</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-jtag.h</filename> file</primary>
      </indexterm>

      <para>
	The low-level interface is abstracted to a set of &or1k; 
	specific functions relating to the behavior of the target. Two
	implementations are provided (in <filename>or1k-jtag.c</filename>),
	one for targets connected directly through the host's parallel port,
	and one for targets connected over TCP/IP using the &or1k; 
	Remote JTAG Protocol.
      </para>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>direct connection (parallel port)</tertiary>
      </indexterm>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>remote connection over TCP/IP</tertiary>
	<see>Remote JTAG Protocol</see>
      </indexterm>
      <indexterm>
	<primary>Remote JTAG Protocol</primary>
      </indexterm>

      <informalexample>
	<programlisting>
void      or1k_jtag_init (char *args);
void      or1k_jtag_close ();
ULONGEST  or1k_jtag_read_spr (unsigned int  sprnum);
void      or1k_jtag_write_spr (unsigned int  sprnum,
                               ULONGEST      data);
int       or1k_jtag_read_mem (CORE_ADDR  addr,
                              gdb_byte  *bdata,
                              int        len);
int       or1k_jtag_write_mem (CORE_ADDR       addr,
                               const gdb_byte *bdata,
                               int             len);
void      or1k_jtag_stall ();
void      or1k_jtag_unstall ();
void      or1k_jtag_wait (int  fast);
	</programlisting>
      </informalexample>

      <para>
	The choice of which implementation to use is determined by the
	argument to <function>or1k_jtag_init</function>.
      </para>
      <indexterm>
	<primary>Remote JTAG Protocol</primary>
	<secondary>interface functions</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>
	    <function>or1k_jtag_init</function> and
	    <function>or1k_jtag_close</function>. Initialize and close a
	    connection to the target. <function>or1k_jtag_init</function> is
	    passed an argument string with the address of the target (either a
	    local device or a remote TCP/IP port address). An optional second
	    argument, <literal>reset</literal> can be provided to indicate the
	    target should be reset once connected.
	  </para>
	  <indexterm>
	    <primary><function>or1k_jtag_init</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_jtag_close</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary>Remote JTAG Protocol</primary>
	    <secondary>resetting the target</secondary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_read_spr</function> and
	    <function>or1k_jtag_write_spr</function>. Read or write a special
	    purpose register.
	  </para>
	  <indexterm>
	    <primary><function>or1k_jtag_read_spr</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_jtag_write_spr</function></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_read_mem</function> and
	    <function>or1k_jtag_write_mem</function>. Read or write a block of
	    memory.
	  </para>
	  <indexterm>
	    <primary><function>or1k_jtag_read_mem</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_jtag_write_mem</function></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_stall</function> and
	    <function>or1k_jtag_unstall</function>. Stall or unstall the target.
	  </para>
	  <indexterm>
	    <primary><function>or1k_jtag_stall</function></primary>
	  </indexterm>
	  <indexterm>
	    <primary><function>or1k_jtag_unstall</function></primary>
	  </indexterm>
	</listitem>

	<listitem>
	  <para>
	    <function>or1k_jtag_wait</function>. Wait for the target to stall.
	  </para>
	  <indexterm>
	    <primary><function>or1k_jtag_wait</function></primary>
	  </indexterm>
	</listitem>
      </itemizedlist>

      <para>
	The binaries for the remote target interface
	(<filename>remote-or1k.o</filename> and
	<filename>or1k-jtag.o</filename>) are added to the
	<filename>configure.tgt</filename> file for the OpenRISC targets. As
	noted in <xref linkend="sec_target_arch" />, this only specifies
	binaries, so dependencies on headers cannot be captured. To do this
	requires editing the <filename>Makefile.in</filename>.
      </para>
      <indexterm>
	<primary><filename>remote-or1k.o</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>or1k-jtag.o</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>configure.tgt</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><filename>Makefile.in</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary>header dependencies</primary>
	<seealso><filename>Makefile.in</filename> file</seealso>
      </indexterm>

      <tip>
	<para>
	  As a shortcut for a simple port, editing
	  <filename>Makefile.in</filename> can be omitted. Instead,
	  <command>touch</command> the target specific C source files before
	  calling <command>make</command> to ensure they are rebuilt.
	</para>
	<indexterm>
	  <primary><command>touch</command> command</primary>
	  <secondary>
	    instead of changing <filename>Makefile.in</filename>
	  </secondary>
	</indexterm>
	<indexterm>
	  <primary><filename>Makefile.in</filename> file</primary>
	  <secondary>
	    <command>touch</command> command as alternative to changing
	  </secondary>
	</indexterm>
      </tip>

      <sect2>
	<title>
	  Creating &target_ops; for &or1k; 
	</title>

	<para>
	  The remote target is created by defining the function
	  <function>_initialize_remote_or1k</function>. A new &target_ops;,
	  <varname>or1k_jtag_target</varname> is populated and added as a
	  target by calling <function>add_target</function>.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	  <secondary>creation</secondary>
	  <tertiary>for &or1k;</tertiary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>creating new &target_ops; for</secondary>
	</indexterm>
	<indexterm>
	  <primary><function>_initialize_remote_or1k</function></primary>
	</indexterm>
	<indexterm>
	  <primary><varname>or1k_jtag_target</varname></primary>
	</indexterm>
	<indexterm>
	  <primary><function>add_target</function></primary>
	</indexterm>

	<para>
	  The majority of the target operations are generic to &or1k;,
	  and independent of the actual low level interface. This is achieved
	  by abstracting the low level interface through the interface
	  functions described in <xref linkend="sec_or1k_remote_target" />.
	</para>
	<indexterm>
	  <primary>Remote &jtag; Protocol</primary>
	  <secondary>interface functions</secondary>
	</indexterm>

	<para>
	  Having established all the target functions, the target is added by
	  calling <function>add_target</function>
	</para>

	<para>
	  When a target is selected (with the &gdb;
	  <command>target&nbsp;jtag</command> command), the set of target
	  operations chosen for use with the &or1k; architecture will
	  be referred to by the global variable,
	  <varname>or1k_target</varname>, defined in
	  <filename>or1k-tdep.c</filename>.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>target&nbsp;jtag</command></secondary>
	</indexterm>
	<indexterm>
	  <primary><varname>or1k_target</varname></primary>
	</indexterm>
	<indexterm>
	  <primary><filename>or1k-tdep.c</filename> file</primary>
	</indexterm>

	<note>
	  <para>
	    &gdb; has its own global variable,
	    <varname>current_target</varname>, which refers to the current set
	    of target operations. However this is not sufficient, since even
	    though a target may be connected via the OpenRISC remote
	    interface, it may not be the <emphasis>current</emphasis>
	    target. The use of strata by &gdb; means there could possibly be
	    another target which is active at the same time.
	  </para>
	  <indexterm>
	    <primary><varname>current_target</varname></primary>
	  </indexterm>
	  <indexterm>
	    <primary>target_strata</primary>
	  </indexterm>
	</note>

	<para>
	  Much of the operation of the target interface involves manipulating
	  the debug &spr;s. Rather than continually writing them out to the
	  target, a cache of their values is maintained in
	  <varname>or1k_dbgcache</varname>, which is flushed prior to any
	  operation that will unstall the target (thus causing it to execute).
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>Debug Unit</secondary>
	  <tertiary>debug register cache</tertiary>
	</indexterm>
	<indexterm>
	  <primary><varname>or1k_dbgcache</varname></primary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  &or1k; Target Functions and Variables Providing Information
	</title>

	<para>
	  A group of variables and functions give the name of the interface
	  and different types of information.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_shortname</varname>. This is the name of the target
	      for use when connecting in &gdb;. For the &or1k;, it is
	      <literal>"jtag"</literal>, so connection in &gdb; will be
	      established by using the command
	      <command>target&nbsp;jtag&nbsp;...</command>.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_shortname</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>target&nbsp;jtag</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_longname</varname>. A brief description of the
	      command for use by the &gdb; <command>info target</command>
	      command.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_longname</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>info&nbsp;target</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_doc</varname>. The help text for this target. The
	      first sentence is used for general help about all targets, the
	      full text for help specifically about this target. The text
	      explains how to connect both directly and over TCP/IP.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_doc</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>help&nbsp;target</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary>
		<command>help&nbsp;target&nbsp;jtag</command>
	      </secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_files_info</function>. This function provides the
	      initial information for <command>info&nbsp;target</command>. For
	      the &or1k; it provides the name of the program being run
	      on the target, if known.
	    </para>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>info&nbsp;target</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_files_info</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_files_info</function></primary>
	    </indexterm>

	  </listitem>
	</itemizedlist>

	<para>
	  OpenRISC remote targets are always executable, with full access to
	  memory, stack, registers etc once the connection is established. A
	  set of variables in &target_ops; for &or1k; records this.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <varname>to_stratum</varname>. Since the &or1k; target
	      can execute code, this field is set to
	      <constant>process_stratum</constant>.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_stratum</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>target_strata</primary>
	      <secondary>for &or1k;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_all_memory</varname>,
	      <varname>to_has_memory</varname>,
	      <varname>to_has_stack</varname> and
	      <varname>to_has_registers</varname>. Once the &or1k; 
	      target is connected, it has access to all its memory, a stack
	      and registers, so all these fields are set to 1 (true).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_all_memory</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_memory</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_stack</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_registers</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>availability in &or1k; target</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_has_execution</varname>. When the connection is
	      initially established, the &or1k; processor will be
	      stalled, so is not actually executing. So this field is
	      initialized to 0 (false).
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_execution</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>Remote &jtag; Protocol</primary>
	      <secondary>execution status</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>to_have_steppable_watchpoint</varname> and
	      <varname>to_have_continuable_watchpoint</varname>. These flags
	      indicate whether the target can step through a watchpoint
	      immediately after it has been executed, or if the watchpoint can
	      be immediate continued without having any effect.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<varname>to_have_steppable_watchpoint</varname>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<varname>to_have_continuable_watchpoint</varname>
	      </secondary>
	    </indexterm>

	    <para>
	      If the &or1k; triggers a hardware watchpoint, the instruction
	      affected will not have completed execution, so must be
	      re-executed (the code cannot continue). Furthermore the
	      watchpoint must be temporarily disabled while re-executing, or
	      it will trigger again (it is not steppable). Thus both these
	      flags are set to 0 (false).
	    </para>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>&gdb; hardware watchpoint</secondary>
	      <tertiary>restarting after</tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &or1k; Target Functions Controlling the Connection
	</title>

	<para>
	  These functions control the connection to the target. For remote
	  targets this involves setting up and closing down a TCP/IP socket
	  link to the server driving the hardware. For local targets it
	  involves opening and closing the device.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_open</function>. This is passed the arguments
	      to the <command>target jtag</command> command and establishes
	      the connection to the target. The arguments are the address of
	      the target (either a local device, or a TCP/IP host/port
	      specification) and an optional second argument
	      <command>reset</command> indicating the target should be reset
	      on connection.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_open</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_open</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Remote JTAG Protocol</primary>
	      <secondary>resetting the target</secondary>
	    </indexterm>

	    <para>
	      Any existing connections are tidied up by
	      <function>target_preopen</function> and any instances of this
	      target are removed from the target stack by
	      <function>unpush_target</function>.
	    </para>
	    <indexterm>
	      <primary><function>target_preopen</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>unpush_target</function></primary>
	    </indexterm>

	    <para>
	      Connection is then established through the low level interface
	      routine, <function>or1k_jtag_init</function>, which resets the
	      target if requested.
	    </para>
	    <indexterm>
	      <primary><function>or1k_jtag_init</function></primary>
	    </indexterm>

	    <para>
	      With the connection established, the target's Unit Present &spr;
	      is checked to verify it has a debug unit available. Data about
	      the number of &gpr;s and matchpoints is read from the CPU
	      Configuration &spr; and used to update &gdbarch_tdep;.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>configuration registers</secondary>
	      <tertiary>
		Unit Present Register
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><acronym>UPR</acronym></primary>
	      <see>Unit Present Register</see>
	    </indexterm>
	    <indexterm>
	      <primary>Unit Present Register</primary>
	      <see>Special Purpose Register</see>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>configuration registers</secondary>
	      <tertiary>
		CPU Configuration Register
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>
		CPU Configuration Register
	      </primary>
	      <see>
		Special Purpose Register
	      </see>
	    </indexterm>
	    <indexterm>
	      <primary>
		<acronym>CPUCFGR</acronym>
	      </primary>
	      <see>
		Special Purpose Register
	      </see>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>availability</secondary>
	    </indexterm>

	    <para>
	      The target processor is then stalled, to prevent further
	      execution, with a 1000&mu;s wait to allow the stall to complete.
	    </para>

	    <para>
	      The debug cache is cleared, and the Debug Stop &spr; set to
	      trigger the &jtag; interface on trap exceptions (which are used
	      for debug breakpoints, watchpoints and single stepping). The
	      cache will be written out to the &spr;s before execution
	      recommences.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>debug register cache</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><varname>or1k_dbgcache</varname></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>watchpoint</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>single step execution</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>

	    <para>
	      Having established a connection, the target is pushed on to
	      the stack. It is marked running, which sets all the flags
	      associated with a running process and updates the choice of
	      current target (which depending on the stratum could be this
	      target). However, the OpenRISC connection is established with
	      the target processor stalled, so the
	      <varname>to_has_execution</varname> flag is cleared by setting
	      the macro <varname>target_has_execution</varname> to 0. It
	      will be set when <function>or1k_resume</function> unstalls the
	      target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>fields</secondary>
	      <tertiary><varname>to_has_execution</varname></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><varname>target_has_execution</varname></primary>
	      <see>convenience macros</see>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_resume</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Remote &jtag; Protocol</primary>
	      <secondary>execution status</secondary>
	    </indexterm>

	    <para>
	      As a matter of good housekeeping, any shared library symbols
	      are cleared using <function>no_shared_libraries</function>.
	    </para>
	    <indexterm>
	      <primary><function>no_shared_libraries</function></primary>
	    </indexterm>

	    <para>
	      &gdb; identifies all inferior executables by their process and
	      thread ID. This port of the &or1k; is for bare metal debugging,
	      so there is no concept of different processes that may be
	      executing. Consequently the <varname>null_ptid</varname> is used
	      as the process/thread ID for the target. This is set in the
	      &gdb; global variable <varname>inferior_pid</varname>.
	    </para>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>bare metal debugging</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>process and thread ID</primary>
	      <secondary>for &or1k;</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>process and thread ID</primary>
	      <secondary>null value</secondary>
	    </indexterm>
	    <indexterm>
	      <primary><varname>null_ptid</varname></primary>
	    </indexterm>
	    <indexterm>
	      <primary><varname>inferior_pid</varname></primary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>process ID</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>

	    <note>
	      <para>
		It is important that the inferior process/thread ID is
		established at this early stage, so that the target can always
		be uniquely identified.
	      </para>
	    </note>

	    <para>
	      Finally the generic <function>start_remote</function> is called
	      to set up the new target ready for execution. It is possible
	      this could fail, so the call is wrapped in a function,
	      <function>or1k_start_remote</function>, which has the correct
	      prototype to run using <function>catch_exception</function>. If
	      failure occurs, the target can be popped, before the exception
	      is thrown on to the top level.
	    </para>
	    <indexterm>
	      <primary><function>start_remote</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_start_remote</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>catch_exception</function></primary>
	    </indexterm>

	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_close</function>. This closes the connection by
	      calling the low level interface function,
	      <function>or1k_jtag_close</function>. The target will
	      already have been unpushed and the inferior mourned (see <xref
	      linkend="sec_or1k_exec_funcs" />), so these
	      actions are not required.
	    </para>
	    <indexterm>
	      <primary><function>or1k_close</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_jtag_close</function></primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_detach</function>. This just detaches from the
	      target being debugged, which is achieved by calling
	      <function>or1k_close</function>.
	    </para>
	    <indexterm>
	      <primary><function>or1k_detach</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_close</function></primary>
	    </indexterm>

	    <para>
	      There is no explicit function to reattach to the target, but a
	      call to <function>or1k_open</function> (by giving a
	      <command>target&nbsp;jtag</command> command in &gdb;) will
	      achieve the same effect.
	    </para>
	    <indexterm>
	      <primary><function>or1k_open</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Remote &jtag; Protocol</primary>
	      <secondary>reattaching to target</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &or1k; Target Functions to Access Memory and Registers
	</title>

	<para>
	  These are a group of functions to access the registers and memory of
	  the target.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_fetch_registers</function>. This function
	      populates the register cache from the actual target
	      registers. The interface to the &or1k; only provides
	      for reading of memory or &spr;s. However the &gpr;s are
	      mapped into the &spr; space, so can be read in this way.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_fetch_registers</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_fetch_registers</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>functions for &or1k;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_store_registers</function>. This is the inverse
	      of <function>or1k_fetch_registers</function>. It writes the
	      contents of the register cache back to the physical registers
	      on the target.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_store_registers</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_store_registers</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>functions for &or1k;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_prepare_to_store</function>. &gdb; allows for
	      targets which need some preparatory work before storing, so
	      provides this function. It is not needed for the &or1k;, so just
	      returns.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_prepare_to_store</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_prepare_to_store</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>functions for &or1k;</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_xfer_partial</function>. This is the
	      generic function for reading and writing objects from and to
	      the target. However the only class of object which needs be
	      supported is read and write from memory. This is achieved
	      through the low-level interface routines
	      <function>or1k_jtag_read_mem</function> and
	      <function>or1k_jtag_write_mem</function>.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_xfer_partial</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_xfer_partial</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_jtag_read_mem</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_jtag_write_mem</function></primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>generic_load</function>. This generic function is used
	      as the <function>to_load</function> function of the target
	      operations. There is nothing special about loading &or1k;
	      images. This function will call the
	      <function>or1k_xfer_partial</function> function to transfer the
	      bytes for each section of the image.
	    </para>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_load</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>generic_load</function></primary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &or1k; Target Functions to Handle Breakpoints and Watchpoints
	</title>

	<para>
	  The &or1k; can support hardware breakpoints and watchpoints, if
	  matchpoints are free in the debug unit.
	</para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>hardware matchpoints and watchpoints</secondary>
	</indexterm>
	<indexterm>
	  <primary>watchpoint</primary>
	  <secondary>in hardware</secondary>
	  <tertiary>for &or1k;</tertiary>
	</indexterm>
	<indexterm>
	  <primary>breakpoint</primary>
	  <secondary>in hardware</secondary>
	  <tertiary>for &or1k;</tertiary>
	</indexterm>

	<note>
	  <para>
	    Beware of confusion over the term "watchpoint". It is used in
	    &gdb; to mean a location, being watched for read or write
	    activity. These may be implemented in hardware or software.
	  </para>

	  <para>
	    If implemented in hardware, they may make use of the &or1k; 
	    Debug Unit mechanism, which also uses the term watchpoint. This
	    document uses the terms "&gdb; watchpoint" and "&or1k; 
	    watchpoint" where there is any risk of confusion.
	  </para>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>hardware matchpoints and watchpoints</secondary>
	  <tertiary>distinction from &gdb; watchpoint</tertiary>
	</indexterm>
	</note>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_set_breakpoint</function>. This is the underlying
	      &or1k; function which sets a hardware breakpoint if one
	      is available. This is controlled through the Debug Value
	      Register and Debug Control Register. This function is used by
	      the target operation functions
	      <function>or1k_insert_breakpoint</function> and
	      <function>or1k_insert_hw_breakpoint</function>.
	    </para>
	    <indexterm>
	      <primary><function>or1k_set_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_insert_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_insert_hw_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_insert_hw_breakpoint</function>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>&gdb; hardware breakpoint</secondary>
	      <tertiary>insertion</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>

	    <para>
	      The first free hardware matchpoint is found by searching
	      through the Debug Control Registers for a register without its
	      &dvr;/&dcr; Preset (DP) flag set using
	      <function>or1k_first_free_matchpoint</function>.
	    </para>
	    <indexterm>
	      <primary><function>or1k_first_free_matchpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>matchpoint</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Value Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Control Register</tertiary>
	    </indexterm>

	    <para>
	      The Debug Value Register is set to the address of the breakpoint
	      and the Debug Control Register to trigger when the unsigned
	      effective address of the fetched instruction is equal to the
	      Debug Value Register. The corresponding &or1k; watchpoint
	      is marked as unchained in Debug Mode Register&nbsp;1 and set to
	      trigger a trap exception in Debug Mode Register&nbsp;2.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Mode Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><acronym>DMR</acronym></primary>
	      <see>Debug Mode Register</see>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Mode Register</primary>
	      <see>Special Purpose Register</see>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_clear_breakpoint</function>. This is the
	      counterpart to <function>or1k_set_breakpoint</function>. It is
	      called by the target operation functions
	      <function>remove_breakpoint</function> and
	      <function>remove_hw_breakpoint</function>.
	    </para>
	    <indexterm>
	      <primary><function>or1k_clear_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_remove_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_remove_hw_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_remove_hw_breakpoint</function>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>&gdb; hardware breakpoint</secondary>
	      <tertiary>removal</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>

	    <para>
	      The Debug Control Registers are searched for an entry matching
	      the given address (using
	      <function>or1k_matchpoint_equal</function>). If a register is
	      found, its &dvr;/&dcr; Present flag is cleared, and the
	      matchpoint marked unused in Debug Mode Register&nbsp;2.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_breakpoint</function>. This function
	      inserts a breakpoint. It tries to insert a hardware breakpoint
	      using <function>or1k_set_breakpoint</function>. If this fails,
	      the generic <function>memory_insert_breakpoint</function> is
	      used to set a software breakpoint.
	    </para>
	    <indexterm>
	      <primary><function>or1k_insert_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_breakpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>hbreak</command></secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_remove_breakpoint</function>. This is the
	      counterpart to <function>or1k_insert_breakpoint</function>. It
	      tries to clear a hardware breakpoint, and if that fails tries
	      to clear a software breakpoint using the generic
	      <function>memory_remove_breakpoint</function>.
	    </para>
	    <indexterm>
	      <primary><function>or1k_remove_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_breakpoint</function></tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_hw_breakpoint</function> and
	      <function>or1k_remove_hw_breakpoint</function>. These
	      functions are similar to
	      <function>or1k_insert_breakpoint</function> and
	      <function>or1k_remove_breakpoint</function>. However if a
	      hardware breakpoint is not available, they do not attempt to
	      use a software (memory) breakpoint instead.
	    </para>
	    <indexterm>
	      <primary><function>or1k_insert_hw_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_insert_hw_breakpoint</function>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_remove_hw_breakpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_remove_hw_breakpoint</function>
	      </secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_insert_watchpoint</function>. This function
	      attempts to insert a &gdb; hardware watchpoint. For this it
	      requires a pair of &or1k; watchpoints chained
	      together. The first will check for a memory access greater than
	      or equal to the start address of interest. The second will check
	      for a memory access less than or equal to the end address of
	      interest. If both criteria are met. The access type can be the
	      load effective address (for &gdb; <command>rwatch</command>
	      watchpoints), store effective address (for &gdb;
	      <command>watch</command> watchpoints) or both (for &gdb;
	      <command>awatch</command> watchpoints).
	    </para>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>&gdb; hardware watchpoint</secondary>
	      <tertiary>insertion</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>in hardware</secondary>
	      <tertiary>for &or1k;</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>hardware matchpoints and watchpoints</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>rwatch</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>watch</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>awatch</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_insert_watchpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_insert_watchpoint</function></tertiary>
	    </indexterm>

	    <para>
	      The pair of &or1k; watchpoints must be adjacent (so they
	      can be chained together using Debug Mode Register 1), but it is
	      possible that successive breakpoints have fragmented the use of
	      &or1k; 
	      watchpoints. <function>or1k_watchpoint_gc</function> is used to
	      shuffle up all the existing &or1k; watchpoints which can
	      be moved, to find a pair if possible.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Mode Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_watchpoint_gc</function></primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_remove_watchpoint</function>. This is the
	      counterpart of <function>or1k_insert_watchpoint</function>. It
	      searches for an adjacent pair of &or1k; watchpoints that
	      match using <function>or1k_matchpoint_equal</function>. If found
	      both are marked unused in their Debug Control Register and
	      cleared from triggering in Debug Mode Register 2.
	    </para>
	    <indexterm>
	      <primary>Debug Unit</primary>
	      <secondary>&gdb; hardware watchpoint</secondary>
	      <tertiary>removal</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_remove_watchpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_remove_watchpoint</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_matchpoint_equal</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Mode Register</tertiary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_stopped_by_watchpoint</function> and
	      <function>or1k_stopped_data_address</function>. These functions
	      are called to find out about &gdb; watchpoints which may have
	      triggered. Both make use of the utility function,
	      <function>or1k_stopped_watchpoint_info</function>, which
	      determines if a &gdb; watchpoint was triggered, if so which
	      watchpoint and for what
	      address. <function>or1k_stopped_watchpoint</function> just
	      returns a Boolean to indicate if a watchpoint was
	      triggered. <function>or1k_stopped_data_address</function> is
	      called once for each watchpoint that has triggered. It returns
	      the address that triggered the watchpoint and must also clear
	      the watchpoint (in Debug Mode Register 2).
	    </para>
	    <indexterm>
	      <primary><function>or1k_stopped_by_watchpoint</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_stopped_by_watchpoint</function>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_stopped_data_address</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>
		<function>to_stopped_data_address</function>
	      </secondary>
	    </indexterm>
	    <indexterm>
	      <primary>
		<function>or1k_stopped_watchpoint_info</function>
	      </primary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Mode Register</tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_or1k_exec_funcs">
	<title>
	  &or1k; Target Functions to Control Execution
	</title>

	<para>
	  When the <command>run</command> command is used to start execution
	  with &gdb; it needs to establish the executable on the inferior, and
	  then start execution. This is done using the
	  <function>to_create_inferior</function> and
	  <function>to_resume</function> functions of the target respectively.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>run</command></secondary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	  <tertiary><function>to_create_inferior</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	  <tertiary><function>to_resume</function></tertiary>
	</indexterm>
	<indexterm>
	  <primary>inferior</primary>
	  <secondary>remote creation</secondary>
	</indexterm>

	<para>
	  Once execution has started, &gdb; waits until the target
	  <function>to_wait</function> function returns control.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	  <tertiary><function>to_wait</function></tertiary>
	</indexterm>

	<para>
	  In addition the target provides operations to stop execution.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_resume</function>. This is the function which
	      causes the target program to run. It is called in response to
	      the <command>run</command>, <command>step</command>,
	      <command>stepi</command>, <command>next</command> and
	      <command>nexti</command> instructions.
	    </para>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>run</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>step</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>stepi</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>next</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>nexti</command></secondary>
	    </indexterm>
	    <indexterm>
	      <primary><function>or1k_resume</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_resume</function></tertiary>
	    </indexterm>

	    <para>
	      The behavior of this function is far simpler than its
	      counterpart in &gdb; 5.3, which required complex logic to
	      re-execute instructions after a breakpoint or
	      watchpoint. &gdb;&nbsp;6.8 will sort out all the issues of
	      re-execution after a breakpoint or watchpoint has been
	      encountered (see <function>or1k_wait</function> below for more
	      on this).
	    </para>

	    <para>
	      The function clears the Debug Reason Register, clears any
	      watchpoint status bits in Debug Mode Register 2 and then
	      commits the debug registers.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Reason Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Mode Register</tertiary>
	    </indexterm>

	    <para>
	      If the caller has requested single stepping, this is set using
	      Debug Mode Register 1, otherwise this is cleared.
	    </para>
	    <indexterm>
	      <primary>single step execution</primary>
	    </indexterm>

	    <para>
	      Finally the target can be marked as executing (the first time
	      <function>or1k_resume</function> is called it will not be marked
	      as executing), the debug registers written out, and the processor
	      unstalled.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_wait </function>. This function waits for the
	      target to stall, and analyzes the cause.  Information about why
	      the target stalled is returned to the caller via the
	      <varname>status</varname> argument. The function returns the
	      process/thread ID of the process which stalled, although for
	      the &or1k; this will always be the same value.
	    </para>
	    <indexterm>
	      <primary><function>or1k_wait</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_wait</function></tertiary>
	    </indexterm>

	    <para>
	      While waiting for the target to stall (using
	      <function>or1k_jtag_wait</function>), a signal handler is
	      installed, so the user can interrupt execution with ctrl-C.
	    </para>
	    <indexterm>
	      <primary><function>or1k_jtag_wait</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>interrupt during debugging</secondary>
	    </indexterm>

	    <para>
	      After the wait returns, all register and frame caches are
	      invalid, These are cleared by calling
	      <function>registers_changed</function> (which in turn clears
	      the frame caches).
	    </para>
	    <indexterm>
	      <primary><function>registers_changed</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>register</primary>
	      <secondary>cache</secondary>
	      <tertiary>invalidating</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>prologue cache</primary>
	      <secondary>invalidating</secondary>
	    </indexterm>

	    <para>
	      When the processor stalls, the Debug Reason Register (a &spr;)
	      shows the reason for the stall. This will be due to any
	      exception set in the Debug Stop Register (currently only trap),
	      due to a single step, due to a reset (the debugger stalls the
	      processor on reset) or (when the target is the architectural
	      simulator, &or1ksim;) due to an exit
	      <literal>l.nop&nbsp;1</literal> being executed.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Reason Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>Debug Unit</secondary>
	      <tertiary>Debug Stop Register</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1ksim;</primary>
	      <secondary>exit handling in &gdb;</secondary>
	    </indexterm>

	    <para>
	      In all cases the previous program counter &spr;
	      points to the instruction just executed and the next program
	      counter &spr; to the instruction about to be executed. For
	      watchpoints and breakpoints, which generate a trap however the
	      instruction at the previous program counter will not have
	      completed execution. As a result, when the program resumes,
	      this instruction should be re-executed without the
	      breakpoint/watchpoint enabled.
	    </para>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>program counters</secondary>
	      <tertiary>
		Previous Program Counter
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><acronym>PPC</acronym></primary>
	      <see>Previous Program Counter</see>
	    </indexterm>
	    <indexterm>
	      <primary>Previous Program Counter</primary>
	      <see>Special Purpose Register</see>
	    </indexterm>
	    <indexterm>
	      <primary>Special Purpose Register</primary>
	      <secondary>program counters</secondary>
	      <tertiary>
		Next Program Counter
	      </tertiary>
	    </indexterm>
	    <indexterm>
	      <primary><acronym>NPC</acronym></primary>
	      <see>Next Program Counter</see>
	    </indexterm>
	    <indexterm>
	      <primary>Next Program Counter</primary>
	      <see>Special Purpose Register</see>
	    </indexterm>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>restarting after</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>restarting after</secondary>
	    </indexterm>

	    <para>
	      &gdb; understands this. It is sufficient to set the program
	      counter to the previous program counter. &gdb; will realize
	      that the instruction corresponds to a breakpoint/watchpoint
	      that has just been encountered, lift the breakpoint, single
	      step past the instruction and reimpose the breakpoint. This is
	      achieved by a call to <function>write_pc</function> with the
	      previous program counter value.
	    </para>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>reinsertion when continuing</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>reinsertion when continuing</secondary>
	    </indexterm>
	    <indexterm>
	      <primary><function>write_pc</function></primary>
	    </indexterm>

	    <para>
	      The &or1k; imposes a slight problem here. The standard &gdb;
	      approach works fine, except if the breakpoint was in the delay
	      slot of a branch or jump instruction. In this case the
	      re-execution must be not just of the previous instruction, but
	      the one before that (restoring the link register as well if it
	      was a jump-and-link instruction). Furthermore this must only be
	      in the case where the branch was truly the preceding
	      instruction, rather than the delay slot having been the target
	      of a different branch instruction.
	    </para>
	    <indexterm>
	      <primary>breakpoint</primary>
	      <secondary>restarting after</secondary>
	      <tertiary>problem with &or1k;</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>watchpoint</primary>
	      <secondary>restarting after</secondary>
	      <tertiary>problem with &or1k;</tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>&or1k;</primary>
	      <secondary>link register</secondary>
	    </indexterm>

	    <para>
	      In the absence of a "previous previous" program counter, this
	      restart cannot be correct under all circumstances. For the
	      time being, breakpoints on delay slots are not expected to
	      work. However it is highly unlikely a source level debugger
	      would ever place a breakpoint in a delay slot.
	    </para>

	    <para>
	      A more complete solution for the future would use the &gdbarch;
	      <function>adjust_breakpoint_address</function> to move any
	      breakpoint requested for a delay slot, to insist the breakpoint
	      is placed on the preceding jump or branch. This would work for
	      all but the most unusual code, which used a delay slot as a
	      branch target.
	    </para>
	    <indexterm>
	      <primary>&gdbarch;</primary>
	      <secondary>functions</secondary>
	      <tertiary>
		<function>adjust_breakpoint_address</function>
	      </tertiary>
	    </indexterm>

	    <para>
	      Having sorted out the program counter readjustment, any single
	      step is marked as though it were a trap. Single step does not
	      set the trap exception, nor does it need re-executing, but by
	      setting the flag here, the exception will be correctly mapped
	      to the <constant>TARGET_SIGNAL_TRAP</constant> for return to
	      &gdb;
	    </para>
	    <indexterm>
	      <primary><constant>TARGET_SIGNAL_TRAP</constant></primary>
	    </indexterm>
	    <indexterm>
	      <primary>single step execution</primary>
	    </indexterm>

	    <para>
	      The response is marked as a a stopped processor
	      (<constant>TARGET_WAITKIND_STOPPED</constant>).  All
	      exceptions are mapped to their corresponding &gdb; signals. If
	      no exception has been raised, then the signal is set to the
	      default, unless the instruction just executed was
	      <literal>l.nop&nbsp;1</literal>, which is used by the
	      architectural simulator to indicate termination. In this case
	      the response is marked as
	      <constant>TARGET_WAITKIND_EXITED</constant>, and the associate
	      value set to the exit return code.
	    </para>
	    <indexterm>
	      <primary><constant>TARGET_WAITKIND_STOPPED</constant></primary>
	    </indexterm>
	    <indexterm>
	      <primary><constant>TARGET_WAITKIND_EXITED</constant></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb;</primary>
	      <secondary>signals</secondary>
	    </indexterm>

	    <para>
	      The debug reason register (which is sticky) can now be cleared
	      and the process/thread ID returned.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_stop</function>. This stops the processor
	      executing. To achieve this cleanly, the processor is stalled,
	      single step mode is set and the processor unstalled, so
	      execution will have stopped at the end of an instruction.
	    </para>
	    <indexterm>
	      <primary><function>or1k_stop</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_stop</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>single step execution</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_kill</function>. This is a more dramatic
	      termination, when <function>or1k_stop</function> has failed to
	      give satisfaction. Communication with the target is assumed to
	      have broken down, so the target is then mourned, which will
	      close the connection.
	    </para>
	    <indexterm>
	      <primary><function>or1k_kill</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_kill</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>remote destruction (mourning)</secondary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_create_inferior</function>. This sets up a
	      program to run on the target, but does not actually start it
	      running. It is called in response to the &gdb;
	      <command>run</command> command and is passed any arguments to
	      that command. However the &or1k; &jtag; protocol has no
	      way to send arguments to the target, so these are ignored.
	    </para>
	    <indexterm>
	      <primary><function>or1k_create_inferior</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_create_inferior</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>remote creation</secondary>
	    </indexterm>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>run</command></secondary>
	    </indexterm>

	    <para>
	      Debugging is much easier if a local copy of the executable
	      symbol table has been loaded with the <command>file</command>
	      command. This is checked for and a warning issued. However if
	      it is not present, it is perfectly acceptable to debug code on
	      the &or1k; target without symbol data.
	    </para>
	    <indexterm>
	      <primary>&gdb; commands</primary>
	      <secondary><command>file</command></secondary>
	    </indexterm>

	    <para>
	      All static data structures (breakpoint lists etc) are then
	      cleared within &gdb; by calling
	      <function>init_wait_for_inferior</function>.
	    </para>
	    <indexterm>
	      <primary><function>init_wait_for_inferior</function></primary>
	    </indexterm>

	    <tip>
	      <para>
		If &gdb; for the &or1k; is used with
		<command>ddd</command> the warning about passing arguments will
		often be triggered. This occurs when <command>ddd</command>
		is asked to run a program in a separate execution window,
		which it attempts to achieve by creating an
		<command>xterm</command> and redirecting I/O via pseudo-TTYs
		to that <command>xterm</command>. The redirections are
		arguments to the &gdb; <command>run</command> command.
	      </para>
	      <indexterm>
		<primary><command>ddd</command></primary>
		<secondary>problem with argument passing</secondary>
	      </indexterm>

	      <para>
		&gdb; for &or1k; does not support this. The
		<parameter>run in separate window</parameter> option should be
		disabled with <command>ddd</command>.
	      </para>
	    </tip>
	  </listitem>

	  <listitem>
	    <para>
	      <function>or1k_mourn_inferior</function>. This is the
	      counterpart to <function>or1k_create_inferior</function>,
	      called after execution has completed. It tidies up by calling
	      the generic function
	      <function>generic_mourn_inferior</function>. If the target is
	      still shown as having execution, it is marked as exited, which
	      will cause the selection of a new current target.
	    </para>
	    <indexterm>
	      <primary><function>or1k_mourn_inferior</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary><function>generic_mourn_inferior</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_mourn_inferior</function></tertiary>
	    </indexterm>
	    <indexterm>
	      <primary>inferior</primary>
	      <secondary>remote destruction (mourning)</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_or1k_exec_comms">
	<title>
	  &or1k; Target Functions to Execute Commands
	</title>

	<para>
	  The &or1k; target does not really have a way to execute
	  commands. However implementing &spr; access as remote commands
	  provides a mechanism for access, which is independent of the target
	  access protocol. In particular the &gdb; architecture need know
	  nothing about the actual remote protocol used.
	</para>

	<para>
	  &spr; access is implemented as though the target were able to run
	  two commands, <command>readspr</command> to get a value from a &spr;
	  and <command>writespr</command> to set a value in a &spr;. Each
	  takes a first argument, specified in hexadecimal, which is the &spr;
	  number. <command>writespr</command> takes a second argument,
	  specified in hexadecimal, which is the value to be
	  written. <command>readspr</command> returns the value read as a
	  number in hexadecimal.
	</para>
	<indexterm>
	  <primary><command>readspr</command></primary>
	</indexterm>
	<indexterm>
	  <primary><command>writespr</command></primary>
	</indexterm>

	<para>
	  When access is needed to the &spr;s it is achieved by passing one of
	  these commands as argument to the <function>to_rcmd</function>
	  function of the target.
	</para>
	<indexterm>
	  <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	  <tertiary><function>to_rcmd</function></tertiary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>or1k_rcmd</function>. The command to execute
	      (<command>readspr</command> or <command>writespr</command>) is
	      passed as the first argument. Results of the command are written
	      back throug the second argument, which is a UI independent file
	      handle.
	    </para>

	    <para>
	      <command>readspr</command> is mapped to the corresponding call
	      to <function>or1k_jtag_read_spr</function>.
	      <command>writespr</command> is mapped to the corresponding call
	      to <function>or1k_jtag_write_spr</function>. In the case of an
	      error (for example badly formed command), the result
	      <literal>"E01"</literal> is returned. If
	      <command>writespr</command> is successful,
	      <literal>"OK"</literal> is returned as result. If
	      <command>readspr</command> is successful, the value as
	      hexadecimal is returned as result. In all cases the result is
	      written as a string to the UI independent file handle specified
	      as second argument to the function.
	    </para>
	    <indexterm>
	      <primary><function>or1k_rcmd</function></primary>
	    </indexterm>
	    <indexterm>
	      <primary>&target_ops;</primary>
	      <secondary>functions</secondary>
	      <tertiary><function>to_rcmd</function></tertiary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2 id="sec_jtag_interface">
	<title>
	  The Low Level &jtag; Interface
	</title>

	<para>
	  The interface to the OpenRISC &jtag; system is found in
	  <filename>gdb/or1k-jtag.c</filename> and
	  <filename>gdb/or1k-jtag.h</filename>. The details are not directly
	  relevant to porting &gdb; so only an overview is given here. Full
	  details are found in the commenting within the source code.
	</para>
	<indexterm>
	  <primary><filename>gdb/or1k-jtag.c</filename> file</primary>
	</indexterm>
	<indexterm>
	  <primary><filename>gdb/or1k-jtag.h</filename> file</primary>
	</indexterm>

	<para>
	  The interface is layered, to maximize use. In particular much of the
	  functionality is the same whether the target is connected remotely
	  over TCP/IP or directly via a JP1 header connected to the parallel
	  port.
	</para>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>&jtag; interface</secondary>
	  <tertiary>layered interface</tertiary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>
	      The highest level is the public function interface, which
	      operate in terms of entities that are visible in &gdb;: open and
	      close the connection, read and write &spr;s, read and write
	      memory, stall, unstall and wait for the processor. These
	      functions always succeed and have function prefixes
	      <literal>or1k_jtag_</literal>.
	    </para>
	    <indexterm>
	      <primary><literal>or1k_jtag_</literal> functions</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is the abstraction provided by the OR1K &jtag;
	      protocol: read/write a &jtag; register, read/write a block of
	      &jtag; registers and select a scan chain. These functions may
	      encounter errors and will deal with them, but otherwise return
	      no error result. These are static functions (i.e. local to this
	      file), with prefixes <literal>or1k_jtag_</literal>.
	    </para>
	    <indexterm>
	      <primary><literal>or1k_jtag_</literal> functions</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      The next level is in two sets, one for use with a locally
	      connected (JP1) &jtag; and one for a remote connection over
	      TCP/IP corresponding to the functions in the previous
	      layer. These functions detect with errors and return an error
	      code to indicate an error has occurred. These are static
	      functions with prefixes: <literal>jp1_</literal> and
	      <literal>jtr_</literal> respectively.
	    </para>
	    <indexterm>
	      <primary><literal>jp1_</literal> functions</primary>
	    </indexterm>
	    <indexterm>
	      <primary><literal>jtr_</literal> functions</primary>
	    </indexterm>
	  </listitem>

	  <listitem>
	    <para>
	      The final level comes in separate flavors for locally connected
	      &jtag; (low level routines to drive the JP1 interface) and
	      remote use (to build and send/receive packets over
	      TCP/IP). These functions detect errors and return an error code
	      to indicate an error has occurred. These are static function
	      with prefixes <literal>jp1_ll_</literal> and
	      <literal>jtr_ll_</literal> respectively.
	    </para>
	    <indexterm>
	      <primary><literal>jp1_ll_</literal> functions</primary>
	    </indexterm>
	    <indexterm>
	      <primary><literal>jtr_ll_</literal> functions</primary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

	<para>
	  Errors are either dealt with silently or (if fatal) via the &gdb;
	  <function>error</function> function.
	</para>
	<indexterm>
	  <primary>Debug Unit</primary>
	  <secondary>&jtag; interface</secondary>
	  <tertiary>error handling</tertiary>
	</indexterm>

	<caution>
	  <para>
	    Few people now use the JP1 direct connection, and there is no
	    confidence that this code works at all!
	  </para>
	  <indexterm>
	    <primary>Debug Unit</primary>
	    <secondary>&jtag; interface</secondary>
	    <tertiary>JP1 interface limitations</tertiary>
	  </indexterm>
	</caution>

      </sect2>

    </sect1>

    <sect1 id="sec_or1k_disasm">
      <title>
	The &or1k; Disassembler
      </title>

      <para>	
	The &or1k; disassembler is part of the wider
	<command>&binutils;</command> utility set and is found in the
	<filename>opcodes</filename> sub-directory. It provides two versions of
	the disassembly function, <function>print_insn_big_or32</function> and
	<function>print_insn_little_or32</function> for use with big-endian
	and little-endian implementations of the architecture in
	<filename>or32-dis.c</filename>
      </para>
      <indexterm>
	<primary>disassembly</primary>
	<secondary>for &or1k;</secondary>
      </indexterm>
      <indexterm>
	<primary>&binutils;</primary>
	<secondary>disassembly function</secondary>
      </indexterm>
      <indexterm>
	<primary><filename>opcodes</filename> directory</primary>
      </indexterm>
      <indexterm>
	<primary><filename>or32-dis.c</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><function>print_insn_big_or32</function></primary>
      </indexterm>
      <indexterm>
	<primary><function>print_insn_little_or32</function></primary>
      </indexterm>
      <indexterm>
	<primary>&target_ops;</primary>
	<secondary>functions</secondary>
	<tertiary><function>to_print_insn</function></tertiary>
      </indexterm>

      <para>
	The instruction decode uses a finite state automaton (&fsa;) in
	<filename>or32-opc.c</filename>. This is constructed at start-up by
	the function <function>build_automata</function> from a table
	describing the instruction set. This function is invoked from the
	<function>_initialize_or1k_tdep</function> function immediately after
	the &or1k; architecture has been defined.
      </para>
      <indexterm>
	<primary><filename>or32-opc.c</filename> file</primary>
      </indexterm>
      <indexterm>
	<primary><function>build_automata</function></primary>
      </indexterm>
      <indexterm>
	<primary><function>_initialize_or1k_tdep</function></primary>
      </indexterm>

      <para>
	The disassembler takes advantage of any symbol table information to
	replace branch and jump targets by symbolic names where possible.
      </para>
    </sect1>

    <sect1>
      <title>
	&or1k; Specific Commands for &gdb;
      </title>

      <para>
	<xref linkend="sec_adding_commands" /> describes how to extend the
	&gdb; command set. For the &or1k; architecture, the
	<command>info</command> command is extended to show the value of
	&spr;s (<command>info&nbsp;spr</command>) and a new command,
	<command>spr</command> is added to set the value of a &spr;<footnote>
	<para>
	    There is a strong case for this being a new sub-command of the
	    <command>set</command>. However the <command>spr</command> command
	    was introduced in &gdb;&nbsp;5.0, and there is no point in
	    replacing it now.
	  </para>
	  </footnote>.
      </para>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary>adding new commands</secondary>
	<tertiary>for &or1k;</tertiary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>info spr</command></secondary>
      </indexterm>
      <indexterm>
	<primary>&gdb; commands</primary>
	<secondary><command>spr</command></secondary>
      </indexterm>

      <para>
	Both these commands are added in
	<function>_initialize_or1k_tdep</function> after the architecture has
	been created and the disassembler automata initialized.
      </para>
      <indexterm>
	<primary><function>_initialize_or1k_tdep</function></primary>
      </indexterm>

      <sect2>
	<title>
	  The <command>info spr</command> Command
	</title>

	<para>
	  The new sub-command for <command>info</command> is added using
	  <function>add_info</function>
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>info</command></secondary>
	</indexterm>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>info spr</command></secondary>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>examining in &gdb;</secondary>
	</indexterm>
	<indexterm>
	  <primary><function>add_info</function></primary>
	</indexterm>

	<informalexample>
	  <programlisting>
add_info ("spr", or1k_info_spr_command,
          "Show the value of a special purpose register");
	  </programlisting>
	</informalexample>

	<para>
	  The functionality is provided in
	  <function>or1k_info_spr_command</function>. The user can specify a
	  group by name or number (the value of all registers in that group is
	  displayed), or a register name (the value of that register is
	  displayed) or a group name/number and register name/number (the
	  value of that register in the group is displayed).
	</para>
	<indexterm>
	  <primary><function>or1k_info_spr_command</function></primary>
	</indexterm>

	<para>
	  The arguments are broken out from the text of the command using
	  <function>or1k_parse_params</function>, which also handles any
	  errors in syntax or semantics. If the arguments are successfully
	  parsed the results are then printed out using the UI independent
	  function, <function>ui_out_field_fmt</function>.
	</para>
	<indexterm>
	  <primary><function>or1k_parse_params</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>ui_out_field_fmt</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>UI independent output</secondary>
	</indexterm>

	<para>
	  The &spr; is read using the convenience function
	  <function>or1k_read_spr</function>. This converts the access to a
	  call of the command <command>readspr</command>, which can be passed
	  to the target usings its <function>to_rcmd</function> target
	  operation (see <xref linkend="sec_or1k_exec_comms"/>). This will
	  allow the &spr; to be accessed in the way most appropriate to the
	  current target access method.
	</para>
	<indexterm>
	  <primary><function>or1k_read_spr</function></primary>
	</indexterm>

      </sect2>

      <sect2>
	<title>
	  The <command>spr</command> Command
	</title>

	<para>
	  This new top level command is added, classified as a support command
	  (<constant>class_support</constant>), using the
	  <function>add_com</function> command.
	</para>
	<indexterm>
	  <primary>&gdb; commands</primary>
	  <secondary><command>spr</command></secondary>
	</indexterm>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	  <secondary>setting in &gdb;</secondary>
	</indexterm>
	<indexterm>
	  <primary><function>add_com</function></primary>
	</indexterm>
	<indexterm>
	  <primary><constant>class_support</constant></primary>
	</indexterm>

	<para>
	  The functionality is provided in
	  <function>or1k_spr_command</function>. This also uses
	  <function>or1k_parse_spr_params</function> to parse the arguments,
	  although there is now one more (the value to set). The new value is
	  written into the relevant &spr; and the change recorded using
	  <function>ui_out_field_fmt</function>.
	</para>
	<indexterm>
	  <primary><function>or1k_spr_command</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>or1k_parse_params</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>or1k_write_spr</function></primary>
	</indexterm>
	<indexterm>
	  <primary><function>ui_out_field_fmt</function></primary>
	</indexterm>
	<indexterm>
	  <primary>&gdb;</primary>
	  <secondary>UI independent output</secondary>
	</indexterm>

	<para>
	  The &spr; is written using the convenience function
	  <function>or1k_write_spr</function>. This converts the access to a
	  call of the command <command>writespr</command>, which can be passed
	  to the target usings its <function>to_rcmd</function> target
	  operation (see <xref linkend="sec_or1k_exec_comms"/>). This will
	  allow the &spr; to be accessed in the way most appropriate to the
	  current target access method.
	</para>
	<indexterm>
	  <primary><function>or1k_write_spr</function></primary>
	</indexterm>

      </sect2>

    </sect1>

  </chapter>

  <chapter>
    <title>
      Summary
    </title>

    <para>
      This application note has described in detail the steps required to port
      &gdb; to a new architecture. That process has been illustrated using the
      port for the &or1k; architecture.
    </para>

    <para>
      Suggestions for corrections or improvements are welcomed. Please contact
      the author at <ulink
      url="mailto:jeremy.bennett@embecosm.com"><literal>jeremy.bennett@embecosm.com</literal></ulink>.
    </para>

  </chapter>

  <glossary id="sec_glossary">
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>
	<indexterm>
	  <primary>&abi;</primary>
	</indexterm>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Binary File Descriptor</glossterm>
      <acronym>BFD</acronym>
      <glossdef>
	<para>
	  A package which allows applications to use the same routines to
	  operate on object files whatever the object file format <xref
	  linkend="ref_bfd" />. A new object file format can be supported
	  simply by creating a new &bfd; back end and adding it to the
	  library.
	</para>
	<indexterm>
	  <primary>&bfd;</primary>
	</indexterm>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Common Object File Format</glossterm>
      <acronym>COFF</acronym>
      <glossdef>
	<para>
	  A specification of a format for executable, object code, and shared
	  library computer files used on Unix systems. Now largely replaced by
	  &elf;
	</para>

	<glossseealso>Executable and Linkable Format (&elf;)</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Executable and Linkable Format</glossterm>
      <acronym>ELF</acronym>
      <glossdef>
	<para>
	  a common standard file format for executables, object code, shared
	  libraries, and core dumps. It is the standard binary file format for
	  Unix and Unix-like systems on x86, where it has largely replaced
	  &coff;.
	</para>

	<para>
	  Formerly known as the  Extensible Linking Format.
	</para>

	<glossseealso>Common Object File Format (&coff;)</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>frame pointer</glossterm>
      <glossdef>
	<para>
	  In stack based languages, the stack pointer typically refers to the
	  end of the local frame. The frame pointer is a second register,
	  which refers to the beginning of the local frame. Not all
	  stack based architectures make use of a frame pointer.
	</para>
	<indexterm>
	  <primary>frame pointer</primary>
	</indexterm>
	<glossseealso>Stack Frame</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>General Purpose Register</glossterm>
      <acronym>GPR</acronym>
      <glossdef>
	<para>
	  In the &or1k; architecture, one of between 16 and 32 general
	  purpose integer registers.
	</para>
	<indexterm>
	  <primary>General Purpose Register</primary>
	</indexterm>

	<para>
	  Although these registers are general purpose, some have specific
	  roles defined by the architecture and the &abi;. &gpr;&nbsp;0 is
	  always 0 and should not be written to. &gpr;&nbsp;1 is the stack
	  pointer, &gpr;&nbsp;2 the frame pointer and &gpr;&nbsp;9 the return
	  address set by <literal>l.jal</literal> (known as the link register)
	  and <literal>l.jalr</literal> instructions. &gpr;&nbsp;3 through
	  &gpr;&nbsp;8 are used to pass arguments to functions, with scalar
	  results returned in &gpr;&nbsp;11.
	</para>
	<indexterm>
	  <primary>stack pointer</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary>frame pointer</primary>
	  <secondary>in &or1k;</secondary>
	</indexterm>
	<indexterm>
	  <primary>&or1k;</primary>
	  <secondary>link register</secondary>
	</indexterm>

	<glossseealso>Application Binary Interface</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Joint Test Action Group</glossterm>
      <acronym>JTAG</acronym>
      <glossdef>
	<para>
	  &jtag; is the usual name used for the IEEE 1149.1 standard entitled
	  <emphasis>Standard Test Access Port and Boundary-Scan
	  Architecture</emphasis> for test access ports used for testing
	  printed circuit boards and chips using boundary scan.
	</para>
	<indexterm>
	  <primary>&jtag;</primary>
	</indexterm>

	<para>
	  This standard allows external reading of state within the board or
	  chip. It is thus a natural mechanism for debuggers to connect to
	  embedded systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Memory Management Unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
	<indexterm>
	  <primary>Harvard architecture</primary>
	</indexterm>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Real Time Executive for Multiprocessor Systems</glossterm>
      <acronym>RTEMS</acronym>
      <glossdef>
	<para>
	  An operating system for real-time embedded systems offering a POSIX
	  interface. It offers no concept of processes or memory management.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Special Purpose Register</glossterm>
      <acronym>GPR</acronym>
      <glossdef>
	<para>
	  In the &or1k; architecture, one of up to 65536 registers
	  controlling all aspects of the processor. The registers are arranged
	  in groups of 2048 registers. The present architecture defines 12
	  groups in total.
	</para>
	<indexterm>
	  <primary>Special Purpose Register</primary>
	</indexterm>

	<para>
	  In general each group controls one component of the processor. Thus
	  there is a group to control the DMMU, the IMMU the data and
	  instruction caches and the debug unit. Group 0 is the system group
	  and includes all the system configuration registers, the next and
	  previous program counters, supervision register and saved exception
	  registers.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>stack frame</glossterm>
      <glossdef>
	<para>
	  In procedural languages, a dynamic data structure used to hold the
	  values of local variables in a procedure at a particular point of
	  execution.
	</para>
	<indexterm>
	  <primary>stack frame</primary>
	</indexterm>

	<para>
	  Typically successive stack frames are placed next to each other in a
	  linear data area. The last address of the current stack frame is
	  pointed to by a register, known as the <emphasis>stack
	  pointer</emphasis>. It will be the first address of the next stack
	  pointer.
	</para>
	<indexterm>
	  <primary>stack pointer</primary>
	</indexterm>

	<glossseealso>frame pointer</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_app_note_2">
      <title id="ref_app_note_2_xr">
	&embecosm; Application Note 2. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide. Issue 3.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	November 2008.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>tool chain</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_4">
      <title>
	&embecosm; Application Note 4. Howto: GDB Remote Serial Protocol:
	Writing a RSP Server.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	November 2008.
      </pubdate>
      <indexterm>
	<primary>Remote Serial Protocol</primary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_gdb_ug">
      <title id="ref_gdb_ug_xr">
	Debugging with &gdb;: The &gnu; Source-Level Debugger,
      </title>
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      <firstname>Roland</firstname> <surname>Pesch</surname>,
      <firstname>Stan</firstname> <surname>Shebbs</surname>, et al,
      issue <issuenum>9</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html"/>
      </bibliosource>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>User Guide</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_gdb_int">
      <title id="ref_gdb_int_xr">
	&gdb; Internals: A guide to the internals of the &gnu; debugger,
      </title>
      <firstname>John</firstname> <surname>Gillmore</surname> and
      <firstname>Stan</firstname> <surname>Shebbs</surname>,
      issue <issuenum>2</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdbint_toc.html"/>
      </bibliosource>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>Internals document</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_bfd">
      <title id="ref_bfd_xr">
	libbfd: The Binary File Descriptor Library,
      </title>
      <firstname>Steve</firstname> <surname>Chamberlain</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
      <indexterm>
	<primary>&bfd;</primary>
	<secondary>User Guide</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_or1k_gdb">
      <title id="ref_gdb_or1k_gdb_xr">
	Debugging the &or1k; with &gdb;: Target Processor Manual,
      </title>
      <firstname>Jeremy</firstname> <surname>Bennett</surname>,
      issue <issuenum>1</issuenum>.
      <publisher>
	<publishername>
	  Embecosm Limited
	</publishername>
      </publisher>
      <pubdate>
	June 2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.embecosm.com/downloads/or1k/or1k.html"/>
      </bibliosource>
      <indexterm>
	<primary>documentation</primary>
	<secondary>source</secondary>
	<tertiary>&or1k; Target &gdb; User Guide</tertiary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_doxygen">
      <title id="ref_gdb_doxygen_xr">
	Doxygen: Source code documentation generator tool,
      </title>
      <firstname>Dimitri</firstname> <surname>van Heesch</surname>,
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.doxygen.org"/>
      </bibliosource>
      <indexterm>
	<primary>Doxygen</primary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_or1k">
      <title id="ref_gdb_or1k_xr">
	&or1k; Architectural Manual,
      </title>
      <firstname>Damjan</firstname> <surname>Lampret</surname>,
      <firstname>Chen-Min</firstname> <surname>Chen</surname>,
      <firstname>Marko</firstname> <surname>Mlinar</surname>,
      <firstname>Johan</firstname> <surname>Rydberg</surname>,
      <firstname>Matan</firstname> <surname>Ziv-Av</surname>,
      <firstname>Chris</firstname> <surname>Ziomkowski</surname>,
      <firstname>Greg</firstname> <surname>McGary</surname>,
      <firstname>Bob</firstname> <surname>Gardner</surname>,
      <firstname>Rohit</firstname> <surname>Mathur</surname> and
      <firstname>Maria</firstname> <surname>Bolado</surname>,
      <pubdate>
	November 2005
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://www.opencores.org/cvsget.cgi/or1k/docs/openrisc_arch.pdf"/>
      </bibliosource>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>architecture</secondary>
	<tertiary>manual</tertiary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_texinfo">
      <title id="ref_texinfo_xr">
	Texinfo: The &gnu; Documentation Format
      </title>
      <firstname>Robert</firstname> J <surname>Chassell</surname> and
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      issue <issuenum>4.12</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	9 April, 2008
      </pubdate>.
    </bibliomixed>

    <bibliomixed id="ref_orpsoc">
      <title>
	&or1k;: ORPSoC
      </title>
      <firstname>Damjan</firstname> <surname>Lampret</surname> et al.
      <publisher>
	<publishername>
	  OpenCores
	</publishername>
      </publisher>
      <bibliosource class="uri">
	<ulink
	    url="http://opencores.org/projects.cgi/web/or1k/orpsoc"/>
      </bibliosource>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>ORPSoC version</tertiary>
      </indexterm>
    </bibliomixed>
	
    <bibliomixed id="ref_or1k_debug">
      <title>
	SoC Debug Interface
      </title>
      <firstname>Igor</firstname> <surname>Mohor</surname>,
      issue <issuenum>3.0</issuenum>.
      <publisher>
	<publishername>
	  OpenCores
	</publishername>
      </publisher>
      <pubdate>
	14 April, 2004
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://opencores.org/cvsweb.shtml/dbg_interface/doc/DbgSupp.pdf"/>
      </bibliosource>
      <indexterm>
	<primary>Debug Unit</primary>
	<secondary>&jtag; interface</secondary>
	<tertiary>Igor Mohor version</tertiary>
      </indexterm>
    </bibliomixed>

  </bibliography>

  <index />
</book>
