<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY hdl "<acronym>HDL</acronym>">
<!ENTITY iss "<acronym>ISS</acronym>">
<!ENTITY osci "<acronym>OSCI</acronym>">
<!ENTITY tlm "<acronym>TLM</acronym>">
<!ENTITY tlm2 "<acronym>TLM</acronym>&nbsp;2.0">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY binutils "<application class='software'>Binutils</application>">
<!ENTITY gcc "<application class='software'>GCC</application>">
<!ENTITY gdb "<application class='software'>GDB</application>">
<!ENTITY ddd "<application class='software'>DDD</application>" >
<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY uclinux "<application class='software'>uClinux</application>" >
<!ENTITY uclibc "<application class='software'>uClibc</application>">
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">
<!ENTITY or1200 "<application class='hardware'>OpenRISC 1200</application>">
<!ENTITY orpsoc "<application class='hardware'>ORPSoC</application>">

<!-- = Commands = -->

<!ENTITY patch "<command>patch</command>" >
<!ENTITY diff "<command>diff</command>" >
<!ENTITY configure "<command>configure</command>" >
<!ENTITY make "<command>make</command>" >
<!ENTITY makefile "<command>make</command> file" >
<!ENTITY makeall "<command>make all</command>" >
<!ENTITY makecheck "<command>make check</command>" >
<!ENTITY makeinstall "<command>make install</command>" >
<!ENTITY makeclean "<command>make clean</command>" >
<!ENTITY xterm "<command>xterm</command>" >
<!ENTITY sh "<command>sh</command>" >
<!ENTITY bash "<command>bash</command>" >
<!ENTITY csh "<command>csh</command>" >
<!ENTITY tcsh "<command>tcsh</command>" >
<!ENTITY bunzip2 "<command>bunzip2</command>" >
<!ENTITY nm "<command>nm</command>" >
<!ENTITY grep "<command>grep</command>" >

<!-- = Libraries = -->

<!ENTITY readline "<systemitem class='library'>readline</systemitem>" >
<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Internal cross references = -->

<!ENTITY patchref "See <xref linkend='sec_binutils_download' /> for an example
  of how to apply a &patch; file." >

<!-- = Web pages = -->

<!ENTITY embecosm "<ulink
  url='http://www.embecosm.com'>Embecosm</ulink>">
<!ENTITY opencores "<ulink
  url='http://www.opencores.org'>OpenCores</ulink>">
<!ENTITY gnu "<ulink url='http://www.gnu.org'>GNU</ulink>">
<!ENTITY gpl "<ulink url='http://www.gnu.org/licenses/gpl.html'>
  GNU General Public License</ulink>">
<!ENTITY lgpl "<ulink url='http://www.gnu.org/licenses/lgpl.html'>
  GNU Lesser General Public License</ulink>">

]>

<!-- ==========================================================================

                  CONFIDENTIAL AND PROPRIETARY INFORMATION
                  ========================================

Copyright (c) 2008 Embecosm.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing the first stage in the conversion of an ISS to use
OSCI TLM 2.0, convenience ports.

$Id$

=========================================================================== -->

<article class="whitepaper" lang="en_GB">
  <title>
    Converting an &iss; to use &osci; TLM 2.0 Convenience Ports
  </title>
  <subtitle>
    A Case Study Using &or1k; &or1ksim;
  </subtitle>

  <articleinfo>

    <corpauthor>
      &embecosm;
    </corpauthor>

    <pubdate>
      14 June 2008
    </pubdate>

    <releaseinfo>
      Application Note 2. Issue 1, draft A
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	Embecosm Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software examples written by &embecosm; and used in this document
	are licensed under the &lgpl;. For detailed licensing information see
	the source code of the examples.
      </para>

      <para>
	Embecosm is the business name of Embecosm Limited, a private limited
	company registered in England and Wales. Registration number 6577021.
      </para>

    </legalnotice>
  </articleinfo>


  <!-- ========================================================================
       Introduction
       ==================================================================== -->

  <sect1>
    <title>
      Introduction
    </title>

    <para>
      The Open <firstterm>&systemc;</firstterm> Initiative
      (<firstterm>&osci;</firstterm>) has recently issued the second version
      of its standard for
      <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;). This
      provides an interface for writing high level software models of
      hardware.
    </para>

    <para>
      One of the most important components in any SoC system model is the
      processor core <firstterm>Instruction Set Simulator</firstterm>
      (&iss;). With the standardization of &osci; &tlm2; for &systemc;, many
      &iss;, providers will wish to convert to offer the
      <firstterm>&tlm2;</firstterm> interface
    </para>

    <para>
      This application note is the first in a series from &embecosm;,
      providing case studies in &osci; &tlm2; use, based on an open source
      &iss;, the &or1ksim; for the &opencores; &or1200; architecture.
    </para>

    <para>
      The objective is to provide an introduction to using &tlm2; within a
      practical context. Examples are provided throughout, which are freely
      available under the &lgpl;.
    </para>

    <!-- ========== Justification ========== -->

    <sect2>
      <title>
	About the &embecosm; TLM 2.0 Application Note Series
      </title>

      <para>
	The &osci; &tlm2; standard represents a signficant advance in
	standardizing the creation of fast software models of
	hardware. However the &osci; reference implementation lacks training
	material and examples to introduce new users to the technology.
      </para>

      <para>
	These users are often trained hardware engineers, who may be
	relatively new to both C++ and transaction level modeling (&tlm;).
      </para>

      <para>
	This series of &embecosm; Application Notes was prompted by a customer
	requesting assistance in porting an existing &iss; to the &tlm2;
	standard. This first application note in the series introduces &tlm2;
	in its simplest form, using &tlm2;
	<firstterm>convenience&#32;socket</firstterm>s.
      </para>

    </sect2>

    <!-- ========== Target Audience ========== -->

    <sect2>
      <title>
	Target Audience
      </title>

      <para>
      </para>

    </sect2>
  </sect1>


  <!-- ========================================================================
       Background to TLM
       ==================================================================== -->

  <sect1>
    <title>
      Background to &tlm; and &systemc;
    </title>

    <para>
      
    </para>

    <!-- ========== What is TLM ========== -->

    <sect2 id="sec_what_is_tlm">
      <title>
	What is a &tlm;
      </title>

      <sect3>
	<title>
	  Hardware and Software Views of Parallelism
	</title>

	<para>
	  At the heart of &tlm; is the difference in approach to parallelsim
	  taken in hardware and software design.
	</para>

	<para>
	  A hardware engineer, typically writing in a
	  <firstterm>Hardware&#32;Description&#32;Language</firstterm> (&hdl;)
	  such as Verilog or VHDL, describes a design as a collection of
	  parallel activities, which communicate via shared data. The parallel
	  activities are <literal>always</literal> (Verilog) or
	  <literal>process</literal> (VHDL) blocks. The shared data structures
	  are wires or signals.
	</para>

	<para>
	  This follows very naturally the way that physical hardware
	  behaves. There is no one <emphasis>flow of
	  control</emphasis>&mdash;all parallel components are active on at
	  the same time, with their individual flow of control.
	</para>

	<para>
	  By contrast, a software engineer usually describes any parallelism
	  as a number of threads or processes, which pass flow of control
	  between them. The threads or processes by a number of mechanisms
	  (message passing or remote procedure call for example), but although
	  there is <emphasis>logical</emphasis> parallelism, only one thread
	  or process is ever physically active at one time.
	</para>

	<para>
	  This follows naturally the behavior on a conventional uni-processor
	  CPU, where there is a single program counter indicating the next
	  instruction to execute, and so only one flow of control. Even with
	  modern multi-processors, this is still a natural way of programming
	  for the software engineer, because the number or threads or
	  processes will not generally match the number of processor cores
	  available.
	</para>
      </sect3>

      <sect3>
	<title>
	  Modelling Hardware Parallelism in Software
	</title>

	<para>
	  A simple way to model hardware is via a round-robin, which updates
	  the state of each component as time advances. This is quite common
	  with cycle accurate models. Each component is represented a software
	  routine. A master clock routine calls each component routine each
	  time the clock advances&mdash;for example on each clock edge. The
	  wires between the components are represented as variables shared
	  between the components. A number of tools (ARC VTOC, ARM RealView
	  SoC Designer, Carbon SpeedCompiler, Verilator use this approach to
	  cycle accurate modeling).
	</para>

	<para>
	  This approach has its merits for detailed modeling, where very
	  register and wire must be accurate, although
	  combinatorial hardware logic can be difficult <footnote>
	    <para>
	      For example if I have two component routines,
	      <function>A</function> and <function>B</function>, the master
	      clock step routine would call <function>A</function> followed by
	      <function>B</function>. However if there was a combinatorial
	      output from <function>B</function> driving an input to
	      <function>B</function> then I would need to call A again to
	      ensure it was correctly updated in the light of the output from
	      <function>B</function>. Sorting out which routines need to be
	      called each time the master clock updates can be extremely
	      complex for large models. Some systems (for example ARM RealView
	      SoC Designer) get round this problem by requiring all
	      combinatorial logic flows to be within a single component.
	    </para>
	  </footnote>. However for less detailed models, the overhead in
	  calling each component whenever time advances cannot be justified.
	</para>

	<para>
	  The solution is to model each component, only when it has something
	  to do. The individual components communicate by sending messages
	  over channels between each other. The exchange of messages is called
	  a transaction, and the approach
	  <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;).
	</para>

	<para>
	  This is the same way hardware behaves at the high level where
	  functional blocks communicate by reading and writing across buses.
	</para>
      </sect3>

    </sect2>

    <!-- ========== What is SystemC ========== -->

    <sect2>
      <title>
	What is &systemc;
      </title>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilite hardware modeling in a mainstream programming
	language. It is now standardized as IEEE 1666-2007.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc; Rather than invent a new language,
	&systemc; is based on the existing C++ language. &systemc; is a true
	superset of C++, so any C++ program is automatically a valid &systemc;
	program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the langauge. The key features it provides are:
	<itemizedlist>

	  <listitem>
	    <para>
	      A class, <type>sc_module</type>, suitable for defining hardware
	      modules, with convenience macros <symbol>SC_MODULE</symbol> and
	      <symbol>SC_CTOR</symbol> to define such classes.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A mechanism to define methods for
	      <type>sc_module</type> classes, which represent its logical
	      parallel behavior, with convenience macros
	      <symbol>SC_METHOD</symbol> and <symbol>SC_THREAD</symbol>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A class, <type>sc_port</type> to represent the interfaces to
	      modules and a class, <type>sc_channel</type> to connect those
	      ports.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A comprehensive set of types to represent hardware wires and
	      register both in <firstterm>2-state</firstterm> and
	      <firstterm>4-state</firstterm> logic.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	These are the key features of &systemc;. The full specification is 441
	pages long. However there is an excellent tutorial included with the
	reference distribution.
      </para>
	
    </sect2>

    <!-- ========== Overview of TLM 2.0 ========== -->

    <sect2>
      <title>
	Overview of OSCI TLM 2.0
      </title>

      <para>
	The &tlm2; standard provides a standard way of building Transaction
	Level Models.
      </para>

      <para>
	At the simplest level a &tlm; is a set of &systemc; modules (i.e. C++
	objects), each providing one or more <firstterm>socket</firstterm>s
	through which the &systemc; modules may communicate.
      </para>

      <para>
	The behavior of each module is provided by a number of parallel
	<firstterm>thread</firstterm>s (methods of the C++ class), which
	communicate with the threads in other modules by passing data
	(i.e. reading or writing) through the sockets. This communication is
	known as a <firstterm>Transaction</firstterm> and the data passed as a
	<firstterm>payload</firstterm>. <xref linkend="fig_tlm_overview" />
	shows the key components in a &tlm2; model.
      </para>

      <figure id="fig_tlm_overview">
	<title>
	  Key components in an &osci; &tlm2; model.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <!-- = Payloads = -->

      <sect3 id="sec_payload">
	<title>
	  Transaction Payload
	</title>

	<para>
	  The data passed in a transaction may take any form. However the
	  &tlm2; standard defines a <firstterm>Generic Payload</firstterm>
	  which is suitable for many uses, and which can be extended if
	  required. By using the Generic Payload, a &tlm2; model will maximize
	  interoperability.
	</para>

	<para>
	  The key features of the Generic Payload are:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>Command</term>
	    <listitem>
	      <para>
		Is this a read or a write?
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Address</term>
	    <listitem>
	      <para>
		What is the address (in the hardware sense of an address in
		memory).
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Data</term>
	    <listitem>
	      <para>
		A pointer to the physical data as an array of bytes
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The payload includes in its structure whether it is a read or a
	  write, and the address to which it refers. A &tlm2;
	  <firstterm>transport&#32;method</firstterm> is used to pass this
	  message between &systemc; modules.
	</para>
      </sect3>

      <!-- = Initators and Targets = -->

      <sect3>
	<title>
	  Initiators and Targets
	</title>

	<para>
	  A module's threads may act as either
	  <firstterm>initiator</firstterm>s or
	  <firstterm>target</firstterm>s. An initiator is reponsible for
	  creating a payload (see <xref linkend="sec_payload" />) and calling
	  the transport routine to send it. A target receives payloads from
	  the transport routine for processing and response.
	</para>

	<para>
	  Initiator calls are made through initiator ports, target calls
	  received through target ports. A module may implement both target
	  and initiator ports, allowing its threads to both generate and
	  receive traffic.
	</para>
      </sect3>

      <!-- = Blocking and Non-Blocking -->

      <sect3>
	<title>
	  Blocking and Non-Blocking Interfaces
	</title>

	<para>
	  There are two types of &tlm2; transport method.
	</para>

	<para>
	  The <firstterm>blocking</firstterm> transport methods are called by
	  the initator thread, received by the target thread, which processes
	  the request and then returns the result. Until the transaction has
	  been processed and released the initiator thread is blocked.
	</para>

	<para>
	  The <firstterm>non-blocking</firstterm> transport methods are called
	  by the initiator thread, received by the target thread, which
	  immediately returns, before processing the request. Subsequently the
	  target, having processed the request makes a transport call back to
	  the initator to return the result.
	</para>

	<para>
	  In the non-blocking case there are actually two types of transport
	  used. The <firstterm>forward&#32;transport&#32;path</firstterm> is
	  used by the initiator to pass the request to the target and the
	  <firstterm>backward&#32;transport&#32;path</firstterm> used by the
	  target to return the response. The advantage of the non-blocking
	  transport interface is that the initiator can carry on processing,
	  while the target is processing the request originally made.
	</para>
      </sect3>

      <!-- = Untimed, Loosely Timed and Approximately Timed = -->

      <sect3>
	<title>
	  Loosely Timed, Approximately Timed and Untimed &tlm;
	</title>

	<para>
	  &tlm2; considers two levels of timing detail. A
	  <firstterm>loosely&#32;timed</firstterm> model uses transactions
	  corresponding to a complete data read or write across a bus or
	  network in physical hardware. It provides timing at the level of the
	  individual transaction.
	</para>

	<para>
	  An <firstterm>approximately&#32;timed</firstterm> model breaks down
	  transactions into a number of <firstterm>phase</firstterm>s
	  corresponding much more closely to the phasing of particular
	  hardware protocols (for example the address and data phases of an
	  AHB read or write).
	</para>

	<para>
	  Typically loosely timed models are implemented with a blocking
	  interface and approximately timed models with a non-blocking
	  interface.
	</para>

	<para>
	  &tlm2; also introduces the concept of
	  <firstterm>temporal&#32;decoupling</firstterm>. Standard SystemC
	  keeps a single synchronized view of time, which is used by all
	  threads in all modules. However with temporal decoupling, each
	  thread can keep its own local view of time, allowing the thread to
	  run ahead in simulation time, until it needs to synchronize with
	  another thread. This is particularly useful with loosely timed
	  models, avoiding bottlenecks in processing.
	</para>

	<para>
	  To ensure that one thread doesn't run away hogging all the
	  processing, &tlm2; introduces the concept of the
	  <firstterm>quantum</firstterm>, the greatest amount that a thread
	  may differ in timing from the central view of time. This allows
	  other threads a chance to catch up
	</para>

	<para>
	  &tlm2; does not have an explicit concept of an untimed socket
	  (something that was explicit in &tlm;&nbsp;1.0). The standardization
	  group took the view that in practice all models need some concept of
	  time, so purely untimed models are of little value.
	</para>

	<para>
	  However, if required, untimed models are easily implemented as
	  loosely timed models which ignore the timing parameters in the
	  interface calls. If temporaly decoupled, then they ignore the
	  quantum as well.
	</para>
      </sect3>

      <!-- = Convenience sockets = -->

      <sect3>
	<title>
	  &tlm2; Convenience Sockets
	</title>

	<para>
	  The standard &tlm2; approach to modeling requires the user to
	  derive their own classes from the standard &tlm2; sockets, so that
	  those sockets can then implement the &tlm2; interfaces. Modules then
	  instantiate these derived sockets and use the bind method to connect
	  them to sockets on other modules.
	</para>

	<para>
	  This is a very flexible method, but the need to define new
	  sub-classes for sockets is an unnecessary layer of complexity for
	  simple modeling. So the &tlm2; standard defines a number of
	  <firstterm>convenience&#32;socket</firstterm>s which can be
	  instantiated directly by modules, and which specify their inteface
	  methods as callbacks.
	</para>

	<para>
	  The first case study in this application note (see <xref
	  linkend="sec_case_study_1" />>uses these convenience sockets to
	  convert an &iss; for use with &tlm2; and connect it to a model of a
	  simple SoC.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       Simple Loosely Timed Model with Convenience Ports
       ==================================================================== -->

  <sect1 id="sec_case_study_1">
    <title>
      Case Study One: A Synchronous Loosely Timed &tlm2; Model Using Convenience Ports
    </title>

    <para>
      In this case study, the &tlm2; convenience ports are used to wrap an
      existing &iss;, which is then built into a simple SoC using additional
      hand-written &tlm2; components.
    </para>

    <para>
      The modeling is at a high level of abstraction, using th &tlm2;
      <glossterm>Generic Payload</glossterm> with no extensions. It is
      completely independent of the actual bus architecture that will be used
      in the implementation. The timing is kept synchronous
      throughout&mdash;the model will be extended to use temporal decoupling
      in a later case study (see <xref linkend="sec_case_study_3" />).
    </para>

    <!-- ========== Example Design ========== -->

    <sect2>
      <title>
	The Example Design
      </title>

      <para>
	The example is a simple SoC, based on the &or1ksim; &iss; for the &or1k;
	architecture. The &or1k; architecture is a conventional 32-bit RISC
	design, with optional instruction and data caches and an optional
	MMU. &or1ksim; is an interpreting &iss; written in C, which in its
	standard configuration models main memory and a number of peripherals
	as well as the CPU itself.
      </para>

      <para>
	Information on obtaining and setting up the open source &or1ksim;
	simulator and its toolchain are given in <xref
	linkend="big_app_note_1" />.
      </para>

      <para>
	For this case study the CPU is deconfigured to remove all the
	peripherals and the caches and MMU, so it models only the CPU and main
	memory.
      </para>

      <para>
	To build a simple SoC the &or1ksim; CPU/memory subsystem is
	connected to a UART modeled in &systemc; using &tlm2;. The testbench
	for the system will be a terminal, also modeled in &systemc; using
	&tlm2;. <xref linkend="fig_simple_soc" /> shows the design.
      </para>

      <figure id="fig_simple_soc">
	<title>
	  Simple SoC based on the &or1k; &or1ksim;.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="simple_soc.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="simple_soc.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>
    </sect2>

    <!-- ========== Wrapping the ISS ========== -->

    <sect2>
      <title>
	Wrapping the &iss;
      </title>

      <!-- = Modifying the &iss; = -->

      <sect3>
	<title>
	  Modifying the &iss; for &tlm2;
	</title>

	<para>
	  Most &iss; need some modification before they can be incorporated into
	  a &tlm2; framework. Like many &iss;, &or1ksim; is designed as a
	  standalone program. The options are:
	  <orderedlist>
	    <listitem>
	      <para>
		Keep &or1ksim; as a standalone program, but modify it to call
		out to a &systemc; model of the peripherals as required.
	      </para>
	    </listitem>

	    <listitem id="or1ksim_lib_opt">
	      <para>
		Modify &or1ksim; to be a library with a set of public
		interfaces that can be part of a larger system.
	      </para>
	    </listitem>
	  </orderedlist>
	</para>

	<para>
	  Given the choice, option <xref linkend="or1ksim_lib_opt" /> is more
	  flexible, making the &iss; widely reusable in other environments. It
	  is the approach adopted in this case study.
	</para>

	<para>
	  The &or1ksim; <function>main()</function> routine first initializes
	  the &iss;, then sits in a loop executing instructions. This
	  <function>main()</function> is replaced by a series of functions
	  which form the interface to the library. The interface functions
	  needed are:
	  <itemizedlist>
	    <listitem>
	      <para>
		<function>ork1sim_init()</function>
	      </para>

	      <para>
		<programlisting>int  or1ksim_init( const char         *config_file,
                   const char         *image_file,
                   void               *class_ptr,
                   unsigned long int (*upr)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask),
                   void              (*upw)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask,
                                             unsigned long int  wdata ) );</programlisting>
	      </para>

	      <para>
		Initializes the simulator. For &or1ksim;, configuration data
		is read from a file, which is passed as the first agument,
		<literal>config_file</literal>. The program image is passed
		as a second argument, <literal>image_file</literal>.
	      </para>

	      <para>
		&or1ksim; also needs to be able to call up to the SystemC
		model of which it is part&mdash;to read and write from the
		peripheral address space. These are provided as the fourth
		and fifth arguments, <literal>upr</literal> and
		<literal>upw</literal>.
	      </para>

	      <para>
		Procedure calls between C and C++ can be awkward. The upcall
		routines form part of the SystemC module object, but are
		written as static routines with C linkage. To enable these
		routines to invoke methods in the SystemC module, they are
		passed a pointer to the module class instance to use as a
		handle. This pointer forms the third argument,
		<literal>class_ptr</literal>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1ksim_run()</function>
	      </para>

	      <para>
		<programlisting>int  or1ksim_run( double  duration );</programlisting>
	      </para>

	      <para>
		Runs the simulator for the specified time in seconds.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1ksim_is_le()</function>
	      </para>

	      <para>
		<programlisting>int  or1ksim_is_le();</programlisting>
	      </para>

	      <para>
		Returns 1 if &or1ksim; is modeling a
		<firstterm>little&#32;endian</firstterm> architecture, 0
		otherwise. Needed to ensure the payload is packed with the
		correct byte ordering.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<function>or1ksim_time()</function>
	      </para>

	      <para>
		<programlisting>double  or1ksim_time();</programlisting>
	      </para>

	      <para>
		Returns the &or1ksim; view of how much time has elapsed while
		simulating. This routine is not needed in the initial case
		study, but will be needed when temporal decoupling is added
		(see <xref linkend="sec_temporal_decoupling" />).
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>

      <!-- = Wrapper Class definition = -->

      <sect3>
	<title>
	  &or1ksim; SystemC Wrapper Definition
	</title>

	<para>
	  The &or1ksim; SystemC wrapper module class,
	  <literal>Or1ksimSC</literal>, is defined in the file
	  <filename>Or1ksimSC.h</filename>. It will provide a single initiator
	  socket, for data access, <literal>dataIni</literal> (at this stage,
	  no instruction accesses are planned, so modeling an external
	  instruction bus is unnecessary).
	</para>

	<para>
	  The module includes the <literal>tlm.h</literal>
	  header, which defines the core &tlm2; interface and the required
	  convenience wrapper header&mdash;in this case for a simple initiator
	  socket.
	</para>

	<para>
	  The POSIX <literal>stdint.h</literal> header is also included, since
	  the code will make use of the fixed width native types defined
	  there.
	</para>

	<programlisting>#include &lt;stdint.h&gt;

#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "or1ksim.h"</programlisting>

	<note>
	  <para>
	    There is no need to include the standard
	    <literal>systemc.h</literal> header, since this is included
	    automatically by <literal>tlm.h</literal>.
	  </para>
	</note>

	<para>
	  The module is declared as a standard &systemc; module, ie. as a
	  derived class of <literal>sc_core::sc_module</literal>.
	</para>

	<programlisting>class Or1ksimSC
: public sc_core::sc_module
{</programlisting>

	<note>
	  <para>
	    The &systemc; tutorial material teaches that a module should be
	    defined using: <programlisting>SC_MODULE( Or1ksimSC
	    )</programlisting> However this is identical to the C++ derived
	    class declaration
	    <programlisting>class Or1ksimSC
: public sc_core::sc_module
{</programlisting>

	    This is the usual way classes are declared in the &systemc; and
	    &tlm2; examples&mdash;<literal>SC_MODULE</literal> seems only to
	    appear in tutorial material for beginners.
	  </para>

	  <para>
	    Throughout this application note, the C++ derived class
	    declaration style is used, rather than
	    <literal>SC_MODULE</literal>.
	  </para>
	</note>

	<para>
	  The example needs a custom constructor, which can be passed the
	  &or1ksim; configuration and image files. It will call the
	  <function>or1ksim_init()</function> routine within the &or1ksim;
	  library to initialize the &iss;.
	</para>

	<programlisting>  Or1ksimSC( sc_core::sc_module_name  name,
             const char              *configFile,
             const char              *imageFile );</programlisting>

	<para>
	  The module will have a single thread, which executes the
	  instructions of the &iss;. The <function>run()</function> method
	  implements this:
	</para>

	<programlisting>  void  run();</programlisting>

	<para>
	  Two methods are needed to implement the read and write upcalls from
	  the &or1ksim; library. Both use the native SystemC type for the
	  address (which is always 64 bits) and the
	  <firstterm>POSIX</firstterm> fixed width data types for mask and
	  data. The synchronized transport mechanism is common to both, so
	  provided in a utility method, <function>syncTrans()</function>.
	</para>

	<programlisting>  uint32_t           readUpcall( sc_dt::uint64  addr,
                                 uint32_t       mask );

  void               writeUpcall( sc_dt::uint64  addr,
                                  uint32_t       mask,
                                  uint32_t       wdata );

  void               syncTrans( tlm::tlm_generic_payload &amp;trans );</programlisting>

        <caution>
	  <para>
	    It might seem logical to use the &systemc; limited precision types,
	    rather than the POSIX types. However the &systemc; types are
	    <emphasis>not</emphasis> native C++ types, so will not cast as
	    expected.
	  </para>
	</caution>

	<para>
	  The initiator socket, <literal>dataIni</literal> is declared for the
	  <literal>Or1ksimSC</literal> class. The convenience sockets are
	  templated with the class of which any callbacks are members, bus
	  width and protocol type. For this case study, the default bus width
	  (32 bits) and default protocol types (the &tlm2; base protocol
	  types) are appropriate and need not be specified. There is no
	  default class for the template, so <literal>Or1ksimSC</literal> is
	  used, although for a simple initiator, no callbacks are actually
	  required.
	</para>

	  <programlisting>  tlm_utils::simple_initiator_socket&lt;Or1ksimSC&gt;  dataIni;</programlisting>

	<para>
	  Two time stamps are declared, one to hold the SystemC view of the
	  time of the last upcall from &or1ksim;, the other to hold the
	  &or1ksim; view of the time of the last upcall.
	</para>

	  <programlisting>  sc_core::sc_time  scLastTime;
  sc_core::sc_time  or1kLastTime;</programlisting>

      </sect3>

      <!-- = Wrapper Class definition = -->

      <sect3>
	<title>
	  &or1ksim; SystemC Wrapper Definition
	</title>

	<para>
	  The class implementation for <literal>Or1ksimSC</literal> is found
	  in the file <filename>Or1ksimSC.cpp</filename>. All the definitions
	  required are obtained from the definition file:
	</para>

	<programlisting>#include "Or1ksimSC.h"</programlisting>

	<para>
	  The first two routines declared are not part of the class at all,
	  but static routines which implement the upcalls from the &or1ksim;
	  library. By declaring the routines static, they are visible only
	  within this source file, and can use simple linkage.
	</para>

	<para>
	  The static routines receive the pointer to the
	  <literal>Or1ksim</literal> instance that is associate with the
	  &or1ksim; (which was provided as part of the call to
	  <function>or1ksim_init()</function> described below). This allows
	  the routines to call the member function which implements the
	  upcall, as shown here with <function>staticReadUpcall</function>:
	</para>

	<programlisting>static unsigned long int  staticReadUpcall( void              *instancePtr,
                                            unsigned long int  addr,
                                            unsigned long int  mask )
{
  Or1ksimSC *classPtr = (Or1ksimSC *)instancePtr;

  return (unsigned long int)classPtr->readUpcall( (sc_dt::uint64)addr,
                                                  (uint32_t)mask );
}       // staticReadUpcall()</programlisting>

        <para>
	  The address is cast to the &systemc; native 64-bit type, which is
	  always used for addresses. The mask and result (and write data for
	  <function>staticWriteUpcall()</function> are cast to POSIX fixed
	  length types to avoid any ambiguity. While
	  <symbol>unsigned&nbsp;long&nbsp;int</symbol> is almost always 32
	  bits long, it is not guaranteed to be so.
	</para>

	<caution>
	  <para>
	    It might be thought that providing a direct upcall to the C++
	    upcall methods of the class would be more efficient, using the C++
	    member reference operator (<literal>::*</literal>). However the
	    linkage to a member is much more complex (to cope with inheritance
	    and overloading). Lack of standardization in the C++
	    <firstterm>Application Binary Interface</firstterm> (ABI) mean
	    that such linkage between C and C++ will not necessarily work.
	  </para>

	  <para>
	    Linkage to static routines is much simpler and usually works
	    between C and C++. So the approach used here is much more likely
	    to work.
	  </para>
	</caution>

	<para>
	  The implementation of a C++ class that is a &systemc; module
	  requires a number of definitions that class to be set up using the
	  <literal>SC_HAS_PROCESS</literal> macro.
	</para>

	<programlisting>SC_HAS_PROCESS( Or1ksimSC );</programlisting>

	<caution>
	  <para>
	    The <literal>SC_HAS_PROCESS</literal> macro is a common cause of
	    confusion with new users to &systemc; It doesn't appear in the
	    tutorial examples. The reason is that those examples use the
	    <literal>SC_CTOR</literal> macro to define the constructor for the
	    class, and the <literal>SC_CTOR</literal> macro provides the same
	    definitions as the <literal>SC_HAS_PROCESS</literal> macro.
	  </para>

	  <para>
	    However the SC_CTOR macro can only be used where the constructor's
	    implementation is given within the class definition. It is not
	    good programming practice to mix the definition of a class
	    (i.e. what it is) with its implementation (i.e. how it does it).
	  </para>

	  <para>
	    This application note follows the standard C++ practice of
	    defining a class in a header (<filename>.cpp</filename>) file
	    based on the class name and providing the implementation in a
	    separate C++ source (<filename>.cpp</filename>) file also based on
	    the class name.
	  </para>

	  <para>
	    Where the constructor implementation is separate from the
	    definition, &systemc; requires that the
	    <literal>SC_HAS_PROCESS</literal> macro is used before the code of
	    any class methods.
	  </para>
	</caution>

	<para>
	  The constructor passes names to the constructors of its
	  parent (<literal>sc_module</literal>) and simple initiator port
	  (<literal>dataIni</literal>, then calls the
	  <function>or1ksim_init()</function> routine in the &or1ksim; library
	  to initialize the &iss;. The member function,
	  <function>run()</function> is then initialized as a &systemc;
	  thread, using the <literal>SC_THREAD</literal> macro.
	</para>

	<programlisting>Or1ksimSC::Or1ksimSC ( sc_core::sc_module_name  name,
                       const char              *configFile,
                       const char              *imageFile ) :
  sc_module( name ),
  dataIni( "data_initiator" )
{
  or1ksim_init( configFile, imageFile, this, staticReadUpcall,
                staticWriteUpcall );

  SC_THREAD( run );               // Thread to run the ISS

}       /* Or1ksimSC() */</programlisting>

	<para>
	  The main thread, <function>run()</function>, takes timestamps from a
	  &systemc; and &or1ksim; perspective, then invokes the &iss; to run for
	  ever (by passing a negative time argument). The &iss; will use the
	  upcalls to request any I/O it requires into peripheral address
	  space.
	</para>

	<programlisting>void
Or1ksimSC::run()
{
  scLastUpTime   = sc_core::sc_time_stamp();
  or1kLastUpTime = or1ksim_time();

  (void)or1ksim_run( -1.0 );

}       // Or1ksimSC()
</programlisting>

	<para>
	  The upcalls from the &iss; generate the transactional activity. These
	  routines set up the payload, execute the transaction (i.e exchange
	  the payload and result with the target) and return the result to the
	  &iss;.
	</para>

	<para>
	  The example here is coded in a very simple fashion, in the knowledge
	  that the requests to read are always four bytes long (the &or1k; has
	  a simple 32 bit bus), possibly with some bytes masked out for byte
	  and half-word reads. This matches the default
	  <symbol>BUSWIDTH</symbol> of the simple initiator socket.
	</para>

	<para>
	  Both payload and data are local (automatic) variables, i.e. on the
	  stack. This is fine with a blocking transport method, since they
	  will remain valid for the duration of the transaction. The data and
	  mask are both encoded in the four bytes of a POSIX
	  <symbol>uint32_t</symbol>.
	</para>

	<caution>
	  <para>
	    Using local variables would not be appropriate with a non-blocking
	    socket, since the initiator routine could return before the result
	    of the transaction is received back from the target.
	  </para>

	  <para>
	    &tlm2; requires that the payload, data and mask fields all remain
	    valid for the duration of the complete transaction, so heap
	    allocation and deletion would be required in this case.
	  </para>
	</caution>

	<para>
	  Once the fields are set up, the <function>syncTrans()</function>
	  method (which is used for both read and write) is called to
	  synchronize with the SystemC clock, transport the payload to the
	  target and return the result.
	</para>

	<para>
	  There are two components to the time taken in this model, the time
	  taken by the &or1ksim; &iss; and the time taken in any peripherals. At
	  the time of an upcall, the SystemC wrapper thread will not have
	  yielded control since the last upcall. It needs to wait for the
	  &systemc; clock to catch up to this time point.
	</para>

	<para>
	  The &systemc; time at which the last upcall was made was recorded in
	  <symbol>scLastUpTime</symbol>. The timestamp of the &or1ksim; &iss; at
	  the last upcall (i.e. the number of cycles it has executed,
	  multiplied by the time taken for each cycle) was recorded in the
	  <symbol>or1kLastUpTime</symbol>.
	</para>

	<para>
	  A call of <function>or1ksim_time()</function> gives the current time
	  of the &iss;, and hence the time that has elapsed since the last up
	  call. This is used to advance both<symbol>scLastUpTime</symbol> and
	  <symbol>or1kLastUpTime</symbol>. The thread then calls
	  <function>wait</function> to allow any other threads in the
	  &systemc; world to run until the calculated simulation time is
	  reached.
	</para>

	<para>
	  At this time the blocking transport method of the simple initiator
	  port is called with the payload and specifying a zero time offset
	  (since the call to <function>wait()</function> means the thread is
	  synchronized with the &systemc; clock).
	</para>

	<para>
	  On return, the <symbol>delay</symbol> parameter will have been
	  updated with any additional delay due to the transaction&mdash;in
	  this case an estimate of the number of cycles to read or write the
	  relevant UART register.
	</para>

	<para>
	  It would be possible to make another call to
	  <function>wait()</function> immediately to synchronize locally for
	  this delay. However there will be no more processing on this thread
	  until the next upcall from the &or1ksim; &iss;, so the delay is added
	  to the <symbol>scLastUpTime</symbol> and will be added to the
	  <function>wait()</function> on the next upcall.
	</para>

      </sect3>

      <!-- = Compiling the Wrapper Module = -->

      <sect3>
	<title>
	  &or1ksim; SystemC Wrapper Definition
	</title>

    </sect2>

    <!-- ========== Connecting to Peripherals ========== -->

    <sect2>
      <title>
	Connecting to Periperhals
      </title>

      <!-- = The UART and Terminal Emulator = -->

      <sect3>
	<title>
	  The UART and Terminal Emulator
	</title>

	<para>
	</para>

      </sect3>

      <!-- = Connecting the system = -->

      <sect3>
	<title>
	  Connecting the Complete System
	</title>

	<para>
	</para>

      </sect3>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Adding an Arbiter
       ==================================================================== -->

  <sect1 id="sec_case_study_2">
    <title>
      Case Study Two: Adding an Arbiter
    </title>

    <para>
      In this case study, the &tlm2; model from the first case study an
      arbiter is added to illustrate the use of the
      <firstterm>passthrough</firstterm> convenience socket and
      <firstterm>tagged&#32;socket</firstterm>s.
    </para>

    <!-- ========== Example Design ========== -->

    <sect2>
      <title>
	The Example Design
      </title>

      <para>
	The example is extended to add further peripherals (another UART,
	connected to a second terminal). An arbiter is introduced, which will
	route traffic to the correct UART, depending on address. <xref
	linkend="fig_arbiter_soc" /> shows the design.
      </para>

      <figure id="fig_arbiter_soc">
	<title>
	  Simple SoC based on the &or1k; &or1ksim;.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="arbiter_soc.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="arbiter_soc.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

    </sect2>

    <!-- ========== Design of the Arbiter ========== -->

    <sect2>
      <title>
	The Aribiter &tlm2; Model
      </title>

      <!-- = Interface = -->

      <sect3>
	<title>
	  Adding a &tlm2; Passthrough Socket
	</title>

	<para>
	</para>

      </sect3>

      <!-- = Interface = -->

      <sect3>
	<title>
	  Using Tagging with Initiator Sockets
	</title>

	<para>
	</para>

      </sect3>

    </sect2>

    <!-- ========== Connecting to Peripherals ========== -->

    <sect2>
      <title>
	Connecting the SoC
      </title>

	<para>
	</para>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Adding an Temporal Decoupling
       ==================================================================== -->

  <sect1 id="sec_case_study_3">
    <title>
      Case Study Three: Temporal Decoupling of the Model
    </title>

    <para>
      In this case study temporal decoupling is added to the &tlm2; model of
      an SoC. The SoC model with arbiter from the previous example is reused.
    </para>

    <!-- ========== The Quantum Keeper ========== -->

    <sect2>
      <title>
	The Quantum Keeper
      </title>

      <!-- = Basic Interface = -->

      <para>
      </para>

    </sect2>

    <!-- ========== Temporal Decoupling ========== -->

    <sect2 id="sec_temporal_decoupling">
      <title>
	Temporal Decoupling Each Component
      </title>

      <!-- = Basic Interface = -->

      <para>
      </para>

    </sect2>

    <!-- ========== Connecting the System ========== -->

    <sect2>
      <title>
	Connecting the Complete System
      </title>

      <para>
      </para>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Non-Blocking Interfaces
       ==================================================================== -->

  <sect1>
    <title>
      Case Study Two: Non-Blocking Interfaces
    </title>

    <!-- ========== Justification ========== -->

    <sect2>
      <title>
	Loosely Timed Non-Blocking Interface
      </title>

      <para>
      </para>

    </sect2>

    <!-- ========== Justification ========== -->

    <sect2>
      <title>
	Approximately Timed Non-Blocking Interface
      </title>

      <para>
      </para>

    </sect2>

  </sect1>

  <!-- ========================================================================
       Appendix: Introduction to C++
       ==================================================================== -->

  <appendix>
    <title>
      Introduction to C++ for Hardware Engineers
    </title>

    <para>
    </para>

  </appendix>

  <!-- ========================================================================
       Glossary
       ==================================================================== -->

  <glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<symbol>X</symbol>)
	  and undriven (<symbol>Z</symbol>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>approximately&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing the phases of data
	  transfer in a specific bus protocol (for example the address and
	  data phases of an <acronym>AHD</acronym> read or write).
	</para>

	<glossseealso>loosely&#32;timed</glossseealso>
	<glossseealso>phase</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>backward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method which
	  returns the resonse transaction from target to initiator.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>forward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which blocks the flow of
	  control in the initiator until the target has completed the
	  transaction request and responded.
	</para>

	<glossseealso>non-blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>convenience&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; wrapper, providing for simple TLM communication based on
	  C++ callbacks.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>forward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method, which
	  passes the opening transaction from initiator to target.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Generic Payload</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a class suitable for use as payload for
	  transactions. Recommended to maximize the interoperability of TLMs.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Hardware&#32;Description&#32;Language</glossterm>
      <glossdef>
	<para>
	  A language (<glossterm>Verilog</glossterm> and
	  <glossterm>VHDL</glossterm> are the best known), which describes
	  hardware. Can be used to describe both an actual chip and its
	  testbench.
	</para>

	<glossseealso>Verilog</glossseealso>
	<glossseealso>VHDL</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>initiator</glossterm>
      <glossdef>
	<para>
	  The initiator of a transactional exchange to a target. In &tlm2; an
	  initiator module must implement an initiator socket of the
	  appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>target</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Instruction&#32;Set&#32;Simulator</glossterm>
      <glossdef>
	<para>
	  A software model of a CPU core instruction set. Typically completely
	  models the instruction semantics, but not the full micorarchitecture
	  of a particular CPU implementation. Timing information may be just
	  an instruction count, or may (as with the &or1ksim;) offer some
	  estimate of timing delays due to memory accesses, cacheing and
	  virtual memory access.
	</para>
      </glossdef>

    </glossentry>

    <glossentry>
      <glossterm>&iss;</glossterm>
      <glosssee>Instruction&#32;Set&#32;Simulator</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&osci;</acronym></glossterm>
      <glosssee>Open &systemc; Initiative</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>loosely&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing a complete data transfer
	  across a hardware bus.
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open&#32;SystemC&#32;Initiative</glossterm>
      <glossdef>
	<para>
	  The industry body standardizing the SystemC language and
	  applications of those language for particular purposes, such as
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>,
	  verification and synthesis. More information is available on their
	  <ulink url="http://www.systemc.org">website</ulink>.
	</para>

	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>non-blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which allows the flow of
	  control in the initiator to continue immediately the transaction is
	  sent. The response will be provided later by a transport call from
	  the target back to the initiator..
	</para>

	<glossseealso>blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>passthrough</glossterm>
      <glossdef>
	<para>
	  A term describing a &tlm2; convenience socket which reuses the
	  payload, thereby eliminating the computational cost of allocation
	  and deallocation. Typically used in modules which perform a routing
	  or arbitration function.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload</glossterm>
      <glossdef>
	<para>
	  The data passed between threads by a transaction.
	</para>

	<glossseealso>Generic Payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>phase</glossterm>
      <glossdef>
	<para>
	  In &tlm2; approximately timed modeling, a transaction exchange
	  representing a single phase of the specific bus protocol being
	  modelled (for example the address phase of an <acronym>AHD</acronym>
	  read or write).
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>POSIX</glossterm>
      <glossdef>
	<para>
	  An IEEE standard for application programming interfaces and
	  utilities for Unix/Linux operating systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, the maximum time a thread may
	  run ahead of the main system clock. This may be regulated by a
	  quantum keeper.
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum keeper</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, an object which enforces the
	  rule that threads may not run more than the quantum ahead of the
	  main system clock
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>socket</glossterm>
      <glossdef>
	<para>
	  Within the context of &tlm2;, a &systemc; port and export combined
	  with the associated interfaces for blocking and non-blocking
	  transport, direct memory access and debug.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>&systemc;</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>tagged&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; convenience socket, which incorporates a numerical
	  <emphasis>tag</emphasis> to identify the socket in use. This allows
	  a single callback routine to handle multiple sockets, with the tag
	  identifying the socket which caused the callback to be invoked.
	</para>

	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>target</glossterm>
      <glossdef>
	<para>
	  The responder to a transactional exchange initiated by an
	  initiator. In &tlm2; a target module must implement a target socket
	  of the appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>initiator</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>temporal&#32;decoupling</glossterm>
      <glossdef>
	<para>
	  In &tlm2; the concept of allowing individual threads to run ahead of
	  the main simulation timestamp. The maximum permitted time of run
	  ahead is known as the <glossterm>quantum</glossterm> and may be
	  regulated by a quantum keeper.
	</para>

	<glossseealso>quantum</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>thread</glossterm>
      <glossdef>
	<para>
	  In software, a logical parallel flow of control. In the context of
	  &systemc;, the main method of such a thread can be specified with
	  the <literal>SC_THREAD</literal> macro. In &systemc; a
	  <literal>SC_THREAD</literal> is distinguished from a
	  <literal>SC_METHOD</literal> because it can suspend execution with
	  <function>wait()</function> calls.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym></glossterm>
      <glossdef>
	<para>
	  An abbreviation for (depending on context)
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm> or
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>Transaction&#32;Level&#32;Modeling</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym>&nbsp;2.0</glossterm>
      <glossdef>
	<para>
	  The &osci; standard interface for writing
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>s in
	  &systemc;.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transport&#32;method</glossterm>
      <glossdef>
	<para>
	  The C++ procedure which transfers data from an initiator to a
	  target, and (for a non-blocking interface), the response back from
	  the target to the initiator. Within the context of &tlm2; blocking
	  and non-blocking transport interfaces are defined.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction</glossterm>
      <glossdef>
	<para>
	  An exchange of data (the payload) between two parallel processes. In
	  &tlm2; this transaction occurs through &systemc; ports implementing
	  the &tlm2; interfaces, which are known as sockets.
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Model</glossterm>
      <glossdef>
	<para>
	  A software model in which the components of the model communicate by
	  transferring information to and from each other (transactions).
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>
      <glossdef>
	<para>
	  The process of writing software models using
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Verilog</glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso><acronym>VHDL</acronym></glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>VHDL</acronym></glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso>Verilog</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <!-- ========================================================================
       References
       ==================================================================== -->

  <bibliography>
    <title>
      References
    </title>

    <biblioentry id="big_app_note_1">
      <title>
	&embecosm; Application Note 1. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide
      </title>

      <publisher>
	<publishername>
	  Embecosm
	</publishername>
	<address>
	  <city>
	    Bournemouth
	  </city>
	  <country>
	    UK
	  </country>
	</address>
      </publisher>

      <pubdate>
	June, 2008
      </pubdate>
    </biblioentry>

  </bibliography>

  <!-- ========================================================================
       Index
       ==================================================================== -->

  <index />

</article>
 