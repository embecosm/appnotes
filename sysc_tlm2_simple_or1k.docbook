<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY hdl "<acronym>HDL</acronym>">
<!ENTITY iss "<acronym>ISS</acronym>">
<!ENTITY osci "<acronym>OSCI</acronym>">
<!ENTITY tlm "<acronym>TLM</acronym>">
<!ENTITY tlm2 "<acronym>TLM</acronym>&nbsp;2.0">
<!ENTITY uart "<acronym>UART</acronym>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY binutils "<application class='software'>Binutils</application>">
<!ENTITY gcc "<application class='software'>GCC</application>">
<!ENTITY gdb "<application class='software'>GDB</application>">
<!ENTITY ddd "<application class='software'>DDD</application>" >
<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY uclinux "<application class='software'>uClinux</application>" >
<!ENTITY uclibc "<application class='software'>uClibc</application>">
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">
<!ENTITY or1200 "<application class='hardware'>OpenRISC 1200</application>">
<!ENTITY orpsoc "<application class='hardware'>ORPSoC</application>">

<!-- = Commands = -->

<!ENTITY patch "<command>patch</command>" >
<!ENTITY diff "<command>diff</command>" >
<!ENTITY configure "<command>configure</command>" >
<!ENTITY make "<command>make</command>" >
<!ENTITY makefile "<command>make</command> file" >
<!ENTITY makeall "<command>make all</command>" >
<!ENTITY makecheck "<command>make check</command>" >
<!ENTITY makeinstall "<command>make install</command>" >
<!ENTITY makeclean "<command>make clean</command>" >
<!ENTITY xterm "<command>xterm</command>" >
<!ENTITY sh "<command>sh</command>" >
<!ENTITY bash "<command>bash</command>" >
<!ENTITY csh "<command>csh</command>" >
<!ENTITY tcsh "<command>tcsh</command>" >
<!ENTITY bunzip2 "<command>bunzip2</command>" >
<!ENTITY nm "<command>nm</command>" >
<!ENTITY grep "<command>grep</command>" >

<!-- = Libraries = -->

<!ENTITY readline "<systemitem class='library'>readline</systemitem>" >
<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Internal cross references = -->

<!ENTITY patchref "See <xref linkend='sec_binutils_download' /> for an example
  of how to apply a &patch; file." >

<!-- = Web pages = -->

<!ENTITY embecosm "<ulink
  url='http://www.embecosm.com'>Embecosm</ulink>">
<!ENTITY opencores "<ulink
  url='http://www.opencores.org'>OpenCores</ulink>">
<!ENTITY gnu "<ulink url='http://www.gnu.org'>GNU</ulink>">
<!ENTITY gpl "<ulink url='http://www.gnu.org/licenses/gpl.html'>
  GNU General Public License</ulink>">
<!ENTITY lgpl "<ulink url='http://www.gnu.org/licenses/lgpl.html'>
  GNU Lesser General Public License</ulink>">

]>

<!-- ==========================================================================

                  CONFIDENTIAL AND PROPRIETARY INFORMATION
                  ========================================

Copyright (c) 2008 Embecosm.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing the first stage in the conversion of an ISS to use
OSCI TLM 2.0, convenience ports.

$Id$

=========================================================================== -->

<article class="whitepaper" lang="en_GB">
  <title>
    Building a Loosely Timed SoC Model with &osci; TLM 2.0
  </title>
  <subtitle>
    A Case Study Reusing the &or1k; &or1ksim; &iss;
  </subtitle>

  <articleinfo>

    <corpauthor>
      &embecosm;
    </corpauthor>

    <pubdate>
      14 June 2008
    </pubdate>

    <releaseinfo>
      Application Note 2. Issue 1, draft A
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	Embecosm Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software examples written by &embecosm; and used in this document
	are licensed under the &lgpl;. For detailed licensing information see
	the source code of the examples.
      </para>

      <para>
	Embecosm is the business name of Embecosm Limited, a private limited
	company registered in England and Wales. Registration number 6577021.
      </para>

    </legalnotice>
  </articleinfo>

  <!-- ========================================================================
       Introduction
       ==================================================================== -->

  <sect1>
    <title>
      Introduction
    </title>

    <para>
      The Open <firstterm>&systemc;</firstterm> Initiative
      (<firstterm>&osci;</firstterm>) has recently issued the second version
      of its standard for
      <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;). This
      provides an interface for writing high level software models of
      hardware.
    </para>

    <para>
      One of the most important components in any SoC system model is the
      processor core <firstterm>Instruction Set Simulator</firstterm>
      (&iss;). With the standardization of &osci; &tlm2; for &systemc;, many
      &iss;, providers will wish to convert to offer the
      <firstterm>&tlm2;</firstterm> interface
    </para>

    <para>
      This application note is the first in a series from &embecosm;,
      providing case studies in &osci; &tlm2; use, based on an open source
      &iss;, the &or1ksim; for the &opencores; &or1200; architecture.
    </para>

    <para>
      The objective is to provide an introduction to using &tlm2; within a
      practical context. Examples are provided throughout, which are freely
      available under the &lgpl;.
    </para>

    <!-- ========== Justification ========== -->

    <sect2>
      <title>
	About the &embecosm; TLM 2.0 Application Note Series
      </title>

      <para>
	The &osci; &tlm2; standard represents a significant advance in
	standardizing the creation of fast software models of
	hardware. However the &osci; reference implementation lacks training
	material and examples to introduce new users to the technology.
      </para>

      <para>
	These users are often trained hardware engineers, who may be
	relatively new to both C++ and transaction level modeling (&tlm;).
      </para>

      <para>
	This series of &embecosm; Application Notes was prompted by a customer
	requesting assistance in porting an existing &iss; to the &tlm2;
	standard. This first application note in the series introduces &tlm2;
	in its simplest form, using &tlm2;
	<firstterm>convenience&#32;socket</firstterm>s.
      </para>

    </sect2>

    <!-- ========== Target Audience ========== -->

    <sect2>
      <title>
	Target Audience
      </title>

      <para>
      </para>

    </sect2>
  </sect1>


  <!-- ========================================================================
       Background to TLM
       ==================================================================== -->

  <sect1>
    <title>
      Background to &tlm; and &systemc;
    </title>

    <para>
      
    </para>

    <!-- ========== What is TLM ========== -->

    <sect2 id="sec_what_is_tlm">
      <title>
	What is a &tlm;
      </title>

      <sect3>
	<title>
	  Hardware and Software Views of Parallelism
	</title>

	<para>
	  At the heart of &tlm; is the difference in approach to parallelism
	  taken in hardware and software design.
	</para>

	<para>
	  A hardware engineer, typically writing in a
	  <firstterm>Hardware&#32;Description&#32;Language</firstterm> (&hdl;)
	  such as Verilog or VHDL, describes a design as a collection of
	  parallel activities, which communicate via shared data. The parallel
	  activities are <literal>always</literal> (Verilog) or
	  <literal>process</literal> (VHDL) blocks. The shared data structures
	  are wires or signals.
	</para>

	<para>
	  This follows very naturally the way that physical hardware
	  behaves. There is no one <emphasis>flow of
	  control</emphasis>&mdash;all parallel components are active on at
	  the same time, with their individual flow of control.
	</para>

	<para>
	  By contrast, a software engineer usually describes any parallelism
	  as a number of threads or processes, which pass flow of control
	  between them. The threads or processes by a number of mechanisms
	  (message passing or remote procedure call for example), but although
	  there is <emphasis>logical</emphasis> parallelism, only one thread
	  or process is ever physically active at one time.
	</para>

	<para>
	  This follows naturally the behavior on a conventional uni-processor
	  CPU, where there is a single program counter indicating the next
	  instruction to execute, and so only one flow of control. Even with
	  modern multiprocessors, this is still a natural way of programming
	  for the software engineer, because the number or threads or
	  processes will not generally match the number of processor cores
	  available.
	</para>
      </sect3>

      <sect3>
	<title>
	  Modelling Hardware Parallelism in Software
	</title>

	<para>
	  A simple way to model hardware is via a round-robin, which updates
	  the state of each component as time advances. This is quite common
	  with cycle accurate models. Each component is represented a software
	  routine. A master clock routine calls each component routine each
	  time the clock advances&mdash;for example on each clock edge. The
	  wires between the components are represented as variables shared
	  between the components. A number of tools (ARC VTOC, ARM RealView
	  SoC Designer, Carbon SpeedCompiler, Verilator use this approach to
	  cycle accurate modeling).
	</para>

	<para>
	  This approach has its merits for detailed modeling, where very
	  register and wire must be accurate, although
	  combinatorial hardware logic can be difficult <footnote>
	    <para>
	      For example if I have two component routines,
	      <function>A</function> and <function>B</function>, the master
	      clock step routine would call <function>A</function> followed by
	      <function>B</function>. However if there was a combinatorial
	      output from <function>B</function> driving an input to
	      <function>B</function> then I would need to call A again to
	      ensure it was correctly updated in the light of the output from
	      <function>B</function>. Sorting out which routines need to be
	      called each time the master clock updates can be extremely
	      complex for large models. Some systems (for example ARM RealView
	      SoC Designer) get round this problem by requiring all
	      combinatorial logic flows to be within a single component.
	    </para>
	  </footnote>. However for less detailed models, the overhead in
	  calling each component whenever time advances cannot be justified.
	</para>

	<para>
	  The solution is to model each component, only when it has something
	  to do. The individual components communicate by sending messages
	  over channels between each other. The exchange of messages is called
	  a transaction, and the approach
	  <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;).
	</para>

	<para>
	  This is the same way hardware behaves at the high level where
	  functional blocks communicate by reading and writing across buses.
	</para>
      </sect3>

    </sect2>

    <!-- ========== What is SystemC ========== -->

    <sect2>
      <title>
	What is &systemc;
      </title>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling in a mainstream programming
	language. It is now standardized as IEEE 1666-2007.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc; Rather than invent a new language,
	&systemc; is based on the existing C++ language. &systemc; is a true
	super-set of C++, so any C++ program is automatically a valid &systemc;
	program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
	<itemizedlist>

	  <listitem>
	    <para>
	      A class, <literal>sc_module</literal>, suitable for defining hardware
	      modules, with convenience macros <symbol>SC_MODULE</symbol> and
	      <symbol>SC_CTOR</symbol> to define such classes.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A mechanism to define methods for
	      <literal>sc_module</literal> classes, which represent its logical
	      parallel behavior, with convenience macros
	      <symbol>SC_METHOD</symbol> and <symbol>SC_THREAD</symbol>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A class, <literal>sc_port</literal> to represent the interfaces to
	      modules and a class, <literal>sc_channel</literal> to connect those
	      ports.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A comprehensive set of types to represent hardware wires and
	      register both in <firstterm>2-state</firstterm> and
	      <firstterm>4-state</firstterm> logic.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	These are the key features of &systemc;. The full specification is 441
	pages long. However there is an excellent tutorial included with the
	reference distribution.
      </para>
	
    </sect2>

    <!-- ========== Overview of TLM 2.0 ========== -->

    <sect2>
      <title>
	Overview of OSCI TLM 2.0
      </title>

      <para>
	The &tlm2; standard provides a standard way of building Transaction
	Level Models.
      </para>

      <para>
	At the simplest level a &tlm; is a set of &systemc; modules (i.e. C++
	objects), each providing one or more <firstterm>socket</firstterm>s
	through which the &systemc; modules may communicate.
      </para>

      <para>
	The behavior of each module is provided by a number of parallel
	<firstterm>thread</firstterm>s (methods of the C++ class), which
	communicate with the threads in other modules by passing data
	(i.e. reading or writing) through the sockets. This communication is
	known as a <firstterm>Transaction</firstterm> and the data passed as a
	<firstterm>payload</firstterm>. <xref linkend="fig_tlm_overview" />
	shows the key components in a &tlm2; model.
      </para>

      <figure id="fig_tlm_overview">
	<title>
	  Key components in an &osci; &tlm2; model.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <!-- = Payloads = -->

      <sect3 id="sec_payload">
	<title>
	  Transaction Payload
	</title>

	<para>
	  The data passed in a transaction may take any form. However the
	  &tlm2; standard defines a <firstterm>Generic Payload</firstterm>
	  which is suitable for many uses, and which can be extended if
	  required. By using the Generic Payload, a &tlm2; model will maximize
	  interoperability.
	</para>

	<para>
	  The key features of the Generic Payload are:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>Command</term>
	    <listitem>
	      <para>
		Is this a read or a write?
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Address</term>
	    <listitem>
	      <para>
		What is the address (in the hardware sense of an address in
		memory).
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Data</term>
	    <listitem>
	      <para>
		A pointer to the physical data as an array of bytes
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The payload includes in its structure whether it is a read or a
	  write, and the address to which it refers. A &tlm2;
	  <firstterm>transport&#32;method</firstterm> is used to pass this
	  message between &systemc; modules.
	</para>
      </sect3>

      <!-- = Initators and Targets = -->

      <sect3>
	<title>
	  Initiators and Targets
	</title>

	<para>
	  A module's threads may act as either
	  <firstterm>initiator</firstterm>s or
	  <firstterm>target</firstterm>s. An initiator is responsible for
	  creating a payload (see <xref linkend="sec_payload" />) and calling
	  the transport routine to send it. A target receives payloads from
	  the transport routine for processing and response.
	</para>

	<para>
	  Initiator calls are made through initiator ports, target calls
	  received through target ports. A module may implement both target
	  and initiator ports, allowing its threads to both generate and
	  receive traffic.
	</para>
      </sect3>

      <!-- = Blocking and Non-Blocking -->

      <sect3>
	<title>
	  Blocking and Non-Blocking Interfaces
	</title>

	<para>
	  There are two types of &tlm2; transport method.
	</para>

	<para>
	  The <firstterm>blocking</firstterm> transport methods are called by
	  the initiator thread, received by the target thread, which processes
	  the request and then returns the result. Until the transaction has
	  been processed and released the initiator thread is blocked.
	</para>

	<para>
	  The <firstterm>non-blocking</firstterm> transport methods are called
	  by the initiator thread, received by the target thread, which
	  immediately returns, before processing the request. Subsequently the
	  target, having processed the request makes a transport call back to
	  the initiator to return the result.
	</para>

	<para>
	  In the non-blocking case there are actually two types of transport
	  used. The <firstterm>forward&#32;transport&#32;path</firstterm> is
	  used by the initiator to pass the request to the target and the
	  <firstterm>backward&#32;transport&#32;path</firstterm> used by the
	  target to return the response. The advantage of the non-blocking
	  transport interface is that the initiator can carry on processing,
	  while the target is processing the request originally made.
	</para>
      </sect3>

      <!-- = Untimed, Loosely Timed and Approximately Timed = -->

      <sect3>
	<title>
	  Loosely Timed, Approximately Timed and Untimed &tlm;
	</title>

	<para>
	  &tlm2; considers two levels of timing detail. A
	  <firstterm>loosely&#32;timed</firstterm> model uses transactions
	  corresponding to a complete data read or write across a bus or
	  network in physical hardware. It provides timing at the level of the
	  individual transaction.
	</para>

	<para>
	  An <firstterm>approximately&#32;timed</firstterm> model breaks down
	  transactions into a number of <firstterm>phase</firstterm>s
	  corresponding much more closely to the phasing of particular
	  hardware protocols (for example the address and data phases of an
	  AHB read or write).
	</para>

	<para>
	  Typically loosely timed models are implemented with a blocking
	  interface and approximately timed models with a non-blocking
	  interface.
	</para>

	<para>
	  &tlm2; also introduces the concept of
	  <firstterm>temporal&#32;decoupling</firstterm>. Standard SystemC
	  keeps a single synchronized view of time, which is used by all
	  threads in all modules. However with temporal decoupling, each
	  thread can keep its own local view of time, allowing the thread to
	  run ahead in simulation time, until it needs to synchronize with
	  another thread. This is particularly useful with loosely timed
	  models, avoiding bottlenecks in processing.
	</para>

	<para>
	  To ensure that one thread doesn't run away hogging all the
	  processing, &tlm2; introduces the concept of the
	  <firstterm>quantum</firstterm>, the greatest amount that a thread
	  may differ in timing from the central view of time. This allows
	  other threads a chance to catch up
	</para>

	<para>
	  &tlm2; does not have an explicit concept of an untimed socket
	  (something that was explicit in &tlm;&nbsp;1.0). The standardization
	  group took the view that in practice all models need some concept of
	  time, so purely untimed models are of little value.
	</para>

	<para>
	  However, if required, untimed models are easily implemented as
	  loosely timed models which ignore the timing parameters in the
	  interface calls. If temporarily decoupled, then they ignore the
	  quantum as well.
	</para>
      </sect3>

      <!-- = Convenience sockets = -->

      <sect3>
	<title>
	  &tlm2; Convenience Sockets
	</title>

	<para>
	  The standard &tlm2; approach to modeling requires the user to
	  derive their own classes from the standard &tlm2; sockets, so that
	  those sockets can then implement the &tlm2; interfaces. Modules then
	  instantiate these derived sockets and use the bind method to connect
	  them to sockets on other modules.
	</para>

	<para>
	  This is a very flexible method, but the need to define new
	  sub-classes for sockets is an unnecessary layer of complexity for
	  simple modeling. So the &tlm2; standard defines a number of
	  <firstterm>convenience&#32;socket</firstterm>s which can be
	  instantiated directly by modules, and which specify their interface
	  methods as callbacks.
	</para>

	<para>
	  Convenience sockets are used throughout most of the case study in
	  this application note. In the final section (see <xref
	  linkend="sec_standard_tlm" />) the conversion from convenience
	  sockets to standard &tlm2; sockets and interfaces is demonstrated.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       The Case Study
       ==================================================================== -->

  <sect1 id="sec_case_study">
    <title>
      Case Study: A SoC Using &tlm2;
    </title>

    <para>
      In this case study, the &tlm2; sockets are used to wrap an
      existing &iss;, which is then built into a simple SoC using additional
      hand-written &tlm2; components.
    </para>

    <para>
      The modeling is at a high level of abstraction, using the &tlm2;
      <glossterm>Generic Payload</glossterm> with no extensions. It is
      completely independent of the actual bus architecture that will be used
      in the implementation.
    </para>

    <para>
      The model is constructed in a number of stages:
    </para>

    <orderedlist>

      <listitem>
	<para>
	  The basic wrapper for the &or1ksim; &iss; is built using &tlm2;
	  convenience sockets and tested with a simple logger. In this first
	  stage timing is ignored&mdash;this is effectively an untimed
	  model. See <xref linkend="sec_iss_wrapper" />
	</para>
      </listitem>

      <listitem>
	<para>
	  A model &uart; is added as an example peripheral, demonstrating how
	  &tlm2; and existing &systemc; technologies can be mixed. See <xref
	  linkend="sec_uart" />
	</para>
      </listitem>

      <listitem>
	<para>
	  A model of a terminal is added as a testbench for the SoC. This
	  demonstrates how to add &systemc; components which use operating
	  system I/O without blocking the &systemc; thread. See <xref
	  linkend="sec_terminal" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Synchronous is added to each component, making the model loosely
	  timed. See <xref linkend="sec_sync" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Temporal decoupling is added to the &or1ksim; &iss;, &uart; and
	  terminal. See <xref linkend="sec_temporal_decoupling" />
	</para>
      </listitem>

      <listitem>
	<para>
	  A second &uart; is added to the system and a &tlm2; arbiter added,
	  demonstrating the use of &tlm2; convenience passthrough sockets. See
	  <xref linkend="sec_arbiter" />
	</para>
      </listitem>

      <listitem>
	<para>
	  The entire model is reimplemented using the standard &tlm2; sockets
	  and interfaces. See <xref linkend="sec_standard_tlm" />
	</para>
      </listitem>
    </orderedlist>

    <para>
      Throughout the model is demonstrated with simple applications to
      exercise the relevant system components. At the final stage, a full
      Linux 2.6 kernel is able to run on the SoC.
    </para>

    <!-- ========== Example Designs ========== -->

    <sect2>
      <title>
	The Example Designs
      </title>

      <para>
	The example is a simple SoC, based on the &or1ksim; &iss; for the &or1k;
	architecture. The &or1k; architecture is a conventional 32-bit RISC
	design, with optional instruction and data caches and an optional
	MMU. &or1ksim; is an interpreting &iss; written in C, which in its
	standard configuration models main memory and a number of peripherals
	as well as the CPU itself.
      </para>

      <para>
	Information on obtaining and setting up the open source &or1ksim;
	simulator and its tool chain are given in <xref
	linkend="ref_app_note_1" />.
      </para>

      <para>
	In general the CPU is configured to remove all the peripherals and
	the caches and MMU, so it models only the CPU and main memory.
      </para>

      <!-- = Plain ISS Wrapper = -->

      <sect3>
	<title>
	  &or1ksim; &iss; &tlm2; Wrapper
	</title>

	<para>
	  The first stage is to just test the &tlm2; wrapper for the &or1ksim;
	  &iss;. The wrapped &iss; is connected to a simple &tlm2; logger
	  module which records transactions sent to it on standard output as
	  shown in <xref linkend="fig_iss_test" />.
	</para>

	<figure id="fig_iss_test">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="iss_test.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="iss_test.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <!-- = Simple SoC Example = -->

      <sect3>
	<title>
	  Simple SoC Design
	</title>

	<para>
	  To build a simple SoC the &or1ksim; CPU/memory subsystem is
	  connected to a &uart; modeled in &systemc; using &tlm2;. The
	  test bench for the system will be a terminal, also modeled in
	  &systemc; using &tlm2;. This model is built up in stages in <xref
	  linkend="sec_iss_wrapper" />, <xref linkend="sec_uart" /> and <xref
	  linkend="sec_terminal" />. <xref linkend="fig_simple_soc" /> shows the
	  design.
	</para>

	<figure id="fig_simple_soc">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <!-- = More complex SoC = -->

      <sect3>
	<title>
	  SoC with Arbiter
	</title>

	<para>
	  For <xref linkend="sec_arbiter" />, the example is extended to add
	  further peripherals (another &uart;, connected to a second
	  terminal). An arbiter is introduced, which will route traffic to the
	  correct &uart;, depending on address. <xref linkend="fig_arbiter_soc"
	  /> shows the design.
	</para>

	<figure id="fig_arbiter_soc">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="arbiter_soc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="arbiter_soc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <!-- = SoC for Linux = -->

      <sect3>
	<title>
	  SoC to run Linux
	</title>

	<para>
	  To demonstrate the SoC running Linux <xref linkend="sec_linux" />,
	  the example is that shown in <xref linkend="fig_arbiter_soc"
	  />. However the non-UART peripheral modeling capabilities of the
	  underlying xISS are turned on, to provided the required functionality.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       Wrapping the ISS
       ==================================================================== -->

  <sect1 id="sec_iss_wrapper">
    <title>
      Wrapping the &iss;
    </title>

    <para>
      The conversion of an existing &iss; to a  &systemc;
      module with &tlm2; sockets involves several steps:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Modify the existing &iss; (in this example &or1ksim; written in C)
	  so it  behaves in a manner suitable for wrapping (see <xref
	  linkend="sec_iss_mods" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  Define a &systemc; module for the wrapper (see <xref
	  linkend="sec_iss_wrapper_def" />) and provide its implementation
	  (see <xref linkend="sec_iss_wrapper_impl" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Test the wrapper with a simple logger module attached to the &tlm2;
	  port and a suitable test application running as embedded code on the
	  &iss; (see <xref linkend="sec_iss_wrapper_test" />).
	</para>
      </listitem>
    </itemizedlist>

    <!-- ========== Modifying the &iss; ========== -->

    <sect2 id="sec_iss_mods">
      <title>
	Modifying the &or1ksim; &iss; for &tlm2;
      </title>

      <para>
	Most &iss; need some modification before they can be incorporated into
	a &tlm2; framework. Like many &iss;, &or1ksim; is designed as a
	standalone program. The options are:
	<orderedlist>
	  <listitem>
	    <para>
	      Keep the &iss; as a standalone program, but modify it to call
	      out to a &systemc; model of the peripherals as required.
	    </para>
	  </listitem>

	  <listitem id="or1ksim_lib_opt">
	    <para>
	      Modify the &iss; to be a library with a set of public interfaces
	      that can be part of a larger system.
	    </para>
	  </listitem>
	</orderedlist>
      </para>

      <para>
	Given the choice, option <xref linkend="or1ksim_lib_opt" /> is more
	flexible, making the &iss; widely reusable in other environments. It
	is the approach adopted in this case study.
      </para>
      <sect3 id="sec_or1ksim_libcals">
	<title>
	  Converting &or1ksim; to a Library
	</title>

	<para>
	  The &or1ksim; <function>main()</function> routine first initializes
	  the &iss;, then sits in a loop executing instructions. This
	  <function>main()</function> routine is replaced by a series of
	  functions which form the interface to the library. The interface
	  functions needed are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_init( const char         *config_file,
                   const char         *image_file,
                   void               *class_ptr,
                   unsigned long int (*upr)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask),
                   void              (*upw)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask,
                                             unsigned long int  wdata ) );</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_init()</function> initializes the
	      simulator. For &or1ksim;, configuration data is read from a
	      file, which is passed as the first argument,
	      <literal>config_file</literal>. The program image is passed as
	      a second argument, <literal>image_file</literal>.
	    </para>

	    <para>
	      &or1ksim; also needs to be able to call up to the SystemC
	      model of which it is part&mdash;to read and write from the
	      peripheral address space. These are provided as the fourth
	      and fifth arguments, <literal>upr</literal> and
	      <literal>upw</literal>. More explanation of the upcall
	      mechanism can be found in <xref linkend="sec_upcall" />.
	    </para>

	    <para>
	      Procedure calls between C and C++ can be awkward. The upcall
	      routines form part of the SystemC module object, but are
	      written as static routines with C linkage. To enable these
	      routines to invoke methods in the SystemC module, they are
	      passed a pointer to the module class instance to use as a
	      handle. This pointer forms the third argument,
	      <literal>class_ptr</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_run( double  duration );</programlisting>
	    </para>
	    <para>
	      <function>or1ksim_run()</function> runs the simulator for the
	      specified time in seconds.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3>
	<title>
	  Additional Functionality for &or1ksim;
	</title>

	<para>
	  The standard &or1ksim; &iss; incorporates the functionality of
	  several common peripherals. The objective of this application note
	  is to demonstrate the &iss; driving external peripherals modelled in
	  &systemc; using &tlm2; interfaces.
	</para>

	<para>
	  &or1ksim; peripherals are configured in a textual configuration file,
	  with a section (introduced by the keyword
	  <literal>section</literal>) for each device attached. This
	  configuration specifies the memory mapped addresses of the
	  peripheral. Any reads or writes to those addresses will be directed
	  to the code of the peripheral within &or1ksim;.
	</para>

	<para>
	  &or1ksim; is extended with a new class of peripheral,
	  <literal>generic</literal>, which specifies an external
	  peripheral. The specification in the configuration file specifies
	  the memory mapped address range covered and whether byte, half word
	  or full word access are enabled. Multiple <literal>generic</literal>
	  sections may be defined (for different address ranges) in the
	  configuration file.
	</para>

	<para>
	  Code is added to &or1ksim;, so that any read or write to a
	  <literal>generic</literal> peripheral is redirected back to the
	  wrapper code via the upcalls specified as arguments to
	  <function>or1ksim_init()</function> (see <xref
	  linkend="sec_or1ksim_libcals" /> and <xref linkend="sec_upcall" />).
	</para>
      </sect3>
    </sect2>

    <!-- ========== Wrapper Class definition ========== -->

    <sect2 id="sec_iss_wrapper_def">
      <title>
	&or1ksim; Wrapper Module Class Definition
      </title>

      <para>
	The class definition for the &or1ksim; wrapper module is found in
	<filename>Or1ksimSC.h</filename>.
      </para>

      <para>
	All the examples in this application note separate the definition of a
	class (i.e. <emphasis>what</emphasis> it does) in a
	<filename>.h</filename> file, from the implementation
	(i.e. <emphasis>how</emphasis> it does it) in a
	<filename>.cpp</filename> file. This is considered good programming
	practice.
      </para>

      <para>
	The examples use the convention that classes and other typenames start
	with an Upper Case letter (e.g. <literal>Or1ksimSC</literal>),
	variables and functions start with a lower case letter
	(e.g. <literal>dataBus</literal>) and defined or enumerated constants
	are all in UPPER CASE (e.g. <literal>#define BAUD_RATE
	9600</literal>).
      </para>

      <para>
	Those routines and variables which other classes will use are declared
	as <literal>public</literal>. For &systemc; modules this usually means
	the constructor and any &systemc; ports or sockets. Occasionally there
	are some utility routines which are also made public (see for example
	<literal>Or1ksimExt::isLittleEndian()</literal> in <xref
	linkend="sec_uart_or1ksim_libext" />)<footnote>
	  <para>
	    Object oriented purists prefer to expose only procedures as the
	    <literal>public</literal> interface, so hiding all state from
	    external view. There is considerable merit in this, but the common
	    &systemc; convention is to expose actual ports or sockets, rather
	    than accessor routines for those objects. This application note
	    sticks with that practice.
	  </para>
	</footnote>.
      </para>

      <para>
	Some non-public parts of the module are declared as
	<literal>protected</literal> (i.e. visible to derived classes). This
	application note develops the example design by subclassing the
	SystemC module classes to add further functionality. Functions and
	objects declared <literal>protected</literal> are those which are
	expected to be reused in later derived classes.
      </para>

      <para>
	The remaining functions and variables, which are for use only by this
	class, are declared <literal>private</literal> (visible only to this
	class). This avoids any unplanned reuse by derived classes.
      </para>

      <para>
	Some of the functions are replaced in later derived classes, so are
	also declared <literal>virtual</literal>.
      </para>

      <para>
	In summary <literal>public</literal> functions and variables may be
	used by any other class, <literal>protected</literal> functions and
	variables may be <emphasis>used</emphasis> only by this class and any
	derived classes and <literal>private</literal> functions and variables
	may be used only by this class. <literal>virtual</literal> functions
	may be <emphasis>replaced</emphasis> in derived classes.
      </para>

      <!-- = Include files and definitions = -->

      <sect3 id="sec_Or1ksimSC_def_inc">
	<title>
	  Included Headers
	</title>

	<para>
	  The &or1ksim; SystemC wrapper module class,
	  <literal>Or1ksimSC</literal>, is defined in the file
	  <filename>Or1ksimSC.h</filename>. It will provide a single initiator
	  socket, for data access, <literal>dataBus</literal> (no instruction
	  accesses are planned, so modeling an external instruction bus is
	  unnecessary).
	</para>

	<para>
	  The module includes the <literal>tlm.h</literal> header, which
	  defines the core &tlm2; interface and the required convenience
	  wrapper header&mdash;in this case for a simple initiator socket.
	</para>

	<para>
	  The POSIX <literal>stdint.h</literal> header is also included, since
	  the definitions and code will make use of the fixed width native
	  types defined there.
	</para>

	<programlisting>#include &lt;stdint.h&gt;

#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "or1ksim.h"</programlisting>

        <note>
	  <para>
	    There is no need to include the standard
	    <literal>systemc.h</literal> header, since this is included
	    automatically by <literal>tlm.h</literal>.
	  </para>
	</note>

      </sect3>

      <!-- = Module declaration = -->

      <sect3 id="sec_Or1ksimSC_def_module">
	<title>
	  Module Declaration
	</title>

	<para>
	  The module is declared as a standard &systemc; module, i.e. as a
	  derived class of <literal>sc_core::sc_module</literal>.
	</para>

	<programlisting>class Or1ksimSC
: public sc_core::sc_module
{</programlisting>

        <note>
	  <para>
	    The &systemc; tutorial material teaches that a module should be
	    defined using:
	  </para>

	  <programlisting>SC_MODULE( Or1ksimSC )</programlisting>

	  <para>
	    However this is equivalent (IEEE 1666-2005 section 5.2.5) to the
	    C++ derived class declaration
	  </para>

	  <programlisting>class Or1ksimSC
: public sc_core::sc_module
{
 public:</programlisting>

          <para>
	    This is the usual way classes are declared in the &systemc; and
	    &tlm2; examples&mdash;<literal>SC_MODULE</literal> seems only to
	    appear in tutorial material for beginners. It has the effect that
	    unless there is a subsequent <literal>protected:</literal> or
	    <literal>private:</literal> all functions and variables will be
	    visible to all other classes.
	  </para>

	  <para>
	    Throughout this application note, the C++ derived class
	    declaration style is used with explicit declarations of
	    <literal>public:</literal>, <literal>protected:</literal> or
	    <literal>private:</literal> as required, rather than
	    <literal>SC_MODULE</literal>.
	  </para>
	</note>

      </sect3>

      <!-- = Constructor and destructor = -->

      <sect3 id="sec_Or1ksimSC_def_constructor">
	<title>
	  Constructor and Destructor
	</title>

	<para>
	  <classname>Or1ksimSC</classname> needs a custom constructor, which
	  can be passed the &or1ksim; &iss; configuration and image files. It
	  will call the <function>or1ksim_init()</function> routine within the
	  &or1ksim; library (see <xref linkend="sec_or1ksim_libcals" />) to
	  initialize the &iss;.
	</para>

	<programlisting>Or1ksimSC( sc_core::sc_module_name  name,
             const char              *configFile,
             const char              *imageFile );</programlisting>

	<para>
	  The default destructor is sufficient here. The module has no tidying
	  up to do on termination.
	</para>

      </sect3>

      <!-- = Public Interface = -->

      <sect3 id="sec_Or1ksimSC_def_pub_if">
	<title>
	  Public Interface
	</title>

	<para>
	  The only public interface is the &tlm2; simple initiator convenience
	  socket, <literal>dataBus</literal>. The &tlm2; convenience sockets are
	  templated with
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      the class of which any callbacks are members;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a bus width (default <literal>BUSWIDTH</literal>, 32); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a protocol type (default the &tlm2; base protocol types).
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  For this case study, the default bus width and protocol are
	  appropriate and need not be specified. There is no default class for
	  the template, so <literal>Or1ksimSC</literal> is used. A class must be
	  specified, even where (as in this case for a simple blocking
	  initiator) no callbacks are actually required.
	</para>

	<programlisting>  tlm_utils::simple_initiator_socket&lt;Or1ksimSC&gt;  dataBus;</programlisting>

      </sect3>

      <!-- = Threads = -->

      <sect3 id="sec_Or1ksimSC_def_threads">
	<title>
	  Threads
	</title>
      
        <para>
	  The module has a single thread, which executes the instructions of
	  the &iss;. The <function>run()</function> procedure implements this:
	</para>

	<programlisting>  void  run();</programlisting>

	<para>
	  The thread is not part of the public interface, but will but will be
	  reused and replaced in derived classes later in the application
	  note, so it is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>
      </sect3>

      <!-- = Upcalls = -->

      <sect3 id="sec_upcall">
	<title>
	  Upcalls
	</title>

	<para>
	  The &or1ksim; &iss; makes requests to read and write peripherals via
	  the upcalls passed as arguments to <function>or1ksim_init</function>
	  (see <xref linkend="sec_or1ksim_libcals" />).
	</para>

	<para>
	  The &or1ksim; &iss; is implemented in C, which cannot easily call
	  C++ class instance functions. The solution is to declare two
	  <emphasis>static</emphasis> member functions which can be called
	  from C. The call to <function>or1ksim_init()</function> also passed
	  the address of the actual C++ class instance (cast to
	  <literal>void&nbsp;*</literal>). This pointer is passed back with
	  the upcall, so the static function can call the corresponding
	  instance function.
	</para>

	<para>
	  A total of 4 functions are needed, one static and one instance each
	  for read and write. The static functions use the native C/C++ types
	  (unsigned long int), but convert to defined fixed width types for
	  the instance functions. The native SystemC 64-bit unsigned type is
	  used for the address (which is always 64 bits in &tlm2; function
	  calls) and the <firstterm>POSIX</firstterm> 32-bit unsigned data
	  type is used for byte enable mask and data.
	</para>

	<para>
	  These upcall functions are not changed throughout this application
	  note, so are declared private.
	</para>

	<programlisting>  static unsigned long int  staticReadUpcall( void              *instancePtr,
                                              unsigned long int  addr,
                                              unsigned long int  mask );

  static void               staticWriteUpcall( void              *instancePtr,
                                               unsigned long int  addr,
                                               unsigned long int  mask,
                                               unsigned long int  wdata );

  uint32_t                  readUpcall( sc_dt::uint64  addr,
                                        uint32_t       mask );

  void                      writeUpcall( sc_dt::uint64  addr,
                                         uint32_t       mask,
                                         uint32_t       wdata );</programlisting>

        <caution>
	  <para>
	    It might seem logical to use the &systemc; limited precision
	    types, rather than the POSIX types. However the &systemc; types
	    are <emphasis>not</emphasis> native C++ types, so will not cast as
	    expected.
	  </para>
	</caution>

	<para>
	  The transport mechanism is common to both, so provided in a utility
	  method, <function>doTrans()</function>. However this function will
	  be used and replaced in derived classes later in this application
	  note, so is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>

      </sect3>
    </sect2>

    <!-- ========== Wrapper Class simplementation ========== -->

    <sect2 id="sec_iss_wrapper_impl">
      <title>
	&or1ksim; Wrapper Module Class Implementation
      </title>

      <para>
	The class implementation for <literal>Or1ksimSC</literal> is found
	in the file <filename>Or1ksimSC.cpp</filename>.
      </para>
<sect3>
	<title>
	  Headers and Macros
	</title>

	<para>
	  All the definitions required are obtained from the definition file:
	</para>

	<programlisting>#include "Or1ksimSC.h"</programlisting>

	<para>
	  The implementation of a C++ class that is a &systemc; module with
	  &systemc; threads (<literal>SC_THREAD</literal>), methods
	  (<literal>SC_METHOD</literal>) or clocked threads
	  (<literal>SC_CTHREAD</literal>) requires a number of definitions for
	  that class to be set up using the <literal>SC_HAS_PROCESS</literal>
	  macro.
	</para>

	<programlisting>SC_HAS_PROCESS( Or1ksimSC );</programlisting>

	<caution>
	  <para>
	    The <literal>SC_HAS_PROCESS</literal> macro is a common cause of
	    confusion with new users to &systemc; It doesn't appear in the
	    tutorial examples. The reason is that those examples use the
	    <literal>SC_CTOR</literal> macro to define the constructor for the
	    class, and the <literal>SC_CTOR</literal> macro provides the same
	    definitions as the <literal>SC_HAS_PROCESS</literal> macro.
	  </para>

	  <para>
	    The SC_CTOR macro can only be used where the constructor's
	    implementation is given within the class definition. However, it
	    is not good programming practice to mix the definition of a class
	    (i.e. what it is) with its implementation (i.e. how it does it).
	  </para>

	  <para>
	    This application note follows the standard C++ practice of
	    defining a class in a header (<filename>.h</filename>) file based
	    on the class name and providing the implementation in a separate
	    C++ source (<filename>.cpp</filename>) file also based on the
	    class name.
	  </para>

	  <para>
	    In cases such as this, where the constructor implementation is
	    separate from the definition, &systemc; requires that the
	    <literal>SC_HAS_PROCESS</literal> macro is used before the code of
	    any class methods.
	  </para>
	</caution>

      </sect3>
<sect3>
	<title>
	  Constructor
	</title>

	<para>
	  The constructor passes names to the constructors of its parent
	  (<literal>sc_module</literal>) and simple initiator port
	  (<literal>dataBus</literal>), then calls the
	  <function>or1ksim_init()</function> routine in the &or1ksim; library
	  to initialize the &iss;.
	</para>

	<para>
	  The member function, <function>run()</function> is initialized as a
	  &systemc; thread, using the <literal>SC_THREAD</literal> macro. It
	  will be called automatically by the &systemc; kernel after
	  elaboration (i.e &systemc; initialization).
	</para>

	<programlisting>Or1ksimSC::Or1ksimSC ( sc_core::sc_module_name  name,
                       const char              *configFile,
                       const char              *imageFile ) :
  sc_module( name ),
  dataIni( "data_initiator" )
{
  or1ksim_init( configFile, imageFile, this, staticReadUpcall,
                staticWriteUpcall );

  SC_THREAD( run );               // Thread to run the ISS

}       /* Or1ksimSC() */</programlisting>


      </sect3>
<sect3 id="sec_Or1ksimSC_impl_thread">
	<title>
	  Thread
	</title>

      <para>
	The main thread, <function>run()</function>, invokes the &or1ksim;
	&iss; to run for ever (by passing a negative time argument). The &iss;
	will use the upcalls (see <xref linkend="sec_upcall" />> to request
	reads from and writes to the peripheral address space.
      </para>

      <para>
	The thread is called automatically when the &systemc; kernel has
	completed elaboration (i.e. is initialized).
      </para>

      <programlisting>void
Or1ksimSC::run()
{
  scLastUpTime   = sc_core::sc_time_stamp();
  or1kLastUpTime = or1ksim_time();

  (void)or1ksim_run( -1.0 );

}       // Or1ksimSC()</programlisting>

      </sect3>
<sect3>
	<title>
	  Upcalls
	</title>

      <para>
	As noted in <xref linkend="sec_upcall" />, the first two functions
	declared are static member functions which implement the upcalls from
	the &or1ksim; library.
      </para>

      <para>
	The static functions receive the pointer to the
	<literal>Or1ksimSC</literal> instance which originally started the
	&or1ksim; &iss; (provided as an argument to
	<function>or1ksim_init()</function> described in <xref
	linkend="sec_Or1ksimSC_impl_thread" />).
      </para>

      <para>
	This allows the each function to call the member function which
	implements the upcall, as shown here with
	<function>staticReadUpcall</function>:
      </para>

      <programlisting>unsigned long int
Or1ksimSC::staticReadUpcall( void              *instancePtr,
			     unsigned long int  addr,
			     unsigned long int  mask )
{
  Or1ksimSC *classPtr = (Or1ksimSC *)instancePtr;

  return (unsigned long int)classPtr->readUpcall( (sc_dt::uint64)addr,
						  (uint32_t)mask );
}	// staticReadUpcall()</programlisting>

        <para>
	  The address is cast to the &systemc; native 64-bit type, which is
	  always used in &tlm2; for addresses. The mask and result (and write
	  data for <function>staticWriteUpcall()</function> are cast to the
	  POSIX <literal>uint32_t</literal> fixed length type to avoid any
	  ambiguity over size<footnote>
	    <para>
	      While <literal>unsigned&nbsp;long&nbsp;int</literal> is almost
	      always 32 bits long, it is not guaranteed to be so.
	    </para>
	  </footnote>.
	</para>

	<caution>
	  <para>
	    It might be thought that providing a direct upcall to the C++
	    upcall methods of the class would be more efficient, using the C++
	    member reference operator (<literal>::*</literal>). However the
	    linkage to a member is much more complex (to cope with inheritance
	    and overloading). Lack of standardization in the C++
	    <firstterm>Application Binary Interface</firstterm> (ABI) means
	    that such linkage between C and C++ will not necessarily work.
	  </para>

	  <para>
	    Linkage to static routines is much simpler and usually works
	    between C and C++. So the approach used here is more reliable.
	  </para>
	</caution>

	<para>
	  The upcalls from the &iss; generate the transactional
	  activity. These routines set up the payload, execute the transaction
	  (i.e exchange the payload and result with the target) and return the
	  result to the &iss;.
	</para>

	<para>
	  The example here is coded in a very simple fashion, in the knowledge
	  that the requests to read are always four bytes long (the &or1k; has
	  a simple 32 bit bus), possibly with some bytes masked out for byte
	  and half-word reads. This matches the default
	  <literal>BUSWIDTH</literal> of the simple initiator socket.
	</para>

	<para>
	  Both payload and data are declared as local (automatic) variables,
	  i.e. on the stack. This is fine with a blocking transport method,
	  since they will remain valid for the duration of the
	  transaction. The data and mask are both encoded in the four bytes of
	  a POSIX <literal>uint32_t</literal>.
	</para>

	<caution>
	  <para>
	    Using local variables would not be appropriate with a non-blocking
	    socket, since the initiator routine could return before the result
	    of the transaction is received back from the target.
	  </para>

	  <para>
	    &tlm2; requires that the payload, data and mask fields all remain
	    valid for the duration of the complete transaction, so heap
	    allocation and deletion would be required in this case.
	  </para>
	</caution>

      </sect3>
      <sect3 id="sec_Or1ksimSC_impl_btrans">
	<title>
	  Blocking Transport
	</title>

	<para>
	  Once the payload fields are set up, the
	  <function>doTrans()</function> function (which is used for both read
	  and write) is called to transport the payload to the target and
	  return the result.
	</para>

	<para>
	  The transport method requires a time to be supplied, even when
	  timing is not being used (as in this case). This must be time
	  variable, since the target can update the value, so a dummy variable
	  is declared with zero time and passed to the blocking transport
	  method of the socket with the payload.
	</para>

        <programlisting>  sc_core::sc_time  dummyDelay = sc_core::sc_time( 0.0, sc_core::SC_SEC );

  dataBus->b_transport( trans, dummyDelay );</programlisting>

        <para>
	  This implementation is sufficient for modeling just the &or1ksim;
	  &iss; in &systemc;. However at no time does the thread execute a
	  &systemc; <function>wait()</function> call. In the absence of any such
	  yield, no other thread would be able to execute. This will be remedied
	  in <xref linkend="sec_uart" /> when other threads are added to model
	  peripherals.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       Testing the Wrapper
       ==================================================================== -->

  <sect1 id="sec_iss_wrapper_test">
    <title>
      Testing the &or1ksim; &iss; &tlm2; Wrapper
    </title>

    <para>
      The test configuration was shown earlier in <xref linkend="fig_iss_test"
      />. For this a simple logger is needed, which must implement a &tlm2;
      simple target socket.
    </para>

    <para>
      In addition, a simple embedded application is needed to run on the
      &or1ksim; &iss;, which will make reads and writes to peripheral address
      space, which can be detected by the loggerfrom and to the logger.
    </para>

    <para>
      All the behavior is in the calback function&mdash;there are no &systemc;
      threads. This means the logger will be suitable for testing the
      <classname>Or1ksimSC</classname> wrapper module, even though its thread
      never yields.
    </para>

    <sect2>
      <title>
	Definition of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Include Files
	</title>

	<para>
	  The logger is based on the &tlm2; convenience simple target socket, so
	  needs the appropriate header:
	</para>

	<programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Declaration and Constructor
	</title>

        <para>
	  The class is a standard &systemc; module:
	</para>

	<programlisting>class LoggerSC
: public sc_core::sc_module</programlisting>

        <para>
	  A custom constructor is needed, which will be used to register the
	  callback function for the simple target convenience socket blocking
	  transport.
	</para>

	<programlisting>  LoggerSC( sc_core::sc_module_name  name );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The public interface is the single simple target convenience
	  socket.
	</para>

	<programlisting>  tlm_utils::simple_target_socket&lt;LoggerSC&gt;  loggerPort;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport
	</title>

	<para>
	  Blocking transport is via a callback routine:
	</para>

        <programlisting>  void  loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                         sc_core::sc_time         &amp;delay );</programlisting>

        <para>
	  All the behavior of the module is captured in this callback
	  routine. There are no &systemc; threads required.
	</para>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Implementation of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The logger will be doing a certain amount of stream IO, so includes
	  the C++ headers that define stream manipulation functions. The POSIX
	  standard integer types are also included.
      </para>

      <programlisting>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdint.h&gt;

#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Constructor
	</title>

        <para>
	  The constructor passes its argument (the module) name to the parent
	  <literal>sc_module</literal>literal> constructor. The body of the
	  routine then registers the <function>loggerReadWrite()</function>
	  method as the callback for blocking transport to this convenience
	  socket. This means that any initiator which requests blocking
	  transport (by calling the initiator socket's
	  <function>b_transport</function> method) will invoke this callback
	  routine in the target.
	</para>

	<programlisting>LoggerSC::LoggerSC( sc_core::sc_module_name  name ) :
  sc_module( name )
{
  loggerPort.register_b_transport( this, &amp;LoggerSC::loggerReadWrite );

}       // Or1ksimSC()</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The callback function, <function>loggerReadWrite()</function> records
	  the key information regarding any transaction it receives. The
	  payload is a &tlm2; Generic Payload, with appropriate access
	  routines. In this simple implementation, a length of 4 bytes is
	  assumed for the data in the payload.
	</para>
	
	<para>
	  To get at the data and byte enable mask, the pointers to
	  <literal>unsigned char</literal> are cast to pointers to the POSIX
	  fixed width type, <literal>uint32_t</literal>, as was used with
	  <classname>Or1ksimSC</classname>. Endianism issues due to the byte
	  pointers not being word aligned are not an issue, because the
	  <classname>Or1ksimSC</classname> module also declared them as
	  <literal>uint32_t</literal>.
	</para>

        <programlisting>void
LoggerSC::loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                           sc_core::sc_time         &amp;delay )
{
  // Break out the address, mask and data pointer.

  tlm::tlm_command   comm    = payload.get_command();
  sc_dt::uint64      addr    = payload.get_address();
  unsigned char     *maskPtr = payload.get_byte_enable_ptr();
  unsigned char     *dataPtr = payload.get_data_ptr();

  // Record the payload fields (data only if it's a write)

  const char *commStr;

  switch( comm ) {
  case tlm::TLM_READ_COMMAND:   commStr = "Read";   break;
  case tlm::TLM_WRITE_COMMAND:  commStr = "Write";  break;
  case tlm::TLM_IGNORE_COMMAND: commStr = "Ignore"; break;
  }

  std::cout &lt;&lt; "Logging" &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Command:      "   &lt;&lt; commStr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Address:      0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; (uint64_t)addr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Byte enables: 0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; *((uint32_t *)maskPtr) &lt;&lt; std::endl;

  if( tlm::TLM_WRITE_COMMAND == comm ) {
    std::cout &lt;&lt; "  Data:         0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
              &lt;&lt;std::hex &lt;&lt; *((uint32_t *)dataPtr) &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

  payload.set_response_status( tlm::TLM_OK_RESPONSE );  // Always OK

}       // loggerReadWrite()</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_logger_main_prog">
      <title>
	The Model Main Program
      </title>

      <para>
	The logger module and the &or1ksim; wrapper module must be connected
	in the main program (<function>sc_main</function> since this is
	&systemc;), and the simulation invoked.
      </para>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The program includes the main &tlm2; header and the header of the
	  two modules which will be used:
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimSC.h"
#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Argument Processing
	</title>

	<para>
	  The program takes two arguments, an &or1ksim; configuration file
	  (described further in <xref linkend="sec_iss_run_test" />) and a
	  binary image to execute on the &or1ksim; &iss; (see <xref
	  linkend="sec_iss_or32_prog" />).
	</para>

	<programlisting>int  sc_main( int   argc,
              char *argv[] )
{
  if( argc != 3 ) {
    fprintf( stderr, "Usage: TestSC &lt;config_file&gt; &lt;image_file&gt;\n" );
    exit( 1 );
  }</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Instantiation
	</title>

        <para>
	  Instances of the &or1ksim; &iss; and the logger are created, the
	  &iss; being passed the two program arguments for its initialization.
	</para>

	<programlisting>  Or1ksimSC  iss( "or1ksim", argv[1], argv[2] );
  LoggerSC   logger( "logger" );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Connecting the Modules
	</title>

        <para>
	  The target socket of the logger (<literal>loggerPort</literal>) is
	  connected by passing it as argument to the initiator socket of the
	  &iss; (<literal>dataBus</literal>). The C++ function application
	  operator, <literal>()</literal>, is overloaded for initiator sockets
	  to provide this binding function.
	</para>

	<programlisting>  iss.dataBus( logger.loggerPort );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Model Execution
	</title>

	<para>
	  Once the model is instantiated, simulation is invoked to run forever.
	</para>
	  
	<programlisting>  sc_core::sc_start();</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_or32_prog">
      <title>
	Test Program to Run on the &or1ksim;
      </title>

      <para>
	The test program (in <filename>logger_test.c</filename> defines a
	memory mapped volatile data structure and then writes to and reads
	from each element of that structure. Compilation of this program
	requires the &or1k; GNU tool chain (see <xref linkend="ref_app_note_1"
	endterm="ref_app_note_1_xr" /> for details of installing this).
      </para>

      <sect3>
	<title>
	  The Utility Functions
	</title>

	<para>
	  The test program uses some simple utility functions which can write
	  characters (<function>simputc()</function>), string
	  (<function>simputs()</function>) and hexadecimal numbers
	  (<function>simputh()</function>). Its header is included:
	</para>

	<programlisting>#include "utils.h"</programlisting>

	<para>
	  The utilies' implementation can be found in
	  <filename>utils.c</filename>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Memory Mapped Data Structure
	</title>

	<para>
	  The memory mapped address is defined in the configuration of
	  &or1ksim; (see <xref linkend="sec_iss_run_test" />) to be
	  0x90000000. This is set as a defined constant in the test program.
	</para>

	<programlisting>#define BASEADDR  0x90000000</programlisting>

	<para>
	  The memory mapped structure consists of a byte, half word (16 bits)
	  and full word (32 bits), all declared as <literal>volatile</literal>
	  within the <literal>struct</literal>. These are all declared with
	  the C types, which for the &or1k; tool chain are known to correspond
	  to these sizes.
	</para>

	<programlisting>struct  testdev
{
  volatile unsigned char       byte;
  volatile unsigned short int  halfword;
  volatile unsigned long  int  fullword;
};</programlisting>

        <para>
	  The main program declares a pointer to this struct at the
	  <literal>BASEADDR</literal>, along with 3 variables to hold the
	  results of the various sized results when reading.
	</para>

	<programlisting>main()
{
  struct testdev *dev = (struct testdev *)BASEADDR;

  unsigned char       byteRes;
  unsigned short int  halfwordRes;
  unsigned long int   fullwordRes;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Write Access
	</title>

	<para>
	  The details of each write are logged and the value then written. (In
	  the absence of a <function>printf()</function>, the logging is
	  necessarily cumbersome).
	</para>

	<programlisting>  simputs( "Writing byte 0xa5 to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );
  dev->byte     =       0xa5;

  simputs( "Writing half word 0xbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );
  dev->halfword =     0xbeef;

  simputs( "Writing full word 0xdeadbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );
  dev->fullword = 0xdeadbeef;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Read Access
	</title>

        <para>
	  The values are then read back. No results are expected (the logger
	  does not set any values), but this should check the process behaves
	  as expected.
	</para>

	<programlisting>  byteRes = dev->byte;
  simputs( "Read 0x" );
  simputh(  byteRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );

  halfwordRes = dev->halfword;
  simputs( "Read 0x" );
  simputh( halfwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );

  fullwordRes = dev->fullword;
  simputs( "Read 0x" );
  simputh( fullwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );</programlisting>

        <para>
	  At the end of the program, the utility
	  <function>simexit()</function> is used. This not only terminates the
	  program, but will also exit the simulation.
	</para>

      </sect3>

      <sect3>
	<title>
	  Program Compilation
	</title>

	<para>
	  The program is compiled with the utility routines (in
	  <filename>utils.c</filename>) and a small boot loader (in
	  <filename>start.s</filename>) which defines a
	  <literal>_start</literal> routine which invokes
	  <function>main()</function>. The linker arguments are chosen to make
	  the program load from start of memory, with the
	  <literal>_start</literal> routine sitting at the &or1k; reset vector
	  (0x100).
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_run_test">
      <title>
	Running the Test
      </title>
      <sect3>
	<title>
	  Compiling the &systemc; Model
	</title>

	<para>
	  The SystemC modules are each compiled with access to the &or1ksim;,
	  &systemc; and &tlm2; header directories. It is also essential that
	  <literal>SC_INCLUDE_DYNAMIC_PROCESSES</literal> is defined when
	  using &tlm2;:
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c TestSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c Or1ksimSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c LoggerSC.cpp</programlisting>

        <para>
	  The final linking must include the &systemc; library, and since the
	  &or1ksim; library includes some shared objects, linker directions to
	  find those shared objects
	  (<literal>-Wl,--rpath,$OR1KSIM_HOME</literal>).
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES TestSC.o Or1ksimSC.o LoggerSC.o \
    -Wl,--rpath,$OR1KSIM_HOME/lib -L$OR1KSIM_HOME/lib \
    -L$SYSTEMC_HOME/lib-linux -lsim -lsystemc -o TestSC</programlisting>

      </sect3>
      <sect3>
	<title>
	  Configuring the &or1k; &or1ksim; &iss;
	</title>

	<para>
	  The &or1ksim; &iss; is configured using a textual configuration
	  file, described in more detail in <xref linkend="ref_app_note_1"
	  endterm="ref_app_note_1_xr" />. For the modified &or1ksim;,
	  <literal>generic</literal> peripherals can be added, which will
	  cause code to call out via the upcall mechanism to the &or1ksim;
	  &systemc; wrapper module (see <xref linkend="sec_upcall" />).
	</para>

	<para>
	  The configuration file for &or1ksim; disables all the standard
	  peripherals, apart from one block of memory from address 0x0. It
	  adds a <literal>generic</literal> peripheral allowing byte, half
	  word and full word access to addresses mapped from 0x90000000 to
	  0x90000007, with the following configuration file entry
	</para>

	<programlisting>section generic
  enabled      =          1
  byte_enabled =          1
  hw_enabled   =          1
  word_enabled =          1
  name         = "External UART"
  baseaddr     = 0x90000000
  size         = 0x8
end</programlisting>

      </sect3>
      <sect3>
	<title>
	  Running the Compiled Model
	</title>

        <para>
	  The compiled program can be executed by passing in as arguments
	  the &or1ksim; configuration file and the &or1k; binary. The result
	  is shown in <xref linkend="fig_logger_test" />.
	</para>

	<figure id="fig_logger_test">
	  <title>
	    Output from the logger test of the &or1ksim; wrapper module.
	  </title>

	  <screen>$ ./TestSC ../simple.cfg ../progs_or32/logger_test

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Writing byte 0xa5 to address 0x090000000
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0x000000ff
  Data:         0x000000a5
  Delay:        0.000000000s

Writing half word 0xbeef to address 0x090000002
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0xffff0000
  Data:         0xbeef0000
  Delay:        0.000000000s

   ... &lt;More test program output&gt;

Logging
  Command:      Read
  Address:      0x90000004
  Byte enables: 0xffffffff
  Delay:        0.000000000s

Read full word 0x0 from address 0x090000004
exit(0)
@reset : cycles 0, insn #0
@exit  : cycles 26921, insn #13854
 diff  : cycles 26921, insn #13854
$ </screen>
	</figure>

	<para>
	  Each access from the application program generates the expected
	  transactional access. All accesses are 32 bits wide, but for byte
	  and half-word access the relevant bytes are masked off.
	</para>

	<note>
	  <para>
	    The &or1ksim; can be configured to model big-endian
	    architectures. The &tlm2; payloads are always packed with data
	    using the endianism of the model.
	  </para>

	  <para>
	    If the exercise were repeated with a big-endian version of
	    &or1ksim; the addresses of the access would be unchanged (they are
	    word aligned), but the byte enable masks for the byte and half
	    word accesses would be inverted.
	  </para>
	</note>

      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       Connecting to Peripherals
       ==================================================================== -->


  <sect1 id="sec_uart">
    <title>
      Modeling Peripherals
    </title>

    <para>
      This example uses a single peripheral, a &uart;. The &uart; model is
      based on National Semiconductor 16450 design.
    </para>

    <sect2>
      <title>
	Details of the 16450 &uart;
      </title>

      <para>
	The 16450 &uart; is a very long established industry component. Data
	written a byte at a time into the transmit buffer is converted to
	serial pulses on the output (Tx) pin. Serial pulses on the input (Rx)
	pin are recognized and converted to byte values, which can be read
	from the receive buffer. Typically Rx and Tx are connected to a
	terminal and keyboard which can generate and recognize the pulses of
	data. The &uart; can also generate additional signals for terminals and
	keyboards to provide physical flow control, but that is beyond the
	scope of this model. The key interfaces are shown in <xref
	linkend="fig_uart" />.
      </para>

	<figure id="fig_uart">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;16450 &uart;: Key interfaces.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="uart.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      <para>
	The 16450 &uart; specifies a set of registers which control the &uart;
	behavior. On the Tx/Rx side, this includes setting the board rate and
	the pattern of stop, start and data bits. On the CPU side this
	includes configuring interrupt behavior (if any) and setting flags to
	show the status of transmit and receive buffers. The registers are
	shown in <xref linkend="tab_ns_16450_regs" />.
      </para>

      <table id="tab_ns_16450_regs" frame='all'>
	<title>
	  NS 16450 &uart; Registers
	</title>
	<tgroup cols='4' align="left" colsep="1" rowsep="1">
	  <colspec colwidth="2*" colname="address" />
	  <colspec colwidth="2*" colname="register" />
	  <colspec colwidth="1*" colname="rw" />
	  <colspec colwidth="8*" colname="description" />

	  <thead>
	    <row>
	      <entry>
		Address
	      </entry>
	      <entry>
		Register
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		Description
	      </entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry morerows="2">
		0
	      </entry>
	      <entry>
		<literal>RXBUF</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for read data.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>TXBUF</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for data to be
		  written.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLL</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the low byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry morerows="1">
		1
	      </entry>
	      <entry>
		<literal>IER</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  The interrupt enable register. The lower 4 bits control
		  which events generate an interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLH</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the high byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		2
	      </entry>
	      <entry>
		<literal>IIR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Interrupt identification register. Bit 0 indicates if an
		  interrupt is pending, bits 1-2 the reason for the
		  interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		3
	      </entry>
	      <entry>
		<literal>LCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Line control register. Various bits controlling the
		  behavior of the &uart;. Of these, DLAB, bit 7, the divisor
		  latch access bit is important, because it controls the
		  behavior of registers 0
		  (<literal>RXBUF</literal>/<literal>TXBUF</literal>/<literal>DLL</literal>)
		  and 1 (<literal>IER</literal>/<literal>DLH</literal>).
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		4
	      </entry>
	      <entry>
		<literal>MCR</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  Modem control register. Bits 0-4 control the
		  behavior of the modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		5
	      </entry>
	      <entry>
		<literal>LSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Line status register. Bits 0-6 report the status of the
		  &uart;. Of these, DR, bit 0, receiver data ready is
		  important, indicating there is valid data in
		  <literal>RXBUF</literal>.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		6
	      </entry>
	      <entry>
		<literal>MSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Modem Status Register. Bits reporting the state of the
		  modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		7
	      </entry>
	      <entry>
		<literal>SCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Scratch register. Not used by the &uart;, but may be used by
		  the application to store an 8-bit value.
		</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
      </para>

    </sect2>

    <sect2>
      <title>
	&uart; Module Design
      </title>

      <para>
	A transaction level model cannot show all the intricacies of a
	&uart;&mdash;the whole point is to simplify and remove detail.
      </para>

      <para>
	The &tlm; should allow the CPU to read and write registers, a terminal
	to send and receive characters and should generate interrupts as
	appropriate. While all writable registers can be written and all
	readable registers read, only those registers and bits of registers
	which are relevant to this level of modeling will have any impact on
	behavior.
      </para>

      <sect3>
	<title>
	  &uart; Model Interfaces
	</title>

	<para>
	  A &tlm2; socket is the natural model for the bus interface to the
	  CPU. However the interface to the terminal is much simpler. A
	  standard &systemc; one byte FIFO will be suitable.
	</para>

	<caution>
	  <para>
	    It might be thought that an 8-bit &systemc; signal port would be
	    suitable. However &systemc; signal ports model physical wires, and
	    only notify changes to the value on the wire. This would be suitable
	    if the &uart; were to model the pulses signalled across the wire.
	  </para>

	  <para>
	    At this level of modeling, complete bytes are being transferred. It
	    is quite possible that two identical bytes would follow each
	    other. A signal port would not notify any change to the recipient,
	    while a FIFO will signal that data has been written.
	  </para>
	</caution>

	<para>
	  The interrupt is modelled as a signal, active high for the
	  16450. &systemc; static sensitivity to this signal is a natural way
	  for connected modules to detect the interrupt.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Model Registers
	</title>

	<para>
	  The divisor latch affects the baud rate, which will affect timing of
	  transfers. This will be covered in a later section (see <xref
	  linkend="sec_sync" />), but is not needed for the current untimed
	  model. The value can be written and read, but does not affect
	  behavior.
	</para>

	<para>
	  Only two interrupts are relevant (see <xref
	  linkend="sec_uart_interrupts" />), and only the corresponding bits
	  in the interrupt enable and interrupt identification registers are
	  modelled.
	</para>

	<para>
	  The modem control and status registers are irrelevant to this model
	  and do not influence its behavior, the modem control register can be
	  written and the status register read, but their contents are not
	  affected by the behavior of the modem.
	</para>

	<para>
	  The line control register sets details of the bit transfers. In a
	  later section (see <xref linkend="sec_sync" />), this will affect
	  the timing of transfers, but it is not relevant to the current
	  untimed model, and is ignored.
	</para>

	<para>
	  In the Line Status Register, the <literal>Data Ready</literal> and
	  <literal>Transmitter Holding Empty</literal>/<literal>Transmitter
	  Empty</literal> bits are the only ones modeled. The model does not
	  distinguish a separate buffer and holding transmit register, so the
	  last two of these will move in step in the model.
	</para>

      </sect3>

      <sect3 id="sec_uart_interrupts">
	<title>
	  &uart; Model Interrupts
	</title>

	<para>
	  Only two interrupts are relevant, <literal>Register Data
	  Empty</literal> and <literal>Transmit Holding Register
	  Empty</literal>. Only the corresponding bits of the interrupt enable
	  and identification registers are relevant.
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_or1ksim_libext">
      <title>
	Updating the <classname>Or1ksimSC</classname> Wrapper Module
      </title>

      <para>
	For a larger system, the
	&or1ksim; wrapper module must be extended. A public function is
	required for peripheral models to establish the CPU endianism.
      </para>

      <para>
	The function must be added to the underlying &or1ksim; library and
	then a wrapper function added to the <classname>Or1ksimSC</classname>
	wrapper module.
      </para>

      <para>
	In <xref linkend="sec_Or1ksimSC_impl_btrans" /> it was noted that the
	absence of any call to <function>wait()</function> meant the &or1ksim;
	&iss; could be the only thread in the model. The
	<function>doTrans()</function> function must be extended to yield
	after each transaction to allow other threads to run.
      </para>

      <para>
	These extensions are achieved by defining a new
	class, <classname>Or1ksimExtSC</classname> derived from the existing
	<classname>Or1ksimSC</classname> class. It inherits all the
	functionality of the existing class, replaces that of the transport
	function, <function>doTrans()</function> and adds an additional public
	interface function, <function>isLittleEndian()</function>.
      </para>
      <sect3 id="sec_or1ksim_extlib">
	<title>
	  Adding an Edianism Test Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function is straightforward, since endianism is a
	  compile time constant in the &or1ksim; &iss;.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_is_le();</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_is_le()</function> returns 1 if &or1ksim; is
	      modeling a <firstterm>little&#32;endian</firstterm>
	      architecture, 0 otherwise. It is needed to ensure the payload is
	      packed with the correct byte ordering.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimExtSC</classname> is derived from
	  <classname>Or1ksimSC</classname>, so the definition file includes
	  its header. The module class can then inherit from that class.
	</para>

	<programlisting>#include "Or1ksimSC.h"

class Or1ksimExtSC
: public Or1ksimSC
{</programlisting>

	<para>
	  A custom constructor must be defined. Custom constructors do not
	  inherit, so a new custom constructor is defined just to pass the
	  arguments on to the parent.
	</para>

	<programlisting>  Or1ksimExtSC( sc_core::sc_module_name  name,
                const char              *configFile,
                const char              *imageFile );</programlisting>

	<para>
	  A new public function to report the endianism of the underlying CPU
	  model is defined
	</para>

	<programlisting>bool  isLittleEndian();</programlisting>

	<para>
	  The <function>doTrans()</function> is reimplemented here, to allow
	  the thread to yield. The function remains protected and virtual,
	  since it will be redefined again later in this application note.
	</para>

	<programlisting>virtual void  doTrans( tlm::tlm_generic_payload &amp;trans );</programlisting>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Implementation
	</title>

	<para>
	  The constructor just passes its arguments to its parent
	</para>

	<programlisting>Or1ksimExtSC::Or1ksimExtSC ( sc_core::sc_module_name  name,
                             const char              *configFile,
                             const char              *imageFile ) :
  Or1ksimSC( name, configFile, imageFile )
{
 }      // Or1ksimExtSC()</programlisting>

	<para>
	  <function>isLittleEndian()</function> is a simple wrapper for the
	  underlying &or1ksim; &iss; library function<footnote>
	    <para>
	      A technicality is that the &or1ksim; library function,
	      <function>is_little_endian()</function> returns an
	      <literal>int</literal>, since C does not have a
	      <literal>bool</literal> type. A C++ compiler would automatically
	      convert one to the other, but making the comparison explicit is
	      good for clarity. The same code will be generated, so there is
	      no loss of performance.
	    </para>
	  </footnote>.
	</para>

	<programlisting>bool
Or1ksimExtSC::isLittleEndian()
{
  return (1 == or1ksim_is_le());

}	// or1ksimIsLe()</programlisting>

	<para>
	  The majority of the code for <function>doTrans()</function> is
	  unchanged from its implmentation in
	  <classname>Or1ksimSC</classname>. The addition is a
	  <function>wait()</function> for zero time immediately after the
	  transaction has completed. This allows the &systemc; thread to
	  yield, so that any other threads that are ready can take a turn.
	</para>

	<programlisting>  wait( sc_core::sc_time( 0.0, sc_core::SC_SEC ));</programlisting>

	<caution>
	  <para>
	    The call to <function>wait()</function> is essential. &systemc; is
	    not preemptive. Other threads are only considered for execution
	    when the currently executing thread yields. If the code were to
	    return here, control would pass back to the underlying &or1ksim;
	    &iss; until its next upcall, with no opportunity for another
	    &systemc; thread to execute.
	  </para>

	  <para>
	    The implementation currently is untimed, so a zero delay wait is
	    perfectly acceptable. That just gives all the other untimed
	    threads a turn at execution.
	  </para>

	  <para>
	    The logger described in <xref linkend="sec_iss_wrapper_test" />
	    worked without this call to <function>wait()</function>, because
	    it had no thread&mdash;all its functionality was in the blocking
	    transaction callback function.
	  </para>
	</caution>

      </sect3>
    </sect2>

    <!-- ========== UART Definition ========== -->

    <sect2>
      <title>
	&uart;: Module Class Definition
      </title>

      <para>
	The &uart; module class, <classname>UartSC</classname> is defined in
	<filename>UartSC.h</filename>. It uses the &tlm2; simple target
	convenience socket (described earlier in <xref
	linkend="sec_iss_wrapper_test" />).
      </para>

      <sect3>
	<title>
	  Headers and Constant Definitions
	</title>

	<para>
	  The header files for &tlm2; and the simple target convenience
	  socket are included.
      </para>

      <programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      <para>
	Convenience constants for the address mask, named register offsets and
	bit fields are then defined. The address mask is needed, since in this
	simple SoC model there is no arbiter/decoder to strip out the higher
	order bits from the address before the transaction is sent to the
	&uart;.
      </para>

      <programlisting>#define UART_ADDR_MASK      7     // Mask for addresses (3 bit bus)

// Offsets for the 16450 UART registers

#define UART_BUF  0             // R/W: Rx/Tx buffer, DLAB=0
#define UART_IER  1             // R/W: Interrupt Enable Register, DLAB=0
#define UART_IIR  2             // R: Interrupt ID Register
#define UART_LCR  3             // R/W: Line Control Register
#define UART_MCR  4             // W: Modem Control Register
#define UART_LSR  5             // R: Line Status Register
#define UART_MSR  6             // R: Modem Status Register
#define UART_SCR  7             // R/W: Scratch Register

// Interrupt Enable register bits of interest

#define UART_IER_ETBEI  0x02    // Enable transmitter holding register int.
#define UART_IER_ERBFI  0x01    // Enable receiver data interrupt

// Interrupt Identification register bits and interrupt masks of interest

#define UART_IIR_RDI    0x04    // Receiver data interrupt
#define UART_IIR_THRE   0x02    // Transmitter holding reg empty interrupt
#define UART_IIR_IPEND  0x00    // Interrupt pending

// Line Control register bits of interest and data word length mask

#define UART_LCR_DLAB   0x80    // Divisor latch access bit
#define UART_LCR_PEN    0x08    // Parity Enable
#define UART_LCR_STB    0x04    // Stop bits: 0=1 stop bit, 1= 2 stop bits
#define UART_LCR_MASK   0x03    // 2-bit mask for word length

// Line Status register bits of interest

#define UART_LSR_TEMT   0x40    // Transmitter serial register empty
#define UART_LSR_THRE   0x20    // Transmitter holding register empty
#define UART_LSR_DR     0x01    // Receiver data ready</programlisting>

      </sect3>

      <sect3>
	<title>
	  Class Declaration and Constructor
	</title>

        <para>
	  The main class is a standard &systemc; module class derived from
	  <classname>sc_core::sc_module</classname>.
	</para>

	<programlisting>class UartSC
: public sc_core::sc_module
{</programlisting>

	<para>
	  The module has a customized constructor, specifying an input clock
	  rate (which in the SoC example will be the SoC clock rate), and a flag
	  to indicate the endianism of the model.
	</para>

	<programlisting>  UartSC( sc_core::sc_module_name  name,
          unsigned long int        _clockRate,
          bool                     _isLittleEndian );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The interfaces to the &uart; model are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      The simple target convenience port, <literal>bus</literal>,
	      representing the bus from the CPU;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The two &systemc; <literal>unsigned char</literal> FIFO ports
	      for Rx (input) and Tx (output) pins, <literal>rx</literal> and
	      <literal>tx</literal>); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A &systemc; boolean output signal port for the interrupt,
	      <literal>intr</literal>.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect3>

      <!-- = Private Functions = -->

      <sect3>
	<title>
	  Threads
	</title>

	<para>
	  The two threads are <function>busThread()</function> waiting for
	  bytes written to the transmit buffer and
	  <function>rxThread()</function> waiting for bytes on the Rx FIFO.
	</para>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The blocking transport callback function is
	  <function>busReadWrite()</function>. This in turn calls for two
	  separate routines which implement read specific
	  (<function>busRead()</function>) and write specific
	  (<function>busWrite()</function>) behavior.
	</para>

      </sect3>

      <!-- = Private Utilities = -->

      <sect3>
	<title>
	  Utility Methods
	</title>

	<para>
	  Two utility routines are provided to generate an interrupt signal
	  (<function>genInt()</function>) and clear an interrupt
	  (<function>clearInt()</function>). A utility routine is also
	  provided to calculate the character delay, based on the baud rate
	  and number of stop, data, parity and start bits
	  (<function>resetCharDelay()</function>).
	</para>

	<para>
	  A set of convenience utilities are provided to set and clear flags
	  in registers (<function>set()</function>) and
	  <function>clear()</function>) and to test the state of a flag bit in
	  a register (<function>isSet()</function>) and
	  <function>isClear()</function>).
	</para>

      </sect3>

      <!-- = Private Attributes  = -->

      <sect3>
	<title>
	  &uart; State
	</title>

	<para>
	  A struct, <literal>regs</literal> is used to hold the value of each
	  register. There are nine of these, since register 0 is really two
	  registers, depending on whether it is being read
	  (<literal>rbr</literal>) or written (<literal>thr</literal>).
	</para>

	<programlisting>  struct {
    unsigned char  rbr;         // R: Rx buffer,
    unsigned char  thr;         // R: Tx hold reg,
    unsigned char  ier;         // R/W: Interrupt Enable Register
    unsigned char  iir;         // R: Interrupt ID Register
    unsigned char  lcr;         // R/W: Line Control Register
    unsigned char  mcr;         // W: Modem Control Register
    unsigned char  lsr;         // R: Line Status Register
    unsigned char  msr;         // R: Modem Status Register
    unsigned char  scr;         // R/W: Scratch Register            
  } regs;</programlisting>

	<para>
	  The divisor latch is effectively another 16-bit register,
	  declared separately, <literal>divLatch</literal>. A flag initialized
	  at construction records the model endianism,
	  <literal>isLittleEndian</literal>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Transmit Data Available Event
	</title>

	<para>
	  A method is needed for the &tlm2; callback routine,
	  <function>busReadWrite()</function> to notify the thread handling
	  data being sent for transmission
	  (<function>busThread()</function>). This is achieved with a
	  &systemc; event:
	</para>

	<programlisting>  sc_core::sc_event  txReceived;</programlisting>

	<para>
	  The callback routine use notification on this event, to trigger
	  behavior in the <function>busThread()</function>.
	</para>

      </sect3>
    </sect2>

    <!-- ========== UART Implementation ========== -->

    <sect2 id="sec_uart_impl">
      <title>
	&uart; Module Class Implementation
      </title>

      <sect3>
	<title>
	  &uart; Constructor
	</title>
	
	<para>
	  Declaration of the constructor is preceded, like
	  <classname>Or1ksimSC</classname>, by the SystemC macro
	</para>

	<programlisting>SC_HAS_PROCESS( UartSC );</programlisting>

	<para>
	  The constructor save the endianism flags in its internal state, then
	  registers the two threads
	</para>

	<programlisting>  SC_THREAD( busThread );
  SC_THREAD( rxThread );</programlisting>

        <para>
	  The blocking transport callback is registered for the
	  <literal>bus</literal> socket, in the same manner as was used for
	  the logger, <classname>LoggerSC</classname>.
	</para>

	<para>
	  Finally the registers (<literal>regs</literal>) are cleared. There
	  is no initialization of the divisor latch, since this is undefined
	  until set.
	</para>
      </sect3>

      <sect3>
	<title>
	  &uart; Threads
	</title>
	
	<para>
	  <literal>busThread</literal> sits in a perpetual loop. It first
	  marks the transmit buffer as empty (on reset the flags are cleared,
	  so the buffer will appear full).
	</para>

	<note>
	  <para>
	    The 16450 &uart; describes two flags for transmit buffer status, one
	    to indicate that the transmit holding register is empty and a
	    second to indicate that the internal transmit buffer register is
	    empty.
	  </para>

	  <para>
	    For simplicity, this model does not model a separate internal
	    register (effectively a one byte FIFO), so both flags are set and
	    cleared together.
	  </para>
	</note>

	<para>
	  If the transmit buffer empty interrupt is enabled, the thread
	  generates an interrupt to indicate that the buffer is empty.
	</para>

	<para>
	  The thread then waits until it is notified via the SystemC event
	  <literal>txReceived</literal> that a byte is in the buffer to be
	  sent. This event will be triggered by the
	  <literal>busWrite()</literal> callback when a value is written into
	  the transmit holding register.
	</para>

	<para>
	  The second thread, <function>rxThread()</function> sits in a
	  perpetual loop, waiting for
	  characters to be received on the Rx FIFO. The character is read into
	  the read buffer register and the line status data ready flag is set
	  to indicate availability.
	</para>

	<para>
	  If the receive data interrupt is enabled, an interrupt is asserted
	  to indicate data availability.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Blocking Transport Callback
	</title>
	
	<para>
	  The registered callback routine is <literal>busReadWrite</literal>,
	  which breaks out the address, byte enable mask pointer and data
	  pointer. A <literal>switch</literal> statement on the mask is used
	  to determine the offset of the actual byte requested and hence the
	  exact byte address, allowing for the endianism of the model. This
	  also provides a check that only a single byte is being requested.
	</para>

	<programlisting>  switch( *((uint32_t *)maskPtr) ) {
  case 0x000000ff: offset = isLittleEndian ? 0 : 3; break;
  case 0x0000ff00: offset = isLittleEndian ? 1 : 2; break;
  case 0x00ff0000: offset = isLittleEndian ? 2 : 1; break;
  case 0xff000000: offset = isLittleEndian ? 3 : 0; break;

  default:              // Invalid request

    payload.set_response_status( tlm::TLM_GENERIC_ERROR_RESPONSE );
    return;
  }</programlisting>

	<para>
	  In a perfect world, the router/arbiter function would have masked
	  the address to the range handled by the &uart;. However for this
	  simple model, the full address is received, so masking with
	  <literal>UART_ADDR_MASK</literal> is carried out here, to give the
	  address of the &uart; register being read.
	</para>

	<para>
	  Separate routines, <function>busRead()</function> and
	  <function>busWrite()</function> are used to implement the register
	  specific behavior, selected as appropriate based on the payload
	  command field.
	</para>

	<para>
	  Single byte reads and writes always succeed, so the response is set
	  to <literal>tlm::TLM_OK_RESPONSE</literal> in all cases.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Read Behavior
	</title>
	
	<para>
	  Read behavior is handled by <function>busRead()</function>.  A
	  switch on the address is used to identify the result to be returned,
	  usually just the value in the register if it is readable. The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then reads to the first two registers (read buffer and
	      interrupt enable) yield instead the low and high bytes of the
	      divisor latch.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the read buffer (when <literal>DLAB=0</literal>) yields
	      the byte just read, if flag <literal>DR</literal> is set in the
	      line status register. The act of reading causes the
	      <literal>DR</literal> flag to be cleared
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the interrupt indicator register clears the highest
	      priority interrupt currently pending. If no interrupts remain
	      pending then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	</itemizedlist>
	
      </sect3>

      <sect3>
	<title>
	  &uart; Write Behavior
	</title>
	
	<para>
	  Write behavior is handled by <function>busWrite()</function>.  A
	  switch on the address is used to identify the action
	  required. Usually the register is just written (if writable). The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then writes to the first two registers (read buffer and
	      interrupt enable) update the low and high bytes of the
	      divisor latch respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Writing the transmit hold register (when
	      <literal>DLAB=0</literal>) triggers a new transfer. The flags
	      are set to indicate data is in the register, and the bus thread
	      (<function>busThread()</function>) notified via the &systemc;
	      event <literal>txReceived</literal>.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  &uart; Utility routines
	</title>
	
	<para>
	  <function>genInt()</function> generates an interrupt by setting the
	  relevant interrupt indicator flag and the interrupt pending flag and
	  then asserting the <literal>intr</literal> signal.
	</para>

	<para>
	  <function>clearInt()</function> is more complex, since there may be
	  more than one interrupt currently asserted (the model uses both the
	  transmit buffer empty and data received interrupt). Only one
	  interrupt is cleared by each read of the interrupt indicator
	  register, with the data received interrupt having higher
	  priority. This function clears the highest priority interrupt
	  currently asserted, and if no interrupts remain clears the pending
	  flag and deasserts the <literal>intr</literal> signal.
	</para>

	<para>
	  Finally a set of functions are provided to set, clear and test bits
	  in registers. Using these makes the code much more readable<footnote>
  	    <para>
	      Many programmers use <literal>#define</literal>d macros for
	      functions such as these. However such macros have no
	      encapsulation (they can be used by anyone including the header)
	      and have a nasty habit of clashing with other peoples macros. By
	      using functions, the routines can be made private to the
	      <classname>UartSC</classname> class alone.
	    </para>

	    <para>
	      The functions are declared in line, and a modern C++ compiler
	      will generate code as efficiently as if they had been
	      <literal>#define</literal>d as macros. Indeed the added type
	      information gives the potential for greater optimization.
	    </para>
	  </footnote>.
	</para>

      </sect3>
    </sect2>

  </sect1>

  <!-- ========================================================================
       a Testbench
       ==================================================================== -->

  <sect1 id="sec_terminal">
    <title>
      Adding a Terminal as Test Bench
    </title>

    <para>
      The &iss; described in <xref linkend="sec_iss_wrapper" /> and the &uart;
      described in described in <xref linkend="sec_uart" /> can be put
      together as a minimal SoC. However a test bench is needed to exercise
      that SoC
    </para>

    <para>
      The natural way of exercising a SoC with a &uart; is to connect a
      terminal to the &uart;. This section describes a suitable &systemc;
      model of a terminal and how to connect it to create the complete SoC.
    </para>

    <para>
      This is not a &tlm2; component&mdash;the interfaces are standard
      &systemc; FIFOs, so the description is less detailed. However it serves
      to illustrate an important general technique when using
      &systemc;&mdash;how to interact with the operating system routines.
    </para>

    <para>
      The problem is that many operating system calls block. Consider
      modelling the terminal as a thread which reads characters from a console
      window. This will block until characters are typed. However the block
      does not use the &systemc; <function>wait()</function> call, so
      &systemc; is not aware that the thread has yielded. The simulation
      will hang until characters are received.
    </para>

    <para>
      This implementation of the terminal will show how to wrap non-blocking
      versions of operating system routines with &systemc; events, to give
      versions that block correctly using &systemc;
      <function>wait()</function>, so allowing the thread to yield.
    </para>

    <sect2>
      <title>
	&systemc; Terminal Module Design
      </title>

      <para>
	The terminal provides &systemc; FIFO interfaces to model the Rx and Tx
	pins of a serial connection. The visualization is provided by a &linux;
	&xterm; running in a child process, with
	communication through a pseudo-TTY<footnote>
	  <para>
	    The description here is specific to &linux;. A future version of
	    this application note will describe use under Microsoft Windows.
	  </para>
        </footnote>.
      </para>

      <para>
	Two threads are used, one waiting for bytes from the UART on the Rx
	FIFO, the other waiting for bytes from the &xterm;. When bytes are
	received on the Rx pin, they are written to the
	&xterm;. When bytes are received from the &xterm; they are written to
	the Tx FIFO. The key interfaces are shown in <xref
	linkend="fig_terminal" />.
      </para>

      <figure id="fig_terminal">
	<title>
	  &systemc; terminal model using a &xterm; child process.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="terminal.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="terminal.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The difficulty is in waiting for the xterm. As described above,
	reading from the pseudo TTY is an operating system call, and does not
	use the &systemc; <function>wait()</function>, so the thread will not
	yield and the simulation will block. Instead the pseudo-TTY is set up
	to use asynchronous I/O, which will cause a &linux;
	<literal>SIGIO</literal> to be raised whenever data is available to
	read. The event handler for <literal>SIGIO</literal> will then notify
	a &systemc; event, and it is this &systemc; event on which the thread
	can safely wait.
      </para>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Definition
      </title>

      <sect3>
	<title>
	  Mapping Signals to Class Instances
	</title>

	<para>
	  The operating system signal handlers require C style linkage, so
	  cannot be used with C++ member functions (the same issue address
	  with the &or1ksim; wrapper in <xref linkend="sec_upcall" />). Thus
	  the <literal>SIGIO</literal> handler will be a static
	  function. However each instance (there could be multiple terminals
	  in a simulation) will have a different file descriptor, which can be
	  used to identify the owning class instance.
	</para>

	<para>
	  The set of mappings from file descriptor to class instance is held
	  in a linked list with static head pointer. The <literal>struct
	  Fd2Inst</literal> is provided for that list, with entries for the
	  file descriptor, instance and a pointer to the next in the list.
	</para>

      </sect3>
      
      <sect3>
	<title>
	  The SystemC Class
	</title>

	<para>
	  <classname>TermSC</classname> is declared as a standard &systemc;
	  class, with two FIFO ports (one in, one out) to talk to the
	  &uart;. In this case it has a custom destructor, which will be
	  used to kill the child process running the &xterm; when the class is
	  deleted.
	</para>

      </sect3>

      <sect3>
	<title>
	  Setting up the &xterm;
	</title>

	<para>
	  A set of utility functionss are provided to set up the &xterm;, with
	  two functions one to read from, and one to write to it,
	  <function>xtermRead()</function> and
	  <function>xtermWrite()</function>. Both these functions are blocking
	  on the operating system. The write routine should always be able to
	  write with minimal delay. However the read routine must only be
	  called when the SIGIO signal handler has determined input is
	  available, in order to avoid blocking the &systemc; simulation.
	</para>

	<para>
	  There is some internal state to hold the pseudo TTY file descriptors
	  and the process ID of the &xterm; (so it can be killed by the
	  destructor). It is the slave file descriptor that is used for both
	  input and output.
	</para>
      </sect3>

<sect3>
	<title>
	  Signal and event handling
	</title>

	<para>
	  The <literal>SIGIO</literal> signal handler
	  (<function>ioHandler()</function>) is declared static as noted
	  above. The static <literal>instList</literal> of type
	  <literal>Fd2Inst</literal> points to the list of mappings from file
	  descriptor to class instance.
	</para>

	<para>
	  The &systemc; event used to signal when input is available is pointed
	  to by <literal>ioEvent</literal>.
	</para>

	<caution>
	  <para>
	    It is essential that the event is declared as a pointer. If the
	    event itself were declared here, it would be available at
	    elaboration, and would crash the system (try it!).
	  </para>

	  <para>
	    The solution is to declare the pointer and allocate the event
	    instance dynamically when the &xterm; is created. The memory can be
	    freed from the destructor on termination.
	  </para>
	</caution>
      </sect3>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Implementation
      </title>

      <para>
	The implementation is a standard &systemc; module communicating via
	the two FIFOs, and with two threads, one listening to the Rx from
	the &uart; the other listening to the &xterm;.
      </para>

      <para>
	The setup of the pseudo TTYs and the &xterm; in a separate process
	uses standard operating system routines, not described further
	here. The key factor is that the file descriptor for the pseudo TTY to
	the &xterm; is set up to be asynchronous, with Linux signal
	<literal>SIGIO</literal> raised when input is available and handled by
	the <literal>ioHandler()</literal> function.
      </para>

      <sect3>
	<title>
	  Threads
	</title>

	<para>
	  The thread listening to the &uart;, <function>rxThread()</function>
	  sits in a perpetual loop, reading from the input FIFO. This blocks
	  until a character is received. The character is immediately copied
	  to the &xterm;. Although this is a blocking write, it should return
	  with minimal delay.
	</para>

	<para>
	  The thread listening to the &xterm;,
	  <function>xtermThread()</function> sits in a perpetual loop, waiting
	  on the &systemc; event pointed to by
	  <literal>ioEvent</literal>. This will safely allow the thread to
	  yield to the &systemc; scheduler until a character is ready.
	</para>

	<para>
	  When input is available, the event is notified (see <xref
	  linkend="sec_xterm_sig_hand" />). The thread can safely make a
	  blocking operating system read to get the character, knowing that
	  data is definitely available.
	</para>
      </sect3>
      
      <sect3 id="sec_xterm_sig_hand">
	<title>
	  Signal and event handling
	</title>

	<para>
	  During initialization of the &xterm; the &systemc; event,
	  <literal>ioEvent</literal> is allocated:
	</para>

	<programlisting>  ioEvent = new sc_core::sc_event();</programlisting>

	<para>
	  When <literal>ioHandler()</literal> is called in response to a Linux
	  SIGIO event, it does not know which pseudo TTY was responsible. The
	  file descriptor responsible is identified by using an operating
	  system <function>select()</function> call. Using the mappings in
	  <literal>instList</literal>, the corresponding class instance can be
	  identified and its <literal>ioEvent</literal> notified.
	</para>

	<programlisting>  for( Fd2Inst *cur = instList; cur != NULL ; cur = cur->next ) {
    if( FD_ISSET( cur->fd, &amp;readFdSet )) {
      (cur->inst)->ioEvent->notify();
    }
  }</programlisting>

        <para>
	  This event then allows the <literal>xtermThread()</literal> to run
	  and read a character.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>
	The Complete SoC
      </title>

      <sect3>
	<title>
	  The Model Main Program
	</title>

	<para>
	  The structure of the main program
	  (<filename>SimpleSoC.cpp</filename>) is similar to that for the
	  logger test program (see <xref linkend="sec_logger_main_prog"
	  />). The &tlm2; header and the headers for each module (&or1ksim;
	  &iss;, &uart; and terminal) are included.
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimExtSC.h"
#include "UartSC.h"
#include "TermSC.h"</programlisting>

	<para>
	  As before the main program (<function>sc_main()</function>) takes as
	  arguments the &or1ksim; configuration file and &or1k;
	  image. Instances of the three modules are declared.
	</para>

	<programlisting>  Or1ksimExtSC  iss( "or1ksim", argv[1], argv[2] );
  UartSC        uart( "uart", iss.isLittleEndian() );
  TermSC        term( "terminal" );</programlisting>

	<para>
	  The endianism for the &uart; is set using the public utility method
	  in <classname>Or1ksimExtSC</classname>. The &tlm; ports of &uart;
	  and &iss; can be connected:
	</para>

	<programlisting>  iss.dataBus( uart.bus );</programlisting>

	<para>
	  Two one byte FIFOs are needed to connect the &uart; and terminal.
	</para>

	<programlisting>  sc_core::sc_fifo&lt;unsigned char&gt;  u2t(1);
  sc_core::sc_fifo&lt;unsigned char&gt;  t2u(1);

  uart.rx( t2u );
  uart.tx( u2t );
  term.rx( u2t );
  term.tx( t2u );</programlisting>

	<para>
	  Finally the &uart; interrupt is connected to a &systemc;
	  <literal>bool</literal> signal. The signal goes nowhere, since for now
	  the interrupts are not required.
	</para>

	<programlisting>sc_core::sc_signal&lt;bool&gt;  intWire;

  uart.intr( intWire );</programlisting>

        <para>
	  The simulation can then be started with a call to
	  <function>sc_start()</function>.
	</para>
      </sect3>

      <sect3>
	<title>
	  Test Program to Run on the &or1ksim; &iss;
	</title>

	<para>
	  The test program, <filename>uartloop.c</filename> is a simple
	  polling loop back driver of the UART. Characters are read and
	  immediately echoed back.
	</para>

	<para>
	  A <literal>volatile</literal> structure is declared for the &uart;
	  registers, with <literal>#define</literal>d constants for the base
	  address and the register bits of interest
	</para>

	<programlisting>#define BASEADDR   0x90000000
#define BAUD_RATE        9600
#define CLOCK_RATE  100000000           // 100 Mhz

struct uart16450
{
  volatile unsigned char  buf;          // R/W: Rx &amp; Tx buffer when DLAB=0  
  volatile unsigned char  ier;          // R/W: Interrupt Enable Register   
  volatile unsigned char  iir;          // R: Interrupt ID Register         
  volatile unsigned char  lcr;          // R/W: Line Control Register       
  volatile unsigned char  mcr;          // W: Modem Control Register        
  volatile unsigned char  lsr;          // R: Line Status Register          
  volatile unsigned char  msr;          // R: Modem Status Register         
  volatile unsigned char  scr;          // R/W: Scratch Register            
};

#define UART_LSR_TEMT   0x40            // Transmitter serial register empty
#define UART_LSR_THRE   0x20            // Transmitter holding register empty
#define UART_LSR_DR     0x01            // Receiver data ready

#define UART_LCR_DLAB   0x80            // Divisor latch access bit</programlisting>

	<para>
	  The utility routines to set and clear flags in the &uart; (see <xref
	  linkend="sec_uart_impl" />) are reused here, modified for C rather
	  than C++ and <literal>volatile</literal> register arguments.
	</para>

	<para>
	  The main program declares a pointer to the UART register structure,
	  <literal>uart</literal>, at the base address. Initialization
	  requires setting the divisor latch, to divide the main clock down to
	  16 x the baud rate.
	</para>

	<programlisting>  volatile struct uart16450 *uart = (struct uart16450 *)BASEADDR;
  unsigned short int         divisor;

  divisor = CLOCK_RATE/16/BAUD_RATE;            // DL is for 16x baud rate

  set( &amp;(uart->lcr), UART_LCR_DLAB );           // Set the divisor latch
  uart->buf  = (unsigned char)( divisor       &amp; 0x00ff);
  uart->ier  = (unsigned char)((divisor >> 8) &amp; 0x00ff);
  clr( &amp;(uart->lcr), UART_LCR_DLAB );</programlisting>

	<para>
	  The remainder of the program is a perpetual loop:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      Wait for a character in the read buffer (flag
	      <literal>DR</literal> of the line status register is set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Read the character from the buffer.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Wait for the transmit buffer to clear (flags
	      <literal>TEMT</literal> and <literal>THRE</literal> of the line
	      status register are set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Write the character back.
	    </para>
	  </listitem>
	</itemizedlist>

	<programlisting>  while( 1 ) {
    unsigned char  ch;

    do {                        // Loop until a char is available
      ;
    } while( is_clr(uart->lsr, UART_LSR_DR) );

    ch = uart->buf;

    simputs( "Read: '" );       // Log what was read
    simputc( ch );
    simputs( "'\n" );

    do {                        // Loop until the transmit register is free
      ;
    } while( is_clr( uart->lsr, UART_LSR_TEMT | UART_LSR_THRE ) );
      
    uart->buf = ch;
  }</programlisting>

      </sect3>

      <sect3>
	<title>
	  Compiling and Running the Model
	</title>

	<para>
	  Compilation uses exactly the same command lines as the
	  standalone test of the &or1ksim; wrapper with the logger (see <xref
	  linkend="sec_iss_run_test" />), but this time links in the &uart;
	  and terminal; rather than the logger.
	</para>

	<para>
	  The &or1ksim; configuration is also unchanged. Like the logger, the
	  &uart; registers start at address 0x90000000 and are 8 bytes long.
	</para>

	<para>
	  Running the model requires specifying the configuration file
	  (unchanged) and the binary executable (this time the &uart; loop
	  back program).
	</para>

	<programlisting>./SimpleSocSC ../simple.cfg ../progs_or32/uart_loop</programlisting>

	<para>
	  The &xterm; terminal should appear. Select it and type some
	  characters. The window running the model, will show the logged
	  output from the terminal, reporting the same characters being
	  written, as shown in <xref linkend="fig_uart_loopback_log" />.
	</para>

	<figure id="fig_uart_loopback_log">
	  <title>
	    &uart; loop back program log output.
	  </title>

          <screen>$ ./SimpleSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Read: 'F'
Read: 'a'
Read: 'r'
Read: 'e'
Read: 'w'
Read: 'e'
Read: 'l'
Read: 'l'
Read: ' '
Read: 'G'
Read: 'a'
Read: 'l'
Read: 'a'
Read: 'x'
Read: 'y'
Read: '!'
Read: '!'
Read: '!'</screen>
	</figure>

	<para>
	  At the same time the characters will be echoed on the xterm, as
	  shown in figure <xref linkend="fig_uart_loopback_screen" />.
	</para>

	<figure id="fig_uart_loopback_screen">
	  <title>
	    &xterm; with the &uart; loop back program running.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart_xterm.png"
			 format="PNG"
			 width="13.754cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Well it makes a change from "Hello World!".
	</para>

	<para>
	  As an exercise, rebuild the model, removing the call to
	  <function>wait()</function> in the
	  <function>Or1ksimExtSC::doTrans()</function> function. Observe that
	  the program hangs without accepting any characters. The reason for
	  this is given in the description of <function>doTrans()</function>
	  in <xref linkend="sec_uart_or1ksim_libext" />.
	</para>

	<para>
	  A debugger connected to the model will show that execution is stuck
	  in &or1ksim; &iss;, waiting for the data ready flag to be set in the
	  &uart;. This can never occur, since neither &uart; nor terminal are
	  given the chance to execute the threads that would set this flag.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <!-- ========================================================================
       Adding Synchronous Timing
       ==================================================================== -->

  <sect1 id="sec_sync">
    <title>
      Adding Synchronous Timing to the Model
    </title>

    <para>
      The model is extended to add timing to all the components
    </para>

    <!-- Further extensions to the Or1ksim library -->

    <sect2>
      <title>
	Further Extending the &or1k; &or1ksim; Library
      </title>

      <para>
	Additional functions are needed in the &or1ksim; library to support
	peripheral modeling. The &uart; will need to know the endianism of the
	model (to decode the address of byte access) and the clock rate of the
	model (to work out the baud rate from the value of the divisor latch).
      </para>

      <para>
	Two functions are added to the &or1ksim; library to extract this
	information.
      </para>

      <!-- = Library Functions -->

      <sect3 id="sec_or1ksim_libsync">
	<title>
	  Additional Functions for the &or1ksim; Library
	</title>

	<para>
	  The two additional functions are simple additions. The information
	  about endianism is a compile time constant in the &or1ksim; &iss;,
	  while the clock rate is a configuration parameter.
	</para>

	<para>
	  The &uart; will need to know the endianism of the model (to decode
	  the address of byte access) and the clock rate of the model (to work
	  out the baud rate from the value of the divisor latch).
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_is_le();</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_is_le()</function> returns 1 if &or1ksim; is
	      modeling a <firstterm>little&#32;endian</firstterm>
	      architecture, 0 otherwise. It is needed to ensure the payload is
	      packed with the correct byte ordering.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>unsigned long int  or1ksim_clock_rate();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_clock_rate()</function> returns the &or1ksim;
	      &iss; clock rate in Hz. This information will be used by the
	      &uart; to allow it to set its baud rate.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>double  or1ksim_time();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_time()</function> returns the &or1ksim; view
	      of how much time has elapsed while simulating. This routine is
	      needed to keep the SystemC model of time due to instruction set
	      processing accurate, both in the synchronous SoC and when
	      temporal decoupling is added (see <xref
	      linkend="sec_temporal_decoupling" />).
	    </para>
	  </listitem>
	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  Extending the Or1ksim class definition
	</title>
      <para>
	Two time stamps are declared, one to hold the SystemC view of the
	time of the last upcall from &or1ksim;, the other to hold the
	&or1ksim; view of the time of the last upcall.
      </para>

      <programlisting>  sc_core::sc_time  scLastTime;
      sc_core::sc_time  or1kLastTime;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Extending the Or1ksim class implementation
	</title>

	<para>
	  Once the fields are set up, the <function>doTrans()</function>
	  method (which is used for both read and write) is called to
	  synchronize with the SystemC clock, transport the payload to the
	  target and return the result.
	</para>

      <para>
	There are two components to the time taken in this model, the time
	taken by the &or1ksim; &iss; and the time taken in any peripherals. At
	the time of an upcall, the SystemC wrapper thread will not have
	yielded control since the last upcall. It needs to wait for the
	&systemc; clock to catch up to this time point.
      </para>

      <para>
	The &systemc; time at which the last upcall was made was recorded in
	<literal>scLastUpTime</literal>. The time stamp of the &or1ksim; &iss; at
	the last upcall (i.e. the number of cycles it has executed,
	multiplied by the time taken for each cycle) was recorded in the
	<literal>or1kLastUpTime</literal>.
      </para>

      <para>
	A call of <function>or1ksim_time()</function> gives the current time
	of the &iss;, and hence the time that has elapsed since the last up
	call. This is used to advance both<literal>scLastUpTime</literal> and
	<literal>or1kLastUpTime</literal>. The thread then calls
	<function>wait()</function> to allow any other threads in the
	&systemc; world to run until the calculated simulation time is
	reached.
      </para>

      <para>
	At this time the blocking transport method of the simple initiator
	port is called with the payload and specifying a zero time offset
	(since the call to <function>wait()</function> means the thread is
	synchronized with the &systemc; clock).
      </para>

      <para>
	On return, the <literal>delay</literal> parameter will have been
	updated with any additional delay due to the transaction&mdash;in
	this case an estimate of the number of cycles to read or write the
	relevant &uart; register.
      </para>

      <para>
	It would be possible to make another call to
	<function>wait()</function> immediately to synchronize locally for
	this delay. However there will be no more processing on this thread
	until the next upcall from the &or1ksim; &iss;, so the delay is added
	to the <literal>scLastUpTime</literal> and will be added to the
	<function>wait()</function> on the next upcall.
      </para>
      </sect3>

      <sect3>
	<title>
	  Modeling teh FIFO timing
	</title>

	<para>
	  The time taken for the serial pules (start, data, parity, stop bits)
	  on the real &uart; will be modeled as a delay before writing data
	  into the FIFO.
	</para>

	<para>
	  Divisor Latch is needed for timing
	</para>

	<para>
	  The divisor latch is effectively another 16-bit register,
	  declared separately:
	  (<literal>divLatch</literal>), the delay modeling the time taken to
	  put bits on the Tx pin (<literal>charDelay</literal>) and the flag
	  indicating model endianism (<literal>isLittleEndian</literal>).
	</para>

	<note>
	  <para>
	    The divisor latch for a 16450 is applied to the input clock to
	    yield an internal clock <emphasis>16x</emphasis> the baud rate
	    (i.e. not the actual baud rate itself)<footnote>
	      <para>
	        The 16450 input clock is specified to a maximum of 24 MHz, so
	        that a 16 bit divisor latch can yield an internal clock for
	        rates down to 50 baud. However for a software model this
	        limitation is ignored. Faster input clocks can be specified,
	        but it will not be possible to configure a divisor latch for
	        very low baud rates
	      </para>
	    </footnote>.
	  </para>
	</note>

	<para>
	  In the Line Control Register, the <literal>Set Break</literal> bit is
	  ignored (in principle it could be modeled as a change in timing of a
	  transfer). The parity control bits are ignored, apart from
	  <literal>Parity Enable</literal>s influence on the timing of a
	  transfer. Similarly the <literal>Stop Bit</literal> and <literal>Word
	  Length Enable</literal>bits are only relevant to timing of a transfer.
	</para>

	<para>
	  UART busThread: The character is not sent immediately. The thread
	  waits for a period, <literal>charDelay</literal> to model the time
	  taken to push the bits (start, data, parity and stop) onto the Tx
	  wire. Only then is the value written onto the Tx FIFO.
	</para>


	<note>
	  <para>
	    UART rxThread: There is no modeling of line delay here. That is the
	    responsibility of the entity (a terminal writing to the Rx pin.
	  </para>
	</note>

	<para>
	  UART BusReadWriteIn each case the delay time is then advanced
	  (neither read nor write has yielded the thread by calling
	  <function>wait()</function> explicitly or implicitly). This is a
	  measure of how far in advance of central &systemc; time the module
	  has progressed.
	</para>

	<para>
	  UART writing registers
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then writes to the first two registers (read buffer and
	      interrupt enable) update the low and high bytes of the
	      divisor latch respectively. This update may cause a change in
	      the character delay on transmit, so this is updated via
	      <function>resetCharDelay()</function>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Writing the transmit hold register (when
	      <literal>DLAB=0</literal>) triggers a new transfer. The flags
	      are set to indicate data is in the register, and the bus thread
	      (<function>busThread()</function>) notified via the &systemc;
	      event <literal>txReceived</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Updating the line control register may affect the character
	      delay on transmit (due to change in number of data, parity or
	      stop bits), so this is updated via
	      <function>resetCharDelay()</function>.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  UART: Char delay fn The time to send a character depends on the baud
	  rate and the number of bits required to send each character. The
	  baud rate in turn depends on the input clock rate and divisor latch,
	  remembering that this generates a clock 16x baud rate. The total
	  number of bits comprises the start bit, data bits (5-8), optional
	  parity bit and stop bits (1, 1.5 or 2). The function
	  <function>charDelay()</function> calculates this character delay
	  whenever one of these parameters is changed.
	</para>

      </sect3>

      <sect3>
	<title>
	  Updating the terminal model
	</title>

      <para>
	Two threads are used, one waiting for bytes from the UART on the Rx
	FIFO, the other waiting for bytes from the &xterm;. When bytes are
	received on the Rx pin, they are immediately written to the
	&xterm;. When bytes are received from the &xterm;,
	<function>wait()</function> is used to model the delay in placing the
	bits on the serial line. This exactly mirrors the implementation in
	the &uart; (see <xref linkend="sec_uart_impl" />).
      </para>

	<para>
	  The thread listening to the &uart;, <function>rxThread()</function>
	  sits in a perpetual loop, reading from the input FIFO. This blocks
	  until a character is received. Any baud-rate delay modeling has been
	  done by the UART, so this character is immediately copied to the
	  &xterm;. This is a blocking write, but should return immediately.
	</para>

	<para>
	  The thread listening to the &xterm;,
	  <function>xtermThread()</function> sits in a perpetual loop, waiting
	  on the &systemc; event pointed to by
	  <literal>ioEvent</literal>. This will safely allow the thread to
	  yield to the &systemc; scheduler until a character is ready.
	</para>

	<para>
	  When input is available, the event is notified (see <xref
	  linkend="sec_xterm_sig_hand" />>). The thread can safely make a
	  blocking operating system read to get the character, knowing that
	  data is definitely available. The baud rate delay is modelled with a
	  further <function>wait()</function> call and the character then
	  written to the Tx FIFO.
	</para>

      </sect3>

      <sect3>
	<title>
	  Updating the main prog
	</title>

	<para>
	  The baud rate for the terminal is defined as a constant for
	  convenience.
	</para>

	<programlisting>#define BAUD_RATE  9600UL               // Baud rate of the terminal</programlisting>

	<para>
	  As before the main program (<function>sc_main()</function>) takes as
	  arguments the &or1ksim; configuration file and &or1k;
	  image. Instances of the three modules are declared.
	</para>

	<programlisting>  Or1ksimSC  iss( "or1ksim", argv[1], argv[2] );
  UartSC     uart( "uart", iss.getClockRate(), iss.isLittleEndian() );
  TermSC     term( "terminal", BAUD_RATE );</programlisting>

	<para>
	  The clock rate and endianism for the &uart; are set using the public
	  utility methods for the &or1ksim; &iss;. The &tlm; ports of &uart;
	  and &iss; can be connected:
	</para>

      </sect3>


    </sect2>

    <!-- ========== Running the System ========== -->

    <sect2>
      <title>
	Connecting the Complete System
      </title>

      <para>
      </para>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Adding Temporal Decoupling
       ==================================================================== -->

  <sect1 id="sec_temporal_decoupling">
    <title>
      Adding Temporal Decoupling of the Model
    </title>

    <para>
      In this case study temporal decoupling is added to the &tlm2; model of
      an SoC. The SoC model with arbiter from the previous example is reused.
    </para>

    <!-- ========== The Quantum Keeper ========== -->

    <sect2>
      <title>
	The Quantum Keeper
      </title>

      <!-- = Basic Interface = -->

      <para>
      </para>

    </sect2>

    <!-- ========== Temporal Decoupling ========== -->

    <sect2>
      <title>
	Temporal Decoupling Each Component
      </title>

      <!-- = Basic Interface = -->

      <para>
      </para>

    </sect2>

    <!-- ========== Connecting the System ========== -->

    <sect2>
      <title>
	Connecting the Complete System
      </title>

      <para>
      </para>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Adding an Arbiter
       ==================================================================== -->

  <sect1 id="sec_arbiter">
    <title>
      Adding an Arbiter
    </title>

    <para>
      In this case study, the &tlm2; model from the first case study an
      arbiter is added to illustrate the use of the
      <firstterm>passthrough</firstterm> convenience socket and
      <firstterm>tagged&#32;socket</firstterm>s.
    </para>

    <!-- ========== Design of the Arbiter ========== -->

    <sect2>
      <title>
	The Arbiter &tlm2; Model
      </title>

      <!-- = Interface = -->

      <sect3>
	<title>
	  Adding a &tlm2; Passthrough Socket
	</title>

	<para>
	</para>

      </sect3>

      <!-- = Interface = -->

      <sect3>
	<title>
	  Using Tagging with Initiator Sockets
	</title>

	<para>
	</para>

      </sect3>

    </sect2>

    <!-- ========== Connecting to Peripherals ========== -->

    <sect2>
      <title>
	Connecting the SoC
      </title>

	<para>
	</para>

    </sect2>
  </sect1>

  <!-- ========================================================================
       Using standard TLM2
       ==================================================================== -->

  <sect1 id="sec_standard_tlm">
    <title>
      Using Standard &tlm2; Sockets and Interfaces
    </title>

    <para>
    </para>
  </sect1>

  <!-- ========================================================================
       Running Linux
       ==================================================================== -->

  <sect1 id="sec_linux">
    <title>
      Running Linux on the Example SoC
    </title>

    <para>
      
    </para>

  </sect1>

  <!-- ========================================================================
       Glossary
       ==================================================================== -->

  <glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>approximately&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing the phases of data
	  transfer in a specific bus protocol (for example the address and
	  data phases of an <acronym>AHB</acronym> read or write).
	</para>

	<glossseealso>loosely&#32;timed</glossseealso>
	<glossseealso>phase</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>backward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method which
	  returns the response transaction from target to initiator.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>forward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which blocks the flow of
	  control in the initiator until the target has completed the
	  transaction request and responded.
	</para>

	<glossseealso>non-blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>convenience&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; wrapper, providing for simple TLM communication based on
	  C++ callbacks.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>forward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method, which
	  passes the opening transaction from initiator to target.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Generic Payload</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a class suitable for use as payload for
	  transactions. Recommended to maximize the interoperability of TLMs.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Hardware&#32;Description&#32;Language</glossterm>
      <glossdef>
	<para>
	  A language (<glossterm>Verilog</glossterm> and
	  <glossterm>VHDL</glossterm> are the best known), which describes
	  hardware. Can be used to describe both an actual chip and its
	  test bench.
	</para>

	<glossseealso>Verilog</glossseealso>
	<glossseealso>VHDL</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>initiator</glossterm>
      <glossdef>
	<para>
	  The initiator of a transactional exchange to a target. In &tlm2; an
	  initiator module must implement an initiator socket of the
	  appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>target</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Instruction&#32;Set&#32;Simulator</glossterm>
      <glossdef>
	<para>
	  A software model of a CPU core instruction set. Typically completely
	  models the instruction semantics, but not the full microarchitecture
	  of a particular CPU implementation. Timing information may be just
	  an instruction count, or may (as with the &or1ksim;) offer some
	  estimate of timing delays due to memory accesses, caching and
	  virtual memory access.
	</para>
      </glossdef>

    </glossentry>

    <glossentry>
      <glossterm>&iss;</glossterm>
      <glosssee>Instruction&#32;Set&#32;Simulator</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&osci;</acronym></glossterm>
      <glosssee>Open &systemc; Initiative</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>loosely&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing a complete data transfer
	  across a hardware bus.
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open&#32;SystemC&#32;Initiative</glossterm>
      <glossdef>
	<para>
	  The industry body standardizing the SystemC language and
	  applications of those language for particular purposes, such as
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>,
	  verification and synthesis. More information is available on their
	  <ulink url="http://www.systemc.org">website</ulink>.
	</para>

	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>non-blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which allows the flow of
	  control in the initiator to continue immediately the transaction is
	  sent. The response will be provided later by a transport call from
	  the target back to the initiator..
	</para>

	<glossseealso>blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>passthrough</glossterm>
      <glossdef>
	<para>
	  A term describing a &tlm2; convenience socket which reuses the
	  payload, thereby eliminating the computational cost of allocation
	  and deallocation. Typically used in modules which perform a routing
	  or arbitration function.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload</glossterm>
      <glossdef>
	<para>
	  The data passed between threads by a transaction.
	</para>

	<glossseealso>Generic Payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>phase</glossterm>
      <glossdef>
	<para>
	  In &tlm2; approximately timed modeling, a transaction exchange
	  representing a single phase of the specific bus protocol being
	  modelled (for example the address phase of an <acronym>AHB</acronym>
	  read or write).
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>POSIX</glossterm>
      <glossdef>
	<para>
	  An IEEE standard for application programming interfaces and
	  utilities for Unix/Linux operating systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, the maximum time a thread may
	  run ahead of the main system clock. This may be regulated by a
	  quantum keeper.
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum keeper</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, an object which enforces the
	  rule that threads may not run more than the quantum ahead of the
	  main system clock
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>socket</glossterm>
      <glossdef>
	<para>
	  Within the context of &tlm2;, a &systemc; port and export combined
	  with the associated interfaces for blocking and non-blocking
	  transport, direct memory access and debug.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>&systemc;</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>tagged&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; convenience socket, which incorporates a numerical
	  <emphasis>tag</emphasis> to identify the socket in use. This allows
	  a single callback routine to handle multiple sockets, with the tag
	  identifying the socket which caused the callback to be invoked.
	</para>

	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>target</glossterm>
      <glossdef>
	<para>
	  The responder to a transactional exchange initiated by an
	  initiator. In &tlm2; a target module must implement a target socket
	  of the appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>initiator</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>temporal&#32;decoupling</glossterm>
      <glossdef>
	<para>
	  In &tlm2; the concept of allowing individual threads to run ahead of
	  the main simulation time stamp. The maximum permitted time of run
	  ahead is known as the <glossterm>quantum</glossterm> and may be
	  regulated by a quantum keeper.
	</para>

	<glossseealso>quantum</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>thread</glossterm>
      <glossdef>
	<para>
	  In software, a logical parallel flow of control. In the context of
	  &systemc;, the main method of such a thread can be specified with
	  the <literal>SC_THREAD</literal> macro. In &systemc; a
	  <literal>SC_THREAD</literal> is distinguished from a
	  <literal>SC_METHOD</literal> because it can suspend execution with
	  <function>wait()</function> calls.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym></glossterm>
      <glossdef>
	<para>
	  An abbreviation for (depending on context)
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm> or
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>Transaction&#32;Level&#32;Modeling</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym>&nbsp;2.0</glossterm>
      <glossdef>
	<para>
	  The &osci; standard interface for writing
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>s in
	  &systemc;.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transport&#32;method</glossterm>
      <glossdef>
	<para>
	  The C++ procedure which transfers data from an initiator to a
	  target, and (for a non-blocking interface), the response back from
	  the target to the initiator. Within the context of &tlm2; blocking
	  and non-blocking transport interfaces are defined.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction</glossterm>
      <glossdef>
	<para>
	  An exchange of data (the payload) between two parallel processes. In
	  &tlm2; this transaction occurs through &systemc; ports implementing
	  the &tlm2; interfaces, which are known as sockets.
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Model</glossterm>
      <glossdef>
	<para>
	  A software model in which the components of the model communicate by
	  transferring information to and from each other (transactions).
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>
      <glossdef>
	<para>
	  The process of writing software models using
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Verilog</glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso><acronym>VHDL</acronym></glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>VHDL</acronym></glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso>Verilog</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <!-- ========================================================================
       References
       ==================================================================== -->

  <bibliography>
    <title>
      References
    </title>

    <biblioentry id="ref_app_note_1">
      <title id="ref_app_note_1_xr">
	&embecosm; Application Note 1. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide
      </title>

      <publisher>
	<publishername>
	  Embecosm
	</publishername>
	<address>
	  <city>
	    Bournemouth
	  </city>
	  <country>
	    UK
	  </country>
	</address>
      </publisher>

      <pubdate>
	June, 2008
      </pubdate>
    </biblioentry>

  </bibliography>
</article>
 