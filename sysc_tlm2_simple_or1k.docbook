<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY hdl "<acronym>HDL</acronym>">
<!ENTITY iss "<acronym>ISS</acronym>">
<!ENTITY osci "<acronym>OSCI</acronym>">
<!ENTITY posix "<acronym>POSIX</acronym>">
<!ENTITY soc "<acronym>SoC</acronym>">
<!ENTITY tlm "<acronym>TLM</acronym>">
<!ENTITY tlm2 "<acronym>TLM</acronym>&nbsp;2.0">
<!ENTITY uart "<acronym>UART</acronym>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">

<!-- = Commands = -->

<!ENTITY xterm "<command>xterm</command>" >

<!-- = Libraries = -->

<!ENTITY readline "<systemitem class='library'>readline</systemitem>" >
<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Web pages = -->

<!ENTITY embecosm "<ulink
  url='http://www.embecosm.com'>Embecosm</ulink>">
<!ENTITY opencores "<ulink
  url='http://www.opencores.org'>OpenCores</ulink>">
<!ENTITY lgpl "<ulink url='http://www.gnu.org/licenses/lgpl.html'>
  GNU Lesser General Public License</ulink>">

]>

<!-- ==========================================================================

Copyright (c) 2008 Embecosm Limited.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing the first stage in the conversion of an ISS to use
OSCI TLM 2.0, convenience sockets.

$Id$

=========================================================================== -->

<article class="whitepaper" lang="en_GB">
  <title>
    Building a Loosely Timed &soc; Model with &osci; TLM 2.0
  </title>
  <subtitle>
    A Case Study Using the &or1k; &or1ksim; &iss;
  </subtitle>

  <articleinfo>

    <corpauthor>
      &embecosm;
    </corpauthor>

    <pubdate>
      14 June 2008
    </pubdate>

    <releaseinfo>
      Application Note 2. Issue 1, draft A
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	Embecosm Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software examples written by &embecosm; and used in this document
	are licensed under the &lgpl;. For detailed licensing information see
	the files <filename>COPYING</filename> and
	<filename>COPYING.LESSER</filename> in the source code of the
	examples.
      </para>

      <para>
	Embecosm is the business name of Embecosm Limited, a private limited
	company registered in England and Wales. Registration number 6577021.
      </para>

    </legalnotice>
  </articleinfo>

<sect1>
    <title>
      Introduction
    </title>

    <para>
      The Open <firstterm>&systemc;</firstterm> Initiative
      (<firstterm>&osci;</firstterm>) has recently issued the second version
      of its standard for
      <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;) [<xref
      linkend="ref_osci_tlm" />]. This defines an interface for writing high
      level software models of hardware.
    </para>

    <para>
      The &osci; standard is comprehensive. As well as a powerful general
      purpose interface, it defines a number of
      <emphasis>convenience</emphasis> components to facilitate adoption of
      the technology.
    </para>

    <para>
      This application note provides an introductory tutorial on using &tlm2;
      for loosely timed models&mdash;ideally suited for early development of
      embedded software. It demonstrates through a practical case study the
      development of a complete &soc; using the &tlm2;
      <emphasis>convenience</emphasis> components.
    </para>

    <para>
      One of the most important components in any &soc; system model is the
      processor core <firstterm>Instruction Set Simulator</firstterm>
      (&iss;). This application note demonstrates how to wrap an existing
      &iss; to provide a &tlm2; compliant interface.
    </para>

    <para>
      This application note is the first in a series from &embecosm;,
      providing case studies in &osci; &tlm2; use. The objective is to provide
      an introduction to &tlm2; within a practical context. Examples are
      provided throughout, based on open source components, which are freely
      reusable under the &lgpl;.
    </para>

    <sect2>
      <title>
	Target Audience
      </title>

      <para>
	&systemc; represents a challenge to engineers, because it bridges the
	divide between the worlds of hardware and software. These are two
	distinct disciplines, the languages of hardware design such as Verilog
	and VHDL are very different in philosophy to the languages of software
	development such as C++ and Java. Yet both are brought together in the
	world of the <firstterm>System on Chip</firstterm>
	&soc;, where large embedded software systems must run
	on complex silicon chips often containing multiple processor cores of
	different architectures.
      </para>

      <para>
	This application note is aimed at any engineer intending to bridge the
	gap between hardware and software. It recognizes that the reader will
	most likely be expert in only one of these. Explanation is provided
	throughout of both the hardware ideas and software ideas being
	covered.
      </para>

      <para>
	The reader is assumed to have basic programming familiarity with C and
	C++ and the key concepts of object oriented programming: classes and
	instances of classes. A basic understanding of system level hardware
	design and the construction of &soc; from components
	linked by buses (or on-chip networks).
      </para>

      <para>
	Familiarity with &systemc; is assumed. The user guide supplied with
	&systemc; provides a good introduction [<xref
	linkend="ref_osci_systemc_ug" />].
      </para>

    </sect2>

    <sect2>
      <title>
	About the &embecosm; TLM 2.0 Application Notes
      </title>

      <para>
	The &osci; &tlm2; standard represents a significant advance in
	standardizing the creation of fast models of
	hardware.
      </para>

      <para>
	However the &osci; reference implementation lacks training material
	and examples to introduce new users to the technology.
      </para>

      <para>
	This series of &embecosm; Application Notes was prompted by a customer
	requesting assistance in porting an existing &iss; to the &tlm2;
	standard. This is the first application note in the series. Further
	&embecosm; Application Notes, addressing different aspects of &tlm2;
	will be published in the future.
      </para>

    </sect2>

  </sect1>

  <sect1>
    <title>
      Background to &systemc; and the &tlm2; Standard
    </title>

    <para>
      The development of &systemc; as a standard for modeling hardware started
      in 1996. Version 2.0 of the proposed standard was released by the Open
      SystemC Initiative (&osci;) in 2002. In 2006, &systemc; became IEEE
      standard 1666-2005 [<xref linkend="ref_ieee_1666" />].
    </para>

    <para>
      &osci; has several groups working on supplementary standards. One of
      these is the &tlm; Working Group. It proposed its first standard for
      transaction level modeling in 2005. Two drafts for version 2.0 were
      released in 2006 and 2007, with the version 2.0 standard issued in June
      2008 [<xref linkend="ref_osci_tlm" />].
    </para>

    <sect2>
      <title>
	What is &systemc;
      </title>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling, particularly the
	parallelism of hardware, in a mainstream programming
	language.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc;. Rather than invent a new language,
	&systemc; is based on the existing C++ language. &systemc; is a true
	super-set of C++, so any C++ program is automatically a valid &systemc;
	program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    A C++ class, <classname>sc_module</classname>, suitable for
	    defining hardware modules containing parallel
	    processes<footnote>
	    <para>
	      <emphasis>Process</emphasis> is a general term in &systemc;
	      to describe the various ways of representing parallel flows
	      of control. It has nothing to do with processes in the Linux
	      or Microsoft Windows operating systems.
	    </para>
	    </footnote>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A mechanism to define functions modeling the parallel
	    threads of control within <classname>sc_module</classname>
	    classes;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Two classes, <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent points of
	    connection a <classname>sc_module</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_interface</classname> to describe the
	    software services required by a <classname>sc_port</classname>
	    or provided by a <classname>sc_export</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_prim_channel</classname> to represent the
	    channel connecting ports;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A set of derived classes, of
	    <classname>sc_prim_channel</classname>,
	    <classname>sc_interface</classname>,
	    <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent and connect common
	    channel types used in hardware design such as signals, buffers and
	    FIFOs; and
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A comprehensive set of types to represent data in both
	    <firstterm>2-state</firstterm> and <firstterm>4-state</firstterm>
	    logic.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The full specification is 441 pages long [<xref
	linkend="ref_ieee_1666" />]. The &osci; reference distribution
	includes a very useful introductory user guide and tutorial [<xref
	linkend="ref_osci_systemc_ug" />].
      </para>
	
    </sect2>

    <sect2 id="sec_what_is_tlm">
      <title>
	What is a &tlm;
      </title>

      <sect3>
	<title>
	  Hardware and Software Views of Parallelism
	</title>

	<para>
	  To understand transaction level modeling, it is essential to
	  understand the difference in approach to parallelism taken in
	  hardware and software design.
	</para>

	<para>
	  A hardware engineer, typically writing in a
	  <firstterm>Hardware&#32;Description&#32;Language</firstterm> (&hdl;)
	  such as Verilog or VHDL, describes a design as a collection of
	  parallel activities, which communicate via shared data. The parallel
	  activities are <literal>always</literal> (Verilog) or
	  <literal>process</literal> (VHDL) blocks. The shared data structures
	  are wires or signals.
	</para>

	<para>
	  This follows very naturally the way that physical hardware
	  behaves. There is no one <emphasis>flow of
	  control</emphasis>&mdash;all parallel components are active at the
	  same time, with their individual flow of control.
	</para>

	<para>
	  By contrast, a software engineer typically describes parallelism in
	  a design as a number of threads, which pass flow of control between
	  them. The threads communicate by a number of mechanisms (message
	  passing or remote procedure call for example), but although there is
	  <emphasis>logical</emphasis> parallelism, only one thread is ever
	  physically active at one time.
	</para>

	<para>
	  This follows naturally the behavior on a conventional uni-processor
	  CPU, where there is a single program counter indicating the next
	  instruction to execute, and so only one flow of control. Even with
	  modern multiprocessors, this is still a natural way of programming
	  for the software engineer, because the number or threads or
	  processes will often exceed the number of processor cores available.
	</para>
      </sect3>

      <sect3>
	<title>
	  Modeling Hardware Parallelism in Software
	</title>

	<para>
	  A simple way to model hardware is via a round-robin, which updates
	  the state of each component as time advances. Each component is
	  represented as a software function. A master clock function calls
	  each component function in turn when the clock advances&mdash;for
	  example on each clock edge. The wires between the components are
	  represented as variables shared between the components. A number of
	  tools (e.g. ARC VTOC, ARM RealView &soc; Designer, Carbon SpeedCompiler,
	  Verilator) use this approach to cycle accurate modeling.
	</para>

	<para>
	  With its close parallel of the way hardware is designed with
	  languages such as Verilog and VHDL, this approach has merit for
	  detailed modeling. It is well suited to cycle accurate modeling where
	  every hardware register and wire must be accurate.
	</para>

	<para>
	  Efficiency demands that not every HDL <literal>process</literal> or
	  <literal>always</literal> is built as a separate function. Automated
	  tools which generate cycle accurate models in &systemc; from HDL can
	  often reduce complex designs to a small number of functions executed
	  on each cycle.
	</para>

	<para>
	  For less detailed models, the overhead in calling each component
	  whenever time advances cannot be justified.
	</para>

	<para>
	  The solution is to model each component only when it has something
	  to do. The individual components communicate by sending messages
	  requesting data be transferred between each other. The exchange of
	  messages is called a transaction, and the approach
	  <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;).
	</para>

	<para>
	  This mirrors the way hardware behaves at the high level, where
	  functional blocks communicate by reading and writing across buses.
	</para>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Overview of OSCI TLM 2.0
      </title>

      <para>
	&osci; &tlm2; offers a standard approach to building Transaction Level
	Models.
      </para>

      <para>
	At the simplest level a &tlm; is a set of &systemc; modules (i.e. C++
	classes), each providing one or more <firstterm>socket</firstterm>s
	through which the &systemc; modules may read and write data.
      </para>

      <para>
	The behavior of each module is provided by a number of parallel
	<firstterm>thread</firstterm>s (functions of the C++ class), which
	communicate with the threads in other modules by passing data
	(i.e. reading or writing) through the sockets. This communication is
	known as a <firstterm>transaction</firstterm> and the data passed as a
	<firstterm>payload</firstterm>. <xref linkend="fig_tlm_overview" />
	shows the key components in a &tlm2; model.
      </para>

      <figure id="fig_tlm_overview">
	<title>
	  Key components in an &osci; &tlm2; model.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <sect3 id="sec_payload">
	<title>
	  Transaction Payload
	</title>

	<para>
	  The data passed in a transaction may take any form. However the
	  &tlm2; standard defines a <firstterm>Generic Payload</firstterm>
	  which is suitable for many uses, and which can be extended if
	  required. By using the Generic Payload, a &tlm2; model will maximize
	  interoperability.
	</para>

	<para>
	  The main features of the Generic Payload are:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>Command</term>
	    <listitem>
	      <para>
		Is this a read or a write?
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Address</term>
	    <listitem>
	      <para>
		What is the address (in the hardware sense of an address in
		memory).
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Data</term>
	    <listitem>
	      <para>
		A pointer to the physical data as an array of bytes
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Byte Enable Mask</term>
	    <listitem>
	      <para>
		A pointer to an array indicating which bytes of the data are
		valid.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Response</term>
	    <listitem>
	      <para>
		An indication of whether the transaction was successful, and
		if not the nature of the error.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  Further features provide support for streaming, custom memory
	  management and extensions to the generic payload.
	</para>

	<para>
	  A &tlm2; <firstterm>transport&#32;function</firstterm> is used to
	  pass the payload to another &systemc; thread and obtain a
	  response&mdash;i.e. a transaction.
	</para>
      </sect3>

      <sect3>
	<title>
	  Initiators and Targets
	</title>

	<para>
	  A module's threads may act as either
	  <firstterm>initiator</firstterm>s or
	  <firstterm>target</firstterm>s. An initiator is responsible for
	  creating a payload (see <xref linkend="sec_payload" />) and calling
	  the transport function to send it. A target receives payloads from
	  the transport function for processing and response. In the case of
	  non-blocking interfaces (see <xref linkend="sec_block_non_block" />,
	  the target may create new transactions backwards in response to a
	  transaction from an initiator.
	</para>

	<para>
	  Initiator calls are made through initiator sockets, target calls
	  received through target sockets. A module may implement both target
	  and initiator sockets, allowing its threads to both generate and
	  receive traffic.
	</para>
      </sect3>


      <sect3 id="sec_block_non_block">
	<title>
	  Blocking, Non-Blocking, Debug and Direct Memory Interfaces
	</title>

	<para>
	  There are two principal types of &tlm2; transport function.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      The <firstterm>blocking</firstterm> transport functions are
	      called by the initiator thread, received by the target thread,
	      which processes the request and then returns the result. Until
	      the transaction has been processed and released the initiator
	      thread is blocked.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The <firstterm>non-blocking</firstterm> transport functions are
	      called by the initiator thread, received by the target thread,
	      which immediately returns, before processing the
	      request. Subsequently the target, having processed the request
	      makes a transport call <emphasis>backwards</emphasis> to the
	      initiator to return the result.
	    </para>
	  </listitem>
	</orderedlist>

	<para>
	  In the non-blocking case there are actually two types of transport
	  used. The <firstterm>forward&#32;transport&#32;path</firstterm> is
	  used by the initiator to pass the request to the target and the
	  <firstterm>backward&#32;transport&#32;path</firstterm> used by the
	  target to return the response. The advantage of the non-blocking
	  transport interface is that the initiator can carry on processing,
	  while the target is processing the request originally made.
	</para>

	<para>
	  In addition &tlm2; provides two more specialized types of
	  transaction.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      A <emphasis>debug transaction</emphasis> is a read that does not
	      affect the state of the model. These are for use by debuggers,
	      which wish to see the state of a model, without affecting that
	      state.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      &tlm2; recognizes that a full-blown transaction is too
	      heavyweight for some types of access. For example an ISS
	      accessing memory using transactions would destroy
	      performance. &tlm2; provides the concept of a
	      <firstterm>direct&#32;memory&#32;interface</firstterm>, allowing
	      threads direct access to blocks of memory in another thread for
	      high performance.
	    </para>
	  </listitem>
	</orderedlist>

      </sect3>

      <sect3>
	<title>
	  Loosely Timed, Approximately Timed and Untimed &tlm;
	</title>

	<para>
	  &tlm2; considers two levels of timing detail.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      A <firstterm>loosely&#32;timed</firstterm> model uses
	      transactions corresponding to a complete read or write across a
	      bus or network in physical hardware. It provides timing at the
	      level of the individual transaction.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      An <firstterm>approximately&#32;timed</firstterm> model breaks
	      down transactions into a number of <firstterm>phase</firstterm>s
	      corresponding much more closely to the phasing of particular
	      hardware protocols (for example the address and data phases of
	      an AHB read or write).
	    </para>
	  </listitem>
	</orderedlist>

	<para>
	  Typically loosely timed models are implemented with a blocking
	  interface and approximately timed models with a non-blocking
	  interface.
	</para>

	<para>
	  &tlm2; also introduces the concept of
	  <firstterm>temporal&#32;decoupling</firstterm>. Standard &systemc;
	  keeps a single synchronized view of time, which is used by all
	  threads in all modules. However with temporal decoupling, each
	  thread can keep its own local view of time, allowing the thread to
	  run ahead in simulation time, until it needs to synchronize with
	  another thread. This improves performance in loosely timed models
	  with blocking interfaces, by avoiding bottlenecks in processing.
	</para>

	<para>
	  To ensure that one thread doesn't run away hogging all the
	  processing, &tlm2; temporal decoupling uses the concept of the
	  <firstterm>quantum</firstterm>, the greatest amount that a thread
	  may differ in timing from the central view of time. This allows
	  other threads a chance to catch up
	</para>

	<para>
	  &tlm2; does not have an explicit concept of an untimed socket
	  (something that was explicit in &tlm;&nbsp;1.0). The standardization
	  group took the view that in practice all models need some concept of
	  time, so purely untimed models are of little value.
	</para>

	<para>
	  However, untimed models are easily implemented as loosely timed
	  models which always set the timing parameter in transport calls to
	  zero. The example in <xref linkend="sec_iss_wrapper" /> <xref
	  linkend="sec_uart" /> and <xref linkend="sec_terminal" /> uses this
	  approach to create an untimed model. This is then refined in <xref
	  linkend="sec_sync" /> to add synchronous timing information and in
	  <xref linkend="sec_temporal_decoupling" /> to add temporal
	  decoupling.
	</para>
      </sect3>

      <sect3>
	<title>
	  &tlm2; Convenience Sockets
	</title>

	<para>
	  The standard &tlm2; approach to modeling requires the user to
	  derive their own classes from the standard &tlm2; sockets, so that
	  those sockets can then implement the &tlm2; interfaces. Modules then
	  instantiate these derived sockets and use the bind function to connect
	  them to sockets on other modules.
	</para>

	<para>
	  This is a very flexible approach, but the need to define new derived
	  classes classes for sockets is an unnecessary layer of complexity
	  for simple modeling. For such uses, the &tlm2; standard defines a
	  number of <firstterm>convenience&#32;socket</firstterm>s which can
	  be instantiated directly by modules, and which specify their
	  interface functions as callbacks.
	</para>

	<para>
	  These convenience sockets are used throughout the case study in this
	  application note.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="sec_case_study">
    <title>
      Case Study: A Loosely Timed &soc; Using &tlm2;
    </title>

    <para>
      In this case study, &tlm2; convenience sockets are used to wrap an
      existing &iss;. This is then built into a simple &soc; using additional
      hand-written &tlm2; components.
    </para>

    <para>
      Modeling uses the &tlm2; <glossterm>Generic Payload</glossterm> with no
      extensions. It is independent of the specific bus architecture that will
      be used in the implementation.
    </para>

    <para>
      The model is constructed in a number of stages:
    </para>

    <orderedlist>

      <listitem>
	<para>
	  The basic wrapper for the &or1ksim; &iss; is built using &tlm2;
	  convenience sockets and tested with a simple logger. In this first
	  stage timing is ignored&mdash;this is effectively an untimed
	  model. See <xref linkend="sec_iss_wrapper" /> and <xref
	  linkend="sec_iss_wrapper_test" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  A model &uart; is added as an example peripheral, demonstrating how
	  &tlm2; and existing &systemc; technologies can be mixed. See <xref
	  linkend="sec_uart" />
	</para>
      </listitem>

      <listitem>
	<para>
	  A model of a terminal is added as a test bench for the &soc;. This
	  demonstrates how to add &systemc; components which use operating
	  system I/O without blocking the &systemc; thread. See <xref
	  linkend="sec_terminal" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Synchronous timing is added to each component, making the model
	  loosely timed. See <xref linkend="sec_sync" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Temporal decoupling is added to the &or1ksim; &iss;, &uart; and
	  terminal, to improve the performance of the model. See <xref
	  linkend="sec_temporal_decoupling" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Interrupt modeling is added to the &uart; and the &or1ksim; &iss;,
	  allowing the model to run &linux;.
	  <xref linkend="sec_linux" />
	</para>
      </listitem>

    </orderedlist>

    <para>
      Simple applications, compiled with the &or1k; tool chain are used
      throughout to exercise the model components. The final model
      is demonstrated booting a Linux 2.6 kernel.
    </para>

    <sect2>
      <title>
	The Example Designs
      </title>

      <para>
	The example, a simple &soc;, is based on the &or1ksim; &iss; for the
	&or1k; architecture. The &or1k; architecture is a conventional 32-bit
	DSP/RISC design, with optional caches and
	<acronym>MMU</acronym>. &or1ksim; is an interpreting &iss; written in
	C, which in its standard configuration models main memory and a number
	of peripherals as well as the CPU itself.
      </para>

      <para>
	Information on obtaining and setting up the open source &or1ksim;
	simulator and its tool chain are given in <xref
	linkend="ref_app_note_1" endterm="ref_app_note_1_xr" /> [<xref
	linkend="ref_app_note_1" />.
      </para>

      <para>
	For <xref linkend="sec_iss_wrapper" /> through <xref
	linkend="sec_temporal_decoupling" /> the &or1ksim; &iss; is configured
	to model only the CPU and main memory, with example peripherals
	modeled as separate &systemc; modules. For <xref linkend="sec_linux"
	/>, the &iss; is configured to model the data and instruction
	<acronym>MMU</acronym>s and a
	<firstterm>programmable&#32;interrupt&#32;controller</firstterm>
	(<acronym>PIC</acronym>). This allows the &iss; to support interrupt
	driven peripherals and hence &linux;
      </para>

      <sect3>
	<title>
	  &or1ksim; &iss; &tlm2; Wrapper with Logger
	</title>

	<para>
	  In <xref linkend="sec_iss_wrapper" /> the &tlm2; wrapper for the
	  &or1ksim; &iss; is developed. In <xref
	  linkend="sec_iss_wrapper_test" /> the wrapped &iss; is tested by
	  connection to a simple &tlm2; logger module. This module records
	  transactions sent to it on standard output as shown in <xref
	  linkend="fig_iss_test" />.
	</para>

	<figure id="fig_iss_test">
	  <title>
	    Testing the &tlm2; wrapper for the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="iss_test.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="iss_test.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <sect3>
	<title>
	  Simple &soc; Design
	</title>

	<para>
	  To build a simple &soc; the &or1ksim; &iss; CPU/memory subsystem is
	  connected to a &uart; modeled in &systemc; using &tlm2;. The test
	  bench for the system is a terminal, also modeled in &systemc; using
	  &tlm2; as shown in <xref linkend="fig_simple_soc" />. The model is
	  built up in stages starting with the &iss; wrapper module developed
	  in <xref linkend="sec_iss_wrapper" />. In sections <xref
	  linkend="sec_uart" /> and <xref linkend="sec_terminal" /> models of
	  the &uart; and terminal are added to create an untimed
	  model. Synchronous timing to create a loosely timed model is added
	  in <xref linkend="sec_sync" /> and temporal decoupling to improve
	  performance is added in <xref linkend="sec_temporal_decoupling"
	  />. .
	</para>

	<figure id="fig_simple_soc">
	  <title>
	    Simple &soc; based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <sect3 id="soc_example_soc_intr">
	<title>
	  &soc; with Interrupt Support
	</title>

	<para>
	  To run &linux; (see <xref linkend="sec_linux" />), the example must be
	  extended to support interrupt driver I/O. It also needs memory
	  management and other peripheral functions. This is provided
	  internally to the &or1ksim; &iss;. This design is shown in <xref
	  linkend="fig_simple_soc_intr" />.
	</para>

	<figure id="fig_simple_soc_intr">
	  <title>
	    Simple &soc; based on the &or1k; &or1ksim; with interrupts and
	    <acronym>MMU</acronym> enabled.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Example Code
      </title>

      <sect3>
	<title>
	  Source Code for Example Models and Programs>
	</title>

	<para>
	  The code for all the &systemc; models is provided in the
	  <filename>sysc_models</filename> sub-directory of the code
	  distribution. See <xref linkend="app_download" /> for details of
	  obtaining the code.
	</para>

	<para>
	  Code for example programs which run on the models can be found in in
	  the <filename>sysc_models/progs_or32</filename> sub-directory of the
	  code distribution. Reference binaries are provided, but to
	  recompiling those models requires the (free) &or1k; tool chain. <xref
	  linkend="ref_app_note_1" endterm="ref_app_note_1_xr" />
	  [<xref linkend="ref_app_note_1" />] provides information on
	  building that tool chain.
	</para>

      </sect3>

      <sect3>
	<title>
	  Code Documentation
	</title>

	<para>
	  The code throughout is documented with
	  <application>Doxygen</application> (see <ulink
	  url="http://www.doxygen.org">www.doxygen.org</ulink>). The generated
	  HTML can be found in the <filename>doc/html</filename> sub-directory
	  of both the &systemc; model directory and the &or1k; program
	  directory.
	</para>
      </sect3>

      <sect3 id="sec_coding_conv">
	<title>
	  &systemc; Model Coding Conventions
	</title>

	<para>
	  All the examples in this application note separate the definition of
	  a class (i.e. <emphasis>what</emphasis> it does) in a
	  <filename>.h</filename> file, from the implementation
	  (i.e. <emphasis>how</emphasis> it does it) in a
	  <filename>.cpp</filename> file. This is considered good programming
	  practice. Class <parameter>X</parameter> is defined in file
	  <filename><parameter>X</parameter>.h</filename> and implemented in
	  <filename><parameter>X</parameter>.cpp</filename>.
	</para>

	<para>
	  The examples use the convention that classes and other type names
	  start with an Upper Case letter (e.g. <classname>Or1ksimSC</classname>),
	  variables and functions start with a lower case letter
	  (e.g. <literal>dataBus</literal>) and defined or enumerated
	  constants are all in UPPER CASE (e.g. <literal>#define BAUD_RATE
	  9600</literal>).
	</para>

      </sect3>

      <sect3>
	<title>
	  Derived classes
	</title>

	<para>
	  C++ provides the hierarchical class mechanism, where
	  <firstterm>derived&#32;class</firstterm>es inherit (some) of the
	  functions and variables of their
	  <firstterm>base&#32;class</firstterm>. This feature is heavily used
	  within &systemc;&mdash;for example all module classes are derived
	  classes of the &systemc; base class,
	  <classname>sc_module</classname>.
	</para>

	<para>
	  The &systemc; models in each section of this application note are
	  build using derived classes of the models from previous
	  sections.
	</para>

	<para>
	  Those functions and variables which other classes will use are
	  declared as <literal>public</literal>. For &systemc; modules this
	  usually means the constructor and any &systemc; ports or
	  sockets. Occasionally there are some utility functions which are
	  also made public (see for example
	  <function>Or1ksimExt::isLittleEndian</function> in <xref
	  linkend="sec_uart_or1ksim_libext" />)<footnote>
	    <para>
	      Object oriented purists prefer to expose only class functions as
	      the <literal>public</literal> interface, so hiding all state
	      implementation from external view. There is considerable merit
	      in this, but the common &systemc; convention is to expose actual
	      ports or sockets, rather than accessor functions for those
	      objects. This application note sticks with this practice.
	    </para>
	    </footnote>.
	</para>

	<para>
	  Variables and functions in classes that are not for use by other
	  classes, but are required in derived classes are declared as
	  <literal>protected</literal> (i.e. visible to derived classes).
	</para>

	<para>
	  The remaining functions and variables, which are for use only by the
	  current class, are declared <literal>private</literal> (visible only
	  to this class). This avoids any unplanned reuse by derived classes.
	</para>

	<para>
	  Some of the functions will be reimplemented in later derived
	  classes. Such functions are also declared <literal>virtual</literal>.
	</para>

	<para>
	  In summary <literal>public</literal> functions and variables may be
	  used by any other class, <literal>protected</literal> functions and
	  variables may be <emphasis>used</emphasis> only by this class and
	  any derived classes and <literal>private</literal> functions and
	  variables may be used only by this class. <literal>virtual</literal>
	  functions may be <emphasis>reimplemented</emphasis> in derived
	  classes.
	</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="sec_iss_wrapper">
    <title>
      Wrapping the &iss;
    </title>

    <para>
      The conversion of an existing &iss; to a  &systemc;
      module with &tlm2; sockets involves several steps.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Modify the existing &iss; (in this example &or1ksim; written in C)
	  so it  behaves in a manner suitable for wrapping (see <xref
	  linkend="sec_iss_mods" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Define a &systemc; module for the wrapper (see <xref
	  linkend="sec_iss_wrapper_def" />) and provide its implementation
	  (see <xref linkend="sec_iss_wrapper_impl" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Test the wrapper with a simple logger module attached to the &tlm2;
	  socket and a suitable test application running as embedded code on the
	  &iss; (see <xref linkend="sec_iss_wrapper_test" />).
	</para>
      </listitem>
    </itemizedlist>

    <sect2 id="sec_iss_mods">
      <title>
	Modifying the &or1ksim; &iss; for &tlm2;
      </title>

      <para>
	Most &iss; need some modification before they can be incorporated into
	a &tlm2; framework. Like many &iss;, &or1ksim; is designed as a
	standalone program. The options are:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Keep the &iss; as a standalone program, but modify it to call
	    out to a &systemc; model of the peripherals as required.
	  </para>
	</listitem>

	<listitem id="or1ksim_lib_opt">
	  <para>
	    Modify the &iss; to be a library with a set of public interfaces
	    that can be part of a larger system.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Given the choice, option <xref linkend="or1ksim_lib_opt" /> is more
	flexible, making the &iss; widely reusable in other environments. It
	is the approach adopted in this application note.
      </para>

      <para>
	All the modifications required to the standard &or1ksim; &iss;
	described in this application note are provided as a
	<command>patch</command> file in the distribution. See <xref
	linkend="app_download" />> for details.
      </para>

      <sect3 id="sec_or1ksim_libcals">
	<title>
	  Converting &or1ksim; to a Library
	</title>

	<para>
	  The &or1ksim; <function>main</function> function first initializes
	  the &iss;, then sits in a loop executing instructions. This
	  <function>main</function> function is replaced by a series of
	  functions which form the interface to the library. The interface
	  functions needed are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_init( const char         *config_file,
                   const char         *image_file,
                   void               *class_ptr,
                   unsigned long int (*upr)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask),
                   void              (*upw)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask,
                                             unsigned long int  wdata ) );</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_init</function> initializes the
	      simulator. For &or1ksim;, configuration data is read from a
	      file, which is passed as the first argument,
	      <literal>config_file</literal>. The program image is passed as
	      a second argument, <literal>image_file</literal>.
	    </para>

	    <para>
	      &or1ksim; also needs to be able to call up to the &systemc;
	      model of which it is part&mdash;to read and write from the
	      peripheral address space. These are provided as the fourth
	      and fifth arguments, <function>upr</function> and
	      <function>upw</function>. More explanation of the upcall
	      mechanism can be found in <xref linkend="sec_upcall" />.
	    </para>

	    <para>
	      Function calls between C and C++ can be awkward. The upcall
	      functions form part of the &systemc; module object, but are
	      written as static functions with C linkage. To enable these
	      functions to invoke functions in the &systemc; module, they are
	      passed a pointer to the module class instance to use as a
	      handle. This pointer forms the third argument,
	      <literal>class_ptr</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_run( double  duration );</programlisting>
	    </para>
	    <para>
	      <function>or1ksim_run</function> runs the simulator for the
	      specified time in seconds.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3 id="sec_or1ksim_generic_sec">
	<title>
	  Additional Functionality for &or1ksim;
	</title>

	<para>
	  The standard &or1ksim; &iss; incorporates the functionality of
	  several common peripherals. The objective of this application note
	  is to demonstrate the &iss; driving external peripherals modeled in
	  &systemc; using &tlm2; interfaces.
	</para>

	<para>
	  &or1ksim; peripherals are configured in a textual configuration
	  file, with a section (introduced by the keyword
	  <literal>section</literal>) for each device attached. This
	  configuration file specifies the memory mapped addresses of the
	  peripheral. Any reads or writes to those addresses will be directed
	  to the code of the peripheral within &or1ksim;.
	</para>

	<para>
	  &or1ksim; is extended with a new class of peripheral,
	  <literal>generic</literal>, which specifies an external
	  peripheral. The specification in the configuration file specifies
	  the memory mapped address range covered and whether byte, half word
	  or full word access are enabled. Multiple <literal>generic</literal>
	  sections may be defined (for different address ranges) in the
	  configuration file.
	</para>

	<para>
	  Code is added to &or1ksim;, so that any read or write to a
	  <literal>generic</literal> peripheral is redirected back to the
	  wrapper code via the upcalls specified as arguments to
	  <function>or1ksim_init</function> (see <xref
	  linkend="sec_or1ksim_libcals" /> and <xref linkend="sec_upcall" />).
	</para>
      </sect3>
    </sect2>


    <sect2 id="sec_iss_wrapper_def">
      <title>
	&or1ksim; Wrapper Module Class Definition
      </title>

      <para>
	The class definition for the &or1ksim; &iss; wrapper module is found in
	the file <filename>Or1ksimSC.h</filename>.
      </para>

      <sect3 id="sec_Or1ksimSC_def_inc">
	<title>
	  Included Headers
	</title>

	<para>
	  The &or1ksim; &systemc; wrapper module class,
	  <classname>Or1ksimSC</classname>, is defined in the file
	  <filename>Or1ksimSC.h</filename>. It will provide a single initiator
	  socket, for data access, <literal>dataBus</literal>. No instruction
	  accesses are planned, so modeling an external instruction bus is
	  unnecessary.
	</para>

	<para>
	  The module includes the <filename>tlm.h</filename> header, which
	  defines the core &tlm2; interface and the required convenience
	  wrapper header&mdash;in this case for a simple initiator socket.
	</para>

	<para>
	  The &posix; <filename>stdint.h</filename> header is also included, since
	  the definitions and code will make use of the fixed width native
	  types defined there.
	</para>

	<programlisting>#include &lt;stdint.h&gt;

#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "or1ksim.h"</programlisting>

        <note>
	  <para>
	    There is no need to include the standard
	    <filename>systemc</filename> header, since this is included
	    automatically by <filename>tlm.h</filename>.
	  </para>
	</note>

      </sect3>

      <sect3 id="sec_Or1ksimSC_def_module">
	<title>
	  Module Declaration
	</title>

	<para>
	  The module is declared as a standard &systemc; module, i.e. as a
	  derived class of <classname>sc_core::sc_module</classname>.
	</para>

	<programlisting>class Or1ksimSC
  : public sc_core::sc_module
{</programlisting>

        <note>
	  <para>
	    &systemc; provides a macro, so that a module can be defined by:
	  </para>

	  <programlisting>SC_MODULE( Or1ksimSC )</programlisting>

	  <para>
	    However this is equivalent (IEEE 1666-2005 section 5.2.5) to the
	    C++ derived class declaration
	  </para>

	  <programlisting>class Or1ksimSC
  : public sc_core::sc_module
{
 public:</programlisting>

          <para>
	    By using <literal>SC_MODULE</literal> all functions and variables
	    will be visible to all other classes (<literal>public</literal>)
	    unless there is a subsequent <literal>protected:</literal> or
	    <literal>private:</literal> declaration.
	  </para>

          <para>
	    The examples provided with &systemc; and &tlm2; all use explicit
	    declarations of classes derived from
	    <classname>sc_module</classname> rather than the
	    <literal>SC_MODULE</literal> macro. This application note uses the
	    same approach.
	  </para>
	</note>

      </sect3>

      <sect3 id="sec_Or1ksimSC_def_constructor">
	<title>
	  Constructor and Destructor
	</title>

	<para>
	  <classname>Or1ksimSC</classname> needs a custom constructor, which
	  can be passed the &or1ksim; &iss; configuration and image files. It
	  will call the <function>or1ksim_init</function> function within the
	  &or1ksim; library (see <xref linkend="sec_or1ksim_libcals" />) to
	  initialize the &iss;.
	</para>

	<programlisting>Or1ksimSC( sc_core::sc_module_name  name,
           const char              *configFile,
           const char              *imageFile );</programlisting>

	<para>
	  The default destructor is sufficient here. The module has no tidying
	  up to do on termination.
	</para>

      </sect3>

      <sect3 id="sec_Or1ksimSC_def_pub_if">
	<title>
	  Public Interface
	</title>

	<para>
	  The only public interface is the &tlm2; simple initiator convenience
	  socket, <literal>dataBus</literal>. The &tlm2; convenience sockets are
	  templated with
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      the class of which any callbacks are members;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a bus width (default <literal>BUSWIDTH</literal>, 32); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a protocol type (default the &tlm2; base protocol types).
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  For this case study, the default bus width and protocol are
	  appropriate and need not be specified. There is no default class for
	  the template, so <classname>Or1ksimSC</classname> is used. A class must be
	  specified, even where (as in this case for a simple blocking
	  initiator) no callbacks are actually required.
	</para>

	<programlisting>  tlm_utils::simple_initiator_socket&lt;Or1ksimSC&gt;  dataBus;</programlisting>

      </sect3>

      <sect3 id="sec_Or1ksimSC_def_threads">
	<title>
	  Threads
	</title>
      
        <para>
	  The module has a single thread, which executes the instructions of
	  the &iss;. The <function>run</function> function implements this:
	</para>

	<programlisting>  void  run();</programlisting>

	<para>
	  The thread is not part of the public interface, but will but will be
	  reused and reimplemented in derived classes later in the application
	  note, so it is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>
      </sect3>

      <sect3 id="sec_upcall">
	<title>
	  Upcalls
	</title>

	<para>
	  The &or1ksim; &iss; makes requests to read and write peripherals via
	  the upcalls passed as arguments to <function>or1ksim_init</function>
	  (see <xref linkend="sec_or1ksim_libcals" />).
	</para>

	<para>
	  The &or1ksim; &iss; is implemented in C, which cannot easily call
	  C++ class instance functions. The solution is to declare two
	  <emphasis>static</emphasis> member functions which can be called
	  from C. The call to <function>or1ksim_init</function> also received
	  the address of the actual C++ class instance (cast to
	  <literal>void&nbsp;*</literal>). This pointer is passed back with
	  the upcall, so the static function can call the corresponding
	  instance function.
	</para>

	<para>
	  A total of 4 functions are needed, one static and one instance each
	  for read and write. The static functions use the native C/C++ types
	  (unsigned long int), but convert to defined fixed width types for
	  the instance functions. The native &systemc; 64-bit unsigned type is
	  used for the address (which is always 64 bits in &tlm2; function
	  calls) and the <firstterm>&posix;</firstterm> 32-bit unsigned data
	  type is used for the byte enable mask and data.
	</para>

	<para>
	  These upcall functions are not changed throughout this application
	  note, so are declared private.
	</para>

	<programlisting>  static unsigned long int  staticReadUpcall( void              *instancePtr,
                                              unsigned long int  addr,
                                              unsigned long int  mask );

  static void               staticWriteUpcall( void              *instancePtr,
                                               unsigned long int  addr,
                                               unsigned long int  mask,
                                               unsigned long int  wdata );

  uint32_t                  readUpcall( sc_dt::uint64  addr,
                                        uint32_t       mask );

  void                      writeUpcall( sc_dt::uint64  addr,
                                         uint32_t       mask,
                                         uint32_t       wdata );</programlisting>

        <caution>
	  <para>
	    It might seem logical to use the &systemc; limited precision
	    types, rather than the &posix; types. However the &systemc; types
	    are <emphasis>not</emphasis> native C++ types, so will not cast as
	    expected.
	  </para>
	</caution>

	<para>
	  The transport mechanism is common to both, so provided in a utility
	  function, <function>doTrans</function>. This function will be used
	  and re-implemented in derived classes, so is declared
	  <literal>protected</literal> and <literal>virtual</literal>.
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_wrapper_impl">
      <title>
	&or1ksim; Wrapper Module Class Implementation
      </title>

      <para>
	The class implementation for <classname>Or1ksimSC</classname> is found
	in the file <filename>Or1ksimSC.cpp</filename>.
      </para>

      <sect3>
	<title>
	  Headers and Macros
	</title>

	<para>
	  All the definitions required are obtained from the definition file:
	</para>

	<programlisting>#include "Or1ksimSC.h"</programlisting>

	<para>
	  The implementation of a C++ class that is a &systemc; module with
	  &systemc; threads (<literal>SC_THREAD</literal>), methods
	  (<literal>SC_METHOD</literal>) or clocked threads
	  (<literal>SC_CTHREAD</literal>) requires a number of definitions for
	  that class to be set up using the <literal>SC_HAS_PROCESS</literal>
	  macro.
	</para>

	<programlisting>SC_HAS_PROCESS( Or1ksimSC );</programlisting>

	<caution>
	  <para>
	    The <literal>SC_HAS_PROCESS</literal> macro is a common cause of
	    confusion with new users to &systemc;. It doesn't appear in the
	    user guide and tutorial examples. The reason is that those
	    examples use the <literal>SC_CTOR</literal> macro to define the
	    constructor for the class, which provides the same definitions as
	    the <literal>SC_HAS_PROCESS</literal> macro.
	  </para>

	  <para>
	    The <literal>SC_CTOR</literal> macro can only be used where the
	    constructor's implementation is given within the class
	    definition. As explained in <xref linkend="sec_coding_conv" />,
	    good object oriented design separates class definition from class
	    implementation, with the constructor implemented separately from
	    the class definition.
	  </para>

	  <para>
	    In cases such as this, where the constructor implementation is
	    separate from the definition, &systemc; requires that the
	    <literal>SC_HAS_PROCESS</literal> macro is used before the code of
	    any class functions. The macro is only required if the constructor
	    uses <literal>SC_METHOD</literal>, <literal>SC_THREAD</literal> or
	    <literal>SC_CTHREAD</literal> to associate a process with the
	    module class.
	  </para>
	</caution>

      </sect3>

      <sect3>
	<title>
	  Constructor
	</title>

	<para>
	  The constructor passes the name to the constructors of its base
	  class (<classname>sc_module</classname>) and its simple initiator socket
	  (<literal>dataBus</literal>), then calls the
	  <function>or1ksim_init</function> function in the &or1ksim; library
	  to initialize the &iss;.
	</para>

	<para>
	  The member function, <function>run</function> is associated with the
	  class as a &systemc; thread, using the <literal>SC_THREAD</literal>
	  macro. It will be called automatically by the &systemc; kernel after
	  elaboration (i.e &systemc; initialization).
	</para>

	<programlisting>Or1ksimSC::Or1ksimSC ( sc_core::sc_module_name  name,
                       const char              *configFile,
                       const char              *imageFile ) :
  sc_module( name ),
  dataIni( "data_initiator" )
{
  or1ksim_init( configFile, imageFile, this, staticReadUpcall,
                staticWriteUpcall );

  SC_THREAD( run );               // Thread to run the ISS

}       /* Or1ksimSC() */</programlisting>


      </sect3>

      <sect3 id="sec_Or1ksimSC_impl_thread">
	<title>
	  Thread
	</title>

      <para>
	The main thread, <function>run</function>, invokes the &or1ksim;
	&iss; to run for ever (by passing a negative time argument). The &iss;
	will use the upcalls (see <xref linkend="sec_upcall" />) to request
	reads from and writes to the peripheral address space.
      </para>

      <para>
	The thread is called automatically when the &systemc; kernel has
	completed elaboration (i.e. is initialized).
      </para>

      <programlisting>void
Or1ksimSC::run()
{
  scLastUpTime   = sc_core::sc_time_stamp();
  or1kLastUpTime = or1ksim_time();

  (void)or1ksim_run( -1.0 );

}       // Or1ksimSC()</programlisting>

      </sect3>

      <sect3>
	<title>
	  Upcalls
	</title>

      <para>
	Two functions are declared as static member functions to implement the
	upcalls from the &or1ksim; library (see <xref linkend="sec_upcall" />
	for an explanation of why these functions are static).
      </para>

      <para>
	The static functions receive the pointer to the
	<classname>Or1ksimSC</classname> instance which originally started the
	&or1ksim; &iss; (provided as an argument to
	<function>or1ksim_init</function> described in <xref
	linkend="sec_Or1ksimSC_impl_thread" />).
      </para>

      <para>
	This allows each static function to call the instance function which
	implements the upcall, as shown here with
	<function>staticReadUpcall</function>:
      </para>

      <programlisting>unsigned long int
Or1ksimSC::staticReadUpcall( void              *instancePtr,
                             unsigned long int  addr,
                             unsigned long int  mask )
{
  Or1ksimSC *classPtr = (Or1ksimSC *)instancePtr;

  return (unsigned long int)classPtr->readUpcall( (sc_dt::uint64)addr,
                                                  (uint32_t)mask );
}       // staticReadUpcall()</programlisting>

        <para>
	  The address is cast to the &systemc; native 64-bit type, which is
	  always used in &tlm2; for addresses. The mask and result (and write
	  data for <function>staticWriteUpcall</function> are cast to the
	  &posix; <literal>uint32_t</literal> fixed length type to avoid any
	  ambiguity over size<footnote>
	    <para>
	      While <literal>unsigned&nbsp;long&nbsp;int</literal> is almost
	      always 32 bits long, it is not guaranteed to be so.
	    </para>
	  </footnote>.
	</para>

	<caution>
	  <para>
	    It might be thought that providing a direct upcall to the C++
	    upcall functions of the class would be more efficient, using the C++
	    member reference operator (<literal>::*</literal>). However the
	    linkage to a member is much more complex (to cope with inheritance
	    and overloading). Lack of standardization in the C++
	    <firstterm>Application Binary Interface</firstterm>
	    (<acronym>ABI</acronym>) means that such linkage between C and C++
	    will not necessarily work.
	  </para>

	  <para>
	    Linkage to static functions is much simpler and usually works
	    between C and C++. So the approach used here is more reliable.
	  </para>
	</caution>

	<para>
	  The upcalls from the &iss; generate the transactional
	  activity. These functions set up the payload, execute the transaction
	  (i.e exchange the payload and result with the target) and return the
	  result to the &iss;.
	</para>

	<para>
	  The example here is coded in a very simple fashion, in the knowledge
	  that the requests to read are always four bytes long (the &or1k; has
	  a simple 32 bit bus), possibly with some bytes masked out for byte
	  and half-word reads. This matches the default
	  <literal>BUSWIDTH</literal> of the simple initiator socket.
	</para>

	<para>
	  Both payload and data are declared as local (automatic) variables,
	  i.e. on the stack. This is fine with a blocking transport function,
	  since they will remain valid for the duration of the
	  transaction. The data and mask are both encoded in the four bytes of
	  a &posix; <literal>uint32_t</literal>.
	</para>

	<caution>
	  <para>
	    Using local variables is this way would <emphasis>not</emphasis>
	    be appropriate with a non-blocking socket, since the initiator
	    function could return before the result of the transaction is
	    received back from the target.
	  </para>

	  <para>
	    &tlm2; requires that the payload, data and mask fields all remain
	    valid for the duration of the complete transaction, so in this
	    case the variables would need to be allocated and deleted from the
	    heap.
	  </para>
	</caution>

      </sect3>

      <sect3 id="sec_Or1ksimSC_impl_btrans">
	<title>
	  Blocking Transport
	</title>

	<para>
	  Once the payload fields are set up, the
	  <function>doTrans</function> function (which is used for both read
	  and write) is called to transport the payload to the target and
	  return the result.
	</para>

	<para>
	  The transport function requires a time to be supplied, even when
	  timing is not being used (as in this case). This must be time
	  variable, not a constant, since the target can update the value. A
	  dummy variable is declared with zero time and passed to the blocking
	  transport function of the socket with the payload.
	</para>

        <programlisting>  sc_core::sc_time  dummyDelay = sc_core::SC_ZERO_TIME;
  dataBus->b_transport( trans, dummyDelay );</programlisting>

        <para>
	  This implementation is sufficient for modeling just the &or1ksim;
	  &iss; in &systemc;. However at no time does the thread execute a
	  &systemc; <function>wait</function> call. In the absence of any such
	  yield, no other thread would be able to execute. This will be remedied
	  in <xref linkend="sec_uart" /> when other threads are added to model
	  peripherals.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="sec_iss_wrapper_test">
    <title>
      Testing the &or1ksim; &iss; &tlm2; Wrapper
    </title>

    <para>
      The test configuration was shown earlier in <xref linkend="fig_iss_test"
      />. For this a simple logger is needed, which must implement a &tlm2;
      simple target socket.
    </para>

    <para>
      In addition, a simple embedded application is needed to run on the
      &or1ksim; &iss;, which will make reads and writes to peripheral address
      space, which can be detected by the logger.
    </para>

    <para>
      All the behavior is in the callback function&mdash;there are no &systemc;
      threads. This means the logger will be suitable for testing the
      <classname>Or1ksimSC</classname> wrapper module, even though its thread
      never yields (see <xref linkend="sec_Or1ksimSC_impl_btrans" />).
    </para>

    <sect2>
      <title>
	Definition of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Include Files
	</title>

	<para>
	  The logger is based on the &tlm2; convenience simple target socket,
	  so needs the appropriate header, in addition to the standard &tlm2;
	  header:
	</para>

	<programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Declaration and Constructor
	</title>

        <para>
	  The class is a standard &systemc; module:
	</para>

	<programlisting>class LoggerSC
: public sc_core::sc_module</programlisting>

        <para>
	  A custom constructor is needed, which will be used to register the
	  callback function for the simple target convenience socket blocking
	  transport.
	</para>

	<programlisting>  LoggerSC( sc_core::sc_module_name  name );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The public interface is the single simple target convenience
	  socket.
	</para>

	<programlisting>  tlm_utils::simple_target_socket&lt;LoggerSC&gt;  loggerPort;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport
	</title>

	<para>
	  Blocking transport is via a callback function:
	</para>

        <programlisting>  void  loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                         sc_core::sc_time         &amp;delay );</programlisting>

        <para>
	  All the behavior of the module is captured in this callback
	  function. There are no &systemc; threads required.
	</para>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Implementation of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The logger will be doing a certain amount of stream IO, so includes
	  the C++ headers that define stream manipulation functions. The &posix;
	  standard integer types are also included.
      </para>

      <programlisting>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdint.h&gt;

#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Constructor
	</title>

        <para>
	  The constructor passes its argument (the module) name to the base
	  class <classname>sc_module</classname> constructor. The body of the
	  function then registers the <function>loggerReadWrite</function>
	  function as the callback for blocking transport to this convenience
	  socket. This means that any initiator which requests blocking
	  transport (by calling the initiator socket's
	  <function>b_transport</function> function) will invoke this callback
	  function in the target.
	</para>

	<programlisting>LoggerSC::LoggerSC( sc_core::sc_module_name  name ) :
  sc_module( name )
{
  loggerPort.register_b_transport( this, &amp;LoggerSC::loggerReadWrite );

}       // Or1ksimSC()</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The callback function, <function>loggerReadWrite</function> records
	  the key information regarding any transaction it receives. The
	  payload is a &tlm2; Generic Payload, with appropriate access
	  functions. In this simple implementation, a length of 4 bytes is
	  assumed for the data in the payload.
	</para>
	
	<para>
	  To get at the data and byte enable mask, the pointers to
	  <literal>unsigned char</literal> are cast to pointers to the &posix;
	  fixed width type, <literal>uint32_t</literal>, as was used with
	  <classname>Or1ksimSC</classname>. Endianism issues due to the byte
	  pointers not being word aligned are not an issue, because the
	  <classname>Or1ksimSC</classname> module also declared them as
	  <literal>uint32_t</literal>.
	</para>

        <programlisting>void
LoggerSC::loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                           sc_core::sc_time         &amp;delay )
{
  // Break out the address, mask and data pointer.

  tlm::tlm_command   comm    = payload.get_command();
  sc_dt::uint64      addr    = payload.get_address();
  unsigned char     *maskPtr = payload.get_byte_enable_ptr();
  unsigned char     *dataPtr = payload.get_data_ptr();

  // Record the payload fields (data only if it's a write)

  const char *commStr;

  switch( comm ) {
  case tlm::TLM_READ_COMMAND:   commStr = "Read";   break;
  case tlm::TLM_WRITE_COMMAND:  commStr = "Write";  break;
  case tlm::TLM_IGNORE_COMMAND: commStr = "Ignore"; break;
  }

  std::cout &lt;&lt; "Logging" &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Command:      "   &lt;&lt; commStr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Address:      0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; (uint64_t)addr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Byte enables: 0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; *((uint32_t *)maskPtr) &lt;&lt; std::endl;

  if( tlm::TLM_WRITE_COMMAND == comm ) {
    std::cout &lt;&lt; "  Data:         0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
              &lt;&lt;std::hex &lt;&lt; *((uint32_t *)dataPtr) &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

  payload.set_response_status( tlm::TLM_OK_RESPONSE );  // Always OK

}       // loggerReadWrite()</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_logger_main_prog">
      <title>
	The Model Main Program
      </title>

      <para>
	The logger module and the &or1ksim; wrapper module must be connected
	in the main program (<function>sc_main</function> since this is
	&systemc;), and the simulation invoked.
      </para>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The program includes the main &tlm2; header and the header of the
	  two modules which will be used:
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimSC.h"
#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Argument Processing
	</title>

	<para>
	  The program takes two arguments, an &or1ksim; configuration file
	  (described further in <xref linkend="sec_iss_run_test" />) and a
	  binary image to execute on the &or1ksim; &iss; (see <xref
	  linkend="sec_iss_or32_prog" />).
	</para>

	<programlisting>int  sc_main( int   argc,
              char *argv[] )
{
  if( argc != 3 ) {
    fprintf( stderr, "Usage: TestSC &lt;config_file&gt; &lt;image_file&gt;\n" );
    exit( 1 );
  }</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Instantiation
	</title>

        <para>
	  Instances of the &or1ksim; &iss; and the logger are created, the
	  &iss; being passed the two program arguments for its initialization.
	</para>

	<programlisting>  Or1ksimSC  iss( "or1ksim", argv[1], argv[2] );
  LoggerSC   logger( "logger" );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Connecting the Modules
	</title>

        <para>
	  The target socket of the logger (<literal>loggerPort</literal>) is
	  connected by passing it as argument to the initiator socket of the
	  &iss; (<literal>dataBus</literal>). The C++ function application
	  operator, <literal>()</literal>, is overloaded for initiator sockets
	  to provide this binding function.
	</para>

	<programlisting>  iss.dataBus( logger.loggerPort );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Model Execution
	</title>

	<para>
	  Once the model is instantiated, simulation is invoked to run forever.
	</para>
	  
	<programlisting>  sc_core::sc_start();</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_or32_prog">
      <title>
	Test Program to Run on the &or1ksim;
      </title>

      <para>
	The test program in <filename>logger_test.c</filename> defines a
	memory mapped volatile data structure and then writes to and reads
	from each element of that structure. Compilation of this program
	requires the &or1k; GNU tool chain (see <xref linkend="ref_app_note_1"
	endterm="ref_app_note_1_xr" /> [<xref linkend="ref_app_note_1" />] for
	details of installing this).
      </para>

      <sect3>
	<title>
	  The Utility Functions
	</title>

	<para>
	  The test program uses some simple utility functions which can write
	  characters (<function>simputc</function>), string
	  (<function>simputs</function>) and hexadecimal numbers
	  (<function>simputh</function>). Its header is included:
	</para>

	<programlisting>#include "utils.h"</programlisting>

	<para>
	  The utilities' implementation can be found in
	  <filename>utils.c</filename>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Memory Mapped Data Structure
	</title>

	<para>
	  The memory mapped address is defined in the configuration of
	  &or1ksim; (see <xref linkend="sec_iss_run_test" />) to be
	  0x90000000. This is set as a defined constant in the test program.
	</para>

	<programlisting>#define BASEADDR  0x90000000</programlisting>

	<para>
	  The memory mapped structure consists of a byte, half word (16 bits)
	  and full word (32 bits), all declared as <literal>volatile</literal>
	  within the <literal>struct</literal>. These are all declared with
	  the C types, which for the &or1k; tool chain are known to correspond
	  to these sizes.
	</para>

	<programlisting>struct  testdev
{
  volatile unsigned char       byte;
  volatile unsigned short int  halfword;
  volatile unsigned long  int  fullword;
};</programlisting>

        <para>
	  The main program declares a pointer to this
	  <literal>struct</literal> at the <literal>BASEADDR</literal>, along
	  with 3 variables to hold the results of the various sized results
	  when reading.
	</para>

	<programlisting>main()
{
  struct testdev *dev = (struct testdev *)BASEADDR;

  unsigned char       byteRes;
  unsigned short int  halfwordRes;
  unsigned long int   fullwordRes;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Write Access
	</title>

	<para>
	  The details of each write are logged and the value then written. (In
	  the absence of a <function>printf</function>, the logging is
	  necessarily cumbersome).
	</para>

	<programlisting>  simputs( "Writing byte 0xa5 to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );
  dev->byte     =       0xa5;

  simputs( "Writing half word 0xbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );
  dev->halfword =     0xbeef;

  simputs( "Writing full word 0xdeadbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );
  dev->fullword = 0xdeadbeef;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Read Access
	</title>

        <para>
	  The values are then read back. No results are expected (the logger
	  does not set any values), but this should check the process behaves
	  as expected.
	</para>

	<programlisting>  byteRes = dev->byte;
  simputs( "Read 0x" );
  simputh(  byteRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );

  halfwordRes = dev->halfword;
  simputs( "Read 0x" );
  simputh( halfwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );

  fullwordRes = dev->fullword;
  simputs( "Read 0x" );
  simputh( fullwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );</programlisting>

        <para>
	  At the end of the program, the utility
	  <function>simexit</function> is used. This not only terminates the
	  program, but will also exit the simulation.
	</para>

      </sect3>

      <sect3>
	<title>
	  Program Compilation
	</title>

	<para>
	  The program is compiled with the utility functions (in
	  <filename>utils.c</filename>) and a small boot loader (in
	  <filename>start.s</filename>) which defines a
	  <function>_start</function> function which invokes
	  <function>main</function>. The linker arguments are chosen to make
	  the program load from start of memory, with the
	  <function>_start</function> function sitting at the &or1k; reset vector
	  (0x100).
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_run_test">
      <title>
	Running the Test
      </title>
      <sect3>
	<title>
	  Compiling the &systemc; Model
	</title>

	<para>
	  The &systemc; modules are each compiled with access to the &or1ksim;,
	  &systemc; and &tlm2; header directories. It is also essential that
	  <literal>SC_INCLUDE_DYNAMIC_PROCESSES</literal> is defined when
	  using &tlm2;:
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c TestSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c Or1ksimSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c LoggerSC.cpp</programlisting>

        <para>
	  The final linking must include the &systemc; library, and since the
	  &or1ksim; library includes some shared objects, linker directions to
	  find those shared objects
	  (<literal>-Wl,--rpath,$OR1KSIM_HOME</literal>).
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES TestSC.o Or1ksimSC.o LoggerSC.o \
    -Wl,--rpath,$OR1KSIM_HOME/lib -L$OR1KSIM_HOME/lib \
    -L$SYSTEMC_HOME/lib-linux -lsim -lsystemc -o TestSC</programlisting>

      </sect3>
      <sect3>
	<title>
	  Configuring the &or1k; &or1ksim; &iss;
	</title>

	<para>
	  The &or1ksim; &iss; is configured using a textual configuration
	  file, described in more detail in <xref linkend="ref_app_note_1"
	  endterm="ref_app_note_1_xr" /> [<xref linkend="ref_app_note_1"
	  />]. For the modified &or1ksim; &iss;, <literal>generic</literal>
	  peripherals can be added (see <xref
	  linkend="sec_or1ksim_generic_sec" />), which will cause code to call
	  out via the upcall mechanism to the &or1ksim; &systemc; wrapper
	  module (see <xref linkend="sec_upcall" />).
	</para>

	<para>
	  The &or1ksim; configuration file for this example is in
	  <filename>simple.cfg</filename>. It disables all the standard
	  peripherals and specifies one block of memory from address 0x0. It
	  adds a <literal>generic</literal> peripheral allowing byte, half
	  word and full word access to addresses mapped from 0x90000000 to
	  0x90000007, with the following configuration file entry
	</para>

	<programlisting>section generic
  enabled      =          1
  baseaddr     = 0x90000000
  size         =        0x8
  name         = "External UART"
  byte_enabled =          1
  hw_enabled   =          1
  word_enabled =          1
end</programlisting>

      </sect3>
      <sect3>
	<title>
	  Running the Compiled Model
	</title>

        <para>
	  The compiled program can be executed by passing in as arguments
	  the &or1ksim; configuration file and the &or1k; binary. The result
	  is shown in <xref linkend="fig_logger_test" />.
	</para>

	<figure id="fig_logger_test">
	  <title>
	    Output from the logger test of the &or1ksim; wrapper module.
	  </title>

	  <screen>$ ./TestSC ../simple.cfg progs_or32/logger_test

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Writing byte 0xa5 to address 0x090000000
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0x000000ff
  Data:         0x000000a5
  Delay:        0.000000000s

Writing half word 0xbeef to address 0x090000002
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0xffff0000
  Data:         0xbeef0000
  Delay:        0.000000000s

   ... &lt;More test program output&gt;

Logging
  Command:      Read
  Address:      0x90000004
  Byte enables: 0xffffffff
  Delay:        0.000000000s

Read full word 0x0 from address 0x090000004
exit(0)
@reset : cycles 0, insn #0
@exit  : cycles 26921, insn #13854
 diff  : cycles 26921, insn #13854
$ </screen>
	</figure>

	<para>
	  Each access from the application program generates the expected
	  transactional access. All accesses are 32 bits wide, but for byte
	  and half-word access the relevant bytes are masked off.
	</para>

	<note>
	  <para>
	    The &or1ksim; can be configured to model big-endian
	    architectures. The &tlm2; payloads are always packed with data
	    using the endianism of the model.
	  </para>

	  <para>
	    If the exercise were repeated with a big-endian version of
	    &or1ksim; the addresses of the access would be unchanged (they are
	    word aligned), but the byte enable masks for the byte and half
	    word accesses would be inverted.
	  </para>
	</note>

      </sect3>
    </sect2>
  </sect1>

<sect1 id="sec_uart">
    <title>
      Modeling Peripherals
    </title>

    <para>
      This example uses a single peripheral, a &uart;. The &uart; model is
      based on National Semiconductor 16450 design.
    </para>

    <sect2>
      <title>
	Details of the 16450 &uart;
      </title>

      <para>
	The 16450 &uart; is a very long established industry component. Data
	written a byte at a time into the transmit buffer is converted to
	serial pulses on the output (Tx) pin. Serial pulses on the input (Rx)
	pin are recognized and converted to byte values, which can be read
	from the receive buffer. Typically Rx and Tx are connected to a
	terminal and keyboard which can generate and recognize the pulses of
	data. The &uart; can also generate additional signals for terminals and
	keyboards to provide physical flow control, but that is beyond the
	scope of this model. The key interfaces are shown in <xref
	linkend="fig_uart" />.
      </para>

	<figure id="fig_uart">
	  <title>
	    16450 &uart;: Key interfaces.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="uart.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      <para>
	The 16450 &uart; specifies a set of registers which control the &uart;
	behavior. On the Tx/Rx side, this includes setting the board rate and
	the pattern of stop, start and data bits. On the CPU side this
	includes configuring interrupt behavior (if any) and setting flags to
	show the status of transmit and receive buffers. The registers are
	shown in <xref linkend="tab_ns_16450_regs" />.
      </para>

      <table id="tab_ns_16450_regs" frame='all'>
	<title>
	  NS 16450 &uart; Registers
	</title>
	<tgroup cols='4' align="left" colsep="1" rowsep="1">
	  <colspec colwidth="2*" colname="address" />
	  <colspec colwidth="2*" colname="register" />
	  <colspec colwidth="1*" colname="rw" />
	  <colspec colwidth="8*" colname="description" />

	  <thead>
	    <row>
	      <entry>
		Address
	      </entry>
	      <entry>
		Register
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		Description
	      </entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry morerows="2">
		0
	      </entry>
	      <entry>
		<literal>RXBUF</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for read data.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>TXBUF</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for data to be
		  written.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLL</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the low byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry morerows="1">
		1
	      </entry>
	      <entry>
		<literal>IER</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  The interrupt enable register. The lower 4 bits control
		  which events generate an interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLH</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the high byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		2
	      </entry>
	      <entry>
		<literal>IIR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Interrupt identification register. Bit 0 indicates if an
		  interrupt is pending, bits 1-2 the reason for the
		  interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		3
	      </entry>
	      <entry>
		<literal>LCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Line control register. Various bits controlling the behavior
		  of the &uart;. Of these, <literal>DLAB</literal>, bit 7, the
		  divisor latch access bit is important, because it controls
		  the behavior of registers 0
		  (<literal>RXBUF</literal>/<literal>TXBUF</literal>/<literal>DLL</literal>)
		  and 1 (<literal>IER</literal>/<literal>DLH</literal>).
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		4
	      </entry>
	      <entry>
		<literal>MCR</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  Modem control register. Bits 0-4 control the
		  behavior of the modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		5
	      </entry>
	      <entry>
		<literal>LSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Line status register. Bits 0-6 report the status of the
		  &uart;. Of these, DR, bit 0, receiver data ready is
		  important, indicating there is valid data in
		  <literal>RXBUF</literal>.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		6
	      </entry>
	      <entry>
		<literal>MSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Modem Status Register. Bits reporting the state of the
		  modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		7
	      </entry>
	      <entry>
		<literal>SCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Scratch register. Not used by the &uart;, but may be used by
		  the application to store an 8-bit value.
		</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
      </para>

    </sect2>

    <sect2>
      <title>
	&uart; Module Design
      </title>

      <para>
	A transaction level model cannot show all the intricacies of a
	&uart;&mdash;the whole point is to simplify and remove detail.
      </para>

      <para>
	The &tlm; should allow the CPU to read and write registers, a terminal
	to send and receive characters and should generate interrupts as
	appropriate. While all writable registers can be written and all
	readable registers read, only those registers and bits of registers
	which are relevant to this level of modeling will have any impact on
	behavior.
      </para>

      <sect3>
	<title>
	  &uart; Model Interfaces
	</title>

	<para>
	  A &tlm2; socket is the natural model for the bus interface to the
	  CPU. However the interface to the terminal is much simpler.
	  Standard &systemc; buffers (<classname>sc_buffer</classname>) will
	  be suitable, one for the Rx direction and one for Tx. The buffer is
	  implemented for the Rx direction and a port to a buffer for the Tx
	  direction. The terminal (see <xref linkend="sec_terminal" />) will
	  offer the complementary arrangement.
	</para>

	<note>
	  <para>
	    A &systemc; buffer (<classname>sc_buffer</classname>) is used
	    rather than a (<classname>sc_signal</classname>), since it must
	    report all writes to the buffer, rather than just changes to the
	    value (as would be the case with a signal). At this level of
	    modeling it is quite possible that two identical bytes would
	    follow each other.
	  </para>
	</note>

	<para>
	  The interrupt is not modeled as an interface at this stage, so the
	  &uart; will only be suitable for polled use. An interrupt interface
	  is added in <xref linkend="sec_linux" />.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Model Registers
	</title>

	<para>
	  The divisor latch affects the baud rate, which will affect timing of
	  transfers. This will be covered in a later section (see <xref
	  linkend="sec_sync" />), but is not needed for the current untimed
	  model. The value can be written and read, but does not affect
	  behavior.
	</para>

	<para>
	  All interrupts are modeled (see <xref linkend="sec_uart_interrupts"
	  />), so all bits in the interrupt enable and interrupt control
	  register are modeled.
	</para>

	<para>
	  The modem control and status registers are only modeled to the
	  extent of supporting modem loopback. This is used by some software
	  to determine the nature of the modem (for example in the standard
	  Linux serial line driver).
	</para>

	<para>
	  The line control register sets details of the bit transfers. In a
	  later section (see <xref linkend="sec_sync" />), this will affect
	  the timing of transfers, but it is not relevant to the current
	  untimed model.
	</para>

	<para>
	  In the Line Status Register, the <literal>Data Ready</literal> and
	  <literal>Transmitter Holding Empty</literal>/<literal>Transmitter
	  Empty</literal> bits are the only ones modeled. The model does not
	  distinguish a separate buffer and holding transmit register, so the
	  last two of these will move in step in the model.
	</para>

      </sect3>

      <sect3 id="sec_uart_interrupts">
	<title>
	  &uart; Model Interrupts
	</title>

	<para>
	  All interrupts are modeled, although there is no way to cause a
	  receiver line status interrupt. The modem status interrupt can only
	  be generated when modem loopback is in operation.
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_or1ksim_libext">
      <title>
	 Extending the <classname>Or1ksimSC</classname> Wrapper Module
      </title>

      <para>
	For a larger system, the &or1ksim; wrapper module described in <xref
	linkend="sec_iss_wrapper" />> must be extended. A public function is
	required for peripheral models to establish the CPU endianism.
      </para>

      <para>
	The function must be added to the underlying &or1ksim; library and
	then a wrapper function added to the <classname>Or1ksimSC</classname>
	wrapper module.
      </para>

      <para>
	In <xref linkend="sec_Or1ksimSC_impl_btrans" /> it was noted that the
	absence of any call to <function>wait</function> meant the &or1ksim;
	&iss; could be the only thread in the model. The
	<function>doTrans</function> function must be extended to yield
	after each transaction to allow other threads to run.
      </para>

      <para>
	These extensions are achieved by defining a new
	class, <classname>Or1ksimExtSC</classname> derived from the existing
	<classname>Or1ksimSC</classname> class. It inherits all the
	functionality of the existing class, re-implements that of the transport
	function, <function>doTrans</function> and adds an additional public
	interface function, <function>isLittleEndian</function>.
      </para>
      <sect3 id="sec_or1ksim_extlib">
	<title>
	  Adding an Endianism Test Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function is straightforward, since endianism is a
	  compile time constant in the &or1ksim; &iss;.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_is_le();</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_is_le</function> returns 1 if &or1ksim; is
	      modeling a <firstterm>little&#32;endian</firstterm>
	      architecture, 0 otherwise. It is needed to ensure the payload is
	      packed with the correct byte ordering.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimExtSC</classname> is derived from
	  <classname>Or1ksimSC</classname>, so the definition file includes
	  its header. The module class can then inherit from that class.
	</para>

	<programlisting>#include "Or1ksimSC.h"

class Or1ksimExtSC
: public Or1ksimSC
{</programlisting>

	<para>
	  A custom constructor must be defined. Custom constructors do not
	  inherit, so a new custom constructor is defined just to pass the
	  arguments on to the base class.
	</para>

	<programlisting>  Or1ksimExtSC( sc_core::sc_module_name  name,
                const char              *configFile,
                const char              *imageFile );</programlisting>

	<para>
	  A new public function to report the endianism of the underlying CPU
	  model is defined
	</para>

	<programlisting>bool  isLittleEndian();</programlisting>

	<para>
	  The <function>doTrans</function> is reimplemented here, to allow
	  the thread to yield. The function remains protected and virtual,
	  since it will be redefined again later in this application note.
	</para>

	<programlisting>virtual void  doTrans( tlm::tlm_generic_payload &amp;trans );</programlisting>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Implementation
	</title>

	<para>
	  The constructor just passes its arguments to its base class
	</para>

	<programlisting>Or1ksimExtSC::Or1ksimExtSC ( sc_core::sc_module_name  name,
                             const char              *configFile,
                             const char              *imageFile ) :
  Or1ksimSC( name, configFile, imageFile )
{
 }      // Or1ksimExtSC()</programlisting>

	<para>
	  <function>isLittleEndian</function> is a simple wrapper for the
	  underlying &or1ksim; &iss; library function<footnote>
	    <para>
	      A technicality is that the &or1ksim; library function,
	      <function>is_little_endian</function> returns an
	      <literal>int</literal>, since C does not have a
	      <literal>bool</literal> type. A C++ compiler would automatically
	      convert one to the other, but making the comparison explicit is
	      good for clarity. The same code will be generated, so there is
	      no loss of performance.
	    </para>
	  </footnote>.
	</para>

	<programlisting>bool
Or1ksimExtSC::isLittleEndian()
{
  return (1 == or1ksim_is_le());

}	// or1ksimIsLe()</programlisting>

	<para>
	  The majority of the code for <function>doTrans</function> is
	  unchanged from its implementation in
	  <classname>Or1ksimSC</classname>. The addition is a
	  <function>wait</function> for zero time immediately after the
	  transaction has completed. This allows the &systemc; thread to
	  yield, so that any other threads that are ready can take a turn.
	</para>

	<programlisting>  wait( sc_core::SC_ZERO_TIME );</programlisting>

	<caution>
	  <para>
	    The call to <function>wait</function> is essential. &systemc; is
	    not preemptive. Other threads are only considered for execution
	    when the currently executing thread yields. If the code were to
	    return here, control would pass back to the underlying &or1ksim;
	    &iss; until its next upcall, with no opportunity for another
	    &systemc; thread to execute.
	  </para>

	  <para>
	    The implementation currently is untimed, so a zero delay wait is
	    perfectly acceptable. That just gives all the other untimed
	    threads a turn at execution.
	  </para>

	  <para>
	    The logger described in <xref linkend="sec_iss_wrapper_test" />
	    worked without this call to <function>wait</function>, because
	    it had no thread&mdash;all its functionality was in the blocking
	    transaction callback function.
	  </para>
	</caution>

      </sect3>
    </sect2>

    <sect2>
      <title>
	&uart;: Module Class Definition
      </title>

      <para>
	The &uart; module class, <classname>UartSC</classname> is defined in
	<filename>UartSC.h</filename>. It uses the &tlm2; simple target
	convenience socket (described earlier in <xref
	linkend="sec_iss_wrapper_test" />).
      </para>

      <sect3>
	<title>
	  Headers and Constant Definitions
	</title>

	<para>
	  The header files for &tlm2; and the simple target convenience
	  socket are included.
      </para>

      <programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      <para>
	Convenience constants for the address mask, named register offsets and
	bit fields are then defined. The address mask is needed, since in this
	simple &soc; model there is no arbiter/decoder to strip out the higher
	order bits from the address before the transaction is sent to the
	&uart;.
      </para>

      <programlisting>#define UART_ADDR_MASK      7     // Mask for addresses (3 bit bus)</programlisting>

      <para>
	Named constants are defined giving the address offset of each register
	of the &uart;
      </para>

      <programlisting>#define UART_BUF  0               // R/W: Rx/Tx buffer, DLAB=0
#define UART_IER  1             // R/W: Interrupt Enable Register, DLAB=0
#define UART_IIR  2             // R: Interrupt ID Register
#define UART_LCR  3             // R/W: Line Control Register
#define UART_MCR  4             // W: Modem Control Register
#define UART_LSR  5             // R: Line Status Register
#define UART_MSR  6             // R: Modem Status Register
#define UART_SCR  7             // R/W: Scratch Register</programlisting>

        <para>
	  Bit masks are declared for each of the bits and bit fields of
	  interest in the &uart;. For example the interrupt identification
	  register needs a mask for the pending bit a mask for the two bits
	  representing the highest priority interrupt and a mask for each
	  possible interrupt.
	</para>

	<programlisting>#define UART_IIR_IPEND  0x01    // Interrupt pending (active low)

#define UART_IIR_MASK   0x06    // the IIR status bits
#define UART_IIR_RLS    0x06    // Receiver line status
#define UART_IIR_RDA    0x04    // Receiver data available
#define UART_IIR_THRE   0x02    // Transmitter holding reg empty
#define UART_IIR_MOD    0x00    // Modem status</programlisting>

      </sect3>

      <sect3>
	<title>
	  Class Declaration and Constructor
	</title>

        <para>
	  The main class is a standard &systemc; module class derived from
	  <classname>sc_core::sc_module</classname>.
	</para>

	<programlisting>class UartSC
: public sc_core::sc_module
{</programlisting>

	<para>
	  The module has a customized constructor, specifying an input clock
	  rate (which in the &soc; example will be the &soc; clock rate), and a flag
	  to indicate the endianism of the model.
	</para>

	<programlisting>  UartSC( sc_core::sc_module_name  name,
          unsigned long int        _clockRate,
          bool                     _isLittleEndian );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The interfaces to the &uart; model are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      The simple target convenience socket, <literal>bus</literal>,
	      representing the bus from the CPU;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A byte wide &systemc; buffer
	      (<classname>sc_buffer&lt;unsigned&nbsp;char&gt;</classname>) for
	      the Rx pin; and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A byte wide &systemc; output port
	      (<classname>sc_out&lt;unsigned&nbsp;char&gt;</classname>) for
	      the Tx pin.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  No external port is provided for the interrupt at this stage. That
	  will be added in <xref linkend="sec_linux" />
	</para>

      </sect3>

      <sect3>
	<title>
	  &systemc; Processes
	</title>

	<para>
	  A &systemc; thread is provided <function>busThread</function> to
	  handle transactions arriving on the bus. A &systemc; method,
	  statically sensitive to writes to the Rx buffer is used to handle
	  bytes arriving in the Rx buffer.
	</para>

	<note>
	  <para>
	    Unlike threads, &systemc; methods may not yield by calling
	    <function>wait</function>. A &systemc; method is started when one
	    of its static sensitivities is triggered and runs to
	    completion. It is suitable here, where it runs when a character is
	    received, copying that character to the &uart;
	    <literal>RXBUF</literal> register and then exiting.
	  </para>

	  <para>
	    it is worth using &systemc; methods whenever possible, because
	    they can potentially be implemented more efficiently than threads.
	  </para>
	</note>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The blocking transport callback function is
	  <function>busReadWrite</function>. This in turn calls for two
	  separate functions which implement read specific
	  (<function>busRead</function>) and write specific
	  (<function>busWrite</function>) behavior.
	</para>

      </sect3>

      <sect3>
	<title>
	  Utility Functions
	</title>

	<para>
	  A utility function, <function>modemLoopback</function> determines
	  the state of registers and generates an interrupt in the event of
	  modem loopback being requested (a bit in the modem control
	  register). It is used by the <function>busRead</function> and
	  <function>busWrite</function> functions.
	</para>

	<para>
	  Three utility functions are provided to handle
	  interrupts. <function>setIntrFlags</function> sets the interrupt
	  indication register according to which interrupts are currently
	  pending. <function>genIntr</function> generates an interrupt and
	  <function>clrIntr</function> clears an interrupt. In this
	  implementation these functions ensure all register flags are set
	  correctly but do not drive an external interrupt signal.
	</para>

	<para>

	  A set of convenience utilities are provided to set and clear flags
	  in registers (<function>set</function> and
	  <function>clear</function>) and to test the state of a flag bit in a
	  register (<function>isSet</function> and
	  <function>isClear</function>).
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; State
	</title>

	<para>
	  <classname>struct regs</classname> is used to hold
	  the value of each register. There are ten of these, since register
	  0 is really two registers, depending on whether it is being read
	  (<literal>rbr</literal>) or written (<literal>thr</literal>) and the
	  divisor latch is really an extra 16 bit register.
	</para>

	<programlisting>  struct {
    unsigned char       rbr;            // R: Rx buffer,
    unsigned char       thr;            // R: Tx hold reg,
    unsigned char       ier;            // R/W: Interrupt Enable Register
    unsigned char       iir;            // R: Interrupt ID Register
    unsigned char       lcr;            // R/W: Line Control Register
    unsigned char       mcr;            // W: Modem Control Register
    unsigned char       lsr;            // R: Line Status Register
    unsigned char       msr;            // R: Modem Status Register
    unsigned char       scr;            // R/W: Scratch Register            
    unsigned short int  dl;             // R/W: Divisor Latch
  } regs;</programlisting>

	<para>
	  An additional register, <literal>intrPending</literal>, holds flags
	  (corresponding the interrupt enable register bits) indicating which
	  interrupts are currently pending. A flag initialized at construction
	  records the model endianism, <literal>isLittleEndian</literal>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Notifying the Bus Thread of Transaction Activity
	</title>

	<para>
	  A function is needed for the &tlm2; callback function,
	  <function>busReadWrite</function> to notify the thread handling
	  data being sent for transmission
	  (<function>busThread</function>). This is achieved with a
	  &systemc; event:
	</para>

	<programlisting>  sc_core::sc_event  txReceived;</programlisting>

	<para>
	  The callback function notifies on this event, to trigger behavior in
	  the <function>busThread</function>.
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_impl">
      <title>
	&uart; Module Class Implementation
      </title>

      <sect3>
	<title>
	  &uart; Constructor
	</title>
	
	<para>
	  Implementation of the constructor is preceded, like
	  <classname>Or1ksimSC</classname>, by the &systemc; macro
	</para>

	<programlisting>SC_HAS_PROCESS( UartSC );</programlisting>

	<para>
	  The constructor calls the base class
	  (<classname>sc_module</classname>) constructor to set the module
	  name, saves the endianism flag in its internal state variable and
	  clears the interrupt pending flags. The thread to handle bus I/O is
	  associated with this module.
	</para>

	<programlisting>  SC_THREAD( busThread );</programlisting>

	<para>
	  The method handling data on the Rx buffer is associated with this
	  module with static sensitivity to writes to that buffer. It is not
	  initialized.
	</para>

	<programlisting>  SC_METHOD( rxMethod );
  sensitive &lt;&lt; rx;
  dont_initialize();</programlisting>

        <para>
	  The blocking transport callback is registered for the
	  <literal>bus</literal> socket, in the same manner as was used for
	  the logger, <classname>LoggerSC</classname>.
	</para>

	<programlisting>  bus.register_b_transport( this, &amp;UartSC::busReadWrite );</programlisting>

	<para>
	  Finally the registers (<literal>regs</literal>) are cleared.
	</para>
      </sect3>

      <sect3>
	<title>
	  &uart; Threads
	</title>
	
	<para>
	  <function>busThread</function> sits in a perpetual loop. It first
	  marks the transmit buffer as empty (on reset the flags are cleared,
	  so the buffer will appear full).
	</para>

	<note>
	  <para>
	    The 16450 &uart; describes two flags for transmit buffer status, one
	    to indicate that the transmit holding register is empty and a
	    second to indicate that the internal transmit buffer register is
	    empty.
	  </para>

	  <para>
	    For simplicity, this model does not model a separate internal
	    register (effectively a one byte FIFO), so both flags are set and
	    cleared together.
	  </para>
	</note>

	<para>
	  If the transmit buffer empty interrupt is enabled, the thread
	  generates an interrupt to indicate that the buffer is empty.
	</para>

	<para>
	  The thread then waits until it is notified via the &systemc; event
	  <literal>txReceived</literal> that a byte is in the buffer to be
	  sent. This event will be triggered by the
	  <function>busWrite</function> callback when a value is written into
	  the transmit holding register.
	</para>

	<para>
	  The second thread, <function>rxThread</function> sits in a
	  perpetual loop, waiting for
	  characters to be received on the Rx buffer. The character is read into
	  the read buffer register and the line status data ready flag is set
	  to indicate availability.
	</para>

	<para>
	  If the receive data interrupt is enabled, an interrupt is asserted
	  to indicate data availability.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Blocking Transport Callback
	</title>
	
	<para>
	  The registered callback function is <function>busReadWrite</function>,
	  which breaks out the address, byte enable mask pointer and data
	  pointer. A <literal>switch</literal> statement on the mask is used
	  to determine the offset of the actual byte requested and hence the
	  exact byte address, allowing for the endianism of the model. This
	  also provides a check that only a single byte is being requested.
	</para>

	<programlisting>  switch( *((uint32_t *)maskPtr) ) {
  case 0x000000ff: offset = isLittleEndian ? 0 : 3; break;
  case 0x0000ff00: offset = isLittleEndian ? 1 : 2; break;
  case 0x00ff0000: offset = isLittleEndian ? 2 : 1; break;
  case 0xff000000: offset = isLittleEndian ? 3 : 0; break;

  default:              // Invalid request

    payload.set_response_status( tlm::TLM_GENERIC_ERROR_RESPONSE );
    return;
  }</programlisting>

	<para>
	  In a perfect world, the router/arbiter function would have masked
	  the address to the range handled by the &uart;. However for this
	  simple model, the full address is received, so masking with
	  <literal>UART_ADDR_MASK</literal> is carried out here, to give the
	  address of the &uart; register being read.
	</para>

	<para>
	  Separate functions, <function>busRead</function> and
	  <function>busWrite</function> are used to implement the register
	  specific behavior, selected as appropriate based on the payload
	  command field.
	</para>

	<para>
	  Single byte reads and writes always succeed, so the response is set
	  to <literal>tlm::TLM_OK_RESPONSE</literal> in all cases.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Read Behavior
	</title>
	
	<para>
	  Read behavior is handled by <function>busRead</function>.  A
	  switch on the address is used to identify the result to be returned,
	  usually just the value in the register if it is readable. The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then reads to the first two registers (read buffer and
	      interrupt enable) yield instead the low and high bytes of the
	      divisor latch.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the read buffer (when <literal>DLAB=0</literal>) yields
	      the byte just read, if flag <literal>DR</literal> is set in the
	      line status register. The act of reading causes the
	      <literal>DR</literal> flag and the read buffer full interrupt to
	      be cleared. If no interrupts remain pending then the interrupt
	      pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the interrupt indicator register clears the transmit
	      buffer empty interrupt if it was pending. If no interrupts
	      remain pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the line status register clears any error indications
	      and the receive line status interrupt if it was pending,
	      although the model has no way of setting any of these
	      indications. If no interrupts remain pending, then the interrupt
	      pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the modem status register clears all flags and the modem
	      status interrupt if it was pending. However the modem loopback
	      indication may still be in operation and if so the bits and
	      interrupts are set to indicate the state of the loopback by a
	      call to <function>modemloopback</function>. If no interrupts
	      remain pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	</itemizedlist>
	
      </sect3>

      <sect3>
	<title>
	  &uart; Write Behavior
	</title>
	
	<para>
	  Write behavior is handled by <function>busWrite</function>.  A
	  switch on the address is used to identify the action
	  required. Usually the register is just written (if writable). The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then writes to the first two registers (read buffer and
	      interrupt enable) update the low and high bytes of the
	      divisor latch respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Writing the transmit hold register (when
	      <literal>DLAB=0</literal>) triggers a new transfer. The flags
	      are set to indicate data is in the register, the transmit buffer
	      empty interrupt is cleared, and the bus thread
	      (<function>busThread</function>) notified via the &systemc;
	      event <literal>txReceived</literal>. If no interrupts remain
	      pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      If the modem loopback bit is set by a write to the modem control
	      register, then the modem status bits are set appropriately by a
	      call to <function>modemLoopback</function>. If enabled a modem
	      status interrupt may be generated.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  &uart; Utility Functions
	</title>
	
	<para>
	  <function>setIntrFlags</function> determines the setting of the
	  interrupt identification register according to which interrupts are
	  currently pending (in <literal>intrPending</literal>).
	</para>

	<para>
	  <function>genIntr</function> generates an interrupt by marking the
	  corresponding interrupt as pending if the interrupt is enabled and
	  setting the interrupt identification register flags
	  appropriately. In this implementation, no external signal is
	  generated (see <xref linkend="sec_linux" /> for details of
	  generating an interrupt signal).
	</para>

	<para>
	  <function>clrIntr</function> clears the interrupt pending flag (no
	  need to check if the interrupt is enabled in this case) and sets the
	  appropriate interrupt identification register flags. Again there is
	  no external generated in this implementation.
	</para>

	<para>
	  A set of functions are provided to set, clear and test bits in
	  registers. Using these makes the code much more readable<footnote>
  	    <para>
	      Many programmers use <literal>#define</literal>d macros for
	      functions such as these. However such macros have no
	      encapsulation (they can be used by anyone including the header)
	      and have a nasty habit of clashing with other peoples macros. By
	      using functions, the functions can be made private to the
	      <classname>UartSC</classname> class alone.
	    </para>

	    <para>
	      The functions are declared in line, and a modern C++ compiler
	      will generate code as efficiently as if they had been
	      <literal>#define</literal>d as macros. Indeed the added type
	      information gives the potential for greater optimization.
	    </para>
	  </footnote>.
	</para>

      </sect3>
    </sect2>

  </sect1>

  <sect1 id="sec_terminal">
    <title>
      Adding a Terminal as Test Bench
    </title>

    <para>
      The &or1ksim; &iss; described in <xref linkend="sec_iss_wrapper" /> and
      the &uart; described in described in <xref linkend="sec_uart" /> can be
      put together as a minimal &soc;. However a test bench is needed to
      exercise that &soc;
    </para>

    <para>
      The usual way of exercising a &soc; with a &uart; is to connect a
      terminal to the &uart;. This section describes a suitable &systemc;
      model of a terminal and how to connect it to create the complete &soc;.
    </para>

    <para>
      This is not a &tlm2; component&mdash;the interfaces are standard
      &systemc; buffers, so the description is less detailed. However it serves
      to illustrate an important general technique when using
      &systemc;&mdash;how to interact with the operating system functions.
    </para>

    <para>
      The problem is that many operating system calls block. Consider
      modeling the terminal as a thread which reads characters from a console
      window. This will block until characters are typed. However the block
      does not use the &systemc; <function>wait</function> call, so
      &systemc; is not aware that the thread has yielded. The simulation
      will hang until characters are received.
    </para>

    <para>
      This implementation of the terminal will show how to wrap non-blocking
      versions of operating system functions with &systemc; events, to give
      versions that block correctly using &systemc;
      <function>wait</function>, so allowing the thread to yield.
    </para>

    <sect2>
      <title>
	&systemc; Terminal Module Design
      </title>

      <para>
	The terminal provides &systemc; buffer to model the Rx and a port to
	model the Tx pins of a serial connection. The visualization is
	provided by a &linux; &xterm; running in a child process, with
	communication through a pseudo-TTY<footnote>
	  <para>
	    The description here is specific to &linux;. A future version of
	    this application note will describe use under Microsoft Windows.
	  </para>
        </footnote>.
      </para>

      <para>
	Two &systemc; processes are used, one a method waiting for bytes from
	the UART in the Rx buffer, the other a thread waiting for bytes from
	the &xterm;. When bytes are received in the Rx buffer, they are
	written to the &xterm;. When bytes are received from the &xterm; they
	are written to the Tx port. The key interfaces are shown in <xref
	linkend="fig_terminal" />.
      </para>

      <figure id="fig_terminal">
	<title>
	  &systemc; terminal model using a &xterm; child process.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="terminal.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="terminal.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The difficulty is in waiting for the xterm. As described above,
	reading from the pseudo-TTY is an operating system call, and does not
	use the &systemc; <function>wait</function>, so the thread will not
	yield and the simulation will block. Instead the pseudo-TTY is set up
	to use asynchronous I/O, which will cause a &linux;
	<literal>SIGIO</literal> to be raised whenever data is available to
	read. The event handler for <literal>SIGIO</literal> will then notify
	a &systemc; event, and it is this &systemc; event on which the thread
	can safely wait.
      </para>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Definition
      </title>

      <sect3>
	<title>
	  Mapping Signals to Class Instances
	</title>

	<para>
	  The operating system signal handlers require C style linkage, so
	  cannot be used with C++ member functions (the same issue addressed
	  by the &or1ksim; wrapper in <xref linkend="sec_upcall" />). Thus the
	  <literal>SIGIO</literal> handler will be a static function. However
	  each instance (there could be multiple terminals in a simulation)
	  will have a different file descriptor, which can be used to identify
	  the owning class instance.
	</para>

	<para>
	  The set of mappings from file descriptor to class instance is held
	  in a linked list with static head pointer. The <literal>struct
	  Fd2Inst</literal> is provided for that list, with entries for the
	  file descriptor, instance and a pointer to the next in the list.
	</para>

      </sect3>
      
      <sect3>
	<title>
	  The &systemc; Class
	</title>

	<para>
	  <classname>TermSC</classname> is declared as a standard &systemc;
	  class, with a buffer for bytes coming in, and a port for bytes out
	  (which will connect to a buffer in the &uart;). In this case it has
	  a custom destructor as well as constructor, which will be used to
	  kill the child process running the &xterm; when the class is
	  deleted.
	</para>

      </sect3>

      <sect3>
	<title>
	  Setting up the &xterm;
	</title>

	<para>
	  A set of utility functions are provided to set up the &xterm;. A
	  function, <function>xtermRead</function>, is provided to read from
	  the &xterm; and a function, <function>xtermWrite</function> to write
	  to the &xterm;. Both these functions are blocking on the operating
	  system. The write function should always be able to write with
	  minimal delay. However the read function must only be called when
	  the <literal>SIGIO</literal> signal handler has determined input is
	  available, in order to avoid blocking the &systemc; simulation.
	</para>

	<para>
	  There is some internal state to hold the pseudo-TTY file descriptors
	  and the process ID of the &xterm; (so it can be killed by the
	  destructor). It is the slave file descriptor that is used for both
	  input and output.
	</para>
      </sect3>

      <sect3>
	<title>
	  Signal and event handling
	</title>

	<para>
	  The <literal>SIGIO</literal> signal handler
	  (<function>ioHandler</function>) is declared static as noted
	  above. The static <literal>instList</literal> of type
	  <classname>Fd2Inst</classname> points to the list of mappings from file
	  descriptor to class instance.
	</para>

	<para>
	  The &systemc; event used to signal when input is available is pointed
	  to by <literal>ioEvent</literal>.
	</para>

	<caution>
	  <para>
	    It is essential that the event is declared as a pointer. If the
	    event itself were declared here, it would be available at
	    elaboration, and would crash the system (try it!).
	  </para>

	  <para>
	    The solution is to declare the pointer and allocate the event
	    instance dynamically when the &xterm; is created. The memory can be
	    freed from the destructor on termination.
	  </para>
	</caution>
      </sect3>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Implementation
      </title>

      <para>
	The implementation is a standard &systemc; module communicating via
	the Rx buffer and Tx port. It has a &systemc; method sensitive to
	writes to the Rx buffer and a &systemc; thread listening to the
	&xterm;.
      </para>

      <para>
	The setup of the pseudo-TTYs and the &xterm; in a separate process
	uses standard operating system functions, not described further
	here. The key factor is that the file descriptor for the pseudo-TTY to
	the &xterm; is set up to be asynchronous, with Linux signal
	<literal>SIGIO</literal> raised when input is available and handled by
	the <function>ioHandler()</function> function.
      </para>

      <sect3>
	<title>
	  &systemc; Processes
	</title>

	<para>
	  The method listening to the &uart;, <function>rxMethod</function> is
	  sensitive to writes to the <literal>rx</literal> buffer. When
	  triggered, the character is read from the buffer and immediately
	  copied to the &xterm;. Although this is a blocking operating system
	  write, it should return with minimal delay. In an environment where
	  any blocking were a concern, a non-blocking write could be used
	  instead.
	</para>

	<para>
	  The thread listening to the &xterm;,
	  <function>xtermThread</function> sits in a perpetual loop, waiting
	  on the &systemc; event pointed to by
	  <literal>ioEvent</literal>. This will safely allow the thread to
	  yield to the &systemc; scheduler until a character is ready.
	</para>

	<para>
	  When input is available, the event is notified (see <xref
	  linkend="sec_xterm_sig_hand" />). The thread can safely make an
	  operating system read to get the character, knowing that data is
	  definitely available.
	</para>
      </sect3>
      

      <sect3 id="sec_xterm_sig_hand">
	<title>
	  Signal and event handling
	</title>

	<para>
	  During initialization of the &xterm; the &systemc; event,
	  <literal>ioEvent</literal> is allocated:
	</para>

	<programlisting>  ioEvent = new sc_core::sc_event();</programlisting>

	<para>
	  When <function>ioHandler</function> is called in response to a Linux
	  <literal>SIGIO</literal> event, it does not know which pseudo-TTY
	  was responsible. The file descriptor responsible is identified by
	  using an operating system <function>select</function> call. Using
	  the mappings in <literal>instList</literal>, the corresponding class
	  instance can be identified and its <literal>ioEvent</literal>
	  notified.
	</para>

	<programlisting>  for( Fd2Inst *cur = instList; cur != NULL ; cur = cur->next ) {
    if( FD_ISSET( cur->fd, &amp;readFdSet )) {
      (cur->inst)->ioEvent->notify();
    }
  }</programlisting>

        <para>
	  This event then allows the <function>xtermThread</function> to run
	  and read a character.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>
	The Complete &soc;
      </title>

      <sect3 id="sec_simple_soc_main">
	<title>
	  The Model Main Program
	</title>

	<para>
	  The structure of the main program
	  (<filename>SimpleSoC.cpp</filename>) is similar to that for the
	  logger test program (see <xref linkend="sec_logger_main_prog"
	  />). The &tlm2; header and the headers for each module (&or1ksim;
	  &iss;, &uart; and terminal) are included.
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimExtSC.h"
#include "UartSC.h"
#include "TermSC.h"</programlisting>

	<para>
	  As before the main program (<function>sc_main</function>) takes as
	  arguments the &or1ksim; configuration file and &or1k;
	  image. Instances of the three modules are declared.
	</para>

	<programlisting>  Or1ksimExtSC  iss( "or1ksim", argv[1], argv[2] );
  UartSC        uart( "uart", iss.isLittleEndian() );
  TermSC        term( "terminal" );</programlisting>

	<para>
	  The endianism for the &uart; is set using the public utility function
	  in <classname>Or1ksimExtSC</classname>. The &tlm; sockets of &uart;
	  and &iss; can be connected:
	</para>

	<programlisting>  iss.dataBus( uart.bus );</programlisting>

	<para>
	  The Rx buffer in the &uart; is connected to the Tx port in the
	  terminal and the Rx buffer in the terminal is connected to the Tx
	  port in the &uart;.
	</para>

	<programlisting>  uart.tx( term.rx );
  term.tx( uart.rx );</programlisting>

        <para>
	  The simulation can then be started with a call to
	  <function>sc_start</function>.
	</para>
      </sect3>

      <sect3>
	<title>
	  Test Program to Run on the &or1ksim; &iss;
	</title>

	<para>
	  The test program, <filename>uart_loop.c</filename> is a simple
	  polling loop back driver of the UART. Characters are read and
	  immediately echoed back.
	</para>

	<para>
	  A <literal>volatile</literal> structure is declared for the &uart;
	  registers, with <literal>#define</literal>d constants for the base
	  address and the register bits of interest
	</para>

	<programlisting>#define BASEADDR   0x90000000
#define BAUD_RATE        9600
#define CLOCK_RATE  100000000           // 100 Mhz

struct uart16450
{
  volatile unsigned char  buf;          // R/W: Rx &amp; Tx buffer when DLAB=0  
  volatile unsigned char  ier;          // R/W: Interrupt Enable Register   
  volatile unsigned char  iir;          // R: Interrupt ID Register         
  volatile unsigned char  lcr;          // R/W: Line Control Register       
  volatile unsigned char  mcr;          // W: Modem Control Register        
  volatile unsigned char  lsr;          // R: Line Status Register          
  volatile unsigned char  msr;          // R: Modem Status Register         
  volatile unsigned char  scr;          // R/W: Scratch Register            
};

#define UART_LSR_TEMT   0x40            // Transmitter serial register empty
#define UART_LSR_THRE   0x20            // Transmitter holding register empty
#define UART_LSR_DR     0x01            // Receiver data ready

#define UART_LCR_DLAB   0x80            // Divisor latch access bit
#define UART_LCR_8BITS  0x03		// 8 bit data bits</programlisting>

	<para>
	  The utility functions to set and clear flags in the &uart; (see <xref
	  linkend="sec_uart_impl" />) are reused here, modified for C rather
	  than C++ and <literal>volatile</literal> register arguments. They
	  are included from the file <filename>binutils.c</filename>
	</para>

	<programlisting>#include "bitutils.c"</programlisting>

	<para>
	  The main program declares a pointer to the UART register structure,
	  <literal>uart</literal>, at the base address. Initialization
	  requires setting the divisor latch, to divide the main clock down to
	  16 x the baud rate and setting 8-bit data.
	</para>

	<programlisting>  volatile struct uart16450 *uart = (struct uart16450 *)BASEADDR;
  unsigned short int         divisor;

  divisor = CLOCK_RATE/16/BAUD_RATE;            // DL is for 16x baud rate

  set( &amp;(uart->lcr), UART_LCR_DLAB );           // Set the divisor latch
  uart->buf  = (unsigned char)( divisor       &amp; 0x00ff);
  uart->ier  = (unsigned char)((divisor >> 8) &amp; 0x00ff);
  clr( &amp;(uart->lcr), UART_LCR_DLAB );

  set( &amp;(uart->lcr), UART_LCR_8BITS );		// Set 8 bit data packet</programlisting>

	<para>
	  The remainder of the program is a perpetual loop:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      Wait for a character in the read buffer (flag
	      <literal>DR</literal> of the line status register is set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Read the character from the buffer and print it.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Wait for the transmit buffer to clear (flags
	      <literal>TEMT</literal> and <literal>THRE</literal> of the line
	      status register are set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Write the character back.
	    </para>
	  </listitem>
	</itemizedlist>

	<programlisting>  while( 1 ) {
    unsigned char  ch;

    do {                        // Loop until a char is available
      ;
    } while( is_clr(uart->lsr, UART_LSR_DR) );

    ch = uart->buf;

    simputs( "Read: '" );       // Log what was read
    simputc( ch );
    simputs( "'\n" );

    do {                        // Loop until the transmit register is free
      ;
    } while( is_clr( uart->lsr, UART_LSR_TEMT | UART_LSR_THRE ) );
      
    uart->buf = ch;
  }</programlisting>

      </sect3>

      <sect3 id="sec_simple_soc_run">
	<title>
	  Compiling and Running the Model
	</title>

	<para>
	  Compilation uses the same command lines as the
	  standalone test of the &or1ksim; wrapper with the logger (see <xref
	  linkend="sec_iss_run_test" />), but this time links in the &uart;
	  and terminal; rather than the logger.
	</para>

	<important>
	  <para>
	    Since <classname>Or1ksimExt</classname> is a derived class of
	    <classname>Or1ksim</classname>, linking should include the
	    compiled base class, <filename>Or1ksimSC.o</filename> as well as
	    the derived class, <filename>Or1ksimExtSC.o</filename>.
	  </para>
	</important>

	<para>
	  The &or1ksim; configuration is also unchanged. Like the logger, the
	  &uart; registers start at address 0x90000000 and are 8 bytes long.
	</para>

	<para>
	  Running the model requires specifying the configuration file
	  (unchanged) and the binary executable (this time the &uart; loop
	  back program).
	</para>

	<programlisting>./SimpleSocSC ../simple.cfg progs_or32/uart_loop</programlisting>

	<para>
	  The &xterm; terminal should appear. Select it and type some
	  characters. The window running the model, will show the logged
	  output from the terminal, reporting the same characters being
	  written, as shown in <xref linkend="fig_uart_loopback_log" />.
	</para>

	<figure id="fig_uart_loopback_log">
	  <title>
	    &uart; loop back program log output.
	  </title>

          <screen>$ ./SimpleSocSC ../simple.cfg progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Read: 'F'
Read: 'a'
Read: 'r'

   ... &lt;more Or1ksim output&gt;

Read: '!'
Read: '!'
Read: '!'</screen>
	</figure>

	<para>
	  At the same time the characters will be echoed on the xterm, as
	  shown in figure <xref linkend="fig_uart_loopback_screen" />.
	</para>

	<figure id="fig_uart_loopback_screen">
	  <title>
	    &xterm; with the &uart; loop back program running.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart_xterm.png"
			 format="PNG"
			 width="13.754cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Well it makes a change from "Hello World!".
	</para>

	<para>
	  As an exercise, rebuild the model, removing the call to
	  <function>wait</function> in the
	  <function>Or1ksimExtSC::doTrans</function> function. Observe that
	  the program hangs without accepting any characters. The reason for
	  this is given in the description of <function>doTrans</function>
	  in <xref linkend="sec_uart_or1ksim_libext" />.
	</para>

	<para>
	  A debugger connected to the model will show that execution is stuck
	  in &or1ksim; &iss;, waiting for the data ready flag to be set in the
	  &uart;. This can never occur, since neither &uart; nor terminal are
	  given the chance to execute the threads that would set this flag.
	</para>
      </sect3>

      <sect3>
	<title>
	  Model Timing
	</title>

	<para>
	  This model is completely untimed. It executes the behavior of the
	  design, and for that reason such models are useful in system
	  verification.
	</para>

	<para>
	  The next stages will add timing to this model. To allow this to be
	  demonstrated, add some logging to the &uart; and terminal to report
	  the timing of reads and writes.
	</para>

	<para>
	  Edit the <function>rxThread</function> in
	  <classname>UartSC</classname>, to print out the time when a
	  character is received from the terminal<footnote>
	    <para>
	      The use of <function>printf</function> and C
	      <literal>stdio</literal> is unfortunate. It would be better to
	      use C++ stream IO. However there seems to be an interaction with
	      either &systemc; or the asynchronous IO of the &xterm;, which
	      makes stream IO to standard output unreliable
	    </para>
	  </footnote>.
	</para>

	<programlisting>void
UartSC::rxThread()
{
  // Loop woken up when a character is written into the buffer from the terminal.

  while( true ) {
    regs.rbr  = rx.read();                      // Blocking read of the data

    sc_core::sc_time  now = sc_core::sc_time_stamp();
    printf( "Char read at    %12.9f sec\n", now.to_seconds());

    set( regs.lsr, UART_LSR_DR );               // Mark data ready

    if( isSet( regs.ier, UART_IER_ERBFI ) ) {   // Send interrupt if enabled
      genIntr( UART_IIR_RDI );
    }
  }
}       // rxThread()</programlisting>

	<para>
	  Similarly edit the <function>rxThread</function> in
	  <classname>TermSC</classname>, to print out the time when a
	  character is received from the UART.
	</para>

	<programlisting>void
TermSC::rxThread()
{
  while( true ) {
    unsigned char  ch = rx.read();      // Blocking read from the buffer

    xtermWrite( ch );                   // Write it to the screen

    sc_core::sc_time  now = sc_core::sc_time_stamp();
    printf( "Char written at %12.9f sec\n", now.to_seconds());
  }
}       // rxThread()</programlisting>

	<para>
	  In both cases the C standard IO header will be needed at the top of
	  the file (<filename>UartSC.cpp</filename> and
	  <filename>TermSC.cpp</filename>):
	</para>

	<programlisting>#include &lt;stdio.h&gt;</programlisting>

	<para>
	  The model can now be rerun as before, and will print out precise
	  timing (use of 9 decimal places ensures that granularity at least as
	  fine as the 100MHz CPU clock will be seen). The output is shown in
	  <xref linkend="fig_uart_loopback_log_timed" />.
	</para>

	<figure id="fig_uart_loopback_log_timed">
	  <title>
	    &uart; loop back program log output with timing annotation.
	  </title>

          <screen>$ ./SimpleSocSC ../simple.cfg progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at    0.000000000 sec
Read: 'F'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: 'a'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: 'r'

   ... &lt;Lots more output&gt;
</screen>
	</figure>

	<para>
	  As can be seen all the reads and writes occur at time zero.
	</para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="sec_sync">
    <title>
      Adding Synchronous Timing to the Model
    </title>

    <para>
      The current models are all untimed. In the &tlm2; components
      (<classname>Or1ksimExtSC</classname> and <classname>UartSC</classname>)
      the delay parameter to the blocking transport function has been ignored
      by setting it to zero.
    </para>

    <para>
      In this section, the models are extended to synchronize explicitly with
      the &systemc; clock.
    </para>

    <para>
      The synchronization is not perfect&mdash;the underlying &or1ksim; &iss;
      executes outside the &systemc; world. Synchronization is only possible
      when it makes an upcall for read or write. In <xref
      linkend="sec_temporal_decoupling" /> this model will be further
      extended to add control over the underlying &iss; and its interaction
      with &systemc; time.
    </para>

    <sect2>
      <title>
	Summary of Changes Required for Synchronous Timing
      </title>

      <para>
	Each module of the existing &soc; requires some changes. New classes,
	<classname>Or1ksimSyncSC</classname>,
	<classname>UartSyncSC</classname> and
	<classname>TermSyncSC</classname> are derived from the existing
	classes to provide added functionality. In addition the underlying
	&or1ksim; &iss; library will need extending. the main program will
	need modifying to use these new classes.
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    <classname>Or1ksimSyncSC</classname>. A public function to report
	    the clock rate of the underlying &or1ksim; &iss; is added
	    (requiring an extension to the &or1ksim; library), and the
	    transport function, <function>doTrans</function> modified to add
	    timing information.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>UartSyncSC</classname>. This now models the time taken
	    to put a character out on the Tx wire, so must know its input
	    clock rate (in this &soc;, the &or1ksim; clock rate), so that baud
	    rate can be calculated from the divisor latch. Also models the
	    true time to process a read or write on the bus and returns this
	    with the transaction response.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>TermSyncSC</classname>. This now models the time taken
	    to put a character out to the UART, so must know its baud
	    rate. This requires an updated thread listening to the xterm, so
	    that the baud rate delay can be added.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    &or1ksim; &iss; library. Information functions are added to return
	    the model clock rate (used as input clock rate for the UART) and
	    to determine the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with &systemc;.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A new main program <filename>SyncSocSC.cpp</filename> to build the
	    new classes into a synchronized &soc;. Information functions are
	    added to return the model clock rate (used as input clock rate for
	    the UART) and the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with &systemc;.
	  </para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>
	Extending the <classname>Or1ksimExtSC</classname> Wrapper Module
      </title>

      <sect3 id="sec_or1ksim_libsync">
	<title>
	  Adding Clock Rate and Timing Functions to the &or1ksim; Library
	</title>

	<para>
	  Three additional functions are needed in the &or1ksim; library to
	  support synchronized timing. The &uart; will need to know the clock
	  rate of the model (to work out the baud rate from the value of the
	  divisor latch). The <classname>Or1ksimSyncSC</classname> class
	  itself will need a pair of functions, one to set a timing point in
	  the &iss; the second to return the amount of time since the last
	  timing point. This the amount of time the underlying &iss; has used
	  when synchronizing with &systemc;.
	</para>

	<para>
	  The three additional functions are simple additions. The clock rate is
	  a configuration parameter, while a run time count of instructions
	  executed is already maintained. An extra record in the run-time
	  structure allows a time to be recorded (in seconds through dividing
	  the count by the clock rate), which can be compared in subsequent
	  calls to give the &iss; time used since the last time point<footnote>
	    <para>
	      This is a loosely timed model. The timing from the &iss; is
	      approximate&mdash;it does not model the microarchitecture in
	      detail. Cycle estimates will not be exact&mdash;that requires a
	      fully cycle accurate model.
	    </para>
	  </footnote>.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>unsigned long int  or1ksim_clock_rate();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_clock_rate</function> returns the &or1ksim;
	      &iss; clock rate in Hz. This information will be used by the
	      &uart; to allow it to set its baud rate.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>void  or1ksim_set_time_point();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_set_time_point</function> records the current
	      &iss; simulation time (clock cycles divided by clock rate) in
	      the run-time data structure.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>double  or1ksim_get_time_period();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_get_time_period</function> returns the time
	      in seconds since the last time point was set. This function is
	      needed to keep the &systemc; model of time due to instruction set
	      processing accurate, both in the synchronous &soc; and when
	      temporal decoupling is added.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimSyncSC</classname> is derived
	  from the existing <classname>Or1ksimExtSC</classname> module
	  class. The header of the base class,
	  <classname>Or1ksimExtSC</classname> is included and the new class
	  derived from that base class.
	</para>

        <programlisting>#include "Or1ksimExtSC.h"

class Or1ksimSyncSC
  : public Or1ksimExtSC
{</programlisting>

        <para>
	  A custom constructor must be defined, but has the same arguments as
	  the base class constructor, to which it will pass its arguments.
	</para>

	<para>
	  The new &or1ksim; library call to give the clock rate is wrapped by
	  a public function<footnote>
	    <para>
	      The use of unsigned long int reflects the usage in the &or1ksim;
	      &iss;. The designers do not anticipate usage to model designs in
	      excess of 4GHz!
	    </para>
	  </footnote>.
	</para>

	<programlisting>  unsigned long int  getClockRate();</programlisting>

	<para>
	  The virtual function, <function>doTrans</function> function is
	  reimplemented&mdash;it will replace the call to
	  <function>doTrans</function> in the base class to add timing
	  synchronization.
	</para>

      </sect3>

      <sect3 id="sec_Or1ksimSyncSC_impl">
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor passes its arguments directly to the base class
	  constructor. It then uses the &or1ksim; library function,
	  <function>or1ksim_set_time_point</function> to set an initial time
	  point at the start of simulation. The first call to
	  <function>or1ksim_get_time_period</function> will return the time
	  since the &iss; started.
	</para>

	<para>
	  The <function>doTrans</function> function (which is used for both
	  read and write) is extended from the version used with
	  <classname>Or1ksimExtSC</classname> to synchronize with the &systemc;
	  clock.
	</para>

	<para>
	  There are two components to the time taken in this model, the time
	  taken by the &or1ksim; &iss; and the time taken in any
	  peripherals. At the time of an upcall, the &systemc; wrapper thread
	  will not have yielded control since either initialization or the
	  last upcall, when a time point was set in the &iss; using
	  <function>or1ksim_set_time_point</function>.
	</para>

	<para>
	  A call to <function>or1ksim_get_time_period</function> gives the
	  time used by the &iss; in this period. This is used as the argument
	  to <function>wait</function>, allowing any other threads in the
	  &systemc; world to run until the calculated simulation time is
	  reached.
	</para>

	<programlisting>  wait( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));</programlisting>

	<para>
	  At this time the blocking transport function of the simple initiator
	  socket is called with the payload and specifying a zero time offset
	  (since the call to <function>wait</function> means the thread is
	  synchronized with the &systemc; clock).
	</para>

	<programlisting>  sc_core::sc_time  delay = sc_core::SC_ZERO_TIME;
  dataBus->b_transport( trans, delay );</programlisting>

	<para>
	  On return, the <literal>delay</literal> parameter will have been
	  updated with any additional delay due to the transaction&mdash;in
	  this case an estimate of the number of cycles to read or write the
	  relevant &uart; register.
	</para>

	<para>
	  However, since this is a synchronized model, the target will have
	  called <function>wait</function> to model the time taken to read
	  or write, so <literal>delay</literal> will still be zero on return.
	</para>

	<para>
	  The read or write is now complete. A new time point is set with
	  <function>set_time_point</function> before control is returned to
	  the &iss;
	</para>

	<programlisting>  or1ksim_set_time_point();</programlisting>

        <para>
	  The utility <function>getClockRate</function> is a simple wrapper
	  for the underlying &or1ksim; library function (see <xref
	  linkend="sec_or1ksim_libsync"/>). It will be used in the main
	  program (see <xref linkend="sec_sync_main_prog" />).
	</para>

	<programlisting>unsigned long int
Or1ksimSyncSC::getClockRate()
{
  return or1ksim_clock_rate();

}       // getClockRate()</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_sync">
      <title>
	Extending the <classname>UartSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>UartSyncSC</classname> derived from
	<classname>UartSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	The time taken for the serial pulses (start, data, parity, stop bits)
	on the real &uart; will be modeled as a delay before writing data onto
	the Tx output port. The corresponding delay on the Rx buffer port will
	be modeled by the terminal writing into that port<footnote>
	  <para>
	    This is not the ideal solution. The delay is really a property of
	    the channel, so should be modeled by a derived class of the
	    standard &systemc; buffer which provides a defined delay between
	    data being written and data availability being signaled. The
	    approach used here (transmitter models the delay) represents a
	    practical compromise.
	  </para>
	</footnote>.
      </para>

      <para>
	The &tlm2; socket modeling the bus is extended to model the time taken
	for reads to and writes from the bus.
      </para>

      <sect3>
	<title>
	  <classname>UartSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition (in <filename>UartSyncSC.h</filename>) includes
	  the header of the base class and defines two new constants to
	  represent the delay in reading and writing in nanoseconds.
	</para>

        <programlisting>#define UART_READ_NS       60   // Time to access the UART for read
#define UART_WRITE_NS      60   // Time to access the UART for write</programlisting>

	<para>
	  The class is derived directly from the base class,
	  <classname>UartSC</classname>. A new custom constructor is needed,
	  with an additional parameter specifying the input clock rate. This
	  is used in conjunction with the divisor latch to specify the baud
	  rate.
	</para>

	<programlisting>  UartSyncSC( sc_core::sc_module_name  name,
              unsigned long int        _clockRate,
              bool                     _isLittleEndian );</programlisting>

	<para>
	  The <function>busThread</function> thread is reimplemented to add the
	  timing delay (as a call to <function>wait</function> in
	  transmitting a character as described above.
	</para>

	<para>
	  The blocking transport function, <function>busReadWrite</function>
	  is reimplemented to add in the bus delays in reading and
	  writing. Again this will be achieved by calls to
	  <function>wait</function>, so keeping the model synchronous.
	</para>

	<para>
	  The <function>busWrite</function> must also be reimplemented, since
	  any change to the divisor latch or the line control register (which
	  specifies the bit format being sent on the wire) could affect the
	  baud rate and timing for <function>busThread</function>
	</para>

	<para>
	  A new utility function, <function>resetCharDelay</function> is
	  defined to compute the delay in putting a character on the Tx port
	  from the clock rate, divisor latch and line control register.
	</para>

	<para>
	  Two new member variables are declared, to hold the clock rate and
	  the calculated delay to put a character on the Tx port.
	</para>

      </sect3>

      <sect3>
	<title>
	  <classname>UartSyncSC</classname> Module Class Implementation
	</title>
	  
	<para>
	  The custom constructor passes the name and
	  <literal>_isLittleEndian</literal> flag to the base class
	  constructor. The clock rate is saved in the state variable,
	  <literal>clockRate</literal>.
	</para>

	<programlisting>UartSyncSC::UartSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        _clockRate,
                        bool                     _isLittleEndian ) :
  UartSC( name, _isLittleEndian ),
  clockRate( _clockRate )
{

}       /* UartSyncSC() */</programlisting>

	<para>
	  The new version of <function>busThread</function> adds only one
	  line to the version in the base class. A call to
	  <function>wait(&nbsp;charDelay&nbsp;)</function> is added when the
	  transmit request is received (notified on the &systemc; event,
	  <literal>txReceived</literal>).
	</para>

	<programlisting>    wait( txReceived );                         // Wait for a Tx request
    wait( charDelay );                          // Wait baud delay
    tx.write( regs.thr );                       // Send char to terminal</programlisting>

	<para>
	  The new version of <function>busReadWrite</function> draws most of
	  its functionality from the base class version. However it then
	  synchronizes with a time delay for the read or write access. Since
	  the thread is now synchronous, a time delay of zero is returned with
	  the transaction.
	</para>

	<programlisting>void
UartSyncSC::busReadWrite( tlm::tlm_generic_payload &amp;payload,
                          sc_core::sc_time         &amp;delay )
{
  UartSC::busReadWrite( payload, delay );       // base function

  switch( payload.get_command() ) {
  case tlm::TLM_READ_COMMAND:
    wait( sc_core::sc_time( UART_READ_NS, sc_core::SC_NS ));
    delay = sc_core::SC_ZERO_TIME;
    break;

    &lt;code for write commands etc&gt;
</programlisting>

	<para>
	  The new version of <function>busWrite</function> similarly relies
	  on the base class for most of its functionality.
	</para>

	<programlisting>void
UartSyncSC::busWrite( unsigned char  uaddr,
                      unsigned char  wdata )
{
  UartSC::busWrite( uaddr, wdata );</programlisting>

	<para>
	  However any change to the divisor latch or line control register
	  could change the baud rate or the number of bits in each Tx
	  transmission, and hence the modeled delay to send a character.
	</para>

	<para>
	  The function identifies if this has happened and if so calls
	  <function>resetCharDelay</function> to recalculate the delay.
	</para>

	<programlisting>  switch( uaddr ) {
  case UART_BUF:                // Only change if divisorLatch update (DLAB=1)
  case UART_IER:
    if( isSet( regs.lcr, UART_LCR_DLAB ) ) {
      resetCharDelay();
    }
    break;

  case UART_LCR:
    resetCharDelay();           // Could change baud delay
    break;</programlisting>

	<para>
	  The time taken to put a character on the Tx line is the product of
	  the time taken to put one bit on the line (the inverse of the baud
	  rate) and the bits required for the character (start bit, data bits,
	  optional parity bit, stop bit(s)). The baud rate is determined by
	  the input clock rate and the 16-bit divisor latch.
	</para>
	  
	<note>
	  <para>
	    The divisor latch for a 16450 divides the input clock to yield an
	    internal clock 16x the baud rate (i.e. not the actual baud rate
	    itself)<footnote>
	      <para>
	        The 16450 input clock is specified to a maximum of 24 MHz, so
	        that a 16 bit divisor latch can yield an internal clock for
	        rates down to 50 baud. However for a software model this
	        limitation is ignored. Faster input clocks can be specified,
	        but it will not be possible to configure a 16-bit divisor
	        latch for very low baud rates
	      </para>
	    </footnote>.
	  </para>
	</note>

	<para>
	  The number of bits to send a character is determined by the line
	  control registers. There is always a stop bit, there can be 5-8 data
	  bits, an optional parity bit and 1, 1.5 or 2 stop bits. The
	  <function>resetCharDelay</function> function calculates the total
	  delay.
	</para>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Extending the <classname>TermSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>TermSyncSC</classname> derived from
	<classname>TermSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	As with the &uart; (see <xref linkend="sec_uart_sync" />), the
	terminal will model the time taken to put the bits of a character on
	its Tx port. This mirrors the arrangement with the UART, so when the
	two are connected, delays in both directions are correctly modeled.
      </para>

      <sect3>
	<title>
	  <classname>TermSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>TermSyncSC</classname> is derived from
	  <classname>TermSC</classname>. The header for that class is included
	  and the new class derived from it.
	</para>

	<programlisting>#include "TermSC.h"

class TermSyncSC
  : public TermSC
{</programlisting>

	<para>
	  A new custom constructor is needed, which takes a second argument to
	  specify the baud rate.
	</para>

	<programlisting>  TermSyncSC( sc_core::sc_module_name  name,
              unsigned long int        baudRate );</programlisting>

	<para>
	  The <function>xtermThread</function> thread will be
	  reimplemented. No further derived classes are anticipated, so this
	  function is declared <literal>private</literal> and not marked as
	  <literal>virtual</literal>.
	</para>

	<para>
	  A variable is needed to hold the baud rate. For convenience the
	  class does not hold the baud rate, but the corresponding delay that
	  this represents in sending a character.
	</para>

	<programlisting>  sc_core::sc_time  charDelay;</programlisting>
      </sect3>

      <sect3>
	<title>
	  <classname>TermSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor calls the base class constructor to set the
	  module name. The body of the constructor is calculates the delay due
	  to the baud rate. There is no configurability (this terminal
	  supports 1 start, 8 data, 0 parity and 1 stop bits only), so this is
	  a one off calculation.
	</para>

	<programlisting>TermSyncSC::TermSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        baudRate ) :
  TermSC( name )  
{
  charDelay = sc_core::sc_time( 10.0 / (double)baudRate, sc_core::SC_SEC );

}       /* TermSyncSC() */</programlisting>

	<para>
	  The <function>xtermThread</function> thread is almost identical to
	  the base class version. A single line is added after the character
	  is read from the &xterm; and before it is written to the port
	  to add the modeled baud rate delay.
	</para>

	<programlisting>    int ch = xtermRead();               // Should not block

    wait( charDelay );                  // Model baud rate delay
    tx.write( (unsigned char)ch );      // Send it
</programlisting>

      </sect3>
    </sect2>


    <sect2 id="sec_sync_main_prog">
      <title>
	Main Program for the Synchronous Model
      </title>

      <para>
	As with the untimed &soc; (see <xref linkend="sec_simple_soc_main" />),
	the main program includes the headers for &tlm2; and the component
	modules, but this time using the synchronously timed versions.
      </para>

      <programlisting>#include "tlm.h"
#include "Or1ksimSyncSC.h"
#include "UartSyncSC.h"
#include "TermSyncSC.h"</programlisting>

      <para>
	The baud rate for the terminal is defined as a constant for
	convenience.
      </para>

      <programlisting>#define BAUD_RATE  9600</programlisting>

      <para>
	As before the main program (<function>sc_main</function>) takes as
	arguments the &or1ksim; configuration file and &or1k; image. Instances
	of the three modules are declared, but now have additional
	arguments. The &uart; requires an input clock rate&mdash;obtained from
	the &iss; via the <classname>Or1ksimSyncSC</classname> public utility
	function, <function>getClockRate</function> (see <xref
	linkend="sec_Or1ksimSyncSC_impl" />). The Terminal requires its baud
	rate to be set.
      </para>

      <programlisting>  Or1ksimSyncSC  iss( "or1ksim", argv[1], argv[2] );
  UartSyncSC     uart( "uart", iss.getClockRate(), iss.isLittleEndian() );
  TermSyncSC     term( "terminal", BAUD_RATE );</programlisting>

      <para>
	The remainder of the program, connecting components and starting the
	simulation is identical to the untimed version.
      </para>
	
    </sect2>



    <sect2>
      <title>
	Compiling and Running the Synchronous Model
      </title>

      <para>
	Compilation uses the same command lines as the untimed model (see
	<xref linkend="sec_simple_soc_run" />), but with the synchronized
	versions of the modules and main program.
      </para>

      <important>
	<para>
	  Since <classname>Or1ksimSync</classname> is a derived class of
	  <classname>Or1ksimExt</classname>,
	  <classname>Or1ksimExt</classname>, linking should include the
	  compiled base classes, <filename>Or1ksimSC.o</filename> and
	  <filename>Or1ksimExtSC.o</filename> as well as the derived class,
	  <filename>Or1ksimSyncSC.o</filename>. Similarly the compiled base
	  classes of <classname>UartSyncSC</classname> and
	  <classname>TermSyncSC</classname> should also be included.
	</para>
      </important>

      <para>
	The &or1ksim; configuration is completely unchanged, and the embedded
	code running on the &or1ksim; &iss; is the same
	(<filename>uart_loop</filename>).
      </para>

      <para>
	The command line to run the model is unchanged, but uses the
	synchronized version of the model
      </para>

      <programlisting>./SyncSocSC ../simple.cfg progs_or32/uart_loop</programlisting>

      <para>
	Once again the &xterm; terminal should appear. Select it and type some
	characters. The window running the model, will show the logged output
	from the terminal, reporting the same characters being written and
	timing of the reads and writes. However this time, the time progresses
	as the characters are written, as shown in <xref
	linkend="fig_uart_loopback_sync_log" />.
      </para>

      <figure id="fig_uart_loopback_sync_log">
	<title>
	  &uart; loop back program log output.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.060059107 sec
Read: 'F'
Char written at  0.061114010 sec
Char read at     0.070717297 sec
Read: 'a'
Char written at  0.071772200 sec
Char read at     0.077270287 sec
Read: 'r'
Char written at  0.078325190 sec

   ... &lt;Lots more output&gt;
</screen>
      </figure>

      <para>
	The read timing is as the character leaves the terminal,
	<emphasis>after</emphasis> the terminal has added the baud rate
	delay. The write timing is as the character leaves the &uart; after the
	echo loop in the embedded application on the &or1ksim; &iss; and
	<emphasis>after</emphasis> the &uart; has added the baud-rate
	delay. So the timing from the <emphasis>read</emphasis> message to the
	<emphasis>write</emphasis> message should be the time for the &uart;
	delay for the current baud rate and packet bits plus the execution
	time for the code to echo the character on the &or1ksim; &iss;.
      </para>

      <para>
	The &uart; was initialized to use 1 start bit, 8 data bits and 1 stop
	bit, which at 9600 baud takes around 1040&mu;s. The time shown
	in <xref linkend="fig_uart_loopback_sync_log" /> for the first
	character to be read and written back is 1055&mu;s. This seems
	reasonable, allowing approximately 1500 cycles (15&mu;s at 100MHz) for
	the &or1ksim; &iss; to process the read and write code.
      </para>
    </sect2>
  </sect1>

<sect1 id="sec_temporal_decoupling">
    <title>
      Adding Temporal Decoupling to the Model
    </title>

    <para>
      In this case study temporal decoupling is added to the &tlm2; model of
      an &soc;. The &soc; model with arbiter from the previous example is reused.
    </para>

    <sect2>
      <title>
	What is Temporal Decoupling
      </title>

      <para>
	The idea of temporal decoupling is very simple and has been around for
	a long time (see for example <xref linkend="ref_fitch_88"
	endterm="ref_fitch_88_xr" />). In a parallel system, the various
	threads keep their own local time, and only synchronize when they need
	to communicate with each other.
      </para>

      <para>
	&tlm2; provides some convenience classes to help threads implement
	temporal decoupling. The nomenclature used by these classes can be
	more than a little confusing&mdash;the following should help to
	explain how the technique works.
      </para>

      <para>
	There are two key points about temporal decoupling.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Temporal decoupling is a property of <emphasis>threads</emphasis>,
	    not module classes. So it is each <emphasis>thread</emphasis> that
	    must keep track of its local view of time.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Nothing in the &tlm2; system checks a program is following the
	    rules. It is up to each thread to ensure it is compliant.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Not all threads need use temporal decoupling, although the more that
	do, the greater the potential model efficiency. In general temporal
	decoupling is only appropriate for threads using &tlm2; blocking
	interfaces for their communication&mdash;typically loosely timed
	models. Where temporal decoupling is implemented it is managed by the
	threads driving <emphasis>initiator</emphasis> sockets.
      </para>

      <sect3>
	<title>
	  Timing Concepts
	</title>

	<para>
	  &tlm2; defines four different timing entities to describe temporal
	  decoupling. These are illustrated in <xref
	  linkend="fig_temporal_decoupling" />.
	</para>

	<figure id="fig_temporal_decoupling">
	  <title>
	    Diagram illustrating temporal decoupling
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<variablelist>

	  <varlistentry>
	    <term>
	      (System) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which all threads
		synchronize. For example a <emphasis>Global Quantum</emphasis>
		of 100&mu;s means that all threads synchronize on 100&mu;s
		200&mu;s, 300&mu;s etc. Although the &tlm2; standard refers to
		this as just the Global Quantum, it is a system wide concept
		and for clarity this application note refers to it as the
		<emphasis>System Global Quantum</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      (Thread) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which a particular thread
		synchronizes. The &tlm2; standard allows different threads to
		have their own private time unit of synchronization, which is
		very confusingly also referred to in the standard as the
		Global Quantum.
	      </para>

	      <para>
		To avoid confusion, in this application note, the term
		<emphasis>Thread Global Quantum</emphasis> is used to mean the
		global quantum used by a particular thread.
	      </para>

	      <para>
		Having different values for the global quantum in different
		threads is a recipe for complete confusion, while offering few
		advantages. The user is strongly recommended to set the Thread
		Global Quantum to the same value as the System Global Quantum
		when the thread is created and not change it.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Quantum
	    </term>

	    <listitem>
	      <para>
		For each thread, this represents the time remaining from the
		current &systemc; time (as returned by
		<function>sc_time_stamp</function>) until the end of the
		current Thread Global Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 235&mu;s and
		the Thread Global Quantum is 100&mu;s, then the Local Quantum
		will be 65&mu;s&mdash;the time until the 300&mu;s Thread Global
		Quantum synchronization is due.
	      </para>

	      <para>
		If the recommendation that all threads set their Thread Global
		Quantum to be the same as the System Global Quantum is
		followed, then the value of the Local Quantum will be the same
		in all threads.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Time Offset
	    </term>

	    <listitem>
	      <para>
		Each thread is allowed to hold a local view of time, which runs
		ahead of the current &systemc; time. This is known as
		the <emphasis>Local Time Offset</emphasis>
	      </para>

	      <para>
		The Local Time Offset must not take the thread's local view of
		time past the next Thread Global Quantum, i.e. it cannot exceed
		the Local Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 235&mu;s and
		the Thread Global Quantum is 100&mu;s, then a local time offset
		of 45&mu;s would represent a thread local effective time of
		280&mu;s.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

      </sect3>

      <sect3>
	<title>
	  The Global Quantum Class,
	  <classname>tlm_global_quantum</classname>
	</title>

	<para>
	  &tlm2; defines a <firstterm>singleton</firstterm> class<footnote>
	    <para>
	      A singleton is a class of which only one instance can be
	      created. The constructor is declared private (so no other class
	      can create it), and a static function is provided to return the
	      single instance. This static function will create the single
	      instance the first time it is called, and thereafter just return
	      a reference to that same instance.
	    </para>

	    <para>
	      Singleton classes are useful for holding centrally required
	      values and providing centrally required functions in a system,
	      where having duplicate provision would lead to incorrect
	      behavior.
	    </para>
	  </footnote> which can be used to hold the system global quantum. A
	  set of functions to manipulate the global quantum are provided.
	</para>

	<variablelist>

	  <varlistentry>
	    <term>
	      <function>instance</function>
	    </term>
	    <listitem>
	      <para>
		Returns a reference to the singleton global quantum object
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>set</function>
	    </term>
	    <listitem>
	      <para>
		Sets the global quantum (as a &systemc;
		<classname>sc_time</classname> object)
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>get</function>
	    </term>
	    <listitem>
	      <para>
		Returns the value of the global quantum
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>compute_local_quantum</function>
	    </term>
	    <listitem>
	      <para>
		Returns the local quantum, i.e. the time from the current
		&systemc; time stamp to the next multiple of the global
		quantum.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The intention is that at start up the main program should set the
	  system global quantum in the singleton
	  <classname>tlm_global_quantum</classname> object. All threads can then
	  set their thread global quantum by getting the value from the
	  <classname>tlm_global_quantum</classname> object.
	</para>

      </sect3>


      <sect3>
	<title>
	  &tlm2; Quantum Keepers
	</title>

	<para>
	  &tlm2; provides a utility class for threads to keep track of their
	  thread global quantum, local quantum and local time offset. This is
	  in the <literal>tlm_utils</literal> namespace (like the convenience
	  sockets) with a header in
	  <filename>tlm_utils/tlm_quantumkeeper.h</filename>.
	</para>

	<para>
	  A module will instantiate one quantum keeper for each thread that is
	  uses temporal decoupling, initializing them in the constructor.
	</para>

	<para>
	  Two functions are provided to manage the thread global quantum:
	  <function>set_global_quantum</function> to set the value and
	  <function>get_global_quantum</function>. Typically a module
	  constructor will get the <emphasis>system</emphasis> global quantum
	  with a call to the singleton
	  <classname>tlm_global_quantum</classname> and immediately use that
	  to set the thread global quantum for each thread's quantum
	  keeper.
	</para>

	<para>
	  One function is provided to manage the local quantum. The
	  <function>reset</function> function calls
	  <function>compute_local_quantum</function> to calculates the local
	  quantum from the time stamp and the global quantum (which is done by
	  calling the <function>compute_local_quantum</function> in the
	  singleton <classname>tlm_global_quantum</classname> object) and sets
	  the local time offset to zero.
	</para>

	<para>
	  Typically a constructor will call <function>reset</function> for
	  each thread immediately after setting the thread global
	  quantum. The <function>compute_local_quantum</function> in the
	  quantum keeper is <literal>protected</literal>, so cannot be called
	  directly (which seems to be an omission). If the value of the local
	  quantum is needed, this can be obtained using the
	  <function>compute_local_quantum</function> function in the
	  singleton <classname>tlm_global_quantum</classname> object.
	</para>

	<para>
	  Four functions are provided to manage the local time
	  offset. <function>set</function> sets the local time offset to a
	  particular value, <function>inc</function> increments by a given
	  value and <function>get_local_time</function> returns the current
	  value of the local time
	  offset. <function>get_current_time</function> computes the local
	  effective time, i.e. the &systemc; time stamp plus the local time
	  offset<footnote>
	    <para>
	      The naming is not
	      consistent. <function>get_local_time</function> should have
	      been just <function>get</function> for consistency with
	      <function>set</function> and
	      <function>inc</function>.
	      <function>get_current_time</function> would be better named
	      <function>get_effective_time</function>, to match its
	      description in the standard.
	    </para>
	  </footnote>. The intention is that a thread advances model time, it
	  will call <function>set</function> and <function>inc</function>
	  to update the local decoupled view of time.
	</para>

	<para>
	  Two functions are provided to handle synchronization. The test
	  <function>need_sync</function> returns true if the local time offset
	  exceeds the local quantum. <function>sync</function> calls
	  <function>wait</function> for the local time offset, synchronizing
	  the thread with the global &systemc; view of time, and allowing
	  other threads to catch up. It then calls <function>reset</function>
	  to update the local quantum and zero the local time
	  offset. <function>sync</function> should always be called when
	  <function>need_sync</function> is true, but may be called at any
	  other time if required.
	</para>

      </sect3>

      <sect3>
	<title>
	  Other Styles of Temporal Decoupling
	</title>

	<para>
	  &tlm2; presents one model of temporal decoupling, with an explicit
	  regular synchronization time.
	</para>

	<para>
	  Other temporal decoupling models can build on the &tlm2;
	  infrastructure, for instance to remove the regular synchronization
	  time, and instead only synchronize when the local time offset
	  reaches some prescribed maximum. A class derived from the
	  <classname>tlm_gatekeeper</classname> class can modify the control
	  and synchronization functions, to allow different approaches to be
	  tried.
	</para>
      </sect3>



    </sect2>

    <sect2>
      <title>
	Guidelines for Using &tlm2; Temporal Decoupling
      </title>

      <para>
	Temporal decoupling is not for use everywhere. These guidelines may help.
      </para>

      <orderedlist>

	<listitem>
	  <para>
	    Use temporal decoupling for models based on blocking transactions,
	    as used for loosely timed models. There is no obvious value to
	    temporal decoupling in non-blocking models.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Only apply temporal decoupling to threads that are communicating
	    via &tlm2; transactions. Other &systemc; protocols (for example
	    via FIFO) have no way of communicating delays between threads (the
	    equivalent of the delay parameter in &tlm2; transport functions).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Let the thread controlling the initiator manage the temporal
	    decoupling and synchronization. Targets should just return the
	    incremented delay, and avoid synchronizing if possible.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Allocate one quantum keeper for each thread that drives an
	    initiator socket and is implementing temporal decoupling.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Ensure that the thread global quantum is always the same as the
	    system global quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Select a global quantum that is small enough not to swamp timing
	    behavior of the system. For example in the &soc; used in this
	    application note, the finest time granularity that matters is the
	    time to put a character over a 9600 baud link, approximately
	    1ms. A time around 10-50% of this would be a reasonable time to
	    use as a global quantum.
	  </para>
	</listitem>
      </orderedlist>

    </sect2>

    <sect2>
      <title>
	Temporal Decoupling the &or1ksim; Wrapper Class
      </title>

      <para>
	The only thread that can be decoupled in the current model is the
	&or1ksim; wrapper class, <classname>Or1ksimSyncSC</classname>, since
	it is the only thread with a &tlm2; initiator socket.
      </para>

      <para>
	&iss; are natural candidates for temporal decoupling, since they often
	can run large blocks of code without any need for hardware
	interaction. This is particularly important for modern compiling &iss;
	(e.g ARM <application>SystemGenerator</application>, ARC
	<application>xISS</application>), which achieve their performance by
	executing thousands of instructions at a time.
      </para>

      <para>
	The changes needed to add temporal decoupling are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Change the main thread, <function>run</function> so that it only
	    tries to execute instructions up to the end of the current global
	    quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Change the upcall transport function,
	    <function>doTrans</function>, so that it increments the local
	    time offset, rather than synchronizing via
	    <function>wait</function>/
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Updates to the &or1ksim; &iss; library to support running to a
	    fixed time time point.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	A new class, <classname>Or1ksimDecoupSC</classname> is derived from
	<classname>Or1ksimSyncSC</classname> to implement the required
	functionality.
      </para>

      <sect3>
	<title>
	  Adding a Function to the &or1ksim; Library to Support Temporal
	  Decoupling
	</title>

	<para>
	  One additional function is needed in the &or1ksim; library to
	  support temporal decoupling. The <function>or1ksim_run</function>
	  already allows the user to specify a duration for which the
	  simulation will run. A function, is added to change the duration of a
	  run already in progress.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>void  or1ksim_reset_duration( double duration );</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_reset_duration</function> resets the
	      duration of a call to <function>or1ksim_run</function> which
	      is already in progress. The argument is the duration for which
	      the run should continue <emphasis>from the current
	      time</emphasis> (i.e. not from the time of the original call to
	      <function>or1ksim_run</function>).
	    </para>

	    <para>
	      This function is needed because upcalls may lead to a
	      synchronization, increasing the time for which the &iss; may run
	      before needing resynchronization.
	    </para>
	  </listitem>

	</itemizedlist>
	<para>
	</para>

      </sect3>


      <sect3>
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimDecoupSC</classname> is derived
	  from <classname>or1ksimSyncSC</classname>, whose header it
	  includes. A custom constructor is defined with the same arguments as
	  the base class constructor.
	</para>

	<para>
	  The &iss; thread, <function>run</function> and the transport
	  function, <function>doTrans</function> are both reimplemented to add
	  temporal decoupling.
	</para>

	<para>
	  A quantum keeper for the &iss; thread, <literal>issQk</literal> is
	  defined.
	</para>

	<programlisting>  tlm_utils::tlm_quantumkeeper  issQk;</programlisting>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class,
	  <classname>Or1ksimSyncSC</classname>. The quantum keeper for the
	  &iss; thread is then initialized with the system global quantum and
	  the local quantum calculated and local time offset zeroed with a
	  call to <function>reset</function>.
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  issQk.set_global_quantum( refTgq.get() );
  issQk.reset();</programlisting>

	<note>
	  <para>
	    The global quantum accessor function,
	    <function>instance</function> returns a reference to the global
	    quantum. Ensure that it is assigned to a reference variable
	    (declared as <literal>&amp;refTgq</literal> here) of type
	    <classname>tlm::tlm_global_quantum</classname>. Use of a plain
	    variable would be valid code, but make a <emphasis>copy</emphasis>
	    of the quantum keeper, so subsequent calls to
	    <function>set</function> would not actually set the singleton
	    instance. An example of the dangers of reference variables in C++
	    and why singleton accessors should return pointers, not
	    references.
	  </para>
	</note>

	<para>
	  The main thread function, <function>run</function> is reimplemented
	  to ensure that &iss; simulation does not run past the end of the
	  current quantum. Instead of running for ever
	  (<function>or1ksim_run(&nbsp;-1.0&nbsp;);</function>), the &iss; is
	  run for the local time quantum, less the local time offset. This
	  means the &iss; will return exactly at the point when it should need
	  to synchronize again.
	</para>

	<para>
	  Since the local quantum is only available through the singleton
	  <classname>tlm::tlm_global_quantum</classname> a reference to that
	  instance is obtained for use throughout this function:
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();</programlisting>

	<para>
	  The body of the program is a perpetual loop, which calculates the
	  time left until the next global quantum then calls the &iss; for that
	  period.
	</para>

	<programlisting>  while( true ) {
    sc_core::sc_time  timeLeft =
      refTgq.compute_local_quantum() - issQk.get_local_time();</programlisting>

	<para>
	  On return, <function>or1ksim_get_time_period</function> is used to
	  find out how much computation has actually been carried out and
	  advance local time accordingly. This may be different to the
	  duration requested, since an upcall may set a new time point and
	  adjusted the duration. A new time point is immediately set ready for
	  the next loop.
	</para>

	<programlisting>    (void)or1ksim_run( timeLeft.to_seconds() );

    issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
    or1ksim_set_time_point();</programlisting>

	<para>
	  If the local time offset has reached the end of the global quantum,
	  the thread synchronizes.
	</para>

	<programlisting>    if( issQk.need_sync() ) {
      issQk.sync();</programlisting>

	<para>
	  The transport function, <function>doTrans</function> has the same
	  structure as the synchronous version in the base class. However
	  instead of calling <function>wait</function> to delay calculation,
	  it updates the local time offset. The time offset is advanced for
	  the &iss; simulation since the last time point and a new time point
	  is set.
	</para>

	<programlisting>  issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
  or1ksim_set_time_point();</programlisting>

	<para>
	  The delay argument to the blocking transport is the local time
	  offset. This may be increased by the target (to model read/write
	  delay), and the new value becomes the local time offset on return.
	</para>

	<programlisting>  sc_core::sc_time  delay = issQk.get_local_time();
  dataBus->b_transport( trans, delay );
  issQk.set( delay );</programlisting>

	<para>
	  At this point synchronization could be required&mdash;the read/write
	  delay could have pushed the local time offset past the global
	  quantum.
	</para>

	<programlisting>  if( issQk.need_sync() ) {
    issQk.sync();
  }</programlisting>

	<para>
	  The duration remaining for the &iss; simulation is reset in the same
	  way as in the main thread to be the local quantum less the local
	  time offset. On return the &iss; will continue for that period.
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  sc_core::sc_time  timeLeft      =
    refTgq.compute_local_quantum() - issQk.get_local_time();

  or1ksim_reset_duration ( timeLeft.to_seconds() );</programlisting>

      </sect3>


    </sect2>

    <sect2>
      <title>
	Modifying the &uart; to Support Temporal Decoupling
      </title>

      <para>
	Although the threads in the &uart; class are not temporarily
	decoupled, a small modification is needed. The callback for the target
	socket is part of this class, and it must handle delay data for the
	initiator in <classname>Or1ksimDecoupSC</classname> suitably.
      </para>

      <para>
	A new class, <classname>UartDecoupSC</classname>, derived from
	<classname>UartSyncSC</classname> is defined to provide a modified
	&tlm2; convenience target socket blocking callback function.
      </para>

      <sect3>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition includes the header of the base class and is
	  derived from it. The constructor has the same parameters as the base
	  class, <classname>UartSyncSC</classname>.
	</para>

	<para>
	  A reimplemented version of the &tlm2; convenience callback,
	  <function>busReadWrite</function> is defined with the same
	  parameters as the base class function.
	</para>
      </sect3>

      <sect3>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor just calls the base class constructor, passing on all
	  its arguments.
	</para>

	<para>
	  The <function>BusReadWrite</function> callback has the same
	  structure as the version in the base class. Like the base class
	  it calls the original <classname>UartSC</classname> version to carry
	  out most of the functionality.
	</para>

	<caution>
	  <para>
	    The call is therefore to the <emphasis>base class of the base
	    class</emphasis> of this class. The call cannot be to the base
	    class, since that would call <function>wait</function>,
	    defeating the temporal decoupling.
	  </para>
	</caution>

	<para>
	  The difference is in updating the delay. The synchronous base class
	  waited to model the timing delay and set the delay in the response
	  to zero. In this version the code just increments the delay (which
	  is the local time offset) by the additional time to carry out the
	  read or write.
	</para>

	<programlisting>  switch( payload.get_command() ) {

  case tlm::TLM_READ_COMMAND:
    delay += sc_core::sc_time( UART_READ_NS, sc_core::SC_NS );
    break;</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_temp_decoup_main">
      <title>
	Main Program for Temporal Decoupling
      </title>

      <para>
	The main program, <filename>DecoupSocSC.cpp</filename> is similar in
	structure to the main program used for the synchronous version (see
	<xref linkend="sec_sync_main_prog" />). This time the headers for the
	versions of the &or1ksim; wrapper and &uart; implementing temporal
	decoupling are used and the time to use as the global quantum is
	defined as a parameter.
      </para>

      <programlisting>#include "Or1ksimDecoupSC.h"
#include "UartDecoupSC.h"
#include "TermSyncSC.h"

#define QUANTUM_US   100</programlisting>

      <para>
	Before any modules are instantiated, the system global quantum must be
	set. For the initial version a value of 100&mu;s is selected, 10% of
	the time taken to transmit a character at 9600 baud, so there should
	be no awkward timing interactions.
      </para>

      <programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  refTgq.set( sc_core::sc_time( QUANTUM_US, sc_core::SC_US ));</programlisting>

      <para>
	Thereafter the program follows the same structure (but using the
	versions of the &or1ksim; wrapper and &uart; with temporal
	decoupling).
      </para>

    </sect2>

    <sect2>
      <title>
	Compiling and Running the Synchronous Model
      </title>

      <para>
	Compilation is very similar to that of the synchronous model. The
	binaries of <emphasis>all</emphasis> the base classes are included
	when linking.
      </para>

      <para>
	The same configuration file and &or1k; compiled image is used to run
	the model with temporal decoupling.
      </para>

      <programlisting>$ ./DecoupSocSC ../simple.cfg progs_or32/uart_loop</programlisting>

      <para>
	The results look very similar to those for the synchronized version,
	as shown in <xref
	linkend="fig_uart_loopback_decoup_log" />.
      </para>

      <figure id="fig_uart_loopback_decoup_log">
	<title>
	  &uart; loop back program log output with temporal decoupling.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.381741687 sec
Read: 'F'
Char written at  0.382841620 sec
Char read at     0.494341667 sec
Read: 'a'
Char written at  0.495441600 sec
Char read at     0.597841677 sec
Read: 'r'
Char written at  0.598941610 sec

   ... &lt;Lots more output&gt;
</screen>
      </figure>

      <para>
	The timing reported for the first character, 'F', is
	1100&mu;s&mdash;in the synchronized version it was 1055&mu;s. The
	global quantum was set to 100&mu;s, which means that other threads may
	have a delay of up to 100&mu;s before they can run, affecting the time
	they will report for their actions.
      </para>

      <para>
	If the quantum is changed from 100&mu;s to 10ms, the change is more
	dramatic, as shown in  <xref
	linkend="fig_uart_loopback_decoup_10ms_log" />.
      </para>

      <figure id="fig_uart_loopback_decoup_10ms_log">
	<title>
	  &uart; loop back program log output with temporal decoupling and
	  10ms global quantum.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.091041667 sec
Read: 'F'
Char written at  0.101041600 sec
Char read at     0.101041667 sec
Read: 'a'
Char written at  0.111041620 sec
Char read at     0.111041687 sec
Read: 'r'
Char written at  0.121041600 sec

   ... &lt;Lots more output&gt;
</screen>
      </figure>

      <para>
	The time taken to write the first character is now 9,999&mu;s,
	completely dominated by the quantum. The typing of characters at the
	xterm is notably sluggish.
      </para>

      <para>
	This is characteristic of loosely timed models with temporal
	decoupling. The objective is to model the gross behavior of the system
	with a reasonable view of the timing, such that events happen in the
	correct sequence. However detailed timing can be sacrificed in the
	interest of greater model performance.
      </para>

      <para>
	The value for the global quantum is a subjective choice. In this case,
	with a busy polling &uart; loop back function, any delays were wasted
	in additional polling cycles, so a small quantum was appropriate.
      </para>

      <para>
	In a more realistic scenario, the &uart; would be interrupt driven (or
	at least not polled continuously). Very likely the &uart; would only
	be lightly used, while other parts of the system were working. Under
	such circumstances, a global quantum of 100-500&mu;s (10%-50% of the
	time to put one character on the &uart;) would be reasonable. The
	timing of characters output would be out by up to 100%, but the model
	would gain from fewer synchronizations.
      </para>

      <para>
	In other scenarios an even higher quantum could be justified&mdash;for
	example if the &uart; were only for occasional diagnostic output,
	where sluggishness did not matter. However when modeling a 100MHz
	&iss; as part of the &soc;, the benefits of such large global quantum
	values would be minimal.
      </para>

      <para>
	Beware that an excessively large quantum may break software with
	timing dependencies. It may mean that interrupt sequences do not
	arrive in a reasonable order, or flood in all at once. An example of
	this is shown in <xref linkend="sec_linux" />.
      </para>

      <para>
	The other step to take to improve performance would be to move to an
	exclusively &tlm2; model. The &systemc; buffer is a good way to model
	the &uart; to terminal connection. However by using a &tlm2; socket in
	each direction, the &uart; could adopt temporal decoupling, giving
	further performance improvement.
      </para>

    </sect2>
  </sect1>

  <sect1 id="sec_linux">
    <title>
      Modeling Interrupts and Running Linux on the Example &soc;
    </title>

    <para>
      The Simple &soc; used in the previous sections is not sufficient to run
      Linux. Two significant extensions are needed.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Memory management must be added to support Linux virtual
	  memory. This is provided by enabling the internal MMUs (instruction
	  and data) of the &or1ksim; &iss;.
	</para>
      </listitem>

      <listitem>
	<para>
	  The &systemc; &uart; peripheral must be extended to handle
	  interrupts.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The example design was shown in <xref linkend="soc_example_soc_intr"/>,
      but for convenience the diagram is repeated here in <xref
      linkend="fig_simple_soc_intr2" />.
    </para>

    <figure id="fig_simple_soc_intr2">
      <title>
	Simple &soc; based on the &or1k; &or1ksim; with interrupts and MMU
	enabled.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      Enabling memory management is a matter of modifying the configuration
      file for &or1ksim;. The Linux port used here expects to boot from flash
      memory, so the internal memory of &or1ksim; is also extended to provide
      this.
    </para>

    <para>
      The &uart; model, <classname>UartDecoupSC</classname> is further
      extended by a new derived class, <classname>UartIntrSC</classname>
      providing a &systemc; <classname>sc_out&lt;bool&gt;</classname> port
      through which the interrupt signal is driven.
    </para>

    <sect2>
      <title>
	Extending the <classname>Or1ksimDecoupSC</classname> Module Class
      </title>

      <para>
	The &or1ksim; &iss; library is extended to provide an
	<acronym>API</acronym> call to generate an interrupt. The &or1ksim;
	includes a programmable interrupt controller
	(<firstterm>PIC</firstterm>), which is enabled. The new
	<acronym>API</acronym> call, <function>or1ksim_interrupt</function>,
	takes as parameter the interrupt number to be triggered.
      </para>

      <para>
	The &or1ksim; wrapper, <classname>Or1ksimDecoupSC</classname> is further
	extended by a new derived class, <classname>Or1ksimIntrSC</classname>,
	which provides an array of signal ports to connect to external devices
	which wish to generate interrupts.
      </para>

      <sect3>
	<title>
	  Adding an Interrupt Generation Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function allows the external &systemc; model to call
	  into the &or1ksim; &iss; to request an interrupt. The &iss; requires
	  that interrupts are not taken mid-instruction (for example while a
	  peripheral memory access upcall is in progress), so a flag is set
	  internally, allowing the &iss; to trigger the interrupt at the start
	  of the next instruction.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>void or1ksim_interrupt( int  i );</programlisting>
	    </para>
	    
	    <para>
	      <function>void or1ksim_interrupt</function> requests the the
	      interrupt given by its argument be taken at the start of the
	      next instruction cycle.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimIntrSC</classname> is
	  derived from the existing <classname>Or1ksimDecoupSC</classname>
	  module class, whose header, <filename>Or1ksimDecoupSC.h</filename>,
	  is included. The number of interrupts to be supported is given by
	  the constant, <literal>NUM_INTR</literal>.
	</para>
	
	<programlisting>#define  NUM_INTR  32</programlisting>

	<para>
	  The new class derived from the base class and a custom constructor
	  defined. The possible interrupts are represented by an array of
	  <classname>sc_signal</classname>.
	</para>

	<programlisting>  sc_core::sc_signal&lt;bool&gt;  intr[NUM_INTR];</programlisting>

	<tip>
	  <para>
	    It would have been possible to define an array of signal input
	    ports, <classname>sc_in&lt;bool&gt;</classname>. However these
	    ports must then be explicitly connected (bound), requiring tie-off
	    signals to be created in the main program.
	  </para>

	  <para>
	    By creating actual signals, interrupts that are unused can be left
	    unbound and ignored.
	  </para>
	</tip>

	<para>
	  A &systemc; method is required to handle the interrupts (since it
	  never waits, a thread is not needed). This can respond to interrupts
	  in parallel with the main &iss; execution thread.
	</para>

	<programlisting>  void  intrMethod();</programlisting>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class constructor
	  for processing. It then sets up <function>intrMethod</function> as a
	  &systemc; method process, sensitive to the positive edge of each
	  interrupt signal. There is no need to initialize this function.
	</para>

	<programlisting>  SC_METHOD( intrMethod );
  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    sensitive &lt;&lt; intr[i].posedge_event();
  }
  dont_initialize();</programlisting>
	
	<para>
	  The interrupt method is triggered by a positive edge on one of the
	  signals. It loops through to find which interrupt was triggered and
	  generates a call to <function>or1ksim_interrupt</function> for that
	  interrupt number. In principle more than one could be triggered in the
	  same cycle, so all are checked.
	</para>

	<programlisting>  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    if( intr[i].event()) {
      or1ksim_interrupt( i );
    }
  }</programlisting>

      </sect3>
    </sect2>


    <sect2>
      <title>
	Extending the <classname>UartDecoupSC</classname> Module Class
      </title>

      <para>
	The existing &uart; module processes interrupts, but does not generate
	an external interrupt signal. To generated an interrupt signal,
	<classname>UartDecoupSC</classname> is further extended by a new
	derived class, <classname>UartIntrSC</classname>, which provides a
	signal port and a new thread to drive that signal port
      </para>

      <para>
	An extra thread is required, because both the
	<function>rxMethod</function> and <function>busThread</function>
	processes may wish to drive signals, but &systemc; requires that a
	signal is driven by a single process. Just as in hardware design a
	simple wire would not normally have more than one driver.
      </para>

      <para>
	The new process communicates with the existing processes via a FIFO
	internal to the UART, allowing <function>rxMethod</function> and
	<function>busThread</function> to both request interrupt activity
	and for those requests to be processed in the order they were
	generated.
      </para>

      <sect3>
	<title>
	  <classname>UartIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>UartIntrSC</classname> is
	  derived from the existing <classname>UartDecoupSC</classname>
	  module class, whose header, <filename>UartDecoupSC.h</filename>,
	  is included.
	</para>

	<para>
	  A custom constructor is declared, and a signal output port,
	  <literal>sc_out&lt;bool&gt; intr</literal> through which the
	  interrupt will be driven.
	</para>

	<para>
	  The new thread, <function>intrThread</function> is declared. It
	  will use re-implemented versions of the <function>genIntrr</function>
	  and <function>clrIntr</function> functions from the base class,
	  <classname>UartSC</classname>.
	</para>

	<para>
	  A Boolean FIFO is used to hold the queue of requests from the
	  existing processes, <function>rxMethod</function> and
	  <function>busThread</function>.
	</para>

	<programlisting>  sc_core::sc_fifo&lt;bool&gt;  intrQueue;</programlisting>

      </sect3>

      <sect3>

	<title>
	  <classname>UartIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  Since this class declares a new &systemc; process,
	  <literal>SC_HAS_PROCESS</literal> is used. The constructor passes
	  its arguments to the base class,
	  <classname>UartDecoupSC</classname> and sets the FIFO queue size to 1.
	</para>

	<programlisting></programlisting>

	<note>
	  <para>
	    The choice of FIFO size means that there should be only one
	    request for interrupt pending. In principle this could block an
	    attempt by the <function>rxMethod</function> to write to the FIFO,
	    and since &systemc; methods may not wait (unlike threads) a
	    run time error will occur.
	  </para>

	  <para>
	    This is an explicit model design decision. If there is interrupt
	    congestion, then it would be useful to know&mdash;indicating
	    design issues over the UART capacity. If this were not an issue,
	    then it would be quite valid to use a larger FIFO capacity.
	  </para>
	</note>

	 <para>
	   The constructor then creates the new &systemc; method for
	   <function>intrThread</function>.
	 </para>

	 <para>
	   <function>intrThread</function> has a very simple
	   <acronym>API</acronym>. If <literal>true</literal> is read it
	   asserts an interrupt (drives the interrupt port
	   <literal>true</literal>), otherwise it deasserts the interrupt port
	   (drives the interrupt port <literal>false</literal>).
	 </para>

	 <para>
	   On initialization, the interrupt port is deasserted
	   (<literal>false</literal>). The thread then sits in a perpetual
	 loop, copying requests from the FIFO to the interrupt signal output
	 port.</para>

	 <programlisting>  while( true ) {
    intr.write( intrQueue.read() );
  }</programlisting>

	 <para>
	   The interrupt generator, <function>genIntr</function> is almost
	   identical to the version in the base class,
	   <classname>UartSC</classname>. The only difference is that if an
	   interrupt is generated, a request to drive the signal is written
	   onto the internal interrupt FIFO for processing by the
	   <function>intrThread</function> thread.
	 </para>

	 <programlisting>    setIntrFlags();                    // Show highest priority
    intrQueue.write( true );            // Request an interrupt signal</programlisting>

	 <para>
	   The interrupt clear routing is a similar modification, this time
	   requesting the interrupt signal to be cleared by writing
	   <literal>false</literal> on the FIFO queue.
	 </para>

	 <programlisting>  if( isSet( regs.iir, UART_IIR_IPEND )) {     // 1 = not pending
    intrQueue.write( false );                   // Deassert if none left</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Main Program for the Interrupt Driven Model
      </title>

      <para>
	The main program for the model supporting interrupts is in
	<filename>intrSocSC>cpp</filename>. It has a very similar structure to
	the main program used with the temporal decoupling example in <xref
	linkend="sec_temp_decoup_main" />, but uses the new versions of the
	&or1ksim; wrapper class and &uart; module,
	<classname>Or1ksimIntrSC</classname> and
	<classname>UartIntrSC</classname>. 
      </para>

      <para>
	A baud rate of 115,200 is expected for the Linux kernel serial port
	and a global quantum of 10&mu;s is appropriate for this. A constant is
	defined to hold the interrupt port number used by the &uart; (2).
      </para>

      <programlisting>#define BAUD_RATE   115200
#define QUANTUM_US      10

#define INTR_UART        2</programlisting>

      <para>
	The main program structure is unchanged, except that the &uart;
	interrupt output port needs to be connected to the correct signal in
	the &or1ksim; wrapper:
      </para>

      <programlisting>  uart.intr( iss.intr[INTR_UART] );</programlisting>
    </sect2>

    <sect2>
      <title>
	Running the Interrupt Driven Model
      </title>

      <para>
	Compilation and linking of the program follows the same procedure as
	previous examples.
      </para>

      <para>
	As a simple test, the interrupt loop program used in earlier examples
	is extended to demonstrate basic interrupt handling. However the main
	test is booting a &linux; kernel.
      </para>

      <sect3>
	<title>
	  Simple Test for the Interrupt Driven &soc; Model
	</title>

	<para>
	  A simple test is provided in <filename>uart_loop_intr.c</filename>
	  as an extension of <filename>uart_loop.c</filename>. After a
	  character is read, the program loops to wait until the interrupt
	  pending flag is clear (indicating the transmit buffer is empty).
	</para>

	<programlisting>    do {                        /* Wait for interrupts to clear */
      ;
    } while( is_set( uart->iir, UART_IIR_IPEND ) );</programlisting>

	<para>
	  This is a very basic test&mdash;if all is well it behaves
	  identically to the existing loop program. If there is a problem
	  clearing the transmit buffer empty interrupt, or the received data
	  available interrupt is not cleared when data is read, then the
	  program will lock up waiting for the interrupt pending flag to
	  clear.
	</para>

      </sect3>

      <sect3>
	<title>
	  Running Linux
	</title>

	<para>
	  This test uses a &linux;&nbsp;2.6.19 kernel built for the standalone
	  &or1ksim; as described in <xref
	  linkend="ref_app_note_1" endterm="ref_app_note_1_xr" /> [<xref
	  linkend="ref_app_note_1" />]. A configuration file, which enables the
	  internal <firstterm>memory management unit</firstterm>s
	  (<acronym>MMU</acronym>s) and Programmable Interrupt Controller
	  (<acronym>PIC</acronym>) of the &or1ksim; is provided,
	  <filename>linux.cfg</filename>. This also declares additional
	  internal memory space in &or1ksim; for flash and
	  <acronym>SRAM</acronym>.
	</para>

	<para>
	  The &systemc; model is then run with this configuration file and the
	  &linux; kernel binary.
	</para>

	<programlisting>./IntrSocSC linux.cfg ../linux-2.6.19/vmlinux</programlisting>

	<para>
	  Initially &linux; copies itself from flash memory to
	  <acronym>RAM</acronym>.
	</para>

	<screen>Copying Linux... Ok, booting the kernel.</screen>

	<para>
	  After a pause while initial booting is taking place the serial
	  interface is ready, allowing the normal kernel boot messages to
	  appear:
	</para>

	<screen>Linux version 2.6.19-or32 (jeremy@thomas) (gcc version 3.4.4) #59 Wed Jun 25 18:48:06 BST 2008
Detecting Processor units:
  Signed 0x391
Setting up paging and PTEs.
write protecting ro sections (0xc0002000 - 0xc024c000)
Setting up identical mapping (0x80000000 - 0x90000000)
Setting up identical mapping (0x92000000 - 0x92002000)
Setting up identical mapping (0xb8070000 - 0xb8072000)
Setting up identical mapping (0x97000000 - 0x97002000)
Setting up identical mapping (0x99000000 - 0x9a000000)
Setting up identical mapping (0x93000000 - 0x93002000)
Setting up identical mapping (0xa6000000 - 0xa6100000)
Setting up identical mapping (0x1e50000 - 0x1fa0000)
dtlb_miss_handler c00040c8
itlb_miss_handler c00041a8
Built 1 zonelists.  Total pages: 3953
Kernel command line: root=/dev/ram console=ttyS0

   &lt;Lots more &linux; kernel messages...&gt;

Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing disabled
serial8250.0: ttyS0 at MMIO 0x90000000 (irq = 2) is a 16450

   &lt;Lots more &linux; kernel messages...&gt;

VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
Starting pid 22, console /dev/ttyS0: '/etc/init.d/rcS'

Please press Enter to activate this console. </screen>

	<para>
	  This takes a simulated time of about 37 seconds, and on a modern PC
	  an elapsed time of around 20-25 seconds (the &or1ksim; &iss; in this
	  minimal configuration runs at 150-200MHz <footnote>
	    <para>
	      This may seem exceptionally fast for an interpreting &iss;, but
	      this model is configured with slow RAM with a 20-25 cycle access
	      time and no caches. So 150-200MHz represents only 5-10
	      MIPS. That's why booting a basic &linux; kernel takes 37s of
	      simulated time, rather than the 2-3s that might reasonably be
	      expected!
	    </para>
	  </footnote>).
	</para>
  
	<para>
	  At this point hitting return will start up a &linux; shell,
	  running some basic commands and in this example the
	  <application>BusyBox</application> utilities (see the <ulink
	  url="http://www.busybox.com">website</ulink> for more details).
	</para>

	<screen>Please press Enter to activate this console. 
Startingpid 25, console /dev/ttyS0: '/bin/sh'


BusyBox v1.4.1 (2007-03-22 18:53:56 EST) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

# ls /proc
1              2              bus            iomem          self
10             25             cmdline        ioports        slabinfo
11             26             cpuinfo        kcore          stat
12             3              crypto         kmsg           sys
13             4              devices        loadavg        sysrq-trigger
14             5              diskstats      locks          sysvipc
15             6              driver         meminfo        tty
16             7              execdomains    misc           uptime
17             8              filesystems    mounts         version
18             9              fs             net            vmstat
19             buddyinfo      interrupts     partitions     zoneinfo
# busybox mount
rootfs on / type rootfs (rw)
/dev/root on / type ext2 (ro)
proc on /proc type proc (rw)
# </screen>

	<para>
	  The importance of choosing a suitable value for the global quantum
	  is well illustrated here. Rebuild the model with a global quantum of
	  100&mu;s&mdash;rather longer than the time it takes to transmit one
	  character at 115,200 baud.
	</para>

	<programlisting>#define QUANTUM_US     100</programlisting>

	<para>
	  The time taken to boot is marginally faster (19s), but this time the
	  terminal cannot cope with the erratic interrupt behavior.
	</para>

	<screen>VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.
Please press Ent</screen>

	<para>
	  The &linux; serial driver loses interrupts and the system locks up
	  and will eventually crash with an unhandled interrupt exception.
	</para>

      </sect3>
    </sect2>



  </sect1>


  <appendix id="app_download">
    <title>
      Downloading the Example Models
    </title>

    <para>
      The example models used in this application note may all be downloaded
      from the &embecosm; website, <ulink
      url="http://www.embecosm.com">www.embecosm.com</ulink>. They are
      licensed under the &lgpl; so are freely available to be used and
      incorporated in other programs.
    </para>

    <para>
      The main directory of the distribution contains:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  A directory, <filename>sysc_models</filename>, containing the
	  example &systemc; models;
	</para>
      </listitem>

      <listitem>
	<para>
	  A patch file to adapt the &or1ksim; &iss; as described in this
	  application note;
	</para>
      </listitem>

      <listitem>
	<para>
	  Configuration files for use with &or1ksim; when running the simple
	  models and the &linux; kernel; and
	</para>
      </listitem>

      <listitem>
	<para>
	  A copy of the &lgpl;
	</para>
      </listitem>
    </itemizedlist>

    <para>
      Within the <filename>sysc_models</filename> directory a further
      directory, <filename>progs_or32</filename>, contains the example
      programs which run on the &or1ksim; &iss;. They are provided as both
      source and compiled binary, so that the &or1k; tool chain need not be
      installed to run the models.
    </para>

    <sect1>
      <title>
	Patching &or1ksim;
      </title>

      <para>
	The instructions for building standard &or1ksim; may be found in <xref
	linkend="ref_app_note_1" endterm="ref_app_note_1_xr" /> [<xref
	linkend="ref_app_note_1" />] on the &embecosm; website. This includes
	some patches to the standard distribution to fix a number of known
	bugs. The &iss; uses standard GNU configuration and build.
      </para>

      <para>
	The changes required to &or1ksim; are provided as a patch file. To use
	this download and unpack standard &or1ksim; has in directory
	<filename>or1ksim-0.2.0</filename>. Apply the &embecosm; bug fix patches
	described above and documented in <xref
	linkend="ref_app_note_1" endterm="ref_app_note_1_xr" /> [<xref
	linkend="ref_app_note_1" />]. This is the source for a working
	<emphasis>standard</emphasis> &or1ksim; &iss;.
      </para>

      <para>
	Change to the <filename>or1ksim-0.2.0</filename> directory. Assuming
	the &embecosm; patches for this application note are in
	<filename>embecosm_patch_or1ksim_an1.bz2</filename>, they can be
	applied by the command:
      </para>

      <programlisting>bzcat -dc ../embecosm_patch_or1ksim_an1.bz2 | patch -p 1</programlisting>

      <para>
	The &or1ksim; &iss; can then be built from this patched source in
	exactly the same way as the standard &iss;.
      </para>
    </sect1>

    <sect1>
      <title>
	Building the Linux Kernel
      </title>

      <para>
	The Linux kernel is built as described in <xref
	linkend="ref_app_note_1" endterm="ref_app_note_1_xr" /> [<xref
	linkend="ref_app_note_1" />]. This does require building the &or1ksim;
	tool chain. This includes patches to the &linux; kernel required to get
	it to work correctly on the &or1ksim; &iss;
      </para>

    </sect1>
  </appendix>


  <glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>2-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>approximately&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style where timing information is provided
	  at the level of transactions representing the phases of data
	  transfer in a specific bus protocol (for example the address and
	  data phases of an <acronym>AHB</acronym> read or write).
	</para>

	<glossseealso>loosely&#32;timed</glossseealso>
	<glossseealso>phase</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>backward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport function which
	  returns the response transaction from target to initiator.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>forward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>base&#32;class</glossterm>
      <glossdef>
	<para>
	  In object oriented programming a class from which other classes (the
	  derived classes) are derived, inheriting variables and
	  functions. Specifically a term favored by C++, also referred to as
	  a parent class or super-class.
	</para>

	<glossseealso>derived&#32;class</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which blocks the flow of
	  control in the initiator until the target has completed the
	  transaction request and responded.
	</para>

	<glossseealso>non-blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>convenience&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; wrapper, providing for simple TLM communication based on
	  C++ callbacks.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>derived&#32;class</glossterm>
      <glossdef>
	<para>
	  In object oriented programming a class which has inheriting
	  variables and functions from another class (known as the base
	  class). Specifically a term favored by C++, also referred to as a
	  child class or sub-class.
	</para>

	<glossseealso>base&#32;class</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>direct&#32;memory&#32;interface</glossterm>
      <glossdef>
	<para>
	  In hardware and software design communication between memory and a
	  peripheral without the constant intervention of the processor.
	</para>

	<para>
	  In &tlm2; communication between two threads (typically representing
	  a processor and a memory block) by direct writing through a pointer
	  to the memory rather than by a transactional exchange.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>forward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport the transport function, which
	  passes the opening transaction from initiator to target.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Generic Payload</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a class suitable for use as payload for
	  transactions. Recommended to maximize the interoperability of &tlm;s.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Hardware&#32;Description&#32;Language</glossterm>
      <glossdef>
	<para>
	  A language (<glossterm>Verilog</glossterm> and
	  <glossterm>VHDL</glossterm> are the best known), which describes
	  hardware. Can be used to describe both an actual chip and its
	  test bench.
	</para>

	<glossseealso>Verilog</glossseealso>
	<glossseealso>VHDL</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>initiator</glossterm>
      <glossdef>
	<para>
	  The initiator of a transactional exchange to a target. In &tlm2; an
	  initiator module must implement an initiator socket of the
	  appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>target</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Instruction&#32;Set&#32;Simulator</glossterm>
      <glossdef>
	<para>
	  A software model of a CPU core instruction set. Typically completely
	  models the instruction semantics, but not the full microarchitecture
	  of a particular CPU implementation. Timing information may be just
	  an instruction count, or may (as with the &or1ksim;) offer some
	  estimate of timing delays due to memory accesses, caching and
	  virtual memory access.
	</para>
      </glossdef>

    </glossentry>

    <glossentry>
      <glossterm>&iss;</glossterm>
      <glosssee>Instruction&#32;Set&#32;Simulator</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&osci;</acronym></glossterm>
      <glosssee>Open &systemc; Initiative</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>loosely&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing a complete data transfer
	  across a hardware bus.
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>MMU</acronym></glossterm>
      <glosssee>memory management unit</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>memory management unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>non-blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which allows the flow of
	  control in the initiator to continue immediately the transaction is
	  sent. The response will be provided later by a transport call from
	  the target back to the initiator..
	</para>

	<glossseealso>blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open&#32;&systemc;&#32;Initiative</glossterm>
      <glossdef>
	<para>
	  The industry body standardizing the &systemc; language and
	  applications of those language for particular purposes, such as
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>,
	  verification and synthesis. More information is available on their
	  website at <ulink
	  url="http://www.systemc.org">www.systemc.org</ulink>.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>passthrough</glossterm>
      <glossdef>
	<para>
	  A term describing a &tlm2; convenience socket which reuses the
	  payload, thereby eliminating the computational cost of allocation
	  and deallocation. Typically used in modules which perform a routing
	  or arbitration function.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload</glossterm>
      <glossdef>
	<para>
	  The data passed between threads by a transaction.
	</para>

	<glossseealso>Generic Payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>phase</glossterm>
      <glossdef>
	<para>
	  In &tlm2; approximately timed modeling, a transaction exchange
	  representing a single phase of the specific bus protocol being
	  modeled (for example the address phase of an <acronym>AHB</acronym>
	  read or write).
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>PIC</acronym></glossterm>
      <glosssee>programmable interrupt controller</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&posix;</acronym></glossterm>
      <glossdef>
	<para>
	  An IEEE standard for application programming interfaces and
	  utilities for Unix/Linux operating systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>programmable interrupt controller</glossterm>
      <acronym>PIC</acronym>
      <glossdef>
	<para>
	  A hardware component which provides a large number of interrupt
	  ports, which are mapped onto one or two interrupt ports on an actual
	  processor. The <acronym>PIC</acronym> will provide a lookup table of
	  interrupt service functions for its interrupts, which the interrupt
	  service function on the processor can use to identify the correct
	  handler to use.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, the maximum time a thread may
	  run ahead of the main system clock. This may be regulated by a
	  quantum keeper.
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum keeper</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, an object which enforces the
	  rule that threads may not run more than the quantum ahead of the
	  main system clock
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>singleton</glossterm>
      <glossdef>
	<para>
	  In object oriented programming, a class which can have at most one
	  instance. Typically implemented by making the constructor private
	  and providing an access function which instantiates the class on its
	  first call and on all other calls returns a pointer to that instance.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>socket</glossterm>
      <glossdef>
	<para>
	  Within the context of &tlm2;, a &systemc; port and export combined
	  with the associated interfaces for blocking and non-blocking
	  transport, direct memory access and debug.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>SystemC</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>tagged&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; convenience socket, which incorporates a numerical
	  <emphasis>tag</emphasis> to identify the socket in use. This allows
	  a single callback function to handle multiple sockets, with the tag
	  identifying the socket which caused the callback to be invoked.
	</para>

	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>target</glossterm>
      <glossdef>
	<para>
	  The responder to a transactional exchange initiated by an
	  initiator. In &tlm2; a target module must implement a target socket
	  of the appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>initiator</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>temporal&#32;decoupling</glossterm>
      <glossdef>
	<para>
	  In &tlm2; the concept of allowing individual threads to run ahead of
	  the main simulation time stamp. The maximum permitted time of run
	  ahead is known as the <glossterm>quantum</glossterm> and may be
	  regulated by a quantum keeper.
	</para>

	<glossseealso>quantum</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>thread</glossterm>
      <glossdef>
	<para>
	  In software, a logical parallel flow of control. In the context of
	  &systemc;, the main function of such a thread can be specified with
	  the <literal>SC_THREAD</literal> macro. In &systemc; a
	  <literal>SC_THREAD</literal> is distinguished from a
	  <literal>SC_METHOD</literal> because it can suspend execution with
	  <function>wait</function> calls.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym></glossterm>
      <glossdef>
	<para>
	  An abbreviation for (depending on context)
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm> or
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>Transaction&#32;Level&#32;Modeling</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym>&nbsp;2.0</glossterm>
      <glossdef>
	<para>
	  The &osci; standard interface for writing
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>s in
	  &systemc;.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transaction</glossterm>
      <glossdef>
	<para>
	  In &tlm; modeling the exchange of data between two threads.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transport&#32;function</glossterm>
      <glossdef>
	<para>
	  The C++ function which transfers data from an initiator to a
	  target, and (for a non-blocking interface), the response back from
	  the target to the initiator. Within the context of &tlm2; blocking
	  and non-blocking transport interfaces are defined.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction</glossterm>
      <glossdef>
	<para>
	  An exchange of data (the payload) between two parallel processes. In
	  &tlm2; this transaction occurs through &systemc; ports implementing
	  the &tlm2; interfaces, which are known as sockets.
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Model</glossterm>
      <glossdef>
	<para>
	  A software model in which the components of the model communicate by
	  transferring information to and from each other (transactions).
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>
      <glossdef>
	<para>
	  The process of writing software models using
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Verilog</glossterm>
      <glossdef>
	<para>
	  A Hardware&#32;Description&#32;Language (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso><acronym>VHDL</acronym></glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>VHDL</acronym></glossterm>
      <glossdef>
	<para>
	  A Hardware&#32;Description&#32;Language (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso>Verilog</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_fitch_88">
      <title id="ref_fitch_88_xr">
	A loosely coupled parallel LISP execution system
      </title>
      <author>
	<surname>ffitch</surname>
	<firstname>J</firstname>
      </author>
      <publisher>
	<publishername>
	  International Specialist Seminar on the Design and Application of
	  Parallel Digital Processors
	</publishername>
      </publisher>
      <pubdate>
	  11-15 Apr 1988
      </pubdate>
      <pagenums>
	128-133
      </pagenums>
    </bibliomixed>

    <bibliomixed id="ref_app_note_1">
      <title id="ref_app_note_1_xr">
	&embecosm; Application Note 1. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide
      </title>
      <publisher>
	<publishername>
	  Embecosm
	</publishername>
	<address>
	  <city>
	    Bournemouth
	  </city>
	  <country>
	    UK
	  </country>
	</address>
      </publisher>
      <pubdate>
	June, 2008
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_ieee_1666">
      <title id="ref_ieee_1666_xr">
	IEEE Standard &systemc; Language Reference Manual
      </title>
      <publisher>
	<publishername>
	  IEEE Computer Society
	</publishername>
      </publisher>
      <pubsnumber>
	1666-2005
      </pubsnumber>
      <pubdate>
	31 March, 2006
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_osci_tlm">
      <title id="ref_osci_tlm_xr">
	OSCI TLM 2.0 User Manual
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative
	</publishername>
      </publisher>
      <pubdate>
	June, 2008
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_osci_systemc_ug">
      <title id="ref_osci_systemc_ug_xr">
	&systemc; Version 2.0 User Guide
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative
	</publishername>
      </publisher>
      <pubdate>
	2002
      </pubdate>
    </bibliomixed>

  </bibliography>
</article>
 