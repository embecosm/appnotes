<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY hdl "<acronym>HDL</acronym>">
<!ENTITY iss "<acronym>ISS</acronym>">
<!ENTITY osci "<acronym>OSCI</acronym>">
<!ENTITY tlm "<acronym>TLM</acronym>">
<!ENTITY tlm2 "<acronym>TLM</acronym>&nbsp;2.0">
<!ENTITY uart "<acronym>UART</acronym>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">
<!ENTITY or1200 "<application class='hardware'>OpenRISC 1200</application>">

<!-- = Commands = -->

<!ENTITY xterm "<command>xterm</command>" >

<!-- = Libraries = -->

<!ENTITY readline "<systemitem class='library'>readline</systemitem>" >
<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Web pages = -->

<!ENTITY embecosm "<ulink
  url='http://www.embecosm.com'>Embecosm</ulink>">
<!ENTITY opencores "<ulink
  url='http://www.opencores.org'>OpenCores</ulink>">
<!ENTITY lgpl "<ulink url='http://www.gnu.org/licenses/lgpl.html'>
  GNU Lesser General Public License</ulink>">

]>

<!-- ==========================================================================

                  CONFIDENTIAL AND PROPRIETARY INFORMATION
                  ========================================

Copyright (c) 2008 Embecosm.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing the first stage in the conversion of an ISS to use
OSCI TLM 2.0, convenience ports.

$Id$

=========================================================================== -->

<article class="whitepaper" lang="en_GB">
  <title>
    Building a Loosely Timed SoC Model with &osci; TLM 2.0
  </title>
  <subtitle>
    A Case Study Using the &or1k; &or1ksim; &iss;
  </subtitle>

  <articleinfo>

    <corpauthor>
      &embecosm;
    </corpauthor>

    <pubdate>
      14 June 2008
    </pubdate>

    <releaseinfo>
      Application Note 2. Issue 1, draft A
    </releaseinfo>

    <copyright>
      <year>
	2008
      </year>
      <holder>
	Embecosm Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software examples written by &embecosm; and used in this document
	are licensed under the &lgpl;. For detailed licensing information see
	the source code of the examples.
      </para>

      <para>
	Embecosm is the business name of Embecosm Limited, a private limited
	company registered in England and Wales. Registration number 6577021.
      </para>

    </legalnotice>
  </articleinfo>

<sect1>
    <title>
      Introduction
    </title>

    <para>
      The Open <firstterm>&systemc;</firstterm> Initiative
      (<firstterm>&osci;</firstterm>) has recently issued the second version
      of its standard for
      <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;). This
      provides an interface for writing high level software models of
      hardware.
    </para>

    <para>
      One of the most important components in any SoC system model is the
      processor core <firstterm>Instruction Set Simulator</firstterm>
      (&iss;). With the standardization of &osci; &tlm2; for &systemc;, many
      &iss;, providers will wish to convert to offer the
      <firstterm>&tlm2;</firstterm> interface
    </para>

    <para>
      This application note is the first in a series from &embecosm;,
      providing case studies in &osci; &tlm2; use, based on an open source
      &iss;, the &or1ksim; for the &opencores; &or1200; architecture.
    </para>

    <para>
      The objective is to provide an introduction to using &tlm2; within a
      practical context. Examples are provided throughout, which are freely
      available under the &lgpl;.
    </para>

    <!-- ========== Justification ========== -->

    <sect2>
      <title>
	About the &embecosm; TLM 2.0 Application Note Series
      </title>

      <para>
	The &osci; &tlm2; standard represents a significant advance in
	standardizing the creation of fast software models of
	hardware. However the &osci; reference implementation lacks training
	material and examples to introduce new users to the technology.
      </para>

      <para>
	These users are often trained hardware engineers, who may be
	relatively new to both C++ and transaction level modeling (&tlm;).
      </para>

      <para>
	This series of &embecosm; Application Notes was prompted by a customer
	requesting assistance in porting an existing &iss; to the &tlm2;
	standard. This first application note in the series introduces &tlm2;
	in its simplest form, using &tlm2;
	<firstterm>convenience&#32;socket</firstterm>s.
      </para>

    </sect2>

    <!-- ========== Target Audience ========== -->

    <sect2>
      <title>
	Target Audience
      </title>

      <para>
      </para>

    </sect2>
  </sect1>

  <sect1>
    <title>
      Background to &tlm; and &systemc;
    </title>

    <para>
      
    </para>

    <!-- ========== What is TLM ========== -->

    <sect2 id="sec_what_is_tlm">
      <title>
	What is a &tlm;
      </title>

      <sect3>
	<title>
	  Hardware and Software Views of Parallelism
	</title>

	<para>
	  At the heart of &tlm; is the difference in approach to parallelism
	  taken in hardware and software design.
	</para>

	<para>
	  A hardware engineer, typically writing in a
	  <firstterm>Hardware&#32;Description&#32;Language</firstterm> (&hdl;)
	  such as Verilog or VHDL, describes a design as a collection of
	  parallel activities, which communicate via shared data. The parallel
	  activities are <literal>always</literal> (Verilog) or
	  <literal>process</literal> (VHDL) blocks. The shared data structures
	  are wires or signals.
	</para>

	<para>
	  This follows very naturally the way that physical hardware
	  behaves. There is no one <emphasis>flow of
	  control</emphasis>&mdash;all parallel components are active on at
	  the same time, with their individual flow of control.
	</para>

	<para>
	  By contrast, a software engineer usually describes any parallelism
	  as a number of threads or processes, which pass flow of control
	  between them. The threads or processes by a number of mechanisms
	  (message passing or remote procedure call for example), but although
	  there is <emphasis>logical</emphasis> parallelism, only one thread
	  or process is ever physically active at one time.
	</para>

	<para>
	  This follows naturally the behavior on a conventional uni-processor
	  CPU, where there is a single program counter indicating the next
	  instruction to execute, and so only one flow of control. Even with
	  modern multiprocessors, this is still a natural way of programming
	  for the software engineer, because the number or threads or
	  processes will not generally match the number of processor cores
	  available.
	</para>
      </sect3>

      <sect3>
	<title>
	  Modeling Hardware Parallelism in Software
	</title>

	<para>
	  A simple way to model hardware is via a round-robin, which updates
	  the state of each component as time advances. This is quite common
	  with cycle accurate models. Each component is represented a software
	  routine. A master clock routine calls each component routine each
	  time the clock advances&mdash;for example on each clock edge. The
	  wires between the components are represented as variables shared
	  between the components. A number of tools (ARC VTOC, ARM RealView
	  SoC Designer, Carbon SpeedCompiler, Verilator use this approach to
	  cycle accurate modeling).
	</para>

	<para>
	  This approach has its merits for detailed modeling, where very
	  register and wire must be accurate, although
	  combinatorial hardware logic can be difficult <footnote>
	    <para>
	      For example if I have two component routines,
	      <function>A</function> and <function>B</function>, the master
	      clock step routine would call <function>A</function> followed by
	      <function>B</function>. However if there was a combinatorial
	      output from <function>B</function> driving an input to
	      <function>B</function> then I would need to call A again to
	      ensure it was correctly updated in the light of the output from
	      <function>B</function>. Sorting out which routines need to be
	      called each time the master clock updates can be extremely
	      complex for large models. Some systems (for example ARM RealView
	      SoC Designer) get round this problem by requiring all
	      combinatorial logic flows to be within a single component.
	    </para>
	  </footnote>. However for less detailed models, the overhead in
	  calling each component whenever time advances cannot be justified.
	</para>

	<para>
	  The solution is to model each component, only when it has something
	  to do. The individual components communicate by sending messages
	  over channels between each other. The exchange of messages is called
	  a transaction, and the approach
	  <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;).
	</para>

	<para>
	  This is the same way hardware behaves at the high level where
	  functional blocks communicate by reading and writing across buses.
	</para>
      </sect3>

    </sect2>

    <!-- ========== What is SystemC ========== -->

    <sect2>
      <title>
	What is &systemc;
      </title>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling in a mainstream programming
	language. It is now standardized as IEEE 1666-2007.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc; Rather than invent a new language,
	&systemc; is based on the existing C++ language. &systemc; is a true
	super-set of C++, so any C++ program is automatically a valid &systemc;
	program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
	<itemizedlist>

	  <listitem>
	    <para>
	      A class, <literal>sc_module</literal>, suitable for defining hardware
	      modules, with convenience macros <literal>SC_MODULE</literal> and
	      <literal>SC_CTOR</literal> to define such classes.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A mechanism to define methods for
	      <literal>sc_module</literal> classes, which represent its logical
	      parallel behavior, with convenience macros
	      <literal>SC_METHOD</literal> and <literal>SC_THREAD</literal>
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A class, <literal>sc_port</literal> to represent the interfaces to
	      modules and a class, <literal>sc_channel</literal> to connect those
	      ports.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A comprehensive set of types to represent hardware wires and
	      register both in <firstterm>2-state</firstterm> and
	      <firstterm>4-state</firstterm> logic.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	These are the key features of &systemc;. The full specification is 441
	pages long. However there is an excellent tutorial included with the
	reference distribution.
      </para>
	
    </sect2>

    <!-- ========== Overview of TLM 2.0 ========== -->

    <sect2>
      <title>
	Overview of OSCI TLM 2.0
      </title>

      <para>
	The &tlm2; standard provides a standard way of building Transaction
	Level Models.
      </para>

      <para>
	At the simplest level a &tlm; is a set of &systemc; modules (i.e. C++
	objects), each providing one or more <firstterm>socket</firstterm>s
	through which the &systemc; modules may communicate.
      </para>

      <para>
	The behavior of each module is provided by a number of parallel
	<firstterm>thread</firstterm>s (methods of the C++ class), which
	communicate with the threads in other modules by passing data
	(i.e. reading or writing) through the sockets. This communication is
	known as a <firstterm>Transaction</firstterm> and the data passed as a
	<firstterm>payload</firstterm>. <xref linkend="fig_tlm_overview" />
	shows the key components in a &tlm2; model.
      </para>

      <figure id="fig_tlm_overview">
	<title>
	  Key components in an &osci; &tlm2; model.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <!-- = Payloads = -->

      <sect3 id="sec_payload">
	<title>
	  Transaction Payload
	</title>

	<para>
	  The data passed in a transaction may take any form. However the
	  &tlm2; standard defines a <firstterm>Generic Payload</firstterm>
	  which is suitable for many uses, and which can be extended if
	  required. By using the Generic Payload, a &tlm2; model will maximize
	  interoperability.
	</para>

	<para>
	  The key features of the Generic Payload are:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>Command</term>
	    <listitem>
	      <para>
		Is this a read or a write?
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Address</term>
	    <listitem>
	      <para>
		What is the address (in the hardware sense of an address in
		memory).
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Data</term>
	    <listitem>
	      <para>
		A pointer to the physical data as an array of bytes
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The payload includes in its structure whether it is a read or a
	  write, and the address to which it refers. A &tlm2;
	  <firstterm>transport&#32;method</firstterm> is used to pass this
	  message between &systemc; modules.
	</para>
      </sect3>

      <!-- = Initators and Targets = -->

      <sect3>
	<title>
	  Initiators and Targets
	</title>

	<para>
	  A module's threads may act as either
	  <firstterm>initiator</firstterm>s or
	  <firstterm>target</firstterm>s. An initiator is responsible for
	  creating a payload (see <xref linkend="sec_payload" />) and calling
	  the transport routine to send it. A target receives payloads from
	  the transport routine for processing and response.
	</para>

	<para>
	  Initiator calls are made through initiator ports, target calls
	  received through target ports. A module may implement both target
	  and initiator ports, allowing its threads to both generate and
	  receive traffic.
	</para>
      </sect3>

      <!-- = Blocking and Non-Blocking -->

      <sect3>
	<title>
	  Blocking and Non-Blocking Interfaces
	</title>

	<para>
	  There are two types of &tlm2; transport method.
	</para>

	<para>
	  The <firstterm>blocking</firstterm> transport methods are called by
	  the initiator thread, received by the target thread, which processes
	  the request and then returns the result. Until the transaction has
	  been processed and released the initiator thread is blocked.
	</para>

	<para>
	  The <firstterm>non-blocking</firstterm> transport methods are called
	  by the initiator thread, received by the target thread, which
	  immediately returns, before processing the request. Subsequently the
	  target, having processed the request makes a transport call back to
	  the initiator to return the result.
	</para>

	<para>
	  In the non-blocking case there are actually two types of transport
	  used. The <firstterm>forward&#32;transport&#32;path</firstterm> is
	  used by the initiator to pass the request to the target and the
	  <firstterm>backward&#32;transport&#32;path</firstterm> used by the
	  target to return the response. The advantage of the non-blocking
	  transport interface is that the initiator can carry on processing,
	  while the target is processing the request originally made.
	</para>
      </sect3>

      <!-- = Untimed, Loosely Timed and Approximately Timed = -->

      <sect3>
	<title>
	  Loosely Timed, Approximately Timed and Untimed &tlm;
	</title>

	<para>
	  &tlm2; considers two levels of timing detail. A
	  <firstterm>loosely&#32;timed</firstterm> model uses transactions
	  corresponding to a complete data read or write across a bus or
	  network in physical hardware. It provides timing at the level of the
	  individual transaction.
	</para>

	<para>
	  An <firstterm>approximately&#32;timed</firstterm> model breaks down
	  transactions into a number of <firstterm>phase</firstterm>s
	  corresponding much more closely to the phasing of particular
	  hardware protocols (for example the address and data phases of an
	  AHB read or write).
	</para>

	<para>
	  Typically loosely timed models are implemented with a blocking
	  interface and approximately timed models with a non-blocking
	  interface.
	</para>

	<para>
	  &tlm2; also introduces the concept of
	  <firstterm>temporal&#32;decoupling</firstterm>. Standard SystemC
	  keeps a single synchronized view of time, which is used by all
	  threads in all modules. However with temporal decoupling, each
	  thread can keep its own local view of time, allowing the thread to
	  run ahead in simulation time, until it needs to synchronize with
	  another thread. This is particularly useful with loosely timed
	  models, avoiding bottlenecks in processing.
	</para>

	<para>
	  To ensure that one thread doesn't run away hogging all the
	  processing, &tlm2; introduces the concept of the
	  <firstterm>quantum</firstterm>, the greatest amount that a thread
	  may differ in timing from the central view of time. This allows
	  other threads a chance to catch up
	</para>

	<para>
	  &tlm2; does not have an explicit concept of an untimed socket
	  (something that was explicit in &tlm;&nbsp;1.0). The standardization
	  group took the view that in practice all models need some concept of
	  time, so purely untimed models are of little value.
	</para>

	<para>
	  However, if required, untimed models are easily implemented as
	  loosely timed models which ignore the timing parameters in the
	  interface calls. If temporarily decoupled, then they ignore the
	  quantum as well.
	</para>
      </sect3>

      <!-- = Convenience sockets = -->

      <sect3>
	<title>
	  &tlm2; Convenience Sockets
	</title>

	<para>
	  The standard &tlm2; approach to modeling requires the user to
	  derive their own classes from the standard &tlm2; sockets, so that
	  those sockets can then implement the &tlm2; interfaces. Modules then
	  instantiate these derived sockets and use the bind method to connect
	  them to sockets on other modules.
	</para>

	<para>
	  This is a very flexible method, but the need to define new
	  sub-classes for sockets is an unnecessary layer of complexity for
	  simple modeling. So the &tlm2; standard defines a number of
	  <firstterm>convenience&#32;socket</firstterm>s which can be
	  instantiated directly by modules, and which specify their interface
	  methods as callbacks.
	</para>

	<para>
	  Convenience sockets are used throughout the case study in this
	  application note.
	</para>

      </sect3>
    </sect2>
  </sect1>

<sect1 id="sec_case_study">
    <title>
      Case Study: A SoC Using &tlm2;
    </title>

    <para>
      In this case study, &tlm2; convenience sockets are used to wrap an
      existing &iss;, which is then built into a simple SoC using additional
      hand-written &tlm2; components.
    </para>

    <para>
      Modeling uses the &tlm2; <glossterm>Generic Payload</glossterm> with no
      extensions. It is independent of the specific bus architecture that will
      be used in the implementation.
    </para>

    <para>
      The model is constructed in a number of stages:
    </para>

    <orderedlist>

      <listitem>
	<para>
	  The basic wrapper for the &or1ksim; &iss; is built using &tlm2;
	  convenience sockets and tested with a simple logger. In this first
	  stage timing is ignored&mdash;this is effectively an untimed
	  model. See <xref linkend="sec_iss_wrapper" /> and <xref
	  linkend="sec_iss_wrapper_test" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  A model &uart; is added as an example peripheral, demonstrating how
	  &tlm2; and existing &systemc; technologies can be mixed. See <xref
	  linkend="sec_uart" />
	</para>
      </listitem>

      <listitem>
	<para>
	  A model of a terminal is added as a test bench for the SoC. This
	  demonstrates how to add &systemc; components which use operating
	  system I/O without blocking the &systemc; thread. See <xref
	  linkend="sec_terminal" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Synchronous timing is added to each component, making the model
	  loosely timed. See <xref linkend="sec_sync" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Temporal decoupling is added to the &or1ksim; &iss;, &uart; and
	  terminal, to improve the performance of the model. See <xref
	  linkend="sec_temporal_decoupling" />
	</para>
      </listitem>

      <listitem>
	<para>
	  Interrupt modeling is added to the &uart; and the &or1ksim; &iss;,
	  allowing the model to run &linux;.
	  <xref linkend="sec_linux" />
	</para>
      </listitem>

    </orderedlist>

    <para>
      Throughout the model is demonstrated with simple applications to
      exercise the relevant system components. The final model, is capable of
      booting a Linux 2.6 kernel.
    </para>
    <sect2>
      <title>
	The Example Designs
      </title>

      <para>
	The example is a simple SoC, based on the &or1ksim; &iss; for the &or1k;
	architecture. The &or1k; architecture is a conventional 32-bit RISC
	design, with optional instruction and data caches and an optional
	MMU. &or1ksim; is an interpreting &iss; written in C, which in its
	standard configuration models main memory and a number of peripherals
	as well as the CPU itself.
      </para>

      <para>
	Information on obtaining and setting up the open source &or1ksim;
	simulator and its tool chain are given in <xref
	linkend="ref_app_note_1" />.
      </para>

      <para>
	In general the CPU is configured to remove all the peripherals and
	the caches and MMU, so it models only the CPU and main memory. The
	peripherals are then modeled as separate &systemc; modules.
      </para>

      <sect3>
	<title>
	  &or1ksim; &iss; &tlm2; Wrapper with Logger
	</title>

	<para>
	  The first stage is to just test the &tlm2; wrapper for the &or1ksim;
	  &iss;. The wrapped &iss; is connected to a simple &tlm2; logger
	  module which records transactions sent to it on standard output as
	  shown in <xref linkend="fig_iss_test" />.
	</para>

	<figure id="fig_iss_test">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="iss_test.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="iss_test.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <sect3>
	<title>
	  Simple SoC Design
	</title>

	<para>
	  To build a simple SoC the &or1ksim; CPU/memory subsystem is
	  connected to a &uart; modeled in &systemc; using &tlm2;. The test
	  bench for the system will be a terminal, also modeled in &systemc;
	  using &tlm2;. This model is built up in stages in <xref
	  linkend="sec_iss_wrapper" />, <xref linkend="sec_uart" /> and <xref
	  linkend="sec_terminal" />. Synchronous timing is added in <xref
	  linkend="sec_sync" /> and temporal decoupling in <xref
	  linkend="sec_temporal_decoupling" />. <xref linkend="fig_simple_soc"
	  /> shows the design.
	</para>

	<figure id="fig_simple_soc">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>

      <sect3 id="soc_example_soc_intr">
	<title>
	  SoC with Interrupt Support
	</title>

	<para>
	  To run Linux (see <xref linkend="sec_linux" />), the example must be
	  extended to support interrupt driver I/O. It also needs memory
	  management and other peripheral functions. This is provided
	  internally to the &or1ksim; &iss;. This design is shown in <xref
	  linkend="fig_simple_soc_intr" />.
	</para>

	<figure id="fig_simple_soc_intr">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim; with interrupts and MMU
	    enabled.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect3>
    </sect2>
  </sect1>

<sect1 id="sec_iss_wrapper">
    <title>
      Wrapping the &iss;
    </title>

    <para>
      The conversion of an existing &iss; to a  &systemc;
      module with &tlm2; sockets involves several steps:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Modify the existing &iss; (in this example &or1ksim; written in C)
	  so it  behaves in a manner suitable for wrapping (see <xref
	  linkend="sec_iss_mods" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  Define a &systemc; module for the wrapper (see <xref
	  linkend="sec_iss_wrapper_def" />) and provide its implementation
	  (see <xref linkend="sec_iss_wrapper_impl" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Test the wrapper with a simple logger module attached to the &tlm2;
	  port and a suitable test application running as embedded code on the
	  &iss; (see <xref linkend="sec_iss_wrapper_test" />).
	</para>
      </listitem>
    </itemizedlist>

    <!-- ========== Modifying the &iss; ========== -->

    <sect2 id="sec_iss_mods">
      <title>
	Modifying the &or1ksim; &iss; for &tlm2;
      </title>

      <para>
	Most &iss; need some modification before they can be incorporated into
	a &tlm2; framework. Like many &iss;, &or1ksim; is designed as a
	standalone program. The options are:
	<orderedlist>
	  <listitem>
	    <para>
	      Keep the &iss; as a standalone program, but modify it to call
	      out to a &systemc; model of the peripherals as required.
	    </para>
	  </listitem>

	  <listitem id="or1ksim_lib_opt">
	    <para>
	      Modify the &iss; to be a library with a set of public interfaces
	      that can be part of a larger system.
	    </para>
	  </listitem>
	</orderedlist>
      </para>

      <para>
	Given the choice, option <xref linkend="or1ksim_lib_opt" /> is more
	flexible, making the &iss; widely reusable in other environments. It
	is the approach adopted in this case study.
      </para>
      <sect3 id="sec_or1ksim_libcals">
	<title>
	  Converting &or1ksim; to a Library
	</title>

	<para>
	  The &or1ksim; <function>main()</function> routine first initializes
	  the &iss;, then sits in a loop executing instructions. This
	  <function>main()</function> routine is replaced by a series of
	  functions which form the interface to the library. The interface
	  functions needed are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_init( const char         *config_file,
                   const char         *image_file,
                   void               *class_ptr,
                   unsigned long int (*upr)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask),
                   void              (*upw)( void              *class_ptr,
                                             unsigned long int  addr,
                                             unsigned long int  mask,
                                             unsigned long int  wdata ) );</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_init()</function> initializes the
	      simulator. For &or1ksim;, configuration data is read from a
	      file, which is passed as the first argument,
	      <literal>config_file</literal>. The program image is passed as
	      a second argument, <literal>image_file</literal>.
	    </para>

	    <para>
	      &or1ksim; also needs to be able to call up to the SystemC
	      model of which it is part&mdash;to read and write from the
	      peripheral address space. These are provided as the fourth
	      and fifth arguments, <literal>upr</literal> and
	      <literal>upw</literal>. More explanation of the upcall
	      mechanism can be found in <xref linkend="sec_upcall" />.
	    </para>

	    <para>
	      Procedure calls between C and C++ can be awkward. The upcall
	      routines form part of the SystemC module object, but are
	      written as static routines with C linkage. To enable these
	      routines to invoke methods in the SystemC module, they are
	      passed a pointer to the module class instance to use as a
	      handle. This pointer forms the third argument,
	      <literal>class_ptr</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_run( double  duration );</programlisting>
	    </para>
	    <para>
	      <function>or1ksim_run()</function> runs the simulator for the
	      specified time in seconds.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3>
	<title>
	  Additional Functionality for &or1ksim;
	</title>

	<para>
	  The standard &or1ksim; &iss; incorporates the functionality of
	  several common peripherals. The objective of this application note
	  is to demonstrate the &iss; driving external peripherals modeled in
	  &systemc; using &tlm2; interfaces.
	</para>

	<para>
	  &or1ksim; peripherals are configured in a textual configuration file,
	  with a section (introduced by the keyword
	  <literal>section</literal>) for each device attached. This
	  configuration specifies the memory mapped addresses of the
	  peripheral. Any reads or writes to those addresses will be directed
	  to the code of the peripheral within &or1ksim;.
	</para>

	<para>
	  &or1ksim; is extended with a new class of peripheral,
	  <literal>generic</literal>, which specifies an external
	  peripheral. The specification in the configuration file specifies
	  the memory mapped address range covered and whether byte, half word
	  or full word access are enabled. Multiple <literal>generic</literal>
	  sections may be defined (for different address ranges) in the
	  configuration file.
	</para>

	<para>
	  Code is added to &or1ksim;, so that any read or write to a
	  <literal>generic</literal> peripheral is redirected back to the
	  wrapper code via the upcalls specified as arguments to
	  <function>or1ksim_init()</function> (see <xref
	  linkend="sec_or1ksim_libcals" /> and <xref linkend="sec_upcall" />).
	</para>
      </sect3>
    </sect2>

    <!-- ========== Wrapper Class definition ========== -->

    <sect2 id="sec_iss_wrapper_def">
      <title>
	&or1ksim; Wrapper Module Class Definition
      </title>

      <para>
	The class definition for the &or1ksim; wrapper module is found in
	<filename>Or1ksimSC.h</filename>.
      </para>

      <para>
	All the examples in this application note separate the definition of a
	class (i.e. <emphasis>what</emphasis> it does) in a
	<filename>.h</filename> file, from the implementation
	(i.e. <emphasis>how</emphasis> it does it) in a
	<filename>.cpp</filename> file. This is considered good programming
	practice.
      </para>

      <para>
	The examples use the convention that classes and other type names start
	with an Upper Case letter (e.g. <literal>Or1ksimSC</literal>),
	variables and functions start with a lower case letter
	(e.g. <literal>dataBus</literal>) and defined or enumerated constants
	are all in UPPER CASE (e.g. <literal>#define BAUD_RATE
	9600</literal>).
      </para>

      <para>
	Those routines and variables which other classes will use are declared
	as <literal>public</literal>. For &systemc; modules this usually means
	the constructor and any &systemc; ports or sockets. Occasionally there
	are some utility routines which are also made public (see for example
	<literal>Or1ksimExt::isLittleEndian()</literal> in <xref
	linkend="sec_uart_or1ksim_libext" />)<footnote>
	  <para>
	    Object oriented purists prefer to expose only procedures as the
	    <literal>public</literal> interface, so hiding all state from
	    external view. There is considerable merit in this, but the common
	    &systemc; convention is to expose actual ports or sockets, rather
	    than accessor routines for those objects. This application note
	    sticks with that practice.
	  </para>
	</footnote>.
      </para>

      <para>
	Some non-public parts of the module are declared as
	<literal>protected</literal> (i.e. visible to derived classes). This
	application note develops the example design by subclassing the
	SystemC module classes to add further functionality. Functions and
	objects declared <literal>protected</literal> are those which are
	expected to be reused in later derived classes.
      </para>

      <para>
	The remaining functions and variables, which are for use only by this
	class, are declared <literal>private</literal> (visible only to this
	class). This avoids any unplanned reuse by derived classes.
      </para>

      <para>
	Some of the functions are replaced in later derived classes, so are
	also declared <literal>virtual</literal>.
      </para>

      <para>
	In summary <literal>public</literal> functions and variables may be
	used by any other class, <literal>protected</literal> functions and
	variables may be <emphasis>used</emphasis> only by this class and any
	derived classes and <literal>private</literal> functions and variables
	may be used only by this class. <literal>virtual</literal> functions
	may be <emphasis>replaced</emphasis> in derived classes.
      </para>

      <!-- = Include files and definitions = -->

      <sect3 id="sec_Or1ksimSC_def_inc">
	<title>
	  Included Headers
	</title>

	<para>
	  The &or1ksim; SystemC wrapper module class,
	  <literal>Or1ksimSC</literal>, is defined in the file
	  <filename>Or1ksimSC.h</filename>. It will provide a single initiator
	  socket, for data access, <literal>dataBus</literal> (no instruction
	  accesses are planned, so modeling an external instruction bus is
	  unnecessary).
	</para>

	<para>
	  The module includes the <literal>tlm.h</literal> header, which
	  defines the core &tlm2; interface and the required convenience
	  wrapper header&mdash;in this case for a simple initiator socket.
	</para>

	<para>
	  The POSIX <literal>stdint.h</literal> header is also included, since
	  the definitions and code will make use of the fixed width native
	  types defined there.
	</para>

	<programlisting>#include &lt;stdint.h&gt;

#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "or1ksim.h"</programlisting>

        <note>
	  <para>
	    There is no need to include the standard
	    <literal>systemc.h</literal> header, since this is included
	    automatically by <literal>tlm.h</literal>.
	  </para>
	</note>

      </sect3>

      <!-- = Module declaration = -->

      <sect3 id="sec_Or1ksimSC_def_module">
	<title>
	  Module Declaration
	</title>

	<para>
	  The module is declared as a standard &systemc; module, i.e. as a
	  derived class of <literal>sc_core::sc_module</literal>.
	</para>

	<programlisting>class Or1ksimSC
: public sc_core::sc_module
{</programlisting>

        <note>
	  <para>
	    The &systemc; tutorial material teaches that a module should be
	    defined using:
	  </para>

	  <programlisting>SC_MODULE( Or1ksimSC )</programlisting>

	  <para>
	    However this is equivalent (IEEE 1666-2005 section 5.2.5) to the
	    C++ derived class declaration
	  </para>

	  <programlisting>class Or1ksimSC
: public sc_core::sc_module
{
 public:</programlisting>

          <para>
	    This is the usual way classes are declared in the &systemc; and
	    &tlm2; examples&mdash;<literal>SC_MODULE</literal> seems only to
	    appear in tutorial material for beginners. It has the effect that
	    unless there is a subsequent <literal>protected:</literal> or
	    <literal>private:</literal> all functions and variables will be
	    visible to all other classes.
	  </para>

	  <para>
	    Throughout this application note, the C++ derived class
	    declaration style is used with explicit declarations of
	    <literal>public:</literal>, <literal>protected:</literal> or
	    <literal>private:</literal> as required, rather than
	    <literal>SC_MODULE</literal>.
	  </para>
	</note>

      </sect3>

      <!-- = Constructor and destructor = -->

      <sect3 id="sec_Or1ksimSC_def_constructor">
	<title>
	  Constructor and Destructor
	</title>

	<para>
	  <classname>Or1ksimSC</classname> needs a custom constructor, which
	  can be passed the &or1ksim; &iss; configuration and image files. It
	  will call the <function>or1ksim_init()</function> routine within the
	  &or1ksim; library (see <xref linkend="sec_or1ksim_libcals" />) to
	  initialize the &iss;.
	</para>

	<programlisting>Or1ksimSC( sc_core::sc_module_name  name,
             const char              *configFile,
             const char              *imageFile );</programlisting>

	<para>
	  The default destructor is sufficient here. The module has no tidying
	  up to do on termination.
	</para>

      </sect3>

      <!-- = Public Interface = -->

      <sect3 id="sec_Or1ksimSC_def_pub_if">
	<title>
	  Public Interface
	</title>

	<para>
	  The only public interface is the &tlm2; simple initiator convenience
	  socket, <literal>dataBus</literal>. The &tlm2; convenience sockets are
	  templated with
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      the class of which any callbacks are members;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a bus width (default <literal>BUSWIDTH</literal>, 32); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a protocol type (default the &tlm2; base protocol types).
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  For this case study, the default bus width and protocol are
	  appropriate and need not be specified. There is no default class for
	  the template, so <literal>Or1ksimSC</literal> is used. A class must be
	  specified, even where (as in this case for a simple blocking
	  initiator) no callbacks are actually required.
	</para>

	<programlisting>  tlm_utils::simple_initiator_socket&lt;Or1ksimSC&gt;  dataBus;</programlisting>

      </sect3>

      <!-- = Threads = -->

      <sect3 id="sec_Or1ksimSC_def_threads">
	<title>
	  Threads
	</title>
      
        <para>
	  The module has a single thread, which executes the instructions of
	  the &iss;. The <function>run()</function> procedure implements this:
	</para>

	<programlisting>  void  run();</programlisting>

	<para>
	  The thread is not part of the public interface, but will but will be
	  reused and replaced in derived classes later in the application
	  note, so it is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>
      </sect3>

      <!-- = Upcalls = -->

      <sect3 id="sec_upcall">
	<title>
	  Upcalls
	</title>

	<para>
	  The &or1ksim; &iss; makes requests to read and write peripherals via
	  the upcalls passed as arguments to <function>or1ksim_init</function>
	  (see <xref linkend="sec_or1ksim_libcals" />).
	</para>

	<para>
	  The &or1ksim; &iss; is implemented in C, which cannot easily call
	  C++ class instance functions. The solution is to declare two
	  <emphasis>static</emphasis> member functions which can be called
	  from C. The call to <function>or1ksim_init()</function> also passed
	  the address of the actual C++ class instance (cast to
	  <literal>void&nbsp;*</literal>). This pointer is passed back with
	  the upcall, so the static function can call the corresponding
	  instance function.
	</para>

	<para>
	  A total of 4 functions are needed, one static and one instance each
	  for read and write. The static functions use the native C/C++ types
	  (unsigned long int), but convert to defined fixed width types for
	  the instance functions. The native SystemC 64-bit unsigned type is
	  used for the address (which is always 64 bits in &tlm2; function
	  calls) and the <firstterm>POSIX</firstterm> 32-bit unsigned data
	  type is used for byte enable mask and data.
	</para>

	<para>
	  These upcall functions are not changed throughout this application
	  note, so are declared private.
	</para>

	<programlisting>  static unsigned long int  staticReadUpcall( void              *instancePtr,
                                              unsigned long int  addr,
                                              unsigned long int  mask );

  static void               staticWriteUpcall( void              *instancePtr,
                                               unsigned long int  addr,
                                               unsigned long int  mask,
                                               unsigned long int  wdata );

  uint32_t                  readUpcall( sc_dt::uint64  addr,
                                        uint32_t       mask );

  void                      writeUpcall( sc_dt::uint64  addr,
                                         uint32_t       mask,
                                         uint32_t       wdata );</programlisting>

        <caution>
	  <para>
	    It might seem logical to use the &systemc; limited precision
	    types, rather than the POSIX types. However the &systemc; types
	    are <emphasis>not</emphasis> native C++ types, so will not cast as
	    expected.
	  </para>
	</caution>

	<para>
	  The transport mechanism is common to both, so provided in a utility
	  method, <function>doTrans()</function>. However this function will
	  be used and replaced in derived classes later in this application
	  note, so is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>

      </sect3>
    </sect2>

    <!-- ========== Wrapper Class simplementation ========== -->

    <sect2 id="sec_iss_wrapper_impl">
      <title>
	&or1ksim; Wrapper Module Class Implementation
      </title>

      <para>
	The class implementation for <literal>Or1ksimSC</literal> is found
	in the file <filename>Or1ksimSC.cpp</filename>.
      </para>
<sect3>
	<title>
	  Headers and Macros
	</title>

	<para>
	  All the definitions required are obtained from the definition file:
	</para>

	<programlisting>#include "Or1ksimSC.h"</programlisting>

	<para>
	  The implementation of a C++ class that is a &systemc; module with
	  &systemc; threads (<literal>SC_THREAD</literal>), methods
	  (<literal>SC_METHOD</literal>) or clocked threads
	  (<literal>SC_CTHREAD</literal>) requires a number of definitions for
	  that class to be set up using the <literal>SC_HAS_PROCESS</literal>
	  macro.
	</para>

	<programlisting>SC_HAS_PROCESS( Or1ksimSC );</programlisting>

	<caution>
	  <para>
	    The <literal>SC_HAS_PROCESS</literal> macro is a common cause of
	    confusion with new users to &systemc; It doesn't appear in the
	    tutorial examples. The reason is that those examples use the
	    <literal>SC_CTOR</literal> macro to define the constructor for the
	    class, and the <literal>SC_CTOR</literal> macro provides the same
	    definitions as the <literal>SC_HAS_PROCESS</literal> macro.
	  </para>

	  <para>
	    The <literal>SC_CTOR</literal> macro can only be used where the
	    constructor's implementation is given within the class
	    definition. However, it is not good programming practice to mix
	    the definition of a class (i.e. what it is) with its
	    implementation (i.e. how it does it).
	  </para>

	  <para>
	    This application note follows the standard C++ practice of
	    defining a class in a header (<filename>.h</filename>) file based
	    on the class name and providing the implementation in a separate
	    C++ source (<filename>.cpp</filename>) file also based on the
	    class name.
	  </para>

	  <para>
	    In cases such as this, where the constructor implementation is
	    separate from the definition, &systemc; requires that the
	    <literal>SC_HAS_PROCESS</literal> macro is used before the code of
	    any class methods.
	  </para>
	</caution>

      </sect3>
<sect3>
	<title>
	  Constructor
	</title>

	<para>
	  The constructor passes names to the constructors of its parent
	  (<literal>sc_module</literal>) and simple initiator port
	  (<literal>dataBus</literal>), then calls the
	  <function>or1ksim_init()</function> routine in the &or1ksim; library
	  to initialize the &iss;.
	</para>

	<para>
	  The member function, <function>run()</function> is initialized as a
	  &systemc; thread, using the <literal>SC_THREAD</literal> macro. It
	  will be called automatically by the &systemc; kernel after
	  elaboration (i.e &systemc; initialization).
	</para>

	<programlisting>Or1ksimSC::Or1ksimSC ( sc_core::sc_module_name  name,
                       const char              *configFile,
                       const char              *imageFile ) :
  sc_module( name ),
  dataIni( "data_initiator" )
{
  or1ksim_init( configFile, imageFile, this, staticReadUpcall,
                staticWriteUpcall );

  SC_THREAD( run );               // Thread to run the ISS

}       /* Or1ksimSC() */</programlisting>


      </sect3>
<sect3 id="sec_Or1ksimSC_impl_thread">
	<title>
	  Thread
	</title>

      <para>
	The main thread, <function>run()</function>, invokes the &or1ksim;
	&iss; to run for ever (by passing a negative time argument). The &iss;
	will use the upcalls (see <xref linkend="sec_upcall" />> to request
	reads from and writes to the peripheral address space.
      </para>

      <para>
	The thread is called automatically when the &systemc; kernel has
	completed elaboration (i.e. is initialized).
      </para>

      <programlisting>void
Or1ksimSC::run()
{
  scLastUpTime   = sc_core::sc_time_stamp();
  or1kLastUpTime = or1ksim_time();

  (void)or1ksim_run( -1.0 );

}       // Or1ksimSC()</programlisting>

      </sect3>
<sect3>
	<title>
	  Upcalls
	</title>

      <para>
	As noted in <xref linkend="sec_upcall" />, the first two functions
	declared are static member functions which implement the upcalls from
	the &or1ksim; library.
      </para>

      <para>
	The static functions receive the pointer to the
	<literal>Or1ksimSC</literal> instance which originally started the
	&or1ksim; &iss; (provided as an argument to
	<function>or1ksim_init()</function> described in <xref
	linkend="sec_Or1ksimSC_impl_thread" />).
      </para>

      <para>
	This allows the each function to call the member function which
	implements the upcall, as shown here with
	<function>staticReadUpcall</function>:
      </para>

      <programlisting>unsigned long int
Or1ksimSC::staticReadUpcall( void              *instancePtr,
			     unsigned long int  addr,
			     unsigned long int  mask )
{
  Or1ksimSC *classPtr = (Or1ksimSC *)instancePtr;

  return (unsigned long int)classPtr->readUpcall( (sc_dt::uint64)addr,
						  (uint32_t)mask );
}	// staticReadUpcall()</programlisting>

        <para>
	  The address is cast to the &systemc; native 64-bit type, which is
	  always used in &tlm2; for addresses. The mask and result (and write
	  data for <function>staticWriteUpcall()</function> are cast to the
	  POSIX <literal>uint32_t</literal> fixed length type to avoid any
	  ambiguity over size<footnote>
	    <para>
	      While <literal>unsigned&nbsp;long&nbsp;int</literal> is almost
	      always 32 bits long, it is not guaranteed to be so.
	    </para>
	  </footnote>.
	</para>

	<caution>
	  <para>
	    It might be thought that providing a direct upcall to the C++
	    upcall methods of the class would be more efficient, using the C++
	    member reference operator (<literal>::*</literal>). However the
	    linkage to a member is much more complex (to cope with inheritance
	    and overloading). Lack of standardization in the C++
	    <firstterm>Application Binary Interface</firstterm>
	    (<acronym>ABI</acronym>) means that such linkage between C and C++
	    will not necessarily work.
	  </para>

	  <para>
	    Linkage to static routines is much simpler and usually works
	    between C and C++. So the approach used here is more reliable.
	  </para>
	</caution>

	<para>
	  The upcalls from the &iss; generate the transactional
	  activity. These routines set up the payload, execute the transaction
	  (i.e exchange the payload and result with the target) and return the
	  result to the &iss;.
	</para>

	<para>
	  The example here is coded in a very simple fashion, in the knowledge
	  that the requests to read are always four bytes long (the &or1k; has
	  a simple 32 bit bus), possibly with some bytes masked out for byte
	  and half-word reads. This matches the default
	  <literal>BUSWIDTH</literal> of the simple initiator socket.
	</para>

	<para>
	  Both payload and data are declared as local (automatic) variables,
	  i.e. on the stack. This is fine with a blocking transport method,
	  since they will remain valid for the duration of the
	  transaction. The data and mask are both encoded in the four bytes of
	  a POSIX <literal>uint32_t</literal>.
	</para>

	<caution>
	  <para>
	    Using local variables would not be appropriate with a non-blocking
	    socket, since the initiator routine could return before the result
	    of the transaction is received back from the target.
	  </para>

	  <para>
	    &tlm2; requires that the payload, data and mask fields all remain
	    valid for the duration of the complete transaction, so heap
	    allocation and deletion would be required in this case.
	  </para>
	</caution>

      </sect3>
      <sect3 id="sec_Or1ksimSC_impl_btrans">
	<title>
	  Blocking Transport
	</title>

	<para>
	  Once the payload fields are set up, the
	  <function>doTrans()</function> function (which is used for both read
	  and write) is called to transport the payload to the target and
	  return the result.
	</para>

	<para>
	  The transport method requires a time to be supplied, even when
	  timing is not being used (as in this case). This must be time
	  variable, since the target can update the value, so a dummy variable
	  is declared with zero time and passed to the blocking transport
	  method of the socket with the payload.
	</para>

        <programlisting>  sc_core::sc_time  dummyDelay = sc_core::sc_time( 0.0, sc_core::SC_SEC );

  dataBus->b_transport( trans, dummyDelay );</programlisting>

        <para>
	  This implementation is sufficient for modeling just the &or1ksim;
	  &iss; in &systemc;. However at no time does the thread execute a
	  &systemc; <function>wait()</function> call. In the absence of any such
	  yield, no other thread would be able to execute. This will be remedied
	  in <xref linkend="sec_uart" /> when other threads are added to model
	  peripherals.
	</para>

      </sect3>
    </sect2>
  </sect1>

<sect1 id="sec_iss_wrapper_test">
    <title>
      Testing the &or1ksim; &iss; &tlm2; Wrapper
    </title>

    <para>
      The test configuration was shown earlier in <xref linkend="fig_iss_test"
      />. For this a simple logger is needed, which must implement a &tlm2;
      simple target socket.
    </para>

    <para>
      In addition, a simple embedded application is needed to run on the
      &or1ksim; &iss;, which will make reads and writes to peripheral address
      space, which can be detected by the logger.
    </para>

    <para>
      All the behavior is in the callback function&mdash;there are no &systemc;
      threads. This means the logger will be suitable for testing the
      <classname>Or1ksimSC</classname> wrapper module, even though its thread
      never yields.
    </para>

    <sect2>
      <title>
	Definition of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Include Files
	</title>

	<para>
	  The logger is based on the &tlm2; convenience simple target socket, so
	  needs the appropriate header:
	</para>

	<programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Declaration and Constructor
	</title>

        <para>
	  The class is a standard &systemc; module:
	</para>

	<programlisting>class LoggerSC
: public sc_core::sc_module</programlisting>

        <para>
	  A custom constructor is needed, which will be used to register the
	  callback function for the simple target convenience socket blocking
	  transport.
	</para>

	<programlisting>  LoggerSC( sc_core::sc_module_name  name );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The public interface is the single simple target convenience
	  socket.
	</para>

	<programlisting>  tlm_utils::simple_target_socket&lt;LoggerSC&gt;  loggerPort;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport
	</title>

	<para>
	  Blocking transport is via a callback routine:
	</para>

        <programlisting>  void  loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                         sc_core::sc_time         &amp;delay );</programlisting>

        <para>
	  All the behavior of the module is captured in this callback
	  routine. There are no &systemc; threads required.
	</para>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Implementation of the &tlm2; Logger Module
      </title>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The logger will be doing a certain amount of stream IO, so includes
	  the C++ headers that define stream manipulation functions. The POSIX
	  standard integer types are also included.
      </para>

      <programlisting>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdint.h&gt;

#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Constructor
	</title>

        <para>
	  The constructor passes its argument (the module) name to the parent
	  <literal>sc_module</literal>literal> constructor. The body of the
	  routine then registers the <function>loggerReadWrite()</function>
	  method as the callback for blocking transport to this convenience
	  socket. This means that any initiator which requests blocking
	  transport (by calling the initiator socket's
	  <function>b_transport</function> method) will invoke this callback
	  routine in the target.
	</para>

	<programlisting>LoggerSC::LoggerSC( sc_core::sc_module_name  name ) :
  sc_module( name )
{
  loggerPort.register_b_transport( this, &amp;LoggerSC::loggerReadWrite );

}       // Or1ksimSC()</programlisting>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The callback function, <function>loggerReadWrite()</function> records
	  the key information regarding any transaction it receives. The
	  payload is a &tlm2; Generic Payload, with appropriate access
	  routines. In this simple implementation, a length of 4 bytes is
	  assumed for the data in the payload.
	</para>
	
	<para>
	  To get at the data and byte enable mask, the pointers to
	  <literal>unsigned char</literal> are cast to pointers to the POSIX
	  fixed width type, <literal>uint32_t</literal>, as was used with
	  <classname>Or1ksimSC</classname>. Endianism issues due to the byte
	  pointers not being word aligned are not an issue, because the
	  <classname>Or1ksimSC</classname> module also declared them as
	  <literal>uint32_t</literal>.
	</para>

        <programlisting>void
LoggerSC::loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                           sc_core::sc_time         &amp;delay )
{
  // Break out the address, mask and data pointer.

  tlm::tlm_command   comm    = payload.get_command();
  sc_dt::uint64      addr    = payload.get_address();
  unsigned char     *maskPtr = payload.get_byte_enable_ptr();
  unsigned char     *dataPtr = payload.get_data_ptr();

  // Record the payload fields (data only if it's a write)

  const char *commStr;

  switch( comm ) {
  case tlm::TLM_READ_COMMAND:   commStr = "Read";   break;
  case tlm::TLM_WRITE_COMMAND:  commStr = "Write";  break;
  case tlm::TLM_IGNORE_COMMAND: commStr = "Ignore"; break;
  }

  std::cout &lt;&lt; "Logging" &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Command:      "   &lt;&lt; commStr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Address:      0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; (uint64_t)addr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Byte enables: 0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; *((uint32_t *)maskPtr) &lt;&lt; std::endl;

  if( tlm::TLM_WRITE_COMMAND == comm ) {
    std::cout &lt;&lt; "  Data:         0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
              &lt;&lt;std::hex &lt;&lt; *((uint32_t *)dataPtr) &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

  payload.set_response_status( tlm::TLM_OK_RESPONSE );  // Always OK

}       // loggerReadWrite()</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_logger_main_prog">
      <title>
	The Model Main Program
      </title>

      <para>
	The logger module and the &or1ksim; wrapper module must be connected
	in the main program (<function>sc_main</function> since this is
	&systemc;), and the simulation invoked.
      </para>

      <sect3>
	<title>
	  Included Headers
	</title>

	<para>
	  The program includes the main &tlm2; header and the header of the
	  two modules which will be used:
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimSC.h"
#include "LoggerSC.h"</programlisting>

      </sect3>

      <sect3>
	<title>
	  Argument Processing
	</title>

	<para>
	  The program takes two arguments, an &or1ksim; configuration file
	  (described further in <xref linkend="sec_iss_run_test" />) and a
	  binary image to execute on the &or1ksim; &iss; (see <xref
	  linkend="sec_iss_or32_prog" />).
	</para>

	<programlisting>int  sc_main( int   argc,
              char *argv[] )
{
  if( argc != 3 ) {
    fprintf( stderr, "Usage: TestSC &lt;config_file&gt; &lt;image_file&gt;\n" );
    exit( 1 );
  }</programlisting>

      </sect3>

      <sect3>
	<title>
	  Module Instantiation
	</title>

        <para>
	  Instances of the &or1ksim; &iss; and the logger are created, the
	  &iss; being passed the two program arguments for its initialization.
	</para>

	<programlisting>  Or1ksimSC  iss( "or1ksim", argv[1], argv[2] );
  LoggerSC   logger( "logger" );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Connecting the Modules
	</title>

        <para>
	  The target socket of the logger (<literal>loggerPort</literal>) is
	  connected by passing it as argument to the initiator socket of the
	  &iss; (<literal>dataBus</literal>). The C++ function application
	  operator, <literal>()</literal>, is overloaded for initiator sockets
	  to provide this binding function.
	</para>

	<programlisting>  iss.dataBus( logger.loggerPort );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Model Execution
	</title>

	<para>
	  Once the model is instantiated, simulation is invoked to run forever.
	</para>
	  
	<programlisting>  sc_core::sc_start();</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_or32_prog">
      <title>
	Test Program to Run on the &or1ksim;
      </title>

      <para>
	The test program (in <filename>logger_test.c</filename> defines a
	memory mapped volatile data structure and then writes to and reads
	from each element of that structure. Compilation of this program
	requires the &or1k; GNU tool chain (see <xref linkend="ref_app_note_1"
	endterm="ref_app_note_1_xr" /> for details of installing this).
      </para>

      <sect3>
	<title>
	  The Utility Functions
	</title>

	<para>
	  The test program uses some simple utility functions which can write
	  characters (<function>simputc()</function>), string
	  (<function>simputs()</function>) and hexadecimal numbers
	  (<function>simputh()</function>). Its header is included:
	</para>

	<programlisting>#include "utils.h"</programlisting>

	<para>
	  The utilities' implementation can be found in
	  <filename>utils.c</filename>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Memory Mapped Data Structure
	</title>

	<para>
	  The memory mapped address is defined in the configuration of
	  &or1ksim; (see <xref linkend="sec_iss_run_test" />) to be
	  0x90000000. This is set as a defined constant in the test program.
	</para>

	<programlisting>#define BASEADDR  0x90000000</programlisting>

	<para>
	  The memory mapped structure consists of a byte, half word (16 bits)
	  and full word (32 bits), all declared as <literal>volatile</literal>
	  within the <literal>struct</literal>. These are all declared with
	  the C types, which for the &or1k; tool chain are known to correspond
	  to these sizes.
	</para>

	<programlisting>struct  testdev
{
  volatile unsigned char       byte;
  volatile unsigned short int  halfword;
  volatile unsigned long  int  fullword;
};</programlisting>

        <para>
	  The main program declares a pointer to this
	  <literal>struct</literal> at the <literal>BASEADDR</literal>, along
	  with 3 variables to hold the results of the various sized results
	  when reading.
	</para>

	<programlisting>main()
{
  struct testdev *dev = (struct testdev *)BASEADDR;

  unsigned char       byteRes;
  unsigned short int  halfwordRes;
  unsigned long int   fullwordRes;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Write Access
	</title>

	<para>
	  The details of each write are logged and the value then written. (In
	  the absence of a <function>printf()</function>, the logging is
	  necessarily cumbersome).
	</para>

	<programlisting>  simputs( "Writing byte 0xa5 to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );
  dev->byte     =       0xa5;

  simputs( "Writing half word 0xbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );
  dev->halfword =     0xbeef;

  simputs( "Writing full word 0xdeadbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );
  dev->fullword = 0xdeadbeef;</programlisting>

      </sect3>

      <sect3>
	<title>
	  Checking Read Access
	</title>

        <para>
	  The values are then read back. No results are expected (the logger
	  does not set any values), but this should check the process behaves
	  as expected.
	</para>

	<programlisting>  byteRes = dev->byte;
  simputs( "Read 0x" );
  simputh(  byteRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );

  halfwordRes = dev->halfword;
  simputs( "Read 0x" );
  simputh( halfwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );

  fullwordRes = dev->fullword;
  simputs( "Read 0x" );
  simputh( fullwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );</programlisting>

        <para>
	  At the end of the program, the utility
	  <function>simexit()</function> is used. This not only terminates the
	  program, but will also exit the simulation.
	</para>

      </sect3>

      <sect3>
	<title>
	  Program Compilation
	</title>

	<para>
	  The program is compiled with the utility routines (in
	  <filename>utils.c</filename>) and a small boot loader (in
	  <filename>start.s</filename>) which defines a
	  <literal>_start</literal> routine which invokes
	  <function>main()</function>. The linker arguments are chosen to make
	  the program load from start of memory, with the
	  <literal>_start</literal> routine sitting at the &or1k; reset vector
	  (0x100).
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_iss_run_test">
      <title>
	Running the Test
      </title>
      <sect3>
	<title>
	  Compiling the &systemc; Model
	</title>

	<para>
	  The SystemC modules are each compiled with access to the &or1ksim;,
	  &systemc; and &tlm2; header directories. It is also essential that
	  <literal>SC_INCLUDE_DYNAMIC_PROCESSES</literal> is defined when
	  using &tlm2;:
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c TestSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c Or1ksimSC.cpp
g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES -I$OR1KSIM_HOME/include \
    -I$SYSTEMC_HOME/include -I$TLM_HOME/include/tlm -c LoggerSC.cpp</programlisting>

        <para>
	  The final linking must include the &systemc; library, and since the
	  &or1ksim; library includes some shared objects, linker directions to
	  find those shared objects
	  (<literal>-Wl,--rpath,$OR1KSIM_HOME</literal>).
	</para>

	<programlisting>g++ -ggdb -DSC_INCLUDE_DYNAMIC_PROCESSES TestSC.o Or1ksimSC.o LoggerSC.o \
    -Wl,--rpath,$OR1KSIM_HOME/lib -L$OR1KSIM_HOME/lib \
    -L$SYSTEMC_HOME/lib-linux -lsim -lsystemc -o TestSC</programlisting>

      </sect3>
      <sect3>
	<title>
	  Configuring the &or1k; &or1ksim; &iss;
	</title>

	<para>
	  The &or1ksim; &iss; is configured using a textual configuration
	  file, described in more detail in <xref linkend="ref_app_note_1"
	  endterm="ref_app_note_1_xr" />. For the modified &or1ksim;,
	  <literal>generic</literal> peripherals can be added, which will
	  cause code to call out via the upcall mechanism to the &or1ksim;
	  &systemc; wrapper module (see <xref linkend="sec_upcall" />).
	</para>

	<para>
	  The configuration file for &or1ksim; disables all the standard
	  peripherals, apart from one block of memory from address 0x0. It
	  adds a <literal>generic</literal> peripheral allowing byte, half
	  word and full word access to addresses mapped from 0x90000000 to
	  0x90000007, with the following configuration file entry
	</para>

	<programlisting>section generic
  enabled      =          1
  byte_enabled =          1
  hw_enabled   =          1
  word_enabled =          1
  name         = "External UART"
  baseaddr     = 0x90000000
  size         = 0x8
end</programlisting>

      </sect3>
      <sect3>
	<title>
	  Running the Compiled Model
	</title>

        <para>
	  The compiled program can be executed by passing in as arguments
	  the &or1ksim; configuration file and the &or1k; binary. The result
	  is shown in <xref linkend="fig_logger_test" />.
	</para>

	<figure id="fig_logger_test">
	  <title>
	    Output from the logger test of the &or1ksim; wrapper module.
	  </title>

	  <screen>$ ./TestSC ../simple.cfg ../progs_or32/logger_test

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Writing byte 0xa5 to address 0x090000000
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0x000000ff
  Data:         0x000000a5
  Delay:        0.000000000s

Writing half word 0xbeef to address 0x090000002
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0xffff0000
  Data:         0xbeef0000
  Delay:        0.000000000s

   ... &lt;More test program output&gt;

Logging
  Command:      Read
  Address:      0x90000004
  Byte enables: 0xffffffff
  Delay:        0.000000000s

Read full word 0x0 from address 0x090000004
exit(0)
@reset : cycles 0, insn #0
@exit  : cycles 26921, insn #13854
 diff  : cycles 26921, insn #13854
$ </screen>
	</figure>

	<para>
	  Each access from the application program generates the expected
	  transactional access. All accesses are 32 bits wide, but for byte
	  and half-word access the relevant bytes are masked off.
	</para>

	<note>
	  <para>
	    The &or1ksim; can be configured to model big-endian
	    architectures. The &tlm2; payloads are always packed with data
	    using the endianism of the model.
	  </para>

	  <para>
	    If the exercise were repeated with a big-endian version of
	    &or1ksim; the addresses of the access would be unchanged (they are
	    word aligned), but the byte enable masks for the byte and half
	    word accesses would be inverted.
	  </para>
	</note>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="sec_uart">
    <title>
      Modeling Peripherals
    </title>

    <para>
      This example uses a single peripheral, a &uart;. The &uart; model is
      based on National Semiconductor 16450 design.
    </para>

    <sect2>
      <title>
	Details of the 16450 &uart;
      </title>

      <para>
	The 16450 &uart; is a very long established industry component. Data
	written a byte at a time into the transmit buffer is converted to
	serial pulses on the output (Tx) pin. Serial pulses on the input (Rx)
	pin are recognized and converted to byte values, which can be read
	from the receive buffer. Typically Rx and Tx are connected to a
	terminal and keyboard which can generate and recognize the pulses of
	data. The &uart; can also generate additional signals for terminals and
	keyboards to provide physical flow control, but that is beyond the
	scope of this model. The key interfaces are shown in <xref
	linkend="fig_uart" />.
      </para>

	<figure id="fig_uart">
	  <title>
	    Simple SoC based on the &or1k; &or1ksim;16450 &uart;: Key interfaces.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="uart.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      <para>
	The 16450 &uart; specifies a set of registers which control the &uart;
	behavior. On the Tx/Rx side, this includes setting the board rate and
	the pattern of stop, start and data bits. On the CPU side this
	includes configuring interrupt behavior (if any) and setting flags to
	show the status of transmit and receive buffers. The registers are
	shown in <xref linkend="tab_ns_16450_regs" />.
      </para>

      <table id="tab_ns_16450_regs" frame='all'>
	<title>
	  NS 16450 &uart; Registers
	</title>
	<tgroup cols='4' align="left" colsep="1" rowsep="1">
	  <colspec colwidth="2*" colname="address" />
	  <colspec colwidth="2*" colname="register" />
	  <colspec colwidth="1*" colname="rw" />
	  <colspec colwidth="8*" colname="description" />

	  <thead>
	    <row>
	      <entry>
		Address
	      </entry>
	      <entry>
		Register
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		Description
	      </entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry morerows="2">
		0
	      </entry>
	      <entry>
		<literal>RXBUF</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for read data.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>TXBUF</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for data to be
		  written.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLL</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the low byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry morerows="1">
		1
	      </entry>
	      <entry>
		<literal>IER</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  The interrupt enable register. The lower 4 bits control
		  which events generate an interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLH</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the high byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		2
	      </entry>
	      <entry>
		<literal>IIR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Interrupt identification register. Bit 0 indicates if an
		  interrupt is pending, bits 1-2 the reason for the
		  interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		3
	      </entry>
	      <entry>
		<literal>LCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Line control register. Various bits controlling the behavior
		  of the &uart;. Of these, <literal>DLAB</literal>, bit 7, the
		  divisor latch access bit is important, because it controls
		  the behavior of registers 0
		  (<literal>RXBUF</literal>/<literal>TXBUF</literal>/<literal>DLL</literal>)
		  and 1 (<literal>IER</literal>/<literal>DLH</literal>).
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		4
	      </entry>
	      <entry>
		<literal>MCR</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  Modem control register. Bits 0-4 control the
		  behavior of the modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		5
	      </entry>
	      <entry>
		<literal>LSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Line status register. Bits 0-6 report the status of the
		  &uart;. Of these, DR, bit 0, receiver data ready is
		  important, indicating there is valid data in
		  <literal>RXBUF</literal>.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		6
	      </entry>
	      <entry>
		<literal>MSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Modem Status Register. Bits reporting the state of the
		  modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		7
	      </entry>
	      <entry>
		<literal>SCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Scratch register. Not used by the &uart;, but may be used by
		  the application to store an 8-bit value.
		</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
      </para>

    </sect2>

    <sect2>
      <title>
	&uart; Module Design
      </title>

      <para>
	A transaction level model cannot show all the intricacies of a
	&uart;&mdash;the whole point is to simplify and remove detail.
      </para>

      <para>
	The &tlm; should allow the CPU to read and write registers, a terminal
	to send and receive characters and should generate interrupts as
	appropriate. While all writable registers can be written and all
	readable registers read, only those registers and bits of registers
	which are relevant to this level of modeling will have any impact on
	behavior.
      </para>

      <sect3>
	<title>
	  &uart; Model Interfaces
	</title>

	<para>
	  A &tlm2; socket is the natural model for the bus interface to the
	  CPU. However the interface to the terminal is much simpler. A
	  standard &systemc; one byte FIFO will be suitable.
	</para>

	<note>
	  <para>
	    It might be thought that an 8-bit &systemc; signal or buffer port
	    would be suitable. However &systemc; signal ports model physical
	    wires, and only notify changes to the value on the wire. This
	    would be suitable if the &uart; were to model the pulses signaled
	    across the wire.
	  </para>

	  <para>
	    &systemc; does offer a buffer class, <literal>sc_buffer</literal>,
	    which provides notification on <emphasis>any</emphasis>
	    write. However support for buffers is limited (there are no
	    special ports provided for example).
	  </para>

	  <para>
	    At this level of modeling, complete bytes are being transferred. It
	    is quite possible that two identical bytes would follow each
	    other. A signal port would not notify any change to the recipient,
	    while a FIFO will signal that data has been written.
	  </para>

	  <para>
	    FIFOs also offer the possibility that a future implementation
	    could implement a custom derived class, which explicitly modeled
	    the delay in putting bits on the wire, delaying notification of a
	    write for the appropriate time.
	  </para>
	</note>

	<para>
	  The interrupt is modeled as a signal, active high for the
	  16450. &systemc; static sensitivity to this signal is a natural way
	  for connected modules to detect the interrupt.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Model Registers
	</title>

	<para>
	  The divisor latch affects the baud rate, which will affect timing of
	  transfers. This will be covered in a later section (see <xref
	  linkend="sec_sync" />), but is not needed for the current untimed
	  model. The value can be written and read, but does not affect
	  behavior.
	</para>

	<para>
	  Only two interrupts are relevant (see <xref
	  linkend="sec_uart_interrupts" />), and only the corresponding bits
	  in the interrupt enable and interrupt identification registers are
	  modeled.
	</para>

	<para>
	  The modem control and status registers are irrelevant to this model
	  and do not influence its behavior, the modem control register can be
	  written and the status register read, but their contents are not
	  affected by the behavior of the modem.
	</para>

	<para>
	  The line control register sets details of the bit transfers. In a
	  later section (see <xref linkend="sec_sync" />), this will affect
	  the timing of transfers, but it is not relevant to the current
	  untimed model, and is ignored.
	</para>

	<para>
	  In the Line Status Register, the <literal>Data Ready</literal> and
	  <literal>Transmitter Holding Empty</literal>/<literal>Transmitter
	  Empty</literal> bits are the only ones modeled. The model does not
	  distinguish a separate buffer and holding transmit register, so the
	  last two of these will move in step in the model.
	</para>

      </sect3>

      <sect3 id="sec_uart_interrupts">
	<title>
	  &uart; Model Interrupts
	</title>

	<para>
	  Only two interrupts are relevant, <literal>Register Data
	  Empty</literal> and <literal>Transmit Holding Register
	  Empty</literal>. Only the corresponding bits of the interrupt enable
	  and identification registers are relevant.
	</para>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_or1ksim_libext">
      <title>
	 Extending the <classname>Or1ksimSC</classname> Wrapper Module
      </title>

      <para>
	For a larger system, the
	&or1ksim; wrapper module must be extended. A public function is
	required for peripheral models to establish the CPU endianism.
      </para>

      <para>
	The function must be added to the underlying &or1ksim; library and
	then a wrapper function added to the <classname>Or1ksimSC</classname>
	wrapper module.
      </para>

      <para>
	In <xref linkend="sec_Or1ksimSC_impl_btrans" /> it was noted that the
	absence of any call to <function>wait()</function> meant the &or1ksim;
	&iss; could be the only thread in the model. The
	<function>doTrans()</function> function must be extended to yield
	after each transaction to allow other threads to run.
      </para>

      <para>
	These extensions are achieved by defining a new
	class, <classname>Or1ksimExtSC</classname> derived from the existing
	<classname>Or1ksimSC</classname> class. It inherits all the
	functionality of the existing class, replaces that of the transport
	function, <function>doTrans()</function> and adds an additional public
	interface function, <function>isLittleEndian()</function>.
      </para>
      <sect3 id="sec_or1ksim_extlib">
	<title>
	  Adding an Endianism Test Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function is straightforward, since endianism is a
	  compile time constant in the &or1ksim; &iss;.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>int  or1ksim_is_le();</programlisting>
	    </para>

	    <para>
	      <function>or1ksim_is_le()</function> returns 1 if &or1ksim; is
	      modeling a <firstterm>little&#32;endian</firstterm>
	      architecture, 0 otherwise. It is needed to ensure the payload is
	      packed with the correct byte ordering.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimExtSC</classname> is derived from
	  <classname>Or1ksimSC</classname>, so the definition file includes
	  its header. The module class can then inherit from that class.
	</para>

	<programlisting>#include "Or1ksimSC.h"

class Or1ksimExtSC
: public Or1ksimSC
{</programlisting>

	<para>
	  A custom constructor must be defined. Custom constructors do not
	  inherit, so a new custom constructor is defined just to pass the
	  arguments on to the parent.
	</para>

	<programlisting>  Or1ksimExtSC( sc_core::sc_module_name  name,
                const char              *configFile,
                const char              *imageFile );</programlisting>

	<para>
	  A new public function to report the endianism of the underlying CPU
	  model is defined
	</para>

	<programlisting>bool  isLittleEndian();</programlisting>

	<para>
	  The <function>doTrans()</function> is reimplemented here, to allow
	  the thread to yield. The function remains protected and virtual,
	  since it will be redefined again later in this application note.
	</para>

	<programlisting>virtual void  doTrans( tlm::tlm_generic_payload &amp;trans );</programlisting>

      </sect3>
      <sect3>
	<title>
	  Extended &or1ksim; Wrapper Module Class Implementation
	</title>

	<para>
	  The constructor just passes its arguments to its parent
	</para>

	<programlisting>Or1ksimExtSC::Or1ksimExtSC ( sc_core::sc_module_name  name,
                             const char              *configFile,
                             const char              *imageFile ) :
  Or1ksimSC( name, configFile, imageFile )
{
 }      // Or1ksimExtSC()</programlisting>

	<para>
	  <function>isLittleEndian()</function> is a simple wrapper for the
	  underlying &or1ksim; &iss; library function<footnote>
	    <para>
	      A technicality is that the &or1ksim; library function,
	      <function>is_little_endian()</function> returns an
	      <literal>int</literal>, since C does not have a
	      <literal>bool</literal> type. A C++ compiler would automatically
	      convert one to the other, but making the comparison explicit is
	      good for clarity. The same code will be generated, so there is
	      no loss of performance.
	    </para>
	  </footnote>.
	</para>

	<programlisting>bool
Or1ksimExtSC::isLittleEndian()
{
  return (1 == or1ksim_is_le());

}	// or1ksimIsLe()</programlisting>

	<para>
	  The majority of the code for <function>doTrans()</function> is
	  unchanged from its implementation in
	  <classname>Or1ksimSC</classname>. The addition is a
	  <function>wait()</function> for zero time immediately after the
	  transaction has completed. This allows the &systemc; thread to
	  yield, so that any other threads that are ready can take a turn.
	</para>

	<programlisting>  wait( sc_core::sc_time( 0.0, sc_core::SC_SEC ));</programlisting>

	<caution>
	  <para>
	    The call to <function>wait()</function> is essential. &systemc; is
	    not preemptive. Other threads are only considered for execution
	    when the currently executing thread yields. If the code were to
	    return here, control would pass back to the underlying &or1ksim;
	    &iss; until its next upcall, with no opportunity for another
	    &systemc; thread to execute.
	  </para>

	  <para>
	    The implementation currently is untimed, so a zero delay wait is
	    perfectly acceptable. That just gives all the other untimed
	    threads a turn at execution.
	  </para>

	  <para>
	    The logger described in <xref linkend="sec_iss_wrapper_test" />
	    worked without this call to <function>wait()</function>, because
	    it had no thread&mdash;all its functionality was in the blocking
	    transaction callback function.
	  </para>
	</caution>

      </sect3>
    </sect2>

    <!-- ========== UART Definition ========== -->

    <sect2>
      <title>
	&uart;: Module Class Definition
      </title>

      <para>
	The &uart; module class, <classname>UartSC</classname> is defined in
	<filename>UartSC.h</filename>. It uses the &tlm2; simple target
	convenience socket (described earlier in <xref
	linkend="sec_iss_wrapper_test" />).
      </para>

      <sect3>
	<title>
	  Headers and Constant Definitions
	</title>

	<para>
	  The header files for &tlm2; and the simple target convenience
	  socket are included.
      </para>

      <programlisting>#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"</programlisting>

      <para>
	Convenience constants for the address mask, named register offsets and
	bit fields are then defined. The address mask is needed, since in this
	simple SoC model there is no arbiter/decoder to strip out the higher
	order bits from the address before the transaction is sent to the
	&uart;.
      </para>

      <programlisting>#define UART_ADDR_MASK      7     // Mask for addresses (3 bit bus)

// Offsets for the 16450 UART registers

#define UART_BUF  0             // R/W: Rx/Tx buffer, DLAB=0
#define UART_IER  1             // R/W: Interrupt Enable Register, DLAB=0
#define UART_IIR  2             // R: Interrupt ID Register
#define UART_LCR  3             // R/W: Line Control Register
#define UART_MCR  4             // W: Modem Control Register
#define UART_LSR  5             // R: Line Status Register
#define UART_MSR  6             // R: Modem Status Register
#define UART_SCR  7             // R/W: Scratch Register

// Interrupt Enable register bits of interest

#define UART_IER_ETBEI  0x02    // Enable transmitter holding register int.
#define UART_IER_ERBFI  0x01    // Enable receiver data interrupt

// Interrupt Identification register bits and interrupt masks of interest

#define UART_IIR_RDI    0x04    // Receiver data interrupt
#define UART_IIR_THRE   0x02    // Transmitter holding reg empty interrupt
#define UART_IIR_IPEND  0x00    // Interrupt pending

// Line Control register bits of interest and data word length mask

#define UART_LCR_DLAB   0x80    // Divisor latch access bit
#define UART_LCR_PEN    0x08    // Parity Enable
#define UART_LCR_STB    0x04    // Stop bits: 0=1 stop bit, 1= 2 stop bits
#define UART_LCR_MASK   0x03    // 2-bit mask for word length

// Line Status register bits of interest

#define UART_LSR_TEMT   0x40    // Transmitter serial register empty
#define UART_LSR_THRE   0x20    // Transmitter holding register empty
#define UART_LSR_DR     0x01    // Receiver data ready</programlisting>

      </sect3>

      <sect3>
	<title>
	  Class Declaration and Constructor
	</title>

        <para>
	  The main class is a standard &systemc; module class derived from
	  <classname>sc_core::sc_module</classname>.
	</para>

	<programlisting>class UartSC
: public sc_core::sc_module
{</programlisting>

	<para>
	  The module has a customized constructor, specifying an input clock
	  rate (which in the SoC example will be the SoC clock rate), and a flag
	  to indicate the endianism of the model.
	</para>

	<programlisting>  UartSC( sc_core::sc_module_name  name,
          unsigned long int        _clockRate,
          bool                     _isLittleEndian );</programlisting>

      </sect3>

      <sect3>
	<title>
	  Public Interface
	</title>

	<para>
	  The interfaces to the &uart; model are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      The simple target convenience port, <literal>bus</literal>,
	      representing the bus from the CPU;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The two &systemc; <literal>unsigned char</literal> FIFO ports
	      for Rx (input) and Tx (output) pins, <literal>rx</literal> and
	      <literal>tx</literal>); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A &systemc; Boolean output signal port for the interrupt,
	      <literal>intr</literal>.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect3>

      <!-- = Private Functions = -->

      <sect3>
	<title>
	  Threads
	</title>

	<para>
	  The two threads are <function>busThread()</function> waiting for
	  bytes written to the transmit buffer and
	  <function>rxThread()</function> waiting for bytes on the Rx FIFO.
	</para>

      </sect3>

      <sect3>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The blocking transport callback function is
	  <function>busReadWrite()</function>. This in turn calls for two
	  separate routines which implement read specific
	  (<function>busRead()</function>) and write specific
	  (<function>busWrite()</function>) behavior.
	</para>

      </sect3>

      <!-- = Private Utilities = -->

      <sect3>
	<title>
	  Utility Methods
	</title>

	<para>
	  Two utility routines are provided to generate an interrupt signal
	  (<function>genInt()</function>) and clear an interrupt
	  (<function>clearInt()</function>). A utility routine is also
	  provided to calculate the character delay, based on the baud rate
	  and number of stop, data, parity and start bits
	  (<function>resetCharDelay()</function>).
	</para>

	<para>
	  A set of convenience utilities are provided to set and clear flags
	  in registers (<function>set()</function>) and
	  <function>clear()</function>) and to test the state of a flag bit in
	  a register (<function>isSet()</function>) and
	  <function>isClear()</function>).
	</para>

      </sect3>

      <!-- = Private Attributes  = -->

      <sect3>
	<title>
	  &uart; State
	</title>

	<para>
	  A <literal>struct</literal>, <literal>regs</literal> is used to hold the value of each
	  register. There are nine of these, since register 0 is really two
	  registers, depending on whether it is being read
	  (<literal>rbr</literal>) or written (<literal>thr</literal>).
	</para>

	<programlisting>  struct {
    unsigned char  rbr;         // R: Rx buffer,
    unsigned char  thr;         // R: Tx hold reg,
    unsigned char  ier;         // R/W: Interrupt Enable Register
    unsigned char  iir;         // R: Interrupt ID Register
    unsigned char  lcr;         // R/W: Line Control Register
    unsigned char  mcr;         // W: Modem Control Register
    unsigned char  lsr;         // R: Line Status Register
    unsigned char  msr;         // R: Modem Status Register
    unsigned char  scr;         // R/W: Scratch Register            
  } regs;</programlisting>

	<para>
	  The divisor latch is effectively another 16-bit register,
	  declared separately, <literal>divLatch</literal>. A flag initialized
	  at construction records the model endianism,
	  <literal>isLittleEndian</literal>.
	</para>

      </sect3>

      <sect3>
	<title>
	  Transmit Data Available Event
	</title>

	<para>
	  A method is needed for the &tlm2; callback routine,
	  <function>busReadWrite()</function> to notify the thread handling
	  data being sent for transmission
	  (<function>busThread()</function>). This is achieved with a
	  &systemc; event:
	</para>

	<programlisting>  sc_core::sc_event  txReceived;</programlisting>

	<para>
	  The callback routine use notification on this event, to trigger
	  behavior in the <function>busThread()</function>.
	</para>

      </sect3>
    </sect2>

    <!-- ========== UART Implementation ========== -->

    <sect2 id="sec_uart_impl">
      <title>
	&uart; Module Class Implementation
      </title>

      <sect3>
	<title>
	  &uart; Constructor
	</title>
	
	<para>
	  Declaration of the constructor is preceded, like
	  <classname>Or1ksimSC</classname>, by the SystemC macro
	</para>

	<programlisting>SC_HAS_PROCESS( UartSC );</programlisting>

	<para>
	  The constructor save the endianism flags in its internal state, then
	  registers the two threads
	</para>

	<programlisting>  SC_THREAD( busThread );
  SC_THREAD( rxThread );</programlisting>

        <para>
	  The blocking transport callback is registered for the
	  <literal>bus</literal> socket, in the same manner as was used for
	  the logger, <classname>LoggerSC</classname>.
	</para>

	<para>
	  Finally the registers (<literal>regs</literal>) are cleared. There
	  is no initialization of the divisor latch, since this is undefined
	  until set.
	</para>
      </sect3>

      <sect3>
	<title>
	  &uart; Threads
	</title>
	
	<para>
	  <literal>busThread</literal> sits in a perpetual loop. It first
	  marks the transmit buffer as empty (on reset the flags are cleared,
	  so the buffer will appear full).
	</para>

	<note>
	  <para>
	    The 16450 &uart; describes two flags for transmit buffer status, one
	    to indicate that the transmit holding register is empty and a
	    second to indicate that the internal transmit buffer register is
	    empty.
	  </para>

	  <para>
	    For simplicity, this model does not model a separate internal
	    register (effectively a one byte FIFO), so both flags are set and
	    cleared together.
	  </para>
	</note>

	<para>
	  If the transmit buffer empty interrupt is enabled, the thread
	  generates an interrupt to indicate that the buffer is empty.
	</para>

	<para>
	  The thread then waits until it is notified via the SystemC event
	  <literal>txReceived</literal> that a byte is in the buffer to be
	  sent. This event will be triggered by the
	  <literal>busWrite()</literal> callback when a value is written into
	  the transmit holding register.
	</para>

	<para>
	  The second thread, <function>rxThread()</function> sits in a
	  perpetual loop, waiting for
	  characters to be received on the Rx FIFO. The character is read into
	  the read buffer register and the line status data ready flag is set
	  to indicate availability.
	</para>

	<para>
	  If the receive data interrupt is enabled, an interrupt is asserted
	  to indicate data availability.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Blocking Transport Callback
	</title>
	
	<para>
	  The registered callback routine is <literal>busReadWrite</literal>,
	  which breaks out the address, byte enable mask pointer and data
	  pointer. A <literal>switch</literal> statement on the mask is used
	  to determine the offset of the actual byte requested and hence the
	  exact byte address, allowing for the endianism of the model. This
	  also provides a check that only a single byte is being requested.
	</para>

	<programlisting>  switch( *((uint32_t *)maskPtr) ) {
  case 0x000000ff: offset = isLittleEndian ? 0 : 3; break;
  case 0x0000ff00: offset = isLittleEndian ? 1 : 2; break;
  case 0x00ff0000: offset = isLittleEndian ? 2 : 1; break;
  case 0xff000000: offset = isLittleEndian ? 3 : 0; break;

  default:              // Invalid request

    payload.set_response_status( tlm::TLM_GENERIC_ERROR_RESPONSE );
    return;
  }</programlisting>

	<para>
	  In a perfect world, the router/arbiter function would have masked
	  the address to the range handled by the &uart;. However for this
	  simple model, the full address is received, so masking with
	  <literal>UART_ADDR_MASK</literal> is carried out here, to give the
	  address of the &uart; register being read.
	</para>

	<para>
	  Separate routines, <function>busRead()</function> and
	  <function>busWrite()</function> are used to implement the register
	  specific behavior, selected as appropriate based on the payload
	  command field.
	</para>

	<para>
	  Single byte reads and writes always succeed, so the response is set
	  to <literal>tlm::TLM_OK_RESPONSE</literal> in all cases.
	</para>

      </sect3>

      <sect3>
	<title>
	  &uart; Read Behavior
	</title>
	
	<para>
	  Read behavior is handled by <function>busRead()</function>.  A
	  switch on the address is used to identify the result to be returned,
	  usually just the value in the register if it is readable. The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then reads to the first two registers (read buffer and
	      interrupt enable) yield instead the low and high bytes of the
	      divisor latch.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the read buffer (when <literal>DLAB=0</literal>) yields
	      the byte just read, if flag <literal>DR</literal> is set in the
	      line status register. The act of reading causes the
	      <literal>DR</literal> flag to be cleared
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the interrupt indicator register clears the highest
	      priority interrupt currently pending. If no interrupts remain
	      pending then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	</itemizedlist>
	
      </sect3>

      <sect3>
	<title>
	  &uart; Write Behavior
	</title>
	
	<para>
	  Write behavior is handled by <function>busWrite()</function>.  A
	  switch on the address is used to identify the action
	  required. Usually the register is just written (if writable). The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then writes to the first two registers (read buffer and
	      interrupt enable) update the low and high bytes of the
	      divisor latch respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Writing the transmit hold register (when
	      <literal>DLAB=0</literal>) triggers a new transfer. The flags
	      are set to indicate data is in the register, and the bus thread
	      (<function>busThread()</function>) notified via the &systemc;
	      event <literal>txReceived</literal>.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  &uart; Utility routines
	</title>
	
	<para>
	  <function>genInt()</function> generates an interrupt by setting the
	  relevant interrupt indicator flag and the interrupt pending flag and
	  then asserting the <literal>intr</literal> signal.
	</para>

	<para>
	  <function>clearInt()</function> is more complex, since there may be
	  more than one interrupt currently asserted (the model uses both the
	  transmit buffer empty and data received interrupt). Only one
	  interrupt is cleared by each read of the interrupt indicator
	  register, with the data received interrupt having higher
	  priority. This function clears the highest priority interrupt
	  currently asserted, and if no interrupts remain clears the pending
	  flag and deasserts the <literal>intr</literal> signal.
	</para>

	<para>
	  Finally a set of functions are provided to set, clear and test bits
	  in registers. Using these makes the code much more readable<footnote>
  	    <para>
	      Many programmers use <literal>#define</literal>d macros for
	      functions such as these. However such macros have no
	      encapsulation (they can be used by anyone including the header)
	      and have a nasty habit of clashing with other peoples macros. By
	      using functions, the routines can be made private to the
	      <classname>UartSC</classname> class alone.
	    </para>

	    <para>
	      The functions are declared in line, and a modern C++ compiler
	      will generate code as efficiently as if they had been
	      <literal>#define</literal>d as macros. Indeed the added type
	      information gives the potential for greater optimization.
	    </para>
	  </footnote>.
	</para>

      </sect3>
    </sect2>

  </sect1>

<sect1 id="sec_terminal">
    <title>
      Adding a Terminal as Test Bench
    </title>

    <para>
      The &iss; described in <xref linkend="sec_iss_wrapper" /> and the &uart;
      described in described in <xref linkend="sec_uart" /> can be put
      together as a minimal SoC. However a test bench is needed to exercise
      that SoC
    </para>

    <para>
      The natural way of exercising a SoC with a &uart; is to connect a
      terminal to the &uart;. This section describes a suitable &systemc;
      model of a terminal and how to connect it to create the complete SoC.
    </para>

    <para>
      This is not a &tlm2; component&mdash;the interfaces are standard
      &systemc; FIFOs, so the description is less detailed. However it serves
      to illustrate an important general technique when using
      &systemc;&mdash;how to interact with the operating system routines.
    </para>

    <para>
      The problem is that many operating system calls block. Consider
      modeling the terminal as a thread which reads characters from a console
      window. This will block until characters are typed. However the block
      does not use the &systemc; <function>wait()</function> call, so
      &systemc; is not aware that the thread has yielded. The simulation
      will hang until characters are received.
    </para>

    <para>
      This implementation of the terminal will show how to wrap non-blocking
      versions of operating system routines with &systemc; events, to give
      versions that block correctly using &systemc;
      <function>wait()</function>, so allowing the thread to yield.
    </para>

    <sect2>
      <title>
	&systemc; Terminal Module Design
      </title>

      <para>
	The terminal provides &systemc; FIFO interfaces to model the Rx and Tx
	pins of a serial connection. The visualization is provided by a &linux;
	&xterm; running in a child process, with
	communication through a pseudo-TTY<footnote>
	  <para>
	    The description here is specific to &linux;. A future version of
	    this application note will describe use under Microsoft Windows.
	  </para>
        </footnote>.
      </para>

      <para>
	Two threads are used, one waiting for bytes from the UART on the Rx
	FIFO, the other waiting for bytes from the &xterm;. When bytes are
	received on the Rx pin, they are written to the
	&xterm;. When bytes are received from the &xterm; they are written to
	the Tx FIFO. The key interfaces are shown in <xref
	linkend="fig_terminal" />.
      </para>

      <figure id="fig_terminal">
	<title>
	  &systemc; terminal model using a &xterm; child process.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="terminal.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="terminal.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The difficulty is in waiting for the xterm. As described above,
	reading from the pseudo TTY is an operating system call, and does not
	use the &systemc; <function>wait()</function>, so the thread will not
	yield and the simulation will block. Instead the pseudo-TTY is set up
	to use asynchronous I/O, which will cause a &linux;
	<literal>SIGIO</literal> to be raised whenever data is available to
	read. The event handler for <literal>SIGIO</literal> will then notify
	a &systemc; event, and it is this &systemc; event on which the thread
	can safely wait.
      </para>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Definition
      </title>

      <sect3>
	<title>
	  Mapping Signals to Class Instances
	</title>

	<para>
	  The operating system signal handlers require C style linkage, so
	  cannot be used with C++ member functions (the same issue address
	  with the &or1ksim; wrapper in <xref linkend="sec_upcall" />). Thus
	  the <literal>SIGIO</literal> handler will be a static
	  function. However each instance (there could be multiple terminals
	  in a simulation) will have a different file descriptor, which can be
	  used to identify the owning class instance.
	</para>

	<para>
	  The set of mappings from file descriptor to class instance is held
	  in a linked list with static head pointer. The <literal>struct
	  Fd2Inst</literal> is provided for that list, with entries for the
	  file descriptor, instance and a pointer to the next in the list.
	</para>

      </sect3>
      
      <sect3>
	<title>
	  The SystemC Class
	</title>

	<para>
	  <classname>TermSC</classname> is declared as a standard &systemc;
	  class, with two FIFO ports (one in, one out) to talk to the
	  &uart;. In this case it has a custom destructor, which will be
	  used to kill the child process running the &xterm; when the class is
	  deleted.
	</para>

      </sect3>

      <sect3>
	<title>
	  Setting up the &xterm;
	</title>

	<para>
	  A set of utility functions are provided to set up the &xterm;, with
	  two functions one to read from, and one to write to it,
	  <function>xtermRead()</function> and
	  <function>xtermWrite()</function>. Both these functions are blocking
	  on the operating system. The write routine should always be able to
	  write with minimal delay. However the read routine must only be
	  called when the <literal>SIGIO</literal> signal handler has
	  determined input is available, in order to avoid blocking the
	  &systemc; simulation.
	</para>

	<para>
	  There is some internal state to hold the pseudo TTY file descriptors
	  and the process ID of the &xterm; (so it can be killed by the
	  destructor). It is the slave file descriptor that is used for both
	  input and output.
	</para>
      </sect3>

<sect3>
	<title>
	  Signal and event handling
	</title>

	<para>
	  The <literal>SIGIO</literal> signal handler
	  (<function>ioHandler()</function>) is declared static as noted
	  above. The static <literal>instList</literal> of type
	  <literal>Fd2Inst</literal> points to the list of mappings from file
	  descriptor to class instance.
	</para>

	<para>
	  The &systemc; event used to signal when input is available is pointed
	  to by <literal>ioEvent</literal>.
	</para>

	<caution>
	  <para>
	    It is essential that the event is declared as a pointer. If the
	    event itself were declared here, it would be available at
	    elaboration, and would crash the system (try it!).
	  </para>

	  <para>
	    The solution is to declare the pointer and allocate the event
	    instance dynamically when the &xterm; is created. The memory can be
	    freed from the destructor on termination.
	  </para>
	</caution>
      </sect3>

    </sect2>

    <sect2>
      <title>
	Terminal Module Class Implementation
      </title>

      <para>
	The implementation is a standard &systemc; module communicating via
	the two FIFOs, and with two threads, one listening to the Rx from
	the &uart; the other listening to the &xterm;.
      </para>

      <para>
	The setup of the pseudo TTYs and the &xterm; in a separate process
	uses standard operating system routines, not described further
	here. The key factor is that the file descriptor for the pseudo TTY to
	the &xterm; is set up to be asynchronous, with Linux signal
	<literal>SIGIO</literal> raised when input is available and handled by
	the <literal>ioHandler()</literal> function.
      </para>

      <sect3>
	<title>
	  Threads
	</title>

	<para>
	  The thread listening to the &uart;, <function>rxThread()</function>
	  sits in a perpetual loop, reading from the input FIFO. This blocks
	  until a character is received. The character is immediately copied
	  to the &xterm;. Although this is a blocking write, it should return
	  with minimal delay.
	</para>

	<para>
	  The thread listening to the &xterm;,
	  <function>xtermThread()</function> sits in a perpetual loop, waiting
	  on the &systemc; event pointed to by
	  <literal>ioEvent</literal>. This will safely allow the thread to
	  yield to the &systemc; scheduler until a character is ready.
	</para>

	<para>
	  When input is available, the event is notified (see <xref
	  linkend="sec_xterm_sig_hand" />). The thread can safely make a
	  blocking operating system read to get the character, knowing that
	  data is definitely available.
	</para>
      </sect3>
      
      <sect3 id="sec_xterm_sig_hand">
	<title>
	  Signal and event handling
	</title>

	<para>
	  During initialization of the &xterm; the &systemc; event,
	  <literal>ioEvent</literal> is allocated:
	</para>

	<programlisting>  ioEvent = new sc_core::sc_event();</programlisting>

	<para>
	  When <literal>ioHandler()</literal> is called in response to a Linux
	  <literal>SIGIO</literal> event, it does not know which pseudo TTY
	  was responsible. The file descriptor responsible is identified by
	  using an operating system <function>select()</function> call. Using
	  the mappings in <literal>instList</literal>, the corresponding class
	  instance can be identified and its <literal>ioEvent</literal>
	  notified.
	</para>

	<programlisting>  for( Fd2Inst *cur = instList; cur != NULL ; cur = cur->next ) {
    if( FD_ISSET( cur->fd, &amp;readFdSet )) {
      (cur->inst)->ioEvent->notify();
    }
  }</programlisting>

        <para>
	  This event then allows the <literal>xtermThread()</literal> to run
	  and read a character.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>
	The Complete SoC
      </title>

      <sect3 id="sec_simple_soc_main">
	<title>
	  The Model Main Program
	</title>

	<para>
	  The structure of the main program
	  (<filename>SimpleSoC.cpp</filename>) is similar to that for the
	  logger test program (see <xref linkend="sec_logger_main_prog"
	  />). The &tlm2; header and the headers for each module (&or1ksim;
	  &iss;, &uart; and terminal) are included.
	</para>

	<programlisting>#include "tlm.h"
#include "Or1ksimExtSC.h"
#include "UartSC.h"
#include "TermSC.h"</programlisting>

	<para>
	  As before the main program (<function>sc_main()</function>) takes as
	  arguments the &or1ksim; configuration file and &or1k;
	  image. Instances of the three modules are declared.
	</para>

	<programlisting>  Or1ksimExtSC  iss( "or1ksim", argv[1], argv[2] );
  UartSC        uart( "uart", iss.isLittleEndian() );
  TermSC        term( "terminal" );</programlisting>

	<para>
	  The endianism for the &uart; is set using the public utility method
	  in <classname>Or1ksimExtSC</classname>. The &tlm; ports of &uart;
	  and &iss; can be connected:
	</para>

	<programlisting>  iss.dataBus( uart.bus );</programlisting>

	<para>
	  Two one byte FIFOs are needed to connect the &uart; and terminal.
	</para>

	<programlisting>  sc_core::sc_fifo&lt;unsigned char&gt;  u2t(1);
  sc_core::sc_fifo&lt;unsigned char&gt;  t2u(1);

  uart.rx( t2u );
  uart.tx( u2t );
  term.rx( u2t );
  term.tx( t2u );</programlisting>

	<para>
	  Finally the &uart; interrupt is connected to a &systemc;
	  <literal>bool</literal> signal. The signal goes nowhere, since for now
	  the interrupts are not required.
	</para>

	<programlisting>sc_core::sc_signal&lt;bool&gt;  intWire;

  uart.intr( intWire );</programlisting>

        <para>
	  The simulation can then be started with a call to
	  <function>sc_start()</function>.
	</para>
      </sect3>

      <sect3>
	<title>
	  Test Program to Run on the &or1ksim; &iss;
	</title>

	<para>
	  The test program, <filename>uart_loop.c</filename> is a simple
	  polling loop back driver of the UART. Characters are read and
	  immediately echoed back.
	</para>

	<para>
	  A <literal>volatile</literal> structure is declared for the &uart;
	  registers, with <literal>#define</literal>d constants for the base
	  address and the register bits of interest
	</para>

	<programlisting>#define BASEADDR   0x90000000
#define BAUD_RATE        9600
#define CLOCK_RATE  100000000           // 100 Mhz

struct uart16450
{
  volatile unsigned char  buf;          // R/W: Rx &amp; Tx buffer when DLAB=0  
  volatile unsigned char  ier;          // R/W: Interrupt Enable Register   
  volatile unsigned char  iir;          // R: Interrupt ID Register         
  volatile unsigned char  lcr;          // R/W: Line Control Register       
  volatile unsigned char  mcr;          // W: Modem Control Register        
  volatile unsigned char  lsr;          // R: Line Status Register          
  volatile unsigned char  msr;          // R: Modem Status Register         
  volatile unsigned char  scr;          // R/W: Scratch Register            
};

#define UART_LSR_TEMT   0x40            // Transmitter serial register empty
#define UART_LSR_THRE   0x20            // Transmitter holding register empty
#define UART_LSR_DR     0x01            // Receiver data ready

#define UART_LCR_DLAB   0x80            // Divisor latch access bit
#define UART_LCR_8BITS  0x03		// 8 bit data bits</programlisting>

	<para>
	  The utility routines to set and clear flags in the &uart; (see <xref
	  linkend="sec_uart_impl" />) are reused here, modified for C rather
	  than C++ and <literal>volatile</literal> register arguments.
	</para>

	<para>
	  The main program declares a pointer to the UART register structure,
	  <literal>uart</literal>, at the base address. Initialization
	  requires setting the divisor latch, to divide the main clock down to
	  16 x the baud rate and setting 8-bit data.
	</para>

	<programlisting>  volatile struct uart16450 *uart = (struct uart16450 *)BASEADDR;
  unsigned short int         divisor;

  divisor = CLOCK_RATE/16/BAUD_RATE;            // DL is for 16x baud rate

  set( &amp;(uart->lcr), UART_LCR_DLAB );           // Set the divisor latch
  uart->buf  = (unsigned char)( divisor       &amp; 0x00ff);
  uart->ier  = (unsigned char)((divisor >> 8) &amp; 0x00ff);
  clr( &amp;(uart->lcr), UART_LCR_DLAB );

  set( &amp;(uart->lcr), UART_LCR_8BITS );		// Set 8 bit data packet</programlisting>

	<para>
	  The remainder of the program is a perpetual loop:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      Wait for a character in the read buffer (flag
	      <literal>DR</literal> of the line status register is set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Read the character from the buffer.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Wait for the transmit buffer to clear (flags
	      <literal>TEMT</literal> and <literal>THRE</literal> of the line
	      status register are set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Write the character back.
	    </para>
	  </listitem>
	</itemizedlist>

	<programlisting>  while( 1 ) {
    unsigned char  ch;

    do {                        // Loop until a char is available
      ;
    } while( is_clr(uart->lsr, UART_LSR_DR) );

    ch = uart->buf;

    simputs( "Read: '" );       // Log what was read
    simputc( ch );
    simputs( "'\n" );

    do {                        // Loop until the transmit register is free
      ;
    } while( is_clr( uart->lsr, UART_LSR_TEMT | UART_LSR_THRE ) );
      
    uart->buf = ch;
  }</programlisting>

      </sect3>

      <sect3 id="sec_simple_soc_run">
	<title>
	  Compiling and Running the Model
	</title>

	<para>
	  Compilation uses the same command lines as the
	  standalone test of the &or1ksim; wrapper with the logger (see <xref
	  linkend="sec_iss_run_test" />), but this time links in the &uart;
	  and terminal; rather than the logger.
	</para>

	<important>
	  <para>
	    Since <classname>Or1ksimExt</classname> is a derived class of
	    <classname>Or1ksim</classname>, linking should include the
	    compiled base class, <filename>Or1ksimSC.o</filename> as well as
	    the derived class, <filename>Or1ksimExtSC.o</filename>.
	  </para>
	</important>

	<para>
	  The &or1ksim; configuration is also unchanged. Like the logger, the
	  &uart; registers start at address 0x90000000 and are 8 bytes long.
	</para>

	<para>
	  Running the model requires specifying the configuration file
	  (unchanged) and the binary executable (this time the &uart; loop
	  back program).
	</para>

	<programlisting>./SimpleSocSC ../simple.cfg ../progs_or32/uart_loop</programlisting>

	<para>
	  The &xterm; terminal should appear. Select it and type some
	  characters. The window running the model, will show the logged
	  output from the terminal, reporting the same characters being
	  written, as shown in <xref linkend="fig_uart_loopback_log" />.
	</para>

	<figure id="fig_uart_loopback_log">
	  <title>
	    &uart; loop back program log output.
	  </title>

          <screen>$ ./SimpleSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Read: 'F'
Read: 'a'
Read: 'r'
Read: 'e'
Read: 'w'
Read: 'e'
Read: 'l'
Read: 'l'
Read: ' '
Read: 'G'
Read: 'a'
Read: 'l'
Read: 'a'
Read: 'x'
Read: 'y'
Read: '!'
Read: '!'
Read: '!'</screen>
	</figure>

	<para>
	  At the same time the characters will be echoed on the xterm, as
	  shown in figure <xref linkend="fig_uart_loopback_screen" />.
	</para>

	<figure id="fig_uart_loopback_screen">
	  <title>
	    &xterm; with the &uart; loop back program running.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart_xterm.png"
			 format="PNG"
			 width="13.754cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Well it makes a change from "Hello World!".
	</para>

	<para>
	  As an exercise, rebuild the model, removing the call to
	  <function>wait()</function> in the
	  <function>Or1ksimExtSC::doTrans()</function> function. Observe that
	  the program hangs without accepting any characters. The reason for
	  this is given in the description of <function>doTrans()</function>
	  in <xref linkend="sec_uart_or1ksim_libext" />.
	</para>

	<para>
	  A debugger connected to the model will show that execution is stuck
	  in &or1ksim; &iss;, waiting for the data ready flag to be set in the
	  &uart;. This can never occur, since neither &uart; nor terminal are
	  given the chance to execute the threads that would set this flag.
	</para>
      </sect3>

      <sect3>
	<title>
	  Model Timing
	</title>

	<para>
	  This model is completely untimed. It executes the behavior of the
	  design, and for that reason such models are useful in system
	  verification.
	</para>

	<para>
	  The next stages will add timing to this model. To allow this to be
	  demonstrated, add some logging to the &uart; and terminal to report
	  the timing of reads and writes.
	</para>

	<para>
	  Edit the <function>rxThread()</function> in
	  <classname>UartSC</classname>, to print out the time when a
	  character is received from the terminal<footnote>
	    <para>
	      The use of <function>printf()</function> and C
	      <literal>stdio</literal> is unfortunate. It would be better to
	      use C++ stream IO. However there seems to be an interaction with
	      either &systemc; or the asynchronous IO of the &xterm;, which
	      makes stream IO to standard output unreliable
	    </para>
	  </footnote>.
	</para>

	<programlisting>void
UartSC::rxThread()
{
  // Loop woken up when a character is written into the fifo from the terminal.

  while( true ) {
    regs.rbr  = rx.read();                      // Blocking read of the data

    sc_core::sc_time  now = sc_core::sc_time_stamp();
    printf( "Char read at    %12.9f sec\n", now.to_seconds());

    set( regs.lsr, UART_LSR_DR );               // Mark data ready

    if( isSet( regs.ier, UART_IER_ERBFI ) ) {   // Send interrupt if enabled
      genInt( UART_IIR_RDI );
    }
  }
}       // rxThread()</programlisting>

	<para>
	  Similarly edit the <function>rxThread()</function> in
	  <classname>TermSC</classname>, to print out the time when a
	  character is received from the UART.
	</para>

	<programlisting>void
TermSC::rxThread()
{
  while( true ) {
    unsigned char  ch = rx.read();      // Blocking read from the FIFO

    xtermWrite( ch );                   // Write it to the screen

    sc_core::sc_time  now = sc_core::sc_time_stamp();
    printf( "Char written at %12.9f sec\n", now.to_seconds());
  }
}       // rxThread()</programlisting>

	<para>
	  In both cases the C standard IO header will be needed at the top of
	  the file (<filename>UartSC.cpp</filename> and
	  <filename>TermSC.cpp</filename>):
	</para>

	<programlisting>#include &lt;stdio.h&gt;</programlisting>

	<para>
	  The model can now be rerun as before, and will print out precise
	  timing (use of 9 decimal places ensures that granularity at least as
	  fine as the 100MHz CPU clock will be seen). The output is shown in
	  <xref linkend="fig_uart_loopback_log_timed" />.
	</para>

	<figure id="fig_uart_loopback_log_timed">
	  <title>
	    &uart; loop back program log output with timing annotation.
	  </title>

          <screen>$ ./SimpleSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at    0.000000000 sec
Read: 'F'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: 'a'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: 'r'

   ... &lt;Lots more output&gt;

Read: 'x'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: 'y'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: '!'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: '!'
Char written at 0.000000000 sec
Char read at    0.000000000 sec
Read: '!'
Char written at 0.000000000 sec</screen>
	</figure>

	<para>
	  As can be seen all the reads and writes occur at time zero.
	</para>

      </sect3>
    </sect2>
  </sect1>

<sect1 id="sec_sync">
    <title>
      Adding Synchronous Timing to the Model
    </title>

    <para>
      The current models are all untimed. In the &tlm2; components
      (<classname>Or1ksimExtSC</classname> and <classname>UartSC</classname>
      the delay parameter to the blocking transport function has been ignored.
    </para>

    <para>
      In this section, the models are extended to synchronize explicitly with
      the SystemC clock.
    </para>

    <para>
      The synchronization is not perfect&mdash;the underlying &or1ksim; &iss;
      executes outside the &systemc; world. Synchronization is only possible
      when it makes an upcall for read or write. In <xref
      linkend="sec_temporal_decoupling" /> this model will be further
      extended to add control over the underlying &iss; and its interaction
      with &systemc; time.
    </para>

    <sect2>
      <title>
	Summary of Changes Required for Synchronous Timing
      </title>

      <para>
	Each module of the existing SoC requires some changes. New classes,
	<classname>Or1ksimSyncSC</classname>,
	<classname>UartSyncSC</classname> and
	<classname>TermSyncSC</classname> are derived from the existing
	classes to provide added functionality. In addition the underlying
	&or1ksim; &iss; library will need extending. the main program will
	need modifying to use these new classes.
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    <classname>Or1ksimSyncSC</classname>. A public function to report
	    the clock rate of the underlying &or1ksim; &iss; is added
	    (requiring an extension to the &or1ksim; library), and the
	    transport function, <function>doTrans()</function> modified to add
	    timing information.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>UartSyncSC</classname>. This now models the time taken
	    to put a character out on the Tx wire, so must know its input
	    clock rate (in this SoC, the &or1ksim; clock rate), so that baud
	    rate can be calculated from the divisor latch. Also models the
	    true time to process a read or write on the bus and returns this
	    with the transaction response.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>TermSyncSC</classname>. This now models the time taken
	    to put a character out to the UART, so must know its baud
	    rate. This requires an updated thread listening to the xterm, so
	    that the baud rate delay can be added.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    &or1ksim; &iss; library. Information functions are added to return
	    the model clock rate (used as input clock rate for the UART) and
	    the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with SystemC.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A new main program <filename>SyncSocSC.cpp</filename> to build the
	    new classes into a synchronized S. Information functions are added to return
	    the model clock rate (used as input clock rate for the UART) and
	    the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with SystemC.
	  </para>
	</listitem>
      </itemizedlist>

    </sect2>

    <sect2>
      <title>
	Extending the <classname>Or1ksimExtSC</classname> Wrapper Module
      </title>

      <sect3 id="sec_or1ksim_libsync">
	<title>
	  Adding Clock Rate and Timing Functions to the &or1ksim; Library
	</title>

	<para>
	  Three additional functions are needed in the &or1ksim; library to
	  support synchronized timing. The &uart; will need to know the clock
	  rate of the model (to work out the baud rate from the value of the
	  divisor latch). The <classname>Or1ksimSyncSC</classname> class
	  itself will need a pair of functions, one to set a timing point in
	  the &iss; the second to return the amount of time since the last
	  timing point. This the amount of time the underlying &iss; has used
	  when synchronizing with &systemc;.
	</para>

	<para>
	  The three additional functions are simple additions. The clock rate is
	  a configuration parameter, while a run time count of instructions
	  executed is already maintained. An extra record in the run-time
	  structure allows a time to be recorded (in seconds through dividing
	  the count by the clock rate), which can be compared in subsequent
	  calls to given the &iss; time used since the last time point<footnote>
	    <para>
	      This is a loosely timed model. The timing from the &iss; is
	      approximate&mdash;it does not model the microarchitecture in
	      detail. Cycle estimates will not be exact&mdash;that requires a
	      fully cycle accurate model.
	    </para>
	  </footnote>.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>unsigned long int  or1ksim_clock_rate();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_clock_rate()</function> returns the &or1ksim;
	      &iss; clock rate in Hz. This information will be used by the
	      &uart; to allow it to set its baud rate.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>void  or1ksim_set_time_point();</programlisting>
	    </para>
	    
	    <para>
	      function <function>or1ksim_set_time_point()</function> records
	      the current &iss; simulation time (clock cycles divided by clock
	      rate) in the run-time data structure.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <programlisting>double  or1ksim_get_time_period();</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_get_time_period()</function> returns the time
	      in seconds since the last time point was set. This routine is
	      needed to keep the SystemC model of time due to instruction set
	      processing accurate, both in the synchronous SoC and when
	      temporal decoupling is added.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimSyncSC</classname> is derived
	  from the existing <classname>Or1ksimExtSC</classname> module
	  class. The header of the base class,
	  <classname>Or1ksimExtSC</classname> is included and the new class
	  derived from that base class.
	</para>

        <programlisting>#include "Or1ksimExtSC.h"

class Or1ksimSyncSC
: public Or1ksimExtSC
{</programlisting>

        <para>
	  A custom constructor must be defined, but has the same arguments as
	  the base class constructor, to which it will pass its arguments.
	</para>

	<para>
	  The new &or1ksim; library call to give the clock rate is wrapper in
	  a public function<footnote>
	    <para>
	      The use of unsigned long int reflects the usage in the &or1ksim;
	      &iss;. The designers do not anticipate usage to model designs in
	      excess of 4GHz!
	    </para>
	  </footnote>.
	</para>

	<programlisting>  unsigned long int  getClockRate();</programlisting>

	<para>
	  The <literal>doTrans()</literal> function is redefined&mdash;it will
	  replace the call to <literal>doTrans()</literal> in the base class
	  to add timing synchronization.
	</para>

      </sect3>

      <sect3 id="sec_Or1ksimSyncSC_impl">
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor passes its arguments directly to the parent
	  constructor. It then uses the &or1ksim; library routine,
	  <function>or1ksim_set_time_point()</function> to set an initial time
	  point at the start of simulation. The first call to
	  <function>or1ksim_get_time_period()</function> will return the time
	  since the &iss; started.
	</para>

	<para>
	  The <function>doTrans()</function> function (which is used for both
	  read and write) is extended from the version used with
	  <classname>Or1ksimExtSC</classname> to synchronize with the SystemC
	  clock.
	</para>

	<para>
	  There are two components to the time taken in this model, the time
	  taken by the &or1ksim; &iss; and the time taken in any
	  peripherals. At the time of an upcall, the SystemC wrapper thread
	  will not have yielded control since either initialization or the
	  last upcall, when a time point was set in the &iss; using
	  <function>or1ksim_set_time_point()</function>.
	</para>

	<para>
	  A call to <function>or1ksim_get_time_period()</function> gives the
	  time used by the &iss; in this period. This is used as the argument
	  to <function>wait()</function>, allowing any other threads in the
	  &systemc; world to run until the calculated simulation time is
	  reached.
	</para>

	<programlisting>  sc_core::sc_time  delay = sc_core::sc_time( 0.0, sc_core::SC_SEC );</programlisting>

	<para>
	  At this time the blocking transport method of the simple initiator
	  port is called with the payload and specifying a zero time offset
	  (since the call to <function>wait()</function> means the thread is
	  synchronized with the &systemc; clock).
	</para>

	<para>
	  On return, the <literal>delay</literal> parameter will have been
	  updated with any additional delay due to the transaction&mdash;in
	  this case an estimate of the number of cycles to read or write the
	  relevant &uart; register.
	</para>

	<para>
	  However, since this is a synchronized model, the target will have
	  called <function>wait()</function> to model the time taken to read
	  or write, so <literal>delay</literal> will still be zero on return.
	</para>

	<para>
	  The read or write is now complete. A new time point is set with
	  <function>set_time_point()</function> before control is returned to
	  the &iss;
	</para>

	<programlisting>  sc_core::sc_time  delay = sc_core::sc_time( 0.0, sc_core::SC_SEC );
  dataBus->b_transport( trans, delay );
  or1ksim_set_time_point();</programlisting>

        <para>
	  Finally the utility <function>getClockRate()</function> is a simple
	  wrapper for the underlying &or1ksim; library routine (see <xref
	  linkend="sec_or1ksim_libsync"/>).
	</para>

	<programlisting>unsigned long int
Or1ksimSyncSC::getClockRate()
{
  return or1ksim_clock_rate();

}       // getClockRate()</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_uart_sync">
      <title>
	Extending the <classname>UartSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>UartSyncSC</classname> derived from
	<classname>UartSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	The time taken for the serial pules (start, data, parity, stop bits)
	on the real &uart; will be modeled as a delay before writing data into
	the Tx FIFO port.
      </para>

      <para>
	The corresponding delay on the Rx FIFO port will be modeled by the
	terminal writing onto that port<footnote>
	  <para>
	    This is not the ideal solution. The delay is really a property of
	    the channel, so should be modeled by a derived class of the
	    standard &systemc; FIFO which provides a defined delay between
	    data being written and data availability being signaled.
	  </para>

	  <para>
	    The approach used here (transmitter models the delay) represents a
	    practical compromise.
	  </para>
	</footnote>.
      </para>

      <para>
	The &tlm2; port modeling the bus is extended to model the time taken
	for reads to and writes from the bus.
      </para>

      <sect3>
	<title>
	  <classname>UartSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition (in <filename>UartSyncSC.h</filename>) includes
	  the header of the base class and defines two new constants to
	  represent the delay in reading and writing in nanoseconds.
	</para>

        <programlisting>#define UART_READ_NS       60   // Time to access the UART for read
#define UART_WRITE_NS      60   // Time to access the UART for write</programlisting>

	<para>
	  The class is derived directly from the base class,
	  <classname>UartSC</classname>. A new custom constructor is needed,
	  with an additional parameter specifying the input clock rate. This
	  is used in conjunction with the divisor latch to specify the baud
	  rate.
	</para>

	<programlisting>  UartSyncSC( sc_core::sc_module_name  name,
              unsigned long int        _clockRate,
              bool                     _isLittleEndian );</programlisting>

	<para>
	  The <function>busThread()</function> thread is updated to add the
	  timing delay (as a call to <function>wait()</function> in
	  transmitting a character as described above.
	</para>

	<para>
	  The blocking transport function, <function>busReadWrite()</function>
	  is updated to add in the bus delays in reading and writing. Again
	  this will be achieved by calls to <function>wait()</function>, so
	  keeping the model synchronous.
	</para>

	<para>
	  The <function>busWrite()</function> must also be updated, since any
	  change to the divisor latch or the line control register (which
	  specifies the bit format being sent on the wire) could affect the
	  baud rate and timing for <function>busThread()</function>
	</para>

	<para>
	  A new utility function, <function>resetCharDelay()</function> is
	  defined to compute the delay in putting a character on the Tx FIFO
	  from the clock rate, divisor latch and line control register.
	</para>

	<para>
	  Two new member variables are declared, to hold the clock rate and
	  the calculated delay to put a character on the Tx FIFO.
	</para>

      </sect3>

      <sect3>
	<title>
	  <classname>UartSyncSC</classname> Module Class Implementation
	</title>
	  
	<para>
	  The custom constructor passes the name and
	  <literal>_isLittleEndian</literal> flag to the base class
	  constructor. The clock rate is saved in the local variable,
	  <literal>clockRate</literal>.
	</para>

	<programlisting>UartSyncSC::UartSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        _clockRate,
                        bool                     _isLittleEndian ) :
  UartSC( name, _isLittleEndian ),
  clockRate( _clockRate )
{

}       /* UartSyncSC() */</programlisting>

	<para>
	  The new version of <function>busThread()</function> adds only one
	  line to the version in the case class. A call to
	  <function>wait(&nbsp;charDelay&nbsp;)</function> is added when the
	  transmit request is received (notified on the &systemc; event,
	  <literal>txReceived</literal>).
	</para>

	<programlisting>    wait( txReceived );                         // Wait for a Tx request
    wait( charDelay );                          // Wait baud delay

    tx.write( regs.thr );                       // Send char to terminal</programlisting>

	<para>
	  The new version of <function>busReadWrite</function> draws most of
	  its functionality from the base class version. However it then
	  synchronizes with a time delay for the read or write access. Since
	  the thread is now synchronous, a time delay of zero is returned with
	  the transaction.
	</para>

	<programlisting>void
UartSyncSC::busReadWrite( tlm::tlm_generic_payload &amp;payload,
                          sc_core::sc_time         &amp;delay )
{
  UartSC::busReadWrite( payload, delay );       // base method

  switch( payload.get_command() ) {

  case tlm::TLM_READ_COMMAND:
    wait( sc_core::sc_time( UART_READ_NS, sc_core::SC_NS ));
    delay = sc_core::sc_time( 0.0, sc_core::SC_SEC );
    break;

    &lt;code for write commands etc&lt;
</programlisting>

	<para>
	  The new version of <function>busWrite()</function> similarly relies
	  on the base class for most of its functionality.
	</para>

	<programlisting>void
UartSyncSC::busWrite( unsigned char  uaddr,
                      unsigned char  wdata )
{
  UartSC::busWrite( uaddr, wdata );</programlisting>

	<para>
	  However any change to the divisor latch or line control register
	  could change the baud rate or the number of bits in each Tx
	  transmission, and hence the modeled delay to send a character.
	</para>

	<para>
	  The function identifies if this has happened and if so calls
	  <function>resetCharDelay()</function> to recalculate the delay.
	</para>

	<programlisting>  switch( uaddr ) {

  case UART_BUF:                // Only change if divisorLatch update (DLAB=1)
  case UART_IER:

    if( isSet( regs.lcr, UART_LCR_DLAB ) ) {
      resetCharDelay();
    }

    break;

  case UART_LCR:

    resetCharDelay();           // Could change baud delay
    break;</programlisting>

	<para>
	  The time taken to put a character on the Tx line is the product of
	  the time taken to put one bit on the line (the inverse of the baud
	  rate) and the bits required for the character (start bit, data bits,
	  optional parity bit, stop bit(s)). The baud rate is determined by
	  the input clock rate and the 16-bit divisor latch.
	</para>
	  
	<note>
	  <para>
	    The divisor latch for a 16450 divides the input clock to yield an
	    internal clock <emphasis>16x</emphasis> the baud rate (i.e. not
	    the actual baud rate itself)<footnote>
	      <para>
	        The 16450 input clock is specified to a maximum of 24 MHz, so
	        that a 16 bit divisor latch can yield an internal clock for
	        rates down to 50 baud. However for a software model this
	        limitation is ignored. Faster input clocks can be specified,
	        but it will not be possible to configure a 16-bit divisor
	        latch for very low baud rates
	      </para>
	    </footnote>.
	  </para>
	</note>

	<para>
	  The number of bits to send a character is determined by the line
	  control registers. There is always a stop bit, there can be 5-8 data
	  bits, an optional parity bit and 1, 1.5 or 2 stop bits. The
	  <function>resetCharDelay()</function> function calculates the total
	  delay.
	</para>

	<programlisting>void
UartSyncSC::resetCharDelay()
{
  if( clockRate > 0 ) {         // Avoid divide by zero!

    int  dataBits  = (regs.lcr &amp; UART_LCR_MASK) + 5;
    int  parityBit = isSet( regs.lcr, UART_LCR_PEN ) ? 1 : 0;
    int  stopBits  = isSet( regs.lcr, UART_LCR_STB ) ? 2 : 1;

    // 5 bit data has max 1.5 stop bits

    double totBits = (double)(1 + dataBits + parityBit + stopBits) -
                     (((5 == dataBits) &amp;&amp; (1 == stopBits)) ? 0.5 : 0.0);
    double baudRate = (double)clockRate / (double)divLatch / 16.0;

    charDelay = sc_core::sc_time( totBits / baudRate, sc_core::SC_SEC );
  }
}       // resetCharDelay()</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Extending the <classname>TermSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>TermSyncSC</classname> derived from
	<classname>TermSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	As with the &uart; (see <xref linkend="sec_uart_sync" />), the
	terminal will model the time taken to put the bits of a character on
	its Tx port. This mirrors the arrangement with the UART, so when the
	two are connected, delays in both directions are correctly modeled.
      </para>

      <sect3>
	<title>
	  <classname>TermSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>TermSyncSC</classname> is derived from
	  <classname>TermSC</classname>. The header for that class is included
	  and the new class derived from that.
	</para>

	<programlisting>#include "TermSC.h"

class TermSyncSC
: public TermSC
{</programlisting>

	<para>
	  A new custom constructor is needed, which takes a second argument to
	  specify the baud rate.
	</para>

	<programlisting>  TermSyncSC( sc_core::sc_module_name  name,
              unsigned long int        baudRate );</programlisting>

	<para>
	  The <function>xtermThread()</function> will be updated. No further
	  derived classes are anticipated, so this function is declared
	  <literal>private</literal> and not marked as
	  <literal>virtual</literal>.
	</para>

	<para>
	  Finally a variable is needed to hold the baud rate. For convenience
	  the class does not hold the baud rate, but the corresponding delay
	  that this represents in sending a character.
	</para>

	<programlisting>  sc_core::sc_time  charDelay;</programlisting>
      </sect3>

      <sect3>
	<title>
	  <classname>TermSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor calls the base class constructor to set the
	  module name. The body of the constructor is in calculating the delay
	  due to the baud rate. There is no configurability there (this
	  terminal supports 1 start, 8 data, 0 parity and 1 stop bits only),
	  so this is a one off calculation.
	</para>

	<programlisting>TermSyncSC::TermSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        baudRate ) :
  TermSC( name )  
{
  charDelay = sc_core::sc_time( 10.0 / (double)baudRate, sc_core::SC_SEC );

}       /* TermSyncSC() */</programlisting>

	<para>
	  The <function>xtermThread()</function> thread is almost identical to
	  the base class version. A single line is added after the character
	  is read from the &xterm; and before it is written to the FIFO port
	  to add the modeled baud rate delay.
	</para>

	<programlisting>    int ch = xtermRead();               // Should not block

    wait( charDelay );                  // Model baud rate delay
    tx.write( (unsigned char)ch );      // Send it
</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_sync_main_prog">
      <title>
	Main Program for the Synchronous Model
      </title>

      <para>
	As with the untimed SoC (see <xref linkend="sec_simple_soc_main" />),
	the main program includes the headers for &tlm2; and the component
	modules, but this time using the synchronously timed versions.
      </para>

      <programlisting>#include "tlm.h"
#include "Or1ksimSyncSC.h"
#include "UartSyncSC.h"
#include "TermSyncSC.h"</programlisting>

      <para>
	The baud rate for the terminal is defined as a constant for
	convenience.
      </para>

      <programlisting>#define BAUD_RATE  9600UL               // Baud rate of the terminal</programlisting>

      <para>
	As before the main program (<function>sc_main()</function>) takes as
	arguments the &or1ksim; configuration file and &or1k; image. Instances
	of the three modules are declared, but now have additional
	arguments. The &uart; requires an input clock rate&mdash;obtained from
	the &iss; via the <classname>Or1ksimSyncSC</classname> public utility
	function, <function>getClockRate()</function> (see <xref
	linkend="sec_Or1ksimSyncSC_impl" />). The Terminal requires its baud
	rate to be set.
      </para>

      <programlisting>  Or1ksimSyncSC  iss( "or1ksim", argv[1], argv[2] );
  UartSyncSC     uart( "uart", iss.getClockRate(), iss.isLittleEndian() );
  TermSyncSC     term( "terminal", BAUD_RATE );</programlisting>

      <para>
	The remainder of the program, connecting components and starting the
	simulation is identical to the untimed version.
      </para>
	
    </sect2>


    <sect2>
      <title>
	Compiling and Running the Synchronous Model
      </title>

      <para>
	Compilation uses the same command lines as the untimed model (see
	<xref linkend="sec_simple_soc_run" />), but with the synchronized
	versions of the modules and main program.
      </para>

      <important>
	<para>
	  Since <classname>Or1ksimSync</classname> is a derived class of
	  <classname>Or1ksimExt</classname>,
	  <classname>Or1ksimExt</classname>, linking should include the
	  compiled base classes, <filename>Or1ksimSC.o</filename> and
	  <filename>Or1ksimExtSC.o</filename> as well as the derived class,
	  <filename>Or1ksimSyncSC.o</filename>. Similarly the compiled base
	  classes of <classname>UartSyncSC</classname> and
	  <classname>TermSyncSC</classname> should also be included.
	</para>
      </important>

      <para>
	The &or1ksim; configuration is completely unchanged, and the embedded
	code running on the &or1ksim; &iss; is the same
	(<filename>uart_loop</filename>).
      </para>

      <para>
	The command line to run the model is unchanged, but uses the
	synchronized version of the model
      </para>

      <programlisting>./SyncSocSC ../simple.cfg ../progs_or32/uart_loop</programlisting>

      <para>
	Once again the &xterm; terminal should appear. Select it and type some
	characters. The window running the model, will show the logged output
	from the terminal, reporting the same characters being written and
	timing of the reads and writes. However this time, the time progresses
	as the characters are written, as shown in <xref
	linkend="fig_uart_loopback_sync_log" />.
      </para>

      <figure id="fig_uart_loopback_sync_log">
	<title>
	  &uart; loop back program log output.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.060059107 sec
Read: 'F'
Char written at  0.061114010 sec
Char read at     0.070717297 sec
Read: 'a'
Char written at  0.071772200 sec
Char read at     0.077270287 sec
Read: 'r'
Char written at  0.078325190 sec


   ... &lt;Lots more output&gt;

Char read at     0.155874487 sec
Read: 'y'
Char written at  0.156929390 sec
Char read at     0.169800997 sec
Read: '!'
Char written at  0.170855900 sec
Char read at     0.174711907 sec
Read: '!'
Char written at  0.175766810 sec
Char read at     0.179016937 sec
Read: '!'
Char written at  0.180071840 sec</screen>
      </figure>

      <para>
	The read timing is as the character leaves the terminal,
	<emphasis>after</emphasis> the terminal has added the baud rate
	delay. The write timing is as the character leaves the &uart; after the
	echo loop in the embedded application on the &or1ksim; &iss; and
	<emphasis>after</emphasis> the &uart; has added the baud-rate
	delay. So the timing from the <emphasis>read</emphasis> message to the
	<emphasis>write</emphasis> message should be the time for the &uart;
	delay for the current baud rate and packet bits plus the execution
	time for the code to echo the character on the &or1ksim; &iss;.
      </para>

      <para>
	The &uart; was initialized to use 1 start bit, 8 data bits and 1 stop
	bit, which at 9600 baud should take around 1040&mu;s. The time shown
	in <xref linkend="fig_uart_loopback_sync_log" /> for the first
	character to be read and written back is 1055&mu;s. This seems
	reasonable, allowing approximately 1500 cycles (15&mu;s at 100MHz( for
	the &or1ksim; &iss; to process the read and write code.
      </para>
    </sect2>
  </sect1>

<sect1 id="sec_temporal_decoupling">
    <title>
      Adding Temporal Decoupling of the Model
    </title>

    <para>
      In this case study temporal decoupling is added to the &tlm2; model of
      an SoC. The SoC model with arbiter from the previous example is reused.
    </para>

    <sect2>
      <title>
	What is Temporal Decoupling
      </title>

      <para>
	The idea of temporal decoupling is very simple and has been around for
	a long time (see for example <xref linkend="ref_fitch_88"
	endterm="ref_fitch_88_xr" />). In a parallel system, let the various
	threads keep their own local time, and only synchronize when they need
	to communicate with each other.
      </para>

      <para>
	&tlm2; provides some convenience classes to help threads implement
	temporal decoupling. The nomenclature used by these classes can be
	more than a little confusing&mdash;the following should make things
	clear.
      </para>

      <para>
	The first thing to be clear about is that temporal decoupling is a
	property of <emphasis>threads</emphasis>, not module classes. So it is
	each <emphasis>thread</emphasis> that must keep track of its local
	view of time.
      </para>

      <para>
	The second thing to be clear about is that nothing in the &tlm2;
	system checks a program is following the rules. It is up to each
	thread to ensure it follows the rules.
      </para>

      <para>
	Not all threads need use temporal decoupling, although the more that
	do, the greater the potential model efficiency. In general temporal
	decoupling is omitted from threads which do not use &tlm2; interfaces
	for their communication. Where threads do use temporal decoupling it
	is threads driving initiator ports which manage the temporal decoupling.
      </para>

      <sect3>
	<title>
	  Timing Concepts
	</title>

	<para>
	  &tlm2; defines four different timing concepts to describe temporal
	  decoupling:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>
	      (System) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which all threads
		synchronize. For example a <emphasis>Global Quantum</emphasis>
		of 100&mu;s means that all threads synchronize on 100&mu;s
		200&mu;s, 300&mu;s etc. Although the &tlm2; standard refers
		to this as just the Global Quantum, it is a system wide concept
		and for clarity this paper refers to it as the <emphasis>System
		Global Quantum</emphasis>
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      (Thread) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which a particular thread
		synchronizes. The &tlm2; standard allows different threads to
		have their own private time unit of synchronization, which is
		very confusingly also referred to in the standard as a the
		Global Quantum.
	      </para>

	      <para>
		To avoid confusion, in this application note, the term
		<emphasis>Thread Global Quantum</emphasis> is used to mean the
		global quantum used by a particular thread.
	      </para>

	      <para>
		Having different values for the global quantum in different
		threads is a recipe for complete confusion, while offering few
		advantages. The user is strongly recommended to set the Thread
		Global Quantum to the same value as the System Global Quantum
		when the thread is created and not change it.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Quantum
	    </term>

	    <listitem>
	      <para>
		For each thread, this represents the time remaining from the
		current &systemc; time (as returned by
		<function>sc_time_stamp()</function>) and the end of the current
		Thread Global Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 825&mu;s and
		the Thread Global Quantum is 100&mu;s, then the Local Quantum
		will be 75&mu;s&mdash;the time until the 900&mu;s Thread Global
		Quantum synchronization is due.
	      </para>

	      <para>
		If the recommendation that all threads set their Thread Global
		Quantum to be the same as the System Global Quantum, then the
		value of the Local Quantum will be the same in all threads.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Time Offset
	    </term>

	    <listitem>
	      <para>
		Each thread is allowed to hold a local view of time, which runs
		ahead of the current &systemc; time. This is known as
		the <emphasis>Local Time Offset</emphasis>
	      </para>

	      <para>
		The Local Time Offset must not take the thread's local view of
		time past the next Thread Global Quantum, i.e. it cannot exceed
		the Local Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 825&mu;s and
		the Thread Global Quantum is 100&mu;s, then a local time offset
		of 50&mu;s would represent a thread local effective time of
		875&mu;s.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  These concepts are shown diagrammatically in <xref
	  linkend="fig_temporal_decoupling" />.
	</para>

	<figure id="fig_temporal_decoupling">
	  <title>
	    Diagram demonstrating temporal decoupling concepts
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect3>

      <sect3>
	<title>
	  The Global Quantum Class,
	  <classname>tlm_global_quantum</classname>
	</title>

	<para>
	  &tlm2; defines a <firstterm>singleton</firstterm> class<footnote>
	    <para>
	      A singleton is a class of which only one instance can be
	      created. The constructor is declared private (so no other class
	      can create it), and a static function is provided to return the
	      single instance. This static function will create the single
	      instance the first time it is called, and thereafter just return
	      a reference to that same instance.
	    </para>

	    <para>
	      Singleton classes are useful for holding centrally required
	      values and providing centrally required functions in a system,
	      where having duplicate provision would lead to incorrect
	      behavior.
	    </para>
	  </footnote> which can be used to hold the system global quantum. A
	  set of functions to manipulate the global quantum are provided.
	</para>

	<variablelist>

	  <varlistentry>
	    <term>
	      <function>instance()</function>
	    </term>
	    <listitem>
	      <para>
		Returns a reference to the singleton global quantum object
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>set()</function>
	    </term>
	    <listitem>
	      <para>
		Sets the global quantum (as a &systemc;
		<literal>sc_time</literal> object)
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>get()</function>
	    </term>
	    <listitem>
	      <para>
		Returns the value of the global quantum
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>compute_local_quantum()</function>
	    </term>
	    <listitem>
	      <para>
		Returns the local quantum, i.e. the time from the current
		&systemc; time stamp to the next multiple of the global
		quantum.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The intention is that at start up the main program should set the
	  system global quantum in the singleton
	  <literal>tlm_global_quantum</literal> object. All threads can then
	  set their thread global quantum by getting the value from the
	  <literal>tlm_global_quantum</literal> object.
	</para>

      </sect3>

      <sect3>
	<title>
	  &tlm2; Quantum Keepers
	</title>

	<para>
	  &tlm2; provides a utility class for threads to keep track of their
	  thread global quantum, local quantum and locale time offset. This is
	  in the <literal>tlm_utils</literal> namespace (like the convenience
	  sockets) with a header in
	  <filename>tlm_utils/tlm_quantumkeeper.h</filename>.
	</para>

	<para>
	  A module will instantiate one quantum keeper for each thread that is
	  temporally decoupled, initializing them in the constructor.
	</para>

	<para>
	  Two functions are provided to manage the thread global quantum:
	  <function>set_global_quantum()</function> to set the value and
	  <function>get_global_quantum</function>. Typically a module
	  constructor will get the <emphasis>system</emphasis> global quantum
	  with a call to the singleton
	  <classname>tlm_global_quantum</classname> and immediately use that
	  to set the thread global quantum for each thread's quantum
	  keeper.
	</para>

	<para>
	  One function is provided to manage the local quantum. The
	  <function>reset()</function> calls
	  <function>compute_local_quantum</function> to calculates the local
	  quantum from the time stamp and the global quantum (which is done by
	  calling the <function>compute_local_quantum</function> in the
	  singleton <classname>tlm_global_quantum</classname> object) and sets
	  the local time offset to zero.
	</para>

	<para>
	  Typically a constructor will call <function>reset()</function> for
	  each thread immediately after setting the thread global
	  quantum. The <function>compute_local_quantum</function> in the
	  quantum keeper is <literal>protected</literal>, so cannot be called
	  directly (which seems to be an omission). If the value of the local
	  quantum is needed, this can be obtained using the
	  <function>compute_local_quantum()</function> function in the
	  singleton <classname>tlm_global_quantum</classname> object.
	</para>

	<para>
	  Four functions are provided to manage the local time
	  offset. <function>set()</function> sets the local time offset to a
	  particular value, <function>inc()</function> increments by a given
	  value and <function>get_local_time</function> returns the current
	  value of the local time
	  offset. <function>get_current_time</function> computes the effective
	  local time, i.e. the &systemc; time stamp plus the local time
	  offset<footnote>
	    <para>
	      The naming is not
	      consistent. <function>get_local_time()</function> should have
	      been just <function>get()</function> for consistency with
	      <function>set()</function> and
	      <function>inc()</function>.
	      <function>get_current_time()</function> would be better named
	      <function>get_effective_time()</function>, to match its
	      description in the standard.
	    </para>
	  </footnote>. The intention is that a thread advances model time, it
	  will call <function>set()</function> and <function>inc()</function>
	  to update the local decoupled view of time.
	</para>

	<para>
	  Two functions are provided to handle synchronization. The test
	  <function>need_sync()</function> returns true if the local time
	  offset exceeds the local quantum. <function>sync()</function> calls
	  <function>wait()</function> for the local time offset, synchronizing
	  the thread with the global &systemc; view of time, and allowing other
	  threads to catch up. It then calls <function>reset()</function> to
	  update the local quantum and zero the local time
	  offset.. <function>sync()</function> should always be called when
	  <function>need_sync()</function> is true, but may be called at any
	  other time if required.
	</para>

      </sect3>

      <sect3>
	<title>
	  Other Styles of Temporal Decoupling
	</title>

	<para>
	  &tlm2; presents one model of temporal decoupling, with an explicit
	  regular synchronization time.
	</para>

	<para>
	  Other temporal decoupling models can build on the &tlm2;
	  infrastructure, for instance to remove the regular synchronization
	  time, and instead only synchronize when the local time offset
	  reaches some prescribed maximum. A class derived from the
	  <classname>tlm_gatekeeper</classname> class can modify the control
	  and synchronization functions, to allow different approaches to be
	  tried.
	</para>
      </sect3>



    </sect2>

    <sect2>
      <title>
	Guidelines for Using &tlm2; Temporal Decoupling
      </title>

      <para>
	Temporal decoupling is not for use everywhere. The guidelines may help.
      </para>

      <orderedlist>

	<listitem>
	  <para>
	    Temporal decoupling is most useful with models based on blocking
	    transactions, as used for loosely timed models.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Only apply temporal decoupling to threads that are communicating
	    via &tlm2; transactions. Other &systemc; protocols (for example
	    via FIFO) have no way of communicating delays between threads.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Let the thread controlling the initiator manage the temporal
	    decoupling and synchronization. Targets should just return the
	    incremented delay, and avoid synchronizing if possible.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Allocate one quantum keeper for each temporally decoupled thread.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Ensure that the thread global quantum is always the same as system
	    global quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Select a global quantum that is small enough not to swamp timing
	    behavior of the system. For example in the SoC used in this
	    application note, the finest time granularity that matters is the
	    time to put a character over a 9600 BAUD link, approximately 1ms,
	    so this would be a reasonable time to use as a global quantum.
	  </para>
	</listitem>
      </orderedlist>

    </sect2>

    <sect2>
      <title>
	Temporal Decoupling the &or1ksim; Wrapper Class
      </title>

      <para>
	The only thread that can be decoupled in the current model is the
	&or1ksim; wrapper class, <classname>Or1ksimSyncSC</classname>. The
	other threads all communicate using non-&tlm; interfaces, so cannot
	easily implement temporal decoupling.
      </para>

      <para>
	&iss; are natural candidates for temporal decoupling, since they often
	can run large blocks of code without any need for hardware
	interaction. This is particularly important for modern compiling &iss;
	(e.g ARM <application>SystemGenerator</application>, ARC
	<application>xISS</application>), which achieve their performance by
	executing thousands of instructions in one go.
      </para>

      <para>
	The changes needed to add temporal decoupling are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Change the main thread, <function>run()</function> so that it only
	    tries to execute instructions up to the end of the current global
	    quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Change the upcall transport function,
	    <function>doTrans()</function>, so that it increments the local
	    time offset, rather than synchronizing via
	    <function>wait()</function>/
	  </para>
	</listitem>

	<listitem>
	  <para>
	    The previous two changes require some changes in the underlying
	    &or1ksim; &iss; library to support running to a fixed time time
	    point.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	A new class, <classname>Or1ksimDecoupSC</classname> is derived from
	<classname>Or1ksimSyncSC</classname> to implement the required
	functionality.
      </para>

      <sect3>
	<title>
	  Adding a Function to Support Temporal Decoupling to the &or1ksim;
	  Library
	</title>

	<para>
	  One additional function is needed in the &or1ksim; library to
	  support temporal decoupling. The <function>or1ksim</function>
	  already allows the user to specify a duration for which the
	  simulation will run. A function, is added to change the duration of a
	  run already in progress.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>void  or1ksim_reset_duration( double duration );</programlisting>
	    </para>
	    
	    <para>
	      <function>or1ksim_reset_duration()</function> resets the
	      duration of a call to <function>or1ksim_run()</function> which
	      is already in progress. The argument is the duration for which
	      the run should continue <emphasis>from the current
	      time</emphasis> (i.e. not from the time of the original call to
	      <function>or1ksim_run()</function>).
	    </para>

	    <para>
	      This function is needed because upcalls may lead to a
	      synchronization, increasing the time for which the &iss; may run
	      before needing resynchronization.
	    </para>
	  </listitem>

	</itemizedlist>
	<para>
	</para>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimDecoupSC</classname> is derived
	  from <classname>or1ksimSyncSC</classname>, whose header it
	  includes. A custom constructor is defined with the same arguments as
	  the base class constructor.
	</para>

	<para>
	  The &iss; thread, <function>run()</function> and the transport
	  function, <function>doTrans()</function> are both redefined to add
	  temporal decoupling.
	</para>

	<para>
	  A quantum keeper for the &iss; thread, <literal>issQk</literal> is
	  defined.
	</para>

	<programlisting>  virtual void  doTrans( tlm::tlm_generic_payload &amp;trans );</programlisting>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class,
	  <classname>Or1ksimSyncSC</classname>. The quantum keeper for the
	  &iss; thread is then initialized with the system global quantum and
	  the local quantum calculated and local time offset zeroed with a
	  call to <function>reset()</function>.
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  issQk.set_global_quantum( refTgq.get() );
  issQk.reset();</programlisting>

	<note>
	  <para>
	    The global quantum accessor function,
	    <function>instance()</function> returns a reference to the global
	    quantum. Ensure that it is assigned to a reference variable
	    (declared as <literal>&amp;refTgq</literal> here) of type
	    <classname>tlm::tlm_global_quantum</classname>. Use of a plain
	    variable would be correct C++, but make a
	    <emphasis>copy</emphasis> of the quantum keeper, so subsequent
	    calls to <function>set()</function> would not actually set the
	    singleton instance. An example of the dangers of reference
	    variables in C++ and why singleton accessors should return
	    pointers, not references.
	  </para>
	</note>

	<para>
	  The main thread function, <function>run()</function> is replaced to
	  ensure that &iss; simulation does not run past the end of the
	  current quantum. Instead of running for ever
	  (<function>or1ksim_run(&nbsp;-1.0&nbsp;);</function>, the &iss; is
	  run for the local time quantum, less the local time offset. This
	  means the &iss; will return exactly at the point when it should need
	  to synchronize again.
	</para>

	<para>
	  Since the local quantum is only available through the singleton
	  <classname>tlm::tlm_global_quantum</classname> a reference to that
	  instance is obtained for use throughout this function:
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();</programlisting>

	<para>
	  The body of the program is a perpetual loop, which calculates the
	  time left until the next global quantum then calls the &iss; for that
	  period.
	</para>

	<programlisting>  while( true ) {
    sc_core::sc_time  timeLeft =
      refTgq.compute_local_quantum() - issQk.get_local_time();</programlisting>

	<para>
	  On return, <function>or1ksim_get_time_period</function> is used to
	  find out how much computation has actually been carried out and
	  advance local time accordingly. This may be different to the
	  duration requested, since an upcall may set a new time point and
	  adjusted the duration. A new time point is immediately set ready for
	  the next loop.
	</para>

	<programlisting>    (void)or1ksim_run( timeLeft.to_seconds() );

    issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
    or1ksim_set_time_point();</programlisting>

	<para>
	  If the local time offset has reached the end of the global quantum,
	  the thread synchronizes.
	</para>

	<programlisting>    if( issQk.need_sync() ) {
      issQk.sync();</programlisting>

	<para>
	  The transport function, <function>doTrans()</function> has the same
	  structure as the synchronous version in the base class. However
	  instead of calling <function>wait()</function> to delay calculation,
	  it updates the local time offset. The time offset is advanced for
	  the &iss; simulation since the last time point and a new time point
	  is set.
	</para>

	<programlisting>  issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
  or1ksim_set_time_point();</programlisting>

	<para>
	  The delay argument to the blocking transport is the local time
	  offset. This may be increased by the target (to model read/write
	  delay), and the new value becomes the local time offset on return.
	</para>

	<programlisting>  sc_core::sc_time  delay = issQk.get_local_time();
  dataBus->b_transport( trans, delay );
  issQk.set( delay );</programlisting>

	<para>
	  At this point synchronization could be required&mdash;the read/write
	  delay could have pushed the local time offset past the global
	  quantum.
	</para>

	<programlisting>  if( issQk.need_sync() ) {
    issQk.sync();
  }</programlisting>

	<para>
	  The duration remaining for the &iss; simulation is reset in the same
	  way as in the main thread to be the local quantum less the local
	  time offset. On return the &iss; will continue for that period.
	</para>

	<programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  sc_core::sc_time  timeLeft      =
    refTgq.compute_local_quantum() - issQk.get_local_time();

  or1ksim_reset_duration ( timeLeft.to_seconds() );</programlisting>

      </sect3>


    </sect2>

    <sect2>
      <title>
	Modifying the &uart; to Support Temporal Decoupling
      </title>

      <para>
	Although the threads in the &uart; class are not temporarily
	decoupled, a small modification is needed. The callback for the target
	socket is part of this class, and it must handle delay data for the
	initiator in <classname>Or1ksimDecoupSC</classname> suitably.
      </para>

      <para>
	A new class, <classname>UartDecoupSC</classname>, derived from
	<classname>UartSyncSC</classname> is defined to provide a modified
	&tlm2; convenience target socket blocking callback function.
      </para>

      <sect3>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition includes the header of the base class and is
	  derived from it. The constructor has the same parameters as the base
	  class, <classname>UartSyncSC</classname>.
	</para>

	<para>
	  A replacement version of the &tlm2; convenience callback,
	  <function>busReadWrite()</function> is defined with the same
	  parameters as the base class function.
	</para>
      </sect3>

      <sect3>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor just calls the base class constructor, passing on all
	  its arguments.
	</para>

	<para>
	  The <function>BusReadWrite()</function> callback has the same
	  structure as the version in the parent class. Like the parent class
	  it calls the original <classname>UartSC</classname> version to carry
	  out most of the functionality.
	</para>

	<caution>
	  <para>
	    The call is therefore to the <emphasis>base class of the base
	    class</emphasis> of this class. The call cannot be to the parent,
	    since that would call <function>wait()</function>, defeating the
	    temporal decoupling.
	  </para>
	</caution>

	<para>
	  The difference is in updating the delay. The synchronous base class
	  waited to model the timing delay and set the delay in the response
	  to zero. In this version the code just increments the delay (which
	  is the local time offset) by the additional time to carry out the
	  read or write.
	</para>

	<programlisting>  switch( payload.get_command() ) {

  case tlm::TLM_READ_COMMAND:
    delay += sc_core::sc_time( UART_READ_NS, sc_core::SC_NS );
    break;</programlisting>

      </sect3>
    </sect2>

    <sect2 id="sec_temp_decoup_main">
      <title>
	Main Program for the Temporally Decoupled Model
      </title>

      <para>
	The main program, <filename>DecoupSocSC.cpp</filename> is similar in
	structure to the main program used for the synchronous version (see
	<xref linkend="sec_sync_main_prog" />). This time the temporally
	decoupled versions of the &or1ksim; wrapper and &uart; headers are
	used and the time to use as the global quantum is defined as a
	parameter.
      </para>

      <programlisting>#include "Or1ksimDecoupSC.h"
#include "UartDecoupSC.h"
#include "TermSyncSC.h"

#define QUANTUM_NS  1000000</programlisting>

      <para>
	Before any modules are instantiated, the system global quantum must be
	set. For the initial version a value of 10,000 ns is selected, 1% of
	the time taken to transmit a character at 9600 baud, so there should
	be no awkward timing interactions.
      </para>

      <programlisting>  tlm::tlm_global_quantum &amp;refTgq = tlm::tlm_global_quantum::instance();
  refTgq.set( sc_core::sc_time( QUANTUM_NS, sc_core::SC_NS ));</programlisting>

      <para>
	Thereafter the program follows the same structure (but using
	the temporarily decoupled versions of the &or1ksim; wrapper and
	&uart;).
      </para>

    </sect2>

    <sect2>
      <title>
	Compiling and Running the Synchronous Model
      </title>

      <para>
	Compilation is very similar to that of the synchronous model. The
	binaries of <emphasis>all</emphasis> the base classes are included
	when linking.
      </para>

      <para>
	The same configuration file and &or1k; compiled image is used to run
	the temporally decoupled model:
      </para>

      <programlisting>$ ./DecoupSocSC ../simple.cfg ../progs_or32/uart_loop</programlisting>

      <para>
	The results look very similar to those for the synchronized version,
	as shown in <xref
	linkend="fig_uart_loopback_decoup_log" />.
      </para>

      <figure id="fig_uart_loopback_decoup_log">
	<title>
	  &uart; loop back program log output with temporal decoupling.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.058881667 sec
Read: 'F'
Char written at  0.059941600 sec
Char read at     0.067121677 sec
Read: 'a'
Char written at  0.068181600 sec
Char read at     0.077411667 sec
Read: 'r'
Char written at  0.078471620 sec

   ... &lt;Lots more output&gt;
</screen>
      </figure>

      <para>
	The timing reported for the first character, 'F', is now
	1059&mu;s&mdash;in the synchronized version it was 1055&mu;s. The
	global quantum was set to 10&mu;s, which means that other threads may
	have a delay of up to 10&mu;s before they can run, affecting the time
	they will report for their actions.
      </para>

      <para>
	If the quantum is changed from 10&mu;s to 10ms, the change is more
	dramatic, as shown in  <xref
	linkend="fig_uart_loopback_decoup_10ms_log" />.
      </para>

      <figure id="fig_uart_loopback_decoup_10ms_log">
	<title>
	  &uart; loop back program log output with temporal decoupling and
	  10ms global quantum.
	</title>

	<screen>$ ./SyncSocSC ../simple.cfg ../progs_or32/uart_loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Reading script file from '../simple.cfg'...

   ... &lt;Or1ksim initialization messages&gt;

Char read at     0.091041667 sec
Read: 'F'
Char written at  0.101041600 sec
Char read at     0.101041667 sec
Read: 'a'
Char written at  0.111041620 sec
Char read at     0.111041687 sec
Read: 'r'
Char written at  0.121041600 sec

   ... &lt;Lots more output&gt;
</screen>
      </figure>

      <para>
	The time taken to write the first character is now 9,999&mu;s,
	completely dominated by the quantum. The typing of characters at the
	xterm is notably sluggish.
      </para>

      <para>
	This is characteristic of loosely timed models with temporal
	decoupling. The objective is to model the gross behavior of the system
	with a reasonable view of the timing, such that events happen in the
	correct sequence. However detailed timing can be sacrificed in the
	interest of greater model performance.
      </para>

      <para>
	The value for the global quantum is a subjective choice. In this case,
	with a busy polling &uart; loop back routine, any delays were wasted
	in additional polling cycles, so a small quantum was appropriate.
      </para>

      <para>
	In a more realistic scenario, the &uart; would be interrupt driven (or
	at least not polled continuously). Very likely the &uart; would only
	be lightly used, while other parts of the system were working. Under
	such circumstances, a global quantum of 100-1000&mu;s (10%-100% of the
	time to put one character on the &uart;) would be reasonable. The
	timing of characters output would be out by up to 100%, but the model
	would gain from fewer synchronizations.
      </para>

      <para>
	In other scenarios an even higher quantum could be justified&mdash;for
	example if the &uart; were only for occasional diagnostic output,
	where sluggishness did not matter. However when modeling a 100MHz
	&iss; as part of the SoC, the benefits of such large global quantum
	values would be minimal.
      </para>

      <para>
	The other step to take to improve performance would be to move to an
	exclusively &tlm2; model. The &systemc; FIFO is a good way to model
	the &uart; to terminal connection. However by using a &tlm2; socket in
	each direction, both &uart; and terminal could be temporally
	decoupled, giving further performance improvement.
      </para>

    </sect2>
  </sect1>

  <sect1 id="sec_linux">
    <title>
      Modeling Interrupts and Running Linux on the Example SoC
    </title>

    <para>
      The Simple SoC used in the previous sections is not sufficient to run
      Linux. Two significant extensions are needed.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Memory management must be added to support Linux virtual
	  memory. This is provided by enabling the internal MMUs (instruction
	  and data) of the &or1ksim; &iss;.
	</para>
      </listitem>

      <listitem>
	<para>
	  The &systemc; &uart; peripheral must be extended to handle
	  interrupts.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The example design was shown in <xref linkend="soc_example_soc_intr"/>,
      but for convenience the diagram is repeated here in <xref
      linkend="fig_simple_soc_intr2" />.
    </para>

    <figure id="fig_simple_soc_intr2">
      <title>
	Simple SoC based on the &or1k; &or1ksim; with interrupts and MMU
	enabled.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      Enabling memory management is a matter of modifying the configuration
      file for &or1ksim;. The Linux port used here expects to boot from flash
      memory, so the internal memory of &or1ksim; is also extended to provide
      this.
    </para>

    <para>
      The &uart; model, <classname>UartDecoupSC</classname> is further
      extended by a new derived class, <classname>UartIntrSC</classname>
      providing a &systemc; <classname>sc_out&lt;bool&gt;</classname> port
      through which the interrupt signal is driven.
    </para>

    <sect2>
      <title>
	Extending the <classname>Or1ksimDecoupSC</classname> Module Class
      </title>

      <para>
	The &or1ksim; &iss; library is extended to provide an
	<acronym>API</acronym> call to generate an interrupt. The &or1ksim;
	includes a programmable interrupt controller
	(<firstterm>PIC</firstterm>), which is enabled. The new
	<acronym>API</acronym> call, takes as parameter the interrupt number
	to be triggered.
      </para>

      <para>
	The &or1ksim; wrapper, <classname>Or1ksimDecoupSC</classname> is further
	extended by a new derived class, <classname>Or1ksimIntrSC</classname>,
	which provides an array of signal ports to connect to external devices
	which wish to generate interrupts.
      </para>

      <sect3>
	<title>
	  Adding an Interrupt Generation Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function allows the external &systemc; model to call
	  into the &or1ksim; &iss; to request an interrupt. The &iss; requires
	  that interrupts are not taken mid-instruction (for example while a
	  peripheral memory access upcall is in progress), so a flag is set
	  internally, allowing the &iss; to trigger the interrupt at the start
	  of the next instruction.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <programlisting>void or1ksim_interrupt( int  i );</programlisting>
	    </para>
	    
	    <para>
	      <function>void or1ksim_interrupt()</function> requests the the
	      interrupt given by its argument be taken at the start of the
	      next instruction cycle.
	    </para>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimIntrSC</classname> is
	  derived from the existing <classname>Or1ksimDecoupSC</classname>
	  module class, whose header, <filename>Or1ksimDecoupSC.h</filename>,
	  is included. The number of interrupts to be supported is given by
	  the constant, <literal>NUM_INTR</literal>.
	</para>
	
	<programlisting>#define  NUM_INTR  32</programlisting>

	<para>
	  The new class derived from the base class and a custom constructor
	  defined. The possible interrupts are represented by an array of
	  <classname>sc_signal</classname>.
	</para>

	<programlisting>  sc_core::sc_signal&lt;bool&gt;  intr[NUM_INTR];</programlisting>

	<tip>
	  <para>
	    It would have been possible to define an array of signal input
	    ports, <classname>sc_in&lt;bool&gt;</classname>. However these
	    ports must then be explicitly connected (bound), requiring tie-off
	    signals to be created in the main program.
	  </para>

	  <para>
	    By creating actual signals, interrupts that are unused can be left
	    unbound and ignored.
	  </para>
	</tip>

	<para>
	  A &systemc; method is required to handle the interrupts (since it
	  never waits, a thread is not needed). This can respond to interrupts
	  in parallel with the main &iss; execution thread.
	</para>

	<programlisting>  void  intrMethod();</programlisting>

      </sect3>

      <sect3>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class constructor
	  for processing. It then sets up <function>intrMethod</function> as a
	  &systemc; method process, sensitive to the positive edge of each
	  interrupt signal. There is no need to initialize this function.
	</para>

	<programlisting>  SC_METHOD( intrMethod );
  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    sensitive &lt;&lt; intr[i].posedge_event();
  }
  dont_initialize();</programlisting>
	
	<para>
	  The interrupt method is triggered by a positive edge on one of the
	  signals. It loops through to find which interrupt was triggered and
	  generates a call to <function>or1ksim_interrupt</function> for that
	  interrupt number. In principle more than one could be triggered in the
	  same cycle, so all are checked.
	</para>

	<programlisting>  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    if( intr[i].event()) {
      or1ksim_interrupt( i );
    }
  }</programlisting>

      </sect3>
    </sect2>


    <sect2>
      <title>
	Extending the <classname>UartDecoupSC</classname> Module Class
      </title>

      <para>
	The existing &uart; module processes interrupts, but does not generate
	an external interrupt signal. To generated an interrupt signal,
	<classname>UartDecoupSC</classname> is further extended by a new
	derived class, <classname>UartIntrSC</classname>, which provides a
	signal port and a new thread to drive that signal port
      </para>

      <para>
	An extra thread is required, because both the
	<function>rxMethod</function> and <function>busThread</function>
	processes may wish to drive signals, but &systemc; requires that a
	signal is driven by a single process. Just as in hardware
	design a wire would not normally have more than one driver.
      </para>

      <para>
	The new process communicates with the existing processes via a FIFO
	internal to the UART, allowing <function>rxMethod()</function> and
	<function>busThread()</function> to both request interrupt activity
	and for those requests to be processed in the order they were
	generated.
      </para>

      <sect3>
	<title>
	  <classname>UartIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>UartIntrSC</classname> is
	  derived from the existing <classname>UartDecoupSC</classname>
	  module class, whose header, <filename>UartDecoupSC.h</filename>,
	  is included.
	</para>

	<para>
	  A custom constructor is declared, and signal output port
	  <classname>sc_out&lt;bool&gt;</classname> through which the
	  interrupt will be driven.
	</para>

	<para>
	  The new thread, <function>intrThread()</function> is declared. It
	  will use re-implemented versions of the <function>genIntr()</function>
	  and <function>clrIntr()</function> functions from the base class,
	  <classname>UartSC</classname>.
	</para>

	<para>
	  A Boolean FIFO is used to hold the queue of requests from the
	  existing processes, <function>rxMethod()</function> and
	  <function>busThread()</function>.
	</para>

	<programlisting>  sc_core::sc_fifo&lt;bool&gt;  intrQueue;</programlisting>

      </sect3>

      <sect3>

	<title>
	  <classname>UartIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  Since this class declares a new &systemc; process,
	  <literal>SC_HAS_PROCESS</literal> is used. The constructor passes
	  its arguments to the base class,
	  <classname>UartDecoupSC</classname> and sets the FIFO queue size to 1.
	</para>

	<programlisting></programlisting>

	<note>
	  <para>
	    The choice of FIFO size means that there should be only one
	    request for interrupt pending. In principle this could block an
	    attempt by the <function>rxMethod</function> to write to the FIFO,
	    and since &systemc; methods may now wait (unlike threads) a
	    run time error will occur.
	  </para>

	  <para>
	    This is an explicit model design decision. If there is interrupt
	    congestion, then it would be useful to know&mdash;indicating
	    design issues over the UART capacity. If this were not an issue,
	    then it would be quite valid to use a larger FIFO capacity.
	  </para>
	</note>

	 <para>
	   The constructor then creates the new &systemc; method for
	   <function>intrThread()</function>.
	 </para>

	 <para>
	   <function>intrThread()</function> has a very simple
	   <acronym>API</acronym>. If <literal>true</literal> is read it
	   asserts an interrupt (drives the interrupt port
	   <literal>true</literal>), otherwise it deasserts the interrupt port
	   (drives the interrupt port <literal>false</literal>).
	 </para>

	 <para>
	   On initialization, the interrupt port is deasserted
	   (<literal>false</literal>). The thread then sits in a perpetual
	 loop, copying requests from the FIFO to the interrupt signal output
	 port.</para>

	 <programlisting>  while( true ) {
    intr.write( intrQueue.read() );
  }</programlisting>

	 <para>
	   The interrupt generator, <function>genIntr</function> is almost
	   identical to the version in the base class,
	   <classname>UartSC</classname>. The only difference is that if an
	   interrupt is generated, a request to drive the signal is written
	   onto the internal interrupt FIFO for processing by the
	   <function>intrThread()</function> thread.
	 </para>

	 <programlisting>    clr( regs.iir, UART_IIR_IPEND );   // Mark (0 = pending) and queue
    intrQueue.write( true );
  }</programlisting>

	 <para>
	   The interrupt clear routing is a similar modification, this time
	   requesting the interrupt signal to be cleared by writing
	   <literal>false</literal> on the FIFO queue.
	 </para>

	 <programlisting>  if( !setIntrFlags()) {               // Deassert if none left
    set( regs.iir, UART_IIR_IPEND );    // 1 = not pending
    intrQueue.write( false );
 }</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>
	Main Program for the Interrupt Driven Model
      </title>

      <para>
	The main program for the model supporting interrupts in is
	<filename>intrSocSC>cpp</filename>. It has a very similar structure to
	the main program used with the temporal decoupling example in <xref
	linkend="sec_temp_decoup_main" />, but uses the new versions of the
	&or1ksim; wrapper class and &uart; module,
	<classname>Or1ksimIntrSC</classname> and
	<classname>UartIntrSC</classname>. 
      </para>

      <para>
	A baud rate of 115,200 is expected for the Linux kernel serial port
	and a global quantum of 10&mu;s is appropriate for this. A constant is
	defined to hold the interrupt port number used by the &uart; (2).
      </para>

      <programlisting>#define BAUD_RATE   115200
#define QUANTUM_US      10

#define INTR_UART        2</programlisting>

      <para>
	The main program structure is unchanged, except that the &uart;
	interrupt output port needs to be connected to the correct signal in
	the &or1ksim; wrapper:
      </para>

      <programlisting>  uart.intr( iss.intr[INTR_UART] );</programlisting>
    </sect2>

    <sect2>
      <title>
	Running the Interrupt Driven Model
      </title>

      <para>
	Compilation and linking of the program follows the same procedure as
	with the previous examples.
      </para>

      <para>
	As a simple test, the interrupt loop program used in earlier examples
	is extended to demonstrate basic interrupt handling. The main test is
	booting a &linux; kernel.
      </para>

      <sect3>
	<title>
	  Simple Test for the Interrupt Driven SoC Model
	</title>

	<para>
	  A simple test is provided in <filename>uart_loop_intr.c</filename>
	  as an extension of <filename>uart_loop.c</filename>. After a
	  character is read, the program loops to wait until the interrupt
	  pending flag is clear (indicating the transmit buffer is empty).
	</para>

	<programlisting>    do {                        /* Wait for interrupts to clear */
      ;
    } while( is_set( uart->iir, UART_IIR_IPEND ) );</programlisting>

	<para>
	  This is a very basic test&mdash;if all is well it behaves
	  identically to the existing loop program. If there is a problem
	  clearing the transmit buffer empty interrupt, or the received data
	  available interrupt is not cleared when data is read, then the
	  program will lock up waiting for the interrupt pending flag to
	  clear.
	</para>

      </sect3>

      <sect3>
	<title>
	  Running Linux
	</title>

	<para>
	  This test uses a &linux;&nbsp;2.6.19 kernel built for the standalone
	  &or1ksim; as described in the Embecosm Application note <xref
	  linkend="ref_app_note_1" />. A configuration file, which enables the
	  internal <firstterm>memory management unit</firstterm>s
	  (<acronym>MMU</acronym>s) and Programmable Interrupt Controller
	  (<acronym>PIC</acronym>) of the &or1ksim; is provided,
	  <filename>linux.cfg</filename>. This also declares additional
	  internal memory space for &or1ksim; for flash and
	  <acronym>SRAM</acronym>.
	</para>

	<para>
	  The &systemc; model is then run with this configuration file and the
	  &linux; kernel binary.
	</para>

	<programlisting>./IntrSocSC linux.cfg ../linux-2.6.19/vmlinux</programlisting>

	<para>
	  Initially &linux; copies itself from flash memory to
	  <acronym>RAM</acronym>.
	</para>

	<screen>Copying Linux... Ok, booting the kernel.</screen>

	<para>
	  After a pause while initial booting is taking place the serial
	  interface is ready, allowing the normal kernel boot messages to
	  appear:
	</para>

	<screen>Linux version 2.6.19-or32 (jeremy@thomas) (gcc version 3.4.4) #59 Wed Jun 25 18:48:06 BST 2008
Detecting Processor units:
  Signed 0x391
Setting up paging and PTEs.
write protecting ro sections (0xc0002000 - 0xc024c000)
Setting up identical mapping (0x80000000 - 0x90000000)
Setting up identical mapping (0x92000000 - 0x92002000)
Setting up identical mapping (0xb8070000 - 0xb8072000)
Setting up identical mapping (0x97000000 - 0x97002000)
Setting up identical mapping (0x99000000 - 0x9a000000)
Setting up identical mapping (0x93000000 - 0x93002000)
Setting up identical mapping (0xa6000000 - 0xa6100000)
Setting up identical mapping (0x1e50000 - 0x1fa0000)
dtlb_miss_handler c00040c8
itlb_miss_handler c00041a8
Built 1 zonelists.  Total pages: 3953
Kernel command line: root=/dev/ram console=ttyS0

   &lt;Lots more &linux; kernel messages...&gt;

Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing disabled
serial8250.0: ttyS0 at MMIO 0x90000000 (irq = 2) is a 16450

   &lt;Lots more &linux; kernel messages...&gt;

VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
Starting pid 22, console /dev/ttyS0: '/etc/init.d/rcS'

Please press Enter to activate this console. </screen>

	<para>
	  This takes a simulated time of about 37 seconds, and on a modern PC
	  around 20-25 seconds elapsed time (the &or1ksim; &iss; in this minimal
	  configuration runs at 150-200MHz <footnote>
	    <para>
	      This may seem exceptionally fast for an interpreting &iss;, but
	      this model is configured with slow RAM with a 20-25 cycle access
	      time and no caches. So 150-200MHz represents only 5-10
	      MIPS. That's why booting a basic &linux; kernel takes 37s of
	      simulated time, rather than the 2-3s that might reasonably be
	      expected!
	    </para>
	  </footnote>).
	</para>
  
	<para>
	  At this point hitting return will start up a &linux; shell,
	  running some basic commands and in this example the
	  <application>BusyBox</application> utilities (see the <ulink
	  url="http://www.busybox.com">website</ulink> for more details).
	</para>

	<screen>Please press Enter to activate this console. 
Startingpid 25, console /dev/ttyS0: '/bin/sh'


BusyBox v1.4.1 (2007-03-22 18:53:56 EST) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

# ls /proc
1              2              bus            iomem          self
10             25             cmdline        ioports        slabinfo
11             26             cpuinfo        kcore          stat
12             3              crypto         kmsg           sys
13             4              devices        loadavg        sysrq-trigger
14             5              diskstats      locks          sysvipc
15             6              driver         meminfo        tty
16             7              execdomains    misc           uptime
17             8              filesystems    mounts         version
18             9              fs             net            vmstat
19             buddyinfo      interrupts     partitions     zoneinfo
# busybox mount
rootfs on / type rootfs (rw)
/dev/root on / type ext2 (ro)
proc on /proc type proc (rw)
# </screen>

	<para>
	  The importance of choosing a suitable value for the global quantum
	  is well illustrated here. Rebuild the model with a global quantum of
	  100&mu;s&mdash;rather longer than the time it takes to transmit one
	  character at 115,200 baud.
	</para>

	<programlisting>#define QUANTUM_US     100</programlisting>

	<para>
	  The time taken to boot is marginally faster (19s), but this time the
	  terminal cannot cope with the erratic interrupt behavior.
	</para>

	<screen>VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.
Please press Ent</screen>

	<para>
	  The &linux; system has locked up, presumably due to interrupt
	  behavior and a few seconds later will crash with an unhandled
	  exception.
	</para>

      </sect3>
    </sect2>



  </sect1>

<glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>approximately&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing the phases of data
	  transfer in a specific bus protocol (for example the address and
	  data phases of an <acronym>AHB</acronym> read or write).
	</para>

	<glossseealso>loosely&#32;timed</glossseealso>
	<glossseealso>phase</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>backward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method which
	  returns the response transaction from target to initiator.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>forward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which blocks the flow of
	  control in the initiator until the target has completed the
	  transaction request and responded.
	</para>

	<glossseealso>non-blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>convenience&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; wrapper, providing for simple TLM communication based on
	  C++ callbacks.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>forward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport method, which
	  passes the opening transaction from initiator to target.
	</para>

	<glossseealso>transport&#32;method</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Generic Payload</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a class suitable for use as payload for
	  transactions. Recommended to maximize the interoperability of &tlm;s.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Hardware&#32;Description&#32;Language</glossterm>
      <glossdef>
	<para>
	  A language (<glossterm>Verilog</glossterm> and
	  <glossterm>VHDL</glossterm> are the best known), which describes
	  hardware. Can be used to describe both an actual chip and its
	  test bench.
	</para>

	<glossseealso>Verilog</glossseealso>
	<glossseealso>VHDL</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>initiator</glossterm>
      <glossdef>
	<para>
	  The initiator of a transactional exchange to a target. In &tlm2; an
	  initiator module must implement an initiator socket of the
	  appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>target</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Instruction&#32;Set&#32;Simulator</glossterm>
      <glossdef>
	<para>
	  A software model of a CPU core instruction set. Typically completely
	  models the instruction semantics, but not the full microarchitecture
	  of a particular CPU implementation. Timing information may be just
	  an instruction count, or may (as with the &or1ksim;) offer some
	  estimate of timing delays due to memory accesses, caching and
	  virtual memory access.
	</para>
      </glossdef>

    </glossentry>

    <glossentry>
      <glossterm>&iss;</glossterm>
      <glosssee>Instruction&#32;Set&#32;Simulator</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&osci;</acronym></glossterm>
      <glosssee>Open &systemc; Initiative</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>loosely&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing a complete data transfer
	  across a hardware bus.
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open&#32;SystemC&#32;Initiative</glossterm>
      <glossdef>
	<para>
	  The industry body standardizing the SystemC language and
	  applications of those language for particular purposes, such as
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>,
	  verification and synthesis. More information is available on their
	  <ulink url="http://www.systemc.org">website</ulink>.
	</para>

	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>MMU</acronym></glossterm>
      <glosssee>memory management unit</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>memory management unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>non-blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which allows the flow of
	  control in the initiator to continue immediately the transaction is
	  sent. The response will be provided later by a transport call from
	  the target back to the initiator..
	</para>

	<glossseealso>blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>passthrough</glossterm>
      <glossdef>
	<para>
	  A term describing a &tlm2; convenience socket which reuses the
	  payload, thereby eliminating the computational cost of allocation
	  and deallocation. Typically used in modules which perform a routing
	  or arbitration function.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload</glossterm>
      <glossdef>
	<para>
	  The data passed between threads by a transaction.
	</para>

	<glossseealso>Generic Payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>phase</glossterm>
      <glossdef>
	<para>
	  In &tlm2; approximately timed modeling, a transaction exchange
	  representing a single phase of the specific bus protocol being
	  modeled (for example the address phase of an <acronym>AHB</acronym>
	  read or write).
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>PIC</acronym></glossterm>
      <glosssee>programmable interrupt controller</glosssee>
    </glossentry>

    <glossentry>
      <glossterm><acronym>POSIX</acronym></glossterm>
      <glossdef>
	<para>
	  An IEEE standard for application programming interfaces and
	  utilities for Unix/Linux operating systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>programmable interrupt controller</glossterm>
      <acronym>PIC</acronym>
      <glossdef>
	<para>
	  A hardware component which provides a large number of interrupt
	  ports, which are mapped onto one or two interrupt ports on an actual
	  processor. The <acronym>PIC</acronym> will provide a lookup table of
	  interrupt service routines for its interrupts, which the interrupt
	  service routine on the processor can use to identify the correct
	  handler to use.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, the maximum time a thread may
	  run ahead of the main system clock. This may be regulated by a
	  quantum keeper.
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum keeper</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, an object which enforces the
	  rule that threads may not run more than the quantum ahead of the
	  main system clock
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>singleton</glossterm>
      <glossdef>
	<para>
	  In object oriented programming, a class which can have at most one
	  instance. Typically implemented by making the constructor private
	  and providing an access routine which instantiates the class on its
	  first call and on all other calls returns a pointer to that instance.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>socket</glossterm>
      <glossdef>
	<para>
	  Within the context of &tlm2;, a &systemc; port and export combined
	  with the associated interfaces for blocking and non-blocking
	  transport, direct memory access and debug.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>&systemc;</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>tagged&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; convenience socket, which incorporates a numerical
	  <emphasis>tag</emphasis> to identify the socket in use. This allows
	  a single callback routine to handle multiple sockets, with the tag
	  identifying the socket which caused the callback to be invoked.
	</para>

	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>target</glossterm>
      <glossdef>
	<para>
	  The responder to a transactional exchange initiated by an
	  initiator. In &tlm2; a target module must implement a target socket
	  of the appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>initiator</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>temporal&#32;decoupling</glossterm>
      <glossdef>
	<para>
	  In &tlm2; the concept of allowing individual threads to run ahead of
	  the main simulation time stamp. The maximum permitted time of run
	  ahead is known as the <glossterm>quantum</glossterm> and may be
	  regulated by a quantum keeper.
	</para>

	<glossseealso>quantum</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>thread</glossterm>
      <glossdef>
	<para>
	  In software, a logical parallel flow of control. In the context of
	  &systemc;, the main method of such a thread can be specified with
	  the <literal>SC_THREAD</literal> macro. In &systemc; a
	  <literal>SC_THREAD</literal> is distinguished from a
	  <literal>SC_METHOD</literal> because it can suspend execution with
	  <function>wait()</function> calls.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym></glossterm>
      <glossdef>
	<para>
	  An abbreviation for (depending on context)
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm> or
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>Transaction&#32;Level&#32;Modeling</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym>&nbsp;2.0</glossterm>
      <glossdef>
	<para>
	  The &osci; standard interface for writing
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>s in
	  &systemc;.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>SystemC</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transport&#32;method</glossterm>
      <glossdef>
	<para>
	  The C++ procedure which transfers data from an initiator to a
	  target, and (for a non-blocking interface), the response back from
	  the target to the initiator. Within the context of &tlm2; blocking
	  and non-blocking transport interfaces are defined.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction</glossterm>
      <glossdef>
	<para>
	  An exchange of data (the payload) between two parallel processes. In
	  &tlm2; this transaction occurs through &systemc; ports implementing
	  the &tlm2; interfaces, which are known as sockets.
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Model</glossterm>
      <glossdef>
	<para>
	  A software model in which the components of the model communicate by
	  transferring information to and from each other (transactions).
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>
      <glossdef>
	<para>
	  The process of writing software models using
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Verilog</glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso><acronym>VHDL</acronym></glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>VHDL</acronym></glossterm>
      <glossdef>
	<para>
	  A <glossterm>Hardware&#32;Description&#32;Language</glossterm> (HDL).
	</para>

	<glossseealso>Hardware&#32;Description&#32;Languages</glossseealso>
	<glossseealso>Verilog</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <biblioentry id="ref_app_note_1">
      <title id="ref_app_note_1_xr">
	&embecosm; Application Note 1. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide
      </title>

      <publisher>
	<publishername>
	  Embecosm
	</publishername>
	<address>
	  <city>
	    Bournemouth
	  </city>
	  <country>
	    UK
	  </country>
	</address>
      </publisher>

      <pubdate>
	June, 2008
      </pubdate>
    </biblioentry>

    <biblioentry id="ref_fitch_88">
      <title id="ref_fitch_88_xr">
	A loosely coupled parallel LISP execution system
      </title>

      <publisher>
	<publishername>
	  IEEE
	</publishername>
      </publisher>

      <author>
	<surname>ffitch</surname>
	<firstname>J</firstname>
      </author>

      <pagenums>
	128-133
      </pagenums>

      <confgroup>
	<conftitle>
	  International Specialist Seminar on the Design and Application of
	  Parallel Digital Processors
	</conftitle>
	<confdates>
	  11-15 Apr 1988
	</confdates>
      </confgroup>

    </biblioentry>

  </bibliography>
</article>
 