<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY abi   "<acronym>ABI</acronym>">
<!ENTITY api   "<acronym>API</acronym>">
<!ENTITY bist  "<acronym>BIST</acronym>">
<!ENTITY codec "<acronym>codec</acronym>">
<!ENTITY cpld  "<acronym>CPLD</acronym>">
<!ENTITY cpu   "<acronym>CPU</acronym>">
<!ENTITY crc   "<acronym>CRC</acronym>">
<!ENTITY dut   "<acronym>DUT</acronym>">
<!ENTITY gnu   "<acronym>GNU</acronym>">
<!ENTITY gpr   "<acronym>GPR</acronym>">
<!ENTITY fifo  "<acronym>FIFO</acronym>">
<!ENTITY fpga  "<acronym>FPGA</acronym>">
<!ENTITY ieee  "<acronym>IEEE</acronym>">
<!ENTITY iss   "<acronym>ISS</acronym>">
<!ENTITY jtag  "<acronym>JTAG</acronym>">
<!ENTITY mmu   "<acronym>MMU</acronym>">
<!ENTITY npc   "<acronym>NPC</acronym>">
<!ENTITY osci  "<acronym>OSCI</acronym>">
<!ENTITY pdf   "<acronym>PDF</acronym>">
<!ENTITY ppc   "<acronym>PPC</acronym>">
<!ENTITY rsp   "<acronym>RSP</acronym>">
<!ENTITY rtl   "<acronym>RTL</acronym>">
<!ENTITY soc   "<acronym>SoC</acronym>">
<!ENTITY spr   "<acronym>SPR</acronym>">
<!ENTITY sram  "<acronym>SRAM</acronym>">
<!ENTITY tap   "<acronym>TAP</acronym>">
<!ENTITY tdm   "<acronym>TDM</acronym>">
<!ENTITY tlm   "<acronym>TLM</acronym>">
<!ENTITY uart  "<acronym>UART</acronym>">
<!ENTITY vcd   "<acronym>VCD</acronym>">

<!-- ========== commonly used things ========== -->

<!ENTITY systemc "SystemC">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY gcc       "<application class='software'><acronym>GCC</acronym></application>">
<!ENTITY gdb       "<application class='software'><acronym>GDB</acronym></application>">
<!ENTITY gtkwave   "<application class='software'>GTKWave</application>">
<!ENTITY icarus    "<application class='software'>Icarus Verilog</application>">
<!ENTITY linux     "<application class='software'>Linux</application>">
<!ENTITY make      "<command>make</command>">
<!ENTITY verilator "<application class='software'>Verilator</application>">

<!-- = Hardware applications = -->

<!ENTITY or1k      "<application class='hardware'>OpenRISC 1000</application>">
<!ENTITY or1200    "<application class='hardware'>OpenRISC 1200</application>">
<!ENTITY orpsoc    "<application class='hardware'>ORPSoC</application>">

<!-- = Commands = -->

<!-- = Libraries = -->

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY lgpl "GNU Lesser General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2009 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing a SystemC cycle accurate interface to JTAG

$Id$

=========================================================================== -->

<book lang="en_GB">
  <title>
    Integrating the GNU Debugger with Cycle Accurate Models
  </title>
  <subtitle>
    A Case Study using a Verilator SystemC Model of the OpenRISC 1000
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      March 2009
    </pubdate>

    <releaseinfo>
      Application Note 7. Issue 1
    </releaseinfo>

    <copyright>
      <year>
	2009
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, Jeremy Bennett of &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software for the &systemc; cycle accurate model written by
	&embecosm; and used in this document is licensed under the
	&gpl_www;. For detailed licensing information see the file
	<filename>COPYING</filename> in the source code.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      This document describes how to integrate the &gnu; Debugger, &gdb;, with
      fast cycle accurate &systemc; models of processors and systems-on-chip
      (&soc;). This provides a highly productive environment for early
      software development, testing and performance analysis before silicon is
      available.
    </para>

    <para>
      The interface is made through the cycle accurate model of the &jtag;
      (IEEE 1149.1) interface of the chip <xref linkend="ref_ieee_jtag"/>
      <xref linkend="ref_ti_jtag"/>. This means the interface is readily
      reusable for FPGA implementations or finished silicon.
    </para>

    <sect1>
      <title>
	Why Use Cycle Accurate Modeling
      </title>

      <para>
	Cycle accurate models in C and &systemc; are becoming an increasingly
	important part of the verification process, particularly for SoCs with
	performance critical embedded software. They represent a software
	friendly compromise, offering higher performance than traditional
	event-driven simulation, but greater accuracy than hand-written
	instruction set simulators (&iss;) and transaction level models
	(&tlm;).
      </para>
    
      <para>
	Typically such models follow 2-state, zero-delay synthesis semantics,
	offering an early insight into the behavior of the synthesized
	design. Applications include:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Implementation of low level firmware, such as board support
	    packages &codec;s and specialist device drivers, which rely on
	    exact behavior of SoC peripherals.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Software optimization. This can be particularly important for
	    &codec; development, where the performance depends critically on
	    interaction between processor, memory, cache and MMU. In such
	    scenarios, estimates by &iss; and &tlm; can be out by a factor of
	    3, resulting either in wasted silicon, or chips that cannot meet
	    their required performance.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Detailed performance analysis of systems, based on the actual
	    hardware implementation running with its embedded software.
	  </para>
	</listitem>

      </itemizedlist>

      <para>
	For all these purposes, a debugger is required, capable of
	communicating with the cycle accurate model. This application note
	shows how to implement that debugger interface for &gdb; using the
	&gdb; Remote Serial Protocol (&rsp;).
      </para>
    
      <para>
	This application note builds on several earlier Embecosm Application
	notes:
      </para>
    
      <itemizedlist>
	<listitem>
	  <para>
	    EAN3. <citetitle>Howto: Porting the GNU Debugger: Practical
	    Experience with the OpenRISC 1000 Architecture</citetitle> <xref
	    linkend="ref_app_note_3"/>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    EAN4. <citetitle>Howto: GDB Remote Serial Protocol: Writing a RSP
	    Server</citetitle> <xref linkend="ref_app_note_4"/>.
	  </para>
	</listitem>
      
	<listitem>
	  <para>
	    EAN5. <citetitle>Using JTAG with SystemC: Implementation of a
	    Cycle Accurate Interface</citetitle> <xref
	    linkend="ref_app_note_5"/>.
	  </para>
	</listitem>
      
	<listitem>
	  <para>
	    EAN6. <citetitle>High Performance SoC Modeling with Verilator: A
	    Tutorial for Cycle Accurate SystemC Model Creation and
	    Optimization</citetitle> <xref linkend="ref_app_note_6"/>.
	  </para>
	</listitem>
      
      </itemizedlist>
    
    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>
      
      <para>
	This application note is intended for any engineer who needs to
	interface &gdb; to a cycle accurate model of a &cpu; or SoC. The earlier
	application notes provide guidance on &gdb; &jtag; and cycle accurate
	modeling.
      </para>
      
      <para>
	While based entirely on open source tools, the techniques
	described are equally applicable to commercial tools.
      </para>
      
    </sect1>
    
    <sect1>
      <title>
	Open Source
      </title>

      <para>
	This application note uses entirely free and open source tools. The
	designed used is an open source SoC, &orpsoc; <xref
	linkend="ref_orpsoc"/>. The cycle accurate model is implemented in
	&systemc; <xref linkend="ref_osci_systemc_ug"/> generated
	automatically by &verilator; <xref linkend="ref_verilator"/>. The
	embedded software is compiled usign the &gnu; C compiler <xref
	linkend="ref_gcc_ug"/> and debugged using the &gnu; debugger <xref
	linkend="ref_gdb_ug"/>.
      </para>

    </sect1>

    <sect1>
      <title>
	Further Sources of Information
      </title>

      <sect2>
	<title>
	  Written Documentation
	</title>

	<para>
	  First and foremost this application note draws on techniques
	  described in Embecosm Application Notes 3-6 <xref
	  linkend="ref_app_note_3"/> <xref linkend="ref_app_note_4"/> <xref
	  linkend="ref_app_note_5"/> <xref linkend="ref_app_note_6"/>. These
	  should be used as the primary source of additional information.
	</para>

	<para>
          &verilator; has its own website (<ulink
          url="http://www.veripool.org">www.veripool.org</ulink>), providing
          guidance for downloading, installing and using the tool. In
          particular this application note should be read in conjunction with
          the &verilator; user guide.
        </para>

	<para>
	  &systemc; is defined by &ieee; standard 1666, and the
	  standardization documents are the ultimate reference. The &systemc;
	  standard <xref linkend="ref_ieee_systemc"/> is a free &pdf; download
	  (a novelty for the &ieee;). The open source reference implementation
	  from &osci; includes an introductory tutorial.
	</para>

	<para>
	  &jtag; is also an &ieee; standard (1149.1), and the standardization
	  documents is the ultimate reference. Unlike the &systemc; standard,
	  the &jtag; standard <xref linkend="ref_ieee_jtag"/> costs money. The
	  Texas Instruments &jtag; primer <xref linkend="ref_ti_jtag"/> is a
	  useful free alternative.
	</para>

	<para>
	  The main user guide for &gdb; <xref linkend="ref_gdb_ug" /> provides
	  a great deal of context about how &gdb; is intended to work. The
	  &gdb; Internals document <xref linkend="ref_gdb_int" /> is essential
	  reading before and during any porting exercise. It is not complete,
	  nor is it always up to date, but it provides the first place to look
	  for explanation of what a particular function does.
	</para>

	<para>
	  The files making up the examples used in this application noted are
	  comprehensively commented, and can be processed with Doxygen <xref
	  linkend="ref_doxygen" />. Each class, member and method's behavior,
	  parameters and return value is described.
	</para>
	<indexterm>
	  <primary>Doxygen</primary>
	</indexterm>
    
      </sect2>

      <sect2>
	<title>
	  Other Information Channels
	</title>

	<para>
	  There is a wealth of material to support both &systemc; and &jtag;
	  on the Internet.
	</para>

	<para>
	  The Open &systemc; Initiative (&osci;) provides an open source
	  reference implementation of the &systemc; library, which includes
	  tutorial material in its documentation directory. These may be
	  accessed from the &osci; website (<ulink
	  url="http://www.systemc.org">www.systemc.org</ulink>).
	</para>

	<para>
	  &osci; also provide a number of public mailing lists. The help forum
	  and the community forum are of particular relevance. Subscription is
	  through the &osci; website (see above).
	</para>

	<para>
	  The main GDB website is at <ulink
	  url="http://sourceware.org/gdb/">sourceware.org/gdb/</ulink>. It is
	  supplemented by the less formal &gdb; Wiki at <ulink
	  url="http://sourceware.org/gdb/wiki/">sourceware.org/gdb/wiki/</ulink>. 
	</para>

	<para>
	  The &gdb; developer community communicate through the &gdb; mailing
	  lists and using <acronym>IRC</acronym> chat. These are always good
	  places to find solutions to problems.
	</para>

	<para>
	  The main mailing list for discussion is gdb@sourceware.org, although
	  for detailed understanding, the patches mailing list,
	  gdb-patches@sourceware.org. See the main &gdb; website for details
	  of subscribing to these mailing lists.
	</para>

	<para>
	  <acronym>IRC</acronym> is on channel <literal>#gdb</literal> on
	  <literal>irc.freenode.net</literal>.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	About &embecosm;
      </title>

      <para>
	&embecosm; is a consultancy specializing in open source tools, models
	and training for the embedded software community. All &embecosm;
	products are freely available under open source licenses.
      </para>
      <indexterm>
	<primary>&embecosm;</primary>
      </indexterm>

      <para>
	&embecosm; offers a range of commercial services:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Customization of open source tools and software, including porting
	    to new architectures.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Support, tutorials and training for open source tools and software.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Custom software development for the embedded market, including
	    bespoke software models of hardware.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Independent evaluation of software tools.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	For further information, visit the &embecosm; website at <ulink
	url="http://www.embecosm.com/">www.embecosm.com</ulink>.
      </para>

    </sect1>

  </chapter>

  <chapter id="chap_overview">
    <title>
      Overview of Technologies and Tools
    </title>

    <sect1>
      <title>
	&osci; &systemc; IEEE 1666
      </title>

      <para>
	The development of &systemc; as a standard for modeling hardware
	started in 1996. Version 2.0 of the proposed standard was released by
	the Open &systemc; Initiative (&osci;) in 2002. In 2006, &systemc;
	became IEEE standard 1666-2005 <xref linkend="ref_ieee_systemc" />.
      </para>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one of the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling, in particular to model the
	parallelism of hardware, in a mainstream programming language.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc;, even though it is a hardware
	modeling language. Rather than invent a new language, &systemc; is
	based on the existing C++ language. &systemc; is a true super-set of
	C++, so any C++ program is automatically a valid &systemc; program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    A C++ class, <classname>sc_module</classname>, suitable for
	    defining hardware modules containing parallel
	    processes.
	  </para>

	  <note>
	    <para>
	      <emphasis>Process</emphasis> is a general term in &systemc;
	      to describe the various ways of representing parallel flows
	      of control. It has nothing to do with processes in the &linux;
	      or Microsoft Windows operating systems.
	    </para>
	  </note>
	</listitem>

	<listitem>
	  <para>
	    A mechanism to define functions modeling the parallel
	    threads of control within <classname>sc_module</classname>
	    classes;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Two classes, <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent points of
	    connection to and from a <classname>sc_module</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_interface</classname> to describe the
	    software services required by a <classname>sc_port</classname>
	    or provided by a <classname>sc_export</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_prim_channel</classname> to represent the
	    channel connecting ports;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A set of derived classes, of
	    <classname>sc_prim_channel</classname>,
	    <classname>sc_interface</classname>,
	    <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent and connect common
	    channel types used in hardware design such as signals, buffers and
	    FIFOs; and
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A comprehensive set of types to represent data in both
	    <firstterm>2-state</firstterm> and <firstterm>4-state</firstterm>
	    logic.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The full specification is 441 pages long <xref
	linkend="ref_ieee_systemc" />. The &osci; reference distribution
	includes a very useful introductory user guide and tutorial <xref
	linkend="ref_osci_systemc_ug" />.
      </para>
	
      <sect2>
	<title>
	  Using Verilator to Create SystemC Cycle Accurate Models
	</title>
	
	<para>
	  Verilator <xref linkend="ref_verilator"/> is an open source tool
	  which generates cycle accurate C++ and SystemC models from
	  synthesizable Verilog &rtl;. The models follow 2-state, zero delay,
	  synthesizable semantics. There have been discussions about a future
	  extension to handle VHDL, but no work yet started on this.
	</para>

	<para>
	  The functionality is similar to commercial offerings from ARC (VTOC)
	  and Carbon Design Systems (Model Studio).
	</para>

	<para>
	  Embecosm Application Note 6 <citetitle>High Performance SoC Modeling
	  with Verilator: A Tutorial for Cycle Accurate SystemC Model Creation
	  and Optimization</citetitle> <xref linkend="ref_app_note_6"/>. A
	  &verilator; SystemC model of ORPSoC simulates at up to 130kHz on a
	  standard Linux PC.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Cycle Accurate Modeling
      </title>

      <para>
	Cycle accurate models provide an accurate description of the state of
	the model on each clock cycle. As such they represent a mid-point
	between traditional event driven simulation (providing detail within
	the clock cycle) and high level transaction models (providing details
	of bus transactions, but usually only approximate estimates of the
	cycle count).
      </para>

      <para>
	Cycle accurate models are of particular value, because they
	reflect the level of detail seen by a software engineer using a
	chip. The software engineer generally cannot see what is happening
	within clock cycles.
      </para>

      <sect2>
	<title>
	  Level of Modeling Detail
	</title>

	<para>
	  There is some variation in the level of detail shown with specific
	  modeling techniques. For example cycle accurate models generated by
	  ARC VTOC from Verilog &rtl; will show the state of every state holding
	  register in the model on each clock edge, and any asynchronous
	  signal edge. Hand-written cycle accurate models within ARM SoC
	  Designer will typically only show the state on the active edge of
	  the clock cycle, and that state will be restricted to the external
	  ports and defined internal registers.
	</para>

	<para>
	  Most cycle accurate models follow 2-state, zero delay synthesis
	  semantics. In this way they are closer to the behavior of the actual
	  chip than traditional 4-state event-driven simulation. However there
	  is no absolute reason why cycle-accurate models could not follow
	  4-state simulation semantics.
	</para>

      </sect2>

      <sect2>
	<title>
	  Tool Support
	</title>

	<para>
	  Some cycle accurate models are written by hand&mdash;for example the
	  cycle accurate models supplied by ARM for their processor
	  cores. However the great majority of cycle accurate models are
	  generated automatically from Verilog or VHDL &rtl;. There are two
	  commercial products (ARC VTOC and Carbon Design Systems <command>ModelStudio</command>)
	  and one free open source product (Verilator).
	</para>

      </sect2>

      <sect2>
	<title>
	  Modeling Language
	</title>

	<para>
	  All these tools generate models in C/C++. However &systemc; is
	  becoming increasingly popular, and is generated by all the tools as
	  well. However the reference &osci; &systemc; simulator carries a
	  serious performance penalty, and in all cases the model is a &systemc;
	  wrapper for the top level ports around a plain C/C++ model.
	</para>

	<para>
	  The performance penalty of &systemc; wrappers should be a
	  consideration when generating cycle accurate models. Performance can
	  be particularly adversely affected by any ports of wider than
	  64-bits. The reference &systemc; simulator has a very
	  low-performance implementation of such ports.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	OpenCores and the OpenRISC Project
      </title>

      <para>
	The &or1k; project forms part of the OpenCores organization (<ulink
	url="http://www.opencores.org">www.opencores.org</ulink>). Its aim is
	to create a free open source computing platform, comprising:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    An open source 32/64 bit RISC/DSP architecture;
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    A set of open source implementations of the architecture; and
	  </para>
	</listitem>
	
	<listitem>
	  <para>
	    A complete open source tool chain and operating system.
	  </para>
	</listitem>

      </itemizedlist>

      <para>
	The &or1k; project has resulted in Verilog for a 32-bit processor
	core, the &or1200; (sometimes known as <abbrev>OR1200</abbrev>) and a
	complete reference System on Chip (&soc;) design using that core,
	&orpsoc;.
      </para>

      <para>
	&or1k; is a traditional RISC load-store architecture. Optional operands
	for multiplication and division may be added and there are optional
	data and instruction caches and MMUs.
      </para>

      <para>
	A particularly useful feature is the <literal>l.nop</literal>
	opcode. This takes an optional 16-bit constant operand, which is
	placed in the low 16-bits of the instruction word. This field has no
	impact on the execution of the instruction, but may be analyzed as
	required by external test benches.
      </para>

      <sect2>
	<title>
	  The OpenRISC Reference Platform System-on-Chip (&orpsoc;)
	</title>

	<para>
	  &orpsoc; is a complete SoC based on the OpenRISC 1000. It combines
	  the processor with &sram;, flash memory and a range of peripherals
	  as shown in <xref linkend="fig_orpsoc"/>.
	</para>

	<figure id="fig_orpsoc">
	  <title>
	    The OpenRISC Reference Platform System-on-Chip (&orpsoc;).
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="orpsoc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="orpsoc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  The full design is around 150k gates + memories. It runs on standard
	  Altera and Xilinx &fpga; boards and is also available commercially
	  from Flextronics.
	</para>

      </sect2>

    </sect1>

  </chapter>

  <chapter>
    <title>
      The Target Model
    </title>

    <para>
      The demonstration system is based on a fully configured &orpsoc; with
      data and instruction caches, data and instruction &mmu;s, multiply and
      divide instructions, 2MB Flash and 2MB &sram;. &sram; and all other
      memories are implemented as generic flip-flop memory. Flash memory is
      modeled as generic &sram; initialized from a file. The architecture of
      &orpsoc; was shown earlier in <xref linkend="fig_orpsoc"/>.
    </para>

    <para>
      A cycle accurate &systemc; model of &orpsoc; is generated using
      &verilator;. The creation of this model is described in Embecosm
      Application Note 6 <xref linkend="ref_app_note_6"/>.
    </para>

    <para>
      With the exception of &jtag; (see <xref linkend="sec_jtag"/>), none of
      the peripherals is modeled&mdash;all external ports are tied off to
      appropriate values.
    </para>

    <para>
      The system clock is set at 10&nbsp;MHz (clock period 100&nbsp;ns). This
      is an arbitrary choice, but makes for easy reading of &vcd;
      traces. Modern FPGAs are capable of running &orpsoc; at around
      30&nbsp;MHz.
    </para>

    <sect1 id="sec_jtag">
      <title>
	&jtag; Interface
      </title>

      <para>
	The five JTAG ports in &orpsoc; are modelled as &systemc;
	<type>sc_in&lt;bool&gt;</type> (for <varname>jtag_tck</varname>,
	<varname>jtag_tdi</varname>, <varname>jtag_tms</varname> and
	<varname>jtag_trst</varname>) and <type>sc_in&lt;bool&gt;</type> ports
	(for <varname>jtag_tdo</varname>).
      </para>

      <para>
	Rather than drive the JTAG ports directly, requiring detailed
	management of the Test Access Port (&tap;) state machine, the &gdb;
	interface uses the Embecosm cycle accurate &systemc; &jtag; interface
	<xref linkend="ref_app_note_5"/>. This provides a &systemc; FIFO
	interface on which requests to read and write the &jtag; instruction
	and data registers can be queued, as well as requests to reset the
	&jtag; &tap; state machine.
      </para>

    </sect1>

    <sect1>
      <title>
	Embedded Software Applications
      </title>

      <para>
	The &orpsoc; model is designed to load an initial image into Flash
	memory at startup. When debugging with GDB it is more usual to used
	the debugger to load a particular image into RAM. So the initial flash
	image is just a simple program which initializes the caches, then sits
	in a tight loop. It may be found in the <filename>sw/loop</filename>
	directory and makes use of the OpenRISC 1000 utilities in
	<filename>sw/utils</filename> and the library in
	<filename>sw/support</filename>.
      </para>

      <para>
	The directory <filename>sw/test-progs</filename> contains a series of
	programs for loading into RAM by &gdb;. The programs are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    <filename>hello.c</filename>. A simple "Hello World" program.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>Building the Model</title>

      <para>
	The distribution includes a top level &make; file, which will build
	the target model and link it to the &gdb; &rsp; server
	interface. Plain <command>make</command> will build an unoptimized
	server and model. Using <command>make&nbsp;optimized</command> will
	build a model with profile-based optimization (which can increase
	performance by a fact of 3). Using
	<command>make&nbsp;VFLAGS=-trace</command> will build an unoptimized
	version of the server and model which also generates a &vcd; dump of
	the model in <filename>v-dump.vcd</filename> (and consequently runs
	many times slower).
      </para>

      <para>
	A number of additional parameters are available, which mirror the
	parameters described in Embecosm Application Note 6, <citetitle>High
	Performance SoC Modeling with Verilator: A Tutorial for Cycle Accurate
	SystemC Model Creation and Optimization</citetitle> <xref
	linkend="ref_app_note_6"/>.
      </para>

    </sect1>

  </chapter>

  <chapter>
    <title>
      The GDB Remote Serial Protocol Server
    </title>

    <sect1>
      <title>
	Overall Class and Module Structure
      </title>

      <para>
	The overall structure of the system is shown in <xref
	linkend="fig_overall_structure"/>.
      </para>

      <figure id="fig_overall_structure">
	<title>
	  Top level Structure of the GDB Server for Cycle Accurate Models.
	</title>
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="overall-structure.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="overall-structure.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The top level SystemC module is the GDB Server. This relies on the RSP
	packet interface to communicate over TCP/IP with the GDB client and
	the a model of the &or1k; Debug Unit to talk to the cycle accurate
	model. The Debug Unit in turn uses the Embecosm &jtag; interface,
	allowing it to keep its &jtag; interactions at a high level.
      </para>

      <para>
	The model side is implemented in SystemC, the RSP interface in plain
	C++.
      </para>

      <para>
	This structure is reflected in the top level class diagram, shown in
	<xref linkend="fig_overall_class_diag"/>. The SystemC classes are C++
	classes which have <classname>sc_module</classname> as a base
	class. By convention SystemC classes have the suffix
	<literal>SC</literal> and Verilator generated model classes have the
	prefix <literal>V</literal> followed by the name of the top level
	Verilog module.
      </para>

      <figure id="fig_overall_class_diag">
	<title>
	  Top level Class Diagram of the GDB Server for Cycle Accurate Models.
	</title>
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="overall-class-diag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="overall-class-diag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

    </sect1>

    <sect1>
      <title>
	The &rsp; Packet Interface, <classname>RspConnection</classname>
      </title>

      <para>
	The &rsp; packet interface is responsible for establishing the
	TCP/IP connection to and from the &gdb; server class,
	<classname>GdbServerSC</classname> and transferring &rsp; packets to
	and from the server. Packets are represented by their own class,
	<classname>RspPacket</classname>.
      </para>

      <para>
	The class diagram in
	<xref linkend="fig_rsp_class_diag"/> shows the relationship
	betweens these components.
      </para>

      <figure id="fig_rsp_class_diag">
	<title>
	  Class Diagram for the &rsp; interface.
	</title>
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="rsp-class-diag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="rsp-class-diag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The main <classname>GdbServerSC</classname> class is responsible for
	creating both the <classname>RspConnection</classname> instance and
	the <classname>RspPacket</classname> instance. In the &rsp; protocol
	there is only ever one packet active at any time, so a single instance
	suffices. It is passed by pointer to
	<classname>RspConnection</classname> for use when getting and putting
	packets on the TCP/IP connection.
      </para>

      <para>
	The &rsp; connection is written in plain C++. There is no need for
	&systemc; functionality. Indeed the use of system library routines to
	establish sockets and listen for new connections does not sit
	comfortably within the &systemc; paradigm. A <function>wait</function>
	in the system library context suspends the entire process pending
	action, whereas <function>wait</function> in the &systemc; context
	merely suspends the current thread.
      </para>

      <para>
	This does not cause any practical problem with the synchronous &gdb;
	&rsp; interface. The TCP/IP connection is only used when the target is
	suspended, so there is no need for &systemc; to be active.
      </para>

      <sect2>
	<title>
	  <classname>RspConnection</classname> class
	</title>

	<para>
	  The public interface to this class is as follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>RspConnection</function>. The constructor, provided in
	      two flavours. The first takes a single integer argument, the
	      port number to listen on. The second takes an optional string
	      argument, the name of a TCP/IP service to listen on (defaults to
	      <literal>"or1ksim-rsp"</literal>.
	    </para>

	    <para>
	      Both use the private function, <function>rspInit</function> to
	      save the port number (0 if the service name is to be used) and
	      service name and set the file descriptor for the connection
	      (private variable <varname>clientFd</varname>) to -1, indicating
	      no connection is present.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>~RspConnection</function>. The destructor, which
	      closes any connection which has been established.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>rspConnect ()</function>. This function listens for
	      client GDB connections over TCP/IP using the port or service
	      specified in the constructor. The connection is established with
	      a keep-alive flag (for long debug sessions) and with Nagel's
	      algorithm disabled. This ensures that the characters of a packet
	      are transmitted as a soon as they are available, rather than
	      being grouped for more efficient transmission. This is
	      appropriate for an interactive interface such as a debugger.
	    </para>

	    <para>
	      Once a connection is established, its file descriptor (which
	      cannot be negative) is stored in the private variable,
	      <varname>clientFd</varname>.
	    </para>

	    <para>
	      The function returns <literal>false</literal> if a catastrophic
	      failure occurs in setting up the connection. This will cause the
	      &gdb; server to terminate. A result of <literal>true</literal>
	      indicates either a successful connection, or that the connection
	      attempt may be retried. The two can be distinguished by use of
	      the <function>isConnected</function> function (see below).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>rspClose</function>. This closes the connection if it
	      is open and sets the file descriptor
	      (<varname>clientFd</varname>) to -1. It may be safely called
	      without checking if the connection is still open, since it will
	      check the value of <varname>clientFd</varname> before closing
	      it.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>isConnected</function>. This returns
	      <literal>true</literal> if a connection is established
	      (i.e. <varname>clientFd</varname> is not negative) and
	      <literal>false</literal> otherwise.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>getPkt</function>. This takes a pointer to a packet
	      and populates it with the data from the next packet read from
	      the TCP/IP stream. It will continue to retry until a packet is
	      successfully read (i.e. is complete, fits into the packet data
	      structure and has a correct checksum) or the connection
	      fails. The packet is acknowledged back to the client.
	    </para>

	    <para>
	      The &rsp; protocol requires certain characters
	      (<literal>'$'</literal>, <literal>'#'</literal> and
	      <literal>'}'</literal>) in the data field of incoming packets to
	      be escaped. However rather than inspecting every packet for
	      escaped characters, it is the raw data which is stored. This is
	      because there is only one packet type (<literal>X</literal>)
	      which can have these characters, and it is more efficient to
	      unescape the characters only in the handler for that packet.
	    </para>

	    <para>
	      The private function <function>getRspChar</function> is used to
	      read individual characters from the socket. It will
	      automatically retry in the event of an interrupt.
	    </para>

	    <para>
	      The function returns <literal>true</literal> if a packet is
	      successfully read and <literal>false</literal> if the connection
	      fails.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>putPkt</function>. This is the complement to
	      <function>getPkt</function>, sending its argument packet back to
	      the client. It will continue to retry until receipt is
	      successfully acknowledged or the connection fails.
	    </para>

	    <para>
	      Unlike <function>getPkt</function>, <function>putPkt</function>
	      escapes its data field. Characters <literal>'$'</literal>,
	      <literal>'#'</literal>, <literal>'*'</literal> and
	      <literal>'}'</literal> are escaped by preceding them with
	      <literal>'}'</literal> and then the original character xored
	      with 0x20. It makes sense to centralize escaping here, since
	      several commands may generate results using these characters.
	    </para>

	    <para>
	      The private function <function>putRspChar</function> is used to
	      write individual characters to the socket. It will automatically
	      retry in the event of an interrupt.
	    </para>

	    <para>
	      The function returns <literal>true</literal> if a packet is
	      successfully sent and <literal>false</literal> if the connection
	      fails.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  <classname>RspPacket</classname> class
	</title>

	<para>
	  The RspPacket cannot be represented as a simple string, since binary
	  packets may contain null (string terminator) characters. Instead the
	  packet is represented as a character buffer and separate length
	  field. However by convention the character buffer is also
	  null-terminated, allowing non-binary packets to be printed out for
	  debugging purposes. The public interface to this class is as
	  follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>RspPacket</function>. The constructor takes a single
	      integer argument, the size of the data buffer to allocate. It
	      allocates that buffer and stores the record of its size.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>~RspPacket</function>. The destructor deletes the
	      allocated data buffer.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <varname>data</varname>. A pointer to the data buffer.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>packStr</function>. Takes a string constant as
	      argument and packs it into the data buffer, setting the length
	      field to the length of the string.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>getBufSize</function>, <function>getLen</function> and
	      <function>setLen</function>. Accessor functions to get the size
	      of the data buffer and to get and set the length of the data
	      currently stored there.
	    </para>

	    <note>
	      <para>
		Although by convention all data is stored null-terminated in
		the buffer, this null-termination is a convenience for
		debugging the &gdb; server and does not form part of the
		data. The length does not include this null-termination
		character.
	      </para>
	    </note>
	  </listitem>

	</itemizedlist>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Modeling the &or1k; Debug Unit
      </title>

      <para>
	The &or1k; Debug Unit model provides a higher level abstraction of the
	debug inteface to the &or1k;, and sits above the &jtag;
	interface. It allows access to main memory and special purpose
	registers (&spr;s) together with control of the &cpu; reset and stall
	lines. These are all mapped onto lower level &jtag; register accesses
	using the Embecosm cycle accurate &systemc; &jtag; interface.
      </para>

      <para>
	The Debug Unit model also offers higher level cacheing functions. The
	&jtag; clock typically has a period ten times greater than the main
	system clock. Combined with the serial nature of &jtag; this means
	that accessing a single register or memory location can take many
	hundreds of system clock cycles.
      </para>

      <para>
	While the processor is stalled, registers and memories do not change,
	so cacheing is possible and can greatly increase performance. This is
	provided through the <classname>SprCache</classname> and
	<classname>MemCache</classname> classes.
      </para>

      <para>
	The class diagram in
	<xref linkend="fig_debug_class_diag"/> shows the relationship
	betweens these components.
      </para>

      <figure id="fig_debug_class_diag">
	<title>
	  Class Diagram for the Debug Unit model
	</title>
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="debug-class-diag.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="debug-class-diag.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The main <classname>GdbServerSC</classname> class is responsible for
	creating the <classname>DebugUnitSC</classname> instance, passing in the
	&systemc; &fifo; used to connect to the &systemc; &jtag;
	interface. The Debug Unit in turn instantiates the
	<classname>SprCache</classname> and <classname>MemCache</classname>
	instances.
      </para>

      <note>
	<para>
	  There are at least two different variants of the &or1k; Debug
	  Unit. This application note describes the version used within the
	  OpenRisc Reference Platform System-on-Chip (&orpsoc;). An
	  alternative implementation by Igor Mohor is simpler and more
	  recent. Where the two need to be distinguished, they will be
	  referred to as the &orpsoc; Debug Unit and Mohor Debug Unit
	  respectively. Where not thus qualified, the &orpsoc; Debug Unit is
	  the implementation being referred to.
	</para>
      </note>

      <sect2>
	<title>
	  How &jtag; is used by the &or1k; Debug Unit
	</title>

	<para>
	  The &or1k; debug unit uses a 4-bit &jtag; instruction register. It
	  adds two additional instructions, <literal>CHAIN_SELECT</literal>
	  (binary 0011) and <literal>DEBUG</literal> (binary 1000).
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      When instruction <literal>CHAIN_SELECT</literal> is used, the
	      subsequent value shifted into the &jtag; data register indicates
	      the debug chain (see <xref linkend="sec_debug_chain"/>) that
	      will be used for subsequent debug operations.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      When instruction <literal>DEBUG</literal> is used,
	      subsequent values shifted into the &jtag; data register are
	      interpreted as instructions for the debug chain seleted by the
	      most recent <literal>CHAIN_SELECT</literal> instruction. 4 bits
	      are used to specify the debug chain.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  All data registers have a cyclic redundancy check (&crc;) field as
	  their final (most significant) 8-bits, calculated on the remaining
	  bits. The &crc; used is the 8-bit ATM Header Error Correction <xref
	  linkend="ref_atm_spec"/>, using the irreducible polynomial
	  x<superscript>8</superscript> + x<superscript>2</superscript> + x +
	  1. This is capable of detecting all single and double bit errors in
	  the data register and single burst errors of up to 8 bits.
	</para>

	<para>
	  So the usual sequence of operations is as follows:
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      Shift instruction register <literal>CHAIN_SELECT</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Shift data register with the desired debug chain (4 bits) +
	      &crc; (8 bits).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Shift instruction register <literal>DEBUG</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Shift the instructions appropriate to the selected debug chain
	      in to the data register. The number of bits depends on the
	      chosen debug chain (see <xref linkend="sec_debug_chain"/>).
	    </para>
	  </listitem>

	</orderedlist>

	<sect3 id="sec_debug_chain">
	  <title>
	    &jtag; Debug Chains
	  </title>

	  <para>
	    The debug chain is a 4-bit field. The &or1k; Debug Unit defines 6
	    scan chains:
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<literal>GLOBAL_BS</literal> (binary 0000). The default
		debug chain, selected on reset, with no functionality.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>RISC_DEBUG</literal> (binary 0001). The data
		register is used to read and write Special Purpose Registers
		(&spr;s). It is described in more detail in <xref
		linkend="sec_risc_debug_chain"/>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>RISC_TEST</literal> (binary 0010). This debug
		chain is specified, but not used. It has no functionality if
		selected.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>TRACE_TEST</literal> (binary 0011). This is a
		optionally available for the Debug Unit (under control of a
		Verilog <literal>`define</literal>), offering hardware trace
		functionality. It is not described further in this application
		note.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>REGISTER</literal> (binary 0100). The data register
		is used to access and set the &cpu;'s control registers. It is
		described in more detail in <xref
		linkend="sec_register_chain"/>.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>WISHBONE</literal> (binary 0101). The data
		register is used to read and write main memory attached to the
		Wishbone bus. It is described in more detail in <xref
		linkend="sec_wishbone_chain"/>.
	      </para>
	    </listitem>

	  </itemizedlist>
	</sect3>

	<sect3 id="sec_risc_debug_chain">
	  <title>
	    The <literal>RISC_DEBUG</literal> Debug Chain
	  </title>

	  <para>
	    The <literal>RISC_DEBUG</literal> chain uses a 73-bit data
	    register as shown in <xref linkend="fig_risc_debug_chain"/>.
	  </para>

	  <figure id="fig_risc_debug_chain">
	    <title>
	      <literal>RISC_DEBUG</literal> &jtag; data register format
	    </title>
	    
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="risc-debug-chain.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="risc-debug-chain.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The first 32 bits (SPR) specify the &spr; to be accessed. Bit 32
	    (W) is set if the value is to be written. Bits 33-64 (Data) form
	    the value to be written (if W is set) or the value read when the
	    result is shifted out. The final 8 bits (65-72) are the &crc;.
	  </para>

	  <para>
	    The &cpu; logic is fast enough that the data field can be set during
	    a single &jtag; capture-shift-update operation.
	  </para>

	</sect3>

	<sect3 id="sec_register_chain">
	  <title>
	    The <literal>REGISTER</literal> Debug Chain
	  </title>

	  <para>
	    The <literal>REGISTER</literal> chain uses a 46-bit data
	    register as shown in <xref linkend="fig_register_chain"/>.
	  </para>

	  <figure id="fig_register_chain">
	    <title>
	      <literal>REGISTER</literal> &jtag; data register format
	    </title>
	    
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="register-chain.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="register-chain.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The first 5 bits (Reg) specify the &cpu; control register to be
	    accessed. Bit 5 (W) is set if the value is to be written. Bits
	    6-37 (Data) form the value to be written (if W is set) or the
	    value read when the result is shifted out. The final 8 bits
	    (38-45) are the &crc;.
	  </para>

	  <para>
	    The &cpu; logic is fast enough that the data field can be set during
	    a single &jtag; capture-shift-update operation.
	  </para>

	  <para>
	    The &or1k; Debug Unit defines 6 &cpu; control registers:
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		<literal>MODER</literal>  (binary 00000),
		<literal>TSEL</literal>   (binary 00001),
		<literal>QSEL</literal>   (binary 00010),
		<literal>SSEL</literal>   (binary 00011) and
		<literal>RECSEL</literal> (binary 10000). These registers
		control hardware trace, if that functionality is
		implemented. They are not described further here.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		<literal>RISCOP</literal> (binary 00100). The bits in this
		register control the &cpu;. Bit 0 is the reset bit. If written
		to 1, the &cpu; will be reset. Bit 1 is the stall bit. The value
		read indicated whether the &cpu; is stalled. The &cpu; can be
		stalled by writing 1 to this bit and unstalled by reading 0
		from this bit.
	      </para>

	      <caution>
		<para>
		  Remember that accessing a  &jtag; register takes hundreds of
		  system clock cycles. It is quite possible to unstall the
		  processor and for the processor to have stalled again
		  (perhaps due to hardware single step, or an adjacent
		  breakpoint) before the register is next read. This can cause
		  confusion, with "unstalling" appearing to have no effect. A
		  &vcd; trace always clarifies what is happening.
		</para>
	      </caution>
	    </listitem>

	  </itemizedlist>

	  <note>
	    <para>
	      The Mohor Debug Unit has no support for trace and the value of
	      the Reg field is ignored. All accesses are for the
	      <literal>RISCOP</literal> register.
	    </para>
	  </note>
		
	</sect3>

	<sect3 id="sec_wishbone_chain">
	  <title>
	    The <literal>WISHBONE</literal> Debug Chain
	  </title>

	  <para>
	    The <literal>WISHBONE</literal> chain uses a 73-bit data
	    register as shown in <xref linkend="fig_wishbone_chain"/>.
	  </para>

	  <figure id="fig_wishbone_chain">
	    <title>
	      <literal>WISHBONE</literal> &jtag; data register format
	    </title>
	    
	    <mediaobject>
	      <imageobject>
		<imagedata fileref="wishbone-chain.svg"
			   format="SVG"
			   width="14cm"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	      <imageobject>
		<imagedata fileref="wishbone-chain.png"
			   format="PNG"
			   width="80%"
			   scalefit="1"
			   align="center" />
	      </imageobject>
	    </mediaobject>
	  </figure>

	  <para>
	    The first 32 bits (Address) specify the memory address to be
	    accessed. Bit 32 (W) is set if the value is to be written. Bits
	    33-64 (Data) form the value to be written (if W is set) or the
	    value read when the result is shifted out. The final 8 bits
	    (65-72) are the &crc;.
	  </para>

	  <para>
	    The Wishbone memory interface, particularly with slow memory, may
	    not be able to set the data field can be set during a single
	    &jtag; capture-shift-update operation. This can be solved either
	    by using the <literal>PAUSE-DR</literal> state of the &jtag; &tap;
	    state machine, or by performing two reads, one immediately after
	    the other.
	  </para>

	</sect3>

      </sect2>

      <sect2>
	<title>
	  <classname>DebugUnitSC</classname> class
	</title>

	<para>
	  This class is a &systemc; module (i.e. it has
	  <classname>sc_module</classname> as a base class).
	</para>

	<para>
	  The Debug Unit functions work by queueing instances of
	  <classname>TapAction</classname> sub-classes on a queue (&fifo;)
	  connected to the &jtag; interface (class
	  <classname>JtagSC</classname>). This allows the debug unit to read
	  and write the various &jtag; registers. In each case the debug unit
	  waits (using the &systemc; <function>wait</function> function) for
	  notification that the action is complete before proceeding. The full
	  interface is described in Embecosm Application Note 5
	  <citetitle>Using JTAG with SystemC: Implementation of a Cycle
	  Accurate Interface</citetitle> <xref linkend="ref_app_note_5"/>.
	</para>

	<para>
	  The Debug Unit caches the current value of the debug chain. This
	  means it can avoid selecting the chain for a debug action, where it
	  is unchanged from the previous action.
	</para>

	<para>
	  The public interface to <literal>DebugUnitSC</literal> is as
	  follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>DebugUnitSC</function>. Constructor, which takes as
	      argument a pointer to the &tap; action queue of the target
	      processor's &jtag; interface.
	    </para>

	    <para>
	      The constructor instantiates the &spr; and memory caches and
	      marks the current stall state of the target as unknown and the
	      current debug chain as undefined.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>~DebugUnitSC</function>. The destructor, which deletes
	      the &spr; and memory caches.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>resetDebugUnit</function>. This function is called to
	      reset the &jtag; interface (rather than the &cpu;). It achieves
	      this by queueing a <classname>TapActionReset</classname>
	      instance on the &jtag; queue.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>reset</function>. This function resets the CPU. This is
	      achieved by selecting the <literal>REGISTER</literal> debug
	      chain and writing bit 1 of the <literal>RISCOP</literal> CPU
	      control register.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>stall</function> and <function>unstall</function>. These
	      stall and unstall the processor by selecting the
	      <literal>REGISTER</literal> debug chain and respectively setting
	      and clearing bit 0 of the <literal>RISCOP</literal> CPU control
	      register. As a matter of good practice the current value of the
	      register is read, the relevant bit changed and the value written
	      back. This ensures any other bits are unchanged.
	    </para>

	    <para>
	      In practice the only other bit that has any effect in the
	      current implementation is bit-1 (the reset bit), which should
	      always be clear in this circumstance. However using this
	      approach ensures robustness of the code in the event of new
	      control bits being added in future debug units. If performance
	      was particularly critical, this function could be optimized by
	      not reading the current value of the register.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>isStalled</function>. Return <literal>true</literal> if
	      the processor is currently stalled and <literal>false</literal>
	      otherwise.
	    </para>

	    <para>
	      The Debug Unit maintains a private enumeration variable
	      (<varname>stallState</varname>) tracking the stall state of the
	      processor. It is set to <literal>STALLED</literal> whenever the
	      processor is explicitly stalled (by using the
	      <function>stall</function> function) or is discovered to be
	      stalled. It is set to <literal>UNKNOWN</literal> whenever the
	      processor is explicitly unstalled, or found to be unstalled.
	    </para>

	    <note>
	      <para>
		A processor which is running (i.e. UNSTALLED) can at any time
		stall, for example due to hitting a breakpoint. Hence the only
		two useful values are <literal>STALLED</literal> and
		<literal>UNKNOWN</literal>.
	      </para>
	    </note>

	    <para>
	      If the <varname>StallState</varname> shows the processor is
	      currently stalled, the function immediately returns
	      TRUE. Otherwise it selects the <literal>REGISTER</literal> debug
	      chain and reads bit 0 of the <literal>RISCOP</literal> CPU
	      control register. It then sets <varname>StallState</varname> to
	      <literal>STALLED</literal> if the bit is set and
	      <literal>UNKNOWN</literal> if it is clear and returns
	      <literal>true</literal> if the state is stalled and
	      <literal>false</literal> otherwise.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>readSpr</function> and
	      <function>writeSpr</function>. These functions respectively read
	      and write a &spr; by selecting the <literal>RISC_DEBUG</literal>
	      debug chain and shifting a data register with the SPR, W and
	      Data fields set appropriately.
	    </para>

	    <para>
	      This access can be optimized by use of the &spr; cache. This is
	      described in <xref linkend="chap_optimization"/>.
	    </para>

	    <para>
	      Almost all &spr;s are readable. However the Next Program Counter
	      (&npc;) &spr; has some unexpected behavior due to the operation
	      of the processor pipeline, which must be managed. This is
	      described in <xref linkend="sec_npc"/>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>andSpr</function> and <function>orSpr</function>. Most
	      &spr; accesses involve reading a &spr; using AND and OR
	      operations to clear or set a bit and then writing the value
	      back. These functions are provided as a convenience for such
	      operations. They just call the main <function>readSpr</function>
	      and <function>writeSpr</function> functions.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>readMem32</function> and
	      <function>writeMem32</function>. These functions respectively
	      read and write a 32-bit value from memory attached to the
	      Wishbone bus of the &or1k;. The <literal>WISHBONE</literal>
	      debug chain is selected, and the value read or written by
	      shifting a data register with the Address, W and Data fields set
	      appropriately.
	    </para>

	    <para>
	      In the case of <function>readMem32</function> the memory access
	      is usually not fast enough to populate the data out field in
	      time. The solution is either to use the &jtag;
	      <literal>PAUSE-DR</literal> state after bit 32 has been shifted,
	      or to perform the read twice. The Embecosm Cycle Accurate
	      &systemc; &jtag; interface currently has no support for
	      mid-transfer use of <literal>PAUSE-DR</literal>, so in this
	      implementation reads are performed twice.
	    </para>

	    <note>
	      <para>
		The &gdb; client will work with target endianess for any data
		it accesses, so there is no need to make any transformation of
		data being transferred.
	      </para>
	    </note>

	    <caution>
	      <para>
		Using &gdb; to read or write memory mapped device registers
		can be unreliable, particularly if reading has side effects
		(due to reads being performed twice). It is best avoided.
	      </para>
	    </caution>
	      
	  </listitem>

	  <listitem>
	    <para>
	      <function>readMem8</function> and
	      <function>writeMem8</function>. These functions respectively
	      read and write a single byte from memory attached to the
	      Wishbone bus of the &or1k;.
	    </para>

	    <para>
	      Since the Debug Unit only provides for 32-bit read and write,
	      the operation is achieved by using 32-bit access (using
	      <function>readMem32</function> and
	      <function>writeMem32</function>) and selecting the relevant
	      byte. In the case of writing this requires reading the original
	      32-bit value, patching the relevant byte and writing back the
	      32-bit value.
	    </para>

	    <para>
	      Since the byte access will used host arithmetic, the value read
	      must be converted from model endianess and any value written
	      must be converted back to model endianess. The
	      <classname>Utils</classname> class provides suitable static
	      functions to do this in <function>Utils::mtohl</function> and
	      <function>Utils::htoml</function>.
	    </para>

	    <note>
	      <para>
		Endianess is a compile time constant of the &gdb;
		server. Either <literal>TARGET_BIG_ENDIAN</literal> or
		<literal>TARGET_LITTLE_ENDIAN</literal> must be defined in the
		C++ compilation flags (<literal>CXXFLAGS</literal>) when
		compiling <filename>sysc-modules/Utils.cpp</filename>.
	      </para>

	      <para>
		This is conveniently set in the <filename>Makefile</filename>
		for that directory
		(<filename>sysc-modules/Makefile</filename>). The distribution
		has <literal>TARGET_BIG_ENDIAN</literal> set, since this
		corresponds to the default setting in the &or1k; Verilog
		source.
	      </para>
	    </note>

	    <caution>
	      <para>
		With the need for multiple accesses to 32-bit values for both
		read and write, using these functions to access memory mapped
		device registers is best avoided, particularly where registers
		(or any neighbouring registers) have side-effects.
	      </para>
	    </caution>
	  </listitem>

	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  <classname>SprCache</classname> class
	</title>

	<para>
	  The &or1k; provides for up to 2<superscript>16</superscript> Special
	  Purpose Registers (&spr;s). These are frequently accessed to
	  implement debugging commands, yet do not change when the &cpu; is
	  stalled (but see the issue concerning the Next Program counter in
	  <xref linkend="sec_npc"/>).
	</para>

	<para>
	  It makes sense to cache all the &spr;s.
	  <classname>SprCache</classname> represents the cache as a pair of
	  private C++ arrays, each with 2<superscript>16</superscript>
	  elements. The <type>bool</type> <varname>sprIsvalid</varname>
	  indicates whether than entry is valid and
	  <varname>sprValue</varname> holds the corresponding cached
	  value. Clearing the cache is a matter of setting all entries in
	  <literal>sprIsValid</literal> to <literal>false</literal> using
	  <function>memset</function>.
	</para>

	<para>
	  In practice only a handful of &spr;s are ever used repeatedly. An
	  alternative would be to use a small open hash table, trading the
	  increased computational cost of access for the reduced cost of
	  clearing the array. Comparing relatively performance of this
	  alternative approach is left as an exercise for the reader.
	</para>

	<para>
	  The use of <classname>SprCache</classname> within the Debug Unit is
	  discussed in the chapter on optimization (<xref
	  linkend="chap_optimization"/>).
	</para>

	<para>
	  The public interface to <literal>SprCache</literal> is as
	  follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>SprCache</function>. Constructor. Calls
	      <function>clear</function> to reset the cache.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>clear</function>. Clears the cache by using
	      <function>memset</function> to set all entries in
	      <varname>sprIsValid</varname> to <literal>false</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>write</function>. Writes a value for a &spr; into the
	      cache.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>read</function>. Returns <literal>true</literal> if a
	      &spr; is in the cache. The cached value is returned by reference
	      through the second argument.
	    </para>
	  </listitem>
	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  <classname>MemCache</classname> class
	</title>

	<para>
	  It also make sense to cache memory accesses when the &cpu; is
	  stalled. The same locations are repeatedly accessed as the stack is
	  analysed.
	</para>

	<para>
	  It is not generally feasible (nor efficient) to cache all of memory
	  as was done for &spr;s. Instead a small hash table is used. In this
	  case the hash table is represented by three private arrays, each of
	  the same size (specified in the constructor and dynamically
	  allocated). <varname>tabIsValid</varname> is a boolean array
	  indicating if the corresponding hash table slot is in
	  used. <varname>tabKeyAddr</varname> holds the memory address being
	  used to key a particular hash table
	  slot. <varname>tabValue</varname> holds the associated cached
	  value. The hash table can be cleared by using
	  <function>memset</function> to set all the elements of
	  <varname>tabIsValid</varname> to <literal>false</literal>.
	</para>

	<para>
	  The hashing function is a simple modulo of the size of the table. It
	  thus makes sense to choose a prime number as the size (the default
	  if not specified in the constructor is 1009).
	</para>

	<para>
	  The hash table provides for no retry function if a lookup
	  clashes. The new key address replaces any existing entry. In
	  practice clashes are very unlikely, so this makes lookup efficient.
	</para>

	<para>
	  The use of <classname>MemCache</classname> within the Debug Unit is
	  discussed in the chapter on optimization (<xref
	  linkend="chap_optimization"/>).
	</para>

	<para>
	  The public interface to <literal>MemCache</literal> is as
	  follows:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <function>MemCache</function>. Constructor, which takes the size
	      of the hash table as an optional argument. The default if no
	      size is specified is 1009. The hash table arrays
	      (<varname>tabIsValid</varname>, <varname>tabKeyAddr</varname>
	      and <varname>tabValue</varname>) are allocated. The table is
	      cleared by calling <function>clear</function>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>~MemCache</function>. The destructor, which frees the
	      hash table arrays.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>clear</function>. Clears the hash table by using
	      <function>memset</function> to set all elements of
	      <varname>tabIsValid</varname> to <literal>false</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>write</function>. Writes a hash table entry for a
	      specified address and value. Any existing entry at that location
	      is overwritten.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <function>read</function>.  Returns <literal>true</literal> if a
	      the given memory address is in the cache. The cached value is
	      returned by reference through the second argument.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Overall &gdb; Server Behavior
      </title>

      <para>
      </para>

    </sect1>

    <sect1>
      <title>
	Foibles of Real Hardware
      </title>

      <para>
	Real hardware always has small issues which deviate from the standard
	documentation. Sometimes these are bugs, but on other occasions they
	represent subtleties of behavior which have not been fully
	documented. Any model generated automatically from Verilog &rtl; will
	always faithfully model these small details. The &or1k; is no
	exception and the RTL includes examples of both classes of minor
	deviation from the documentation.
      </para>

      <para>
	Any debug interface must take account of such variations, in order to
	ensure consistent behavior.
      </para>

      <sect2 id="sec_npc">
	<title>
	  Setting the Next Program Counter &spr;
	</title>

	<para>
	  The &or1k; instruction set architecture specifies two &spr;s
	  describing the program counter. The Previous Program Counter (&ppc;)
	  represents the address of the instruction just completed. The Next
	  Program Counter (&npc;) represents the address of the instruction
	  about to be executed.
	</para>

	<para>
	  However the &or1k; is a pipelined processor with a 4/5 stage
	  pipeline, so at any one time up to 4 instructions can be at some
	  stage of execution. The pipeline stages are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      Instruction Fetch
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Instruction Decode
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Execute
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Memory access (only for load/store instructions). Will stall the
	      pipeline while the memory is accessed.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Write Back
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  The &ppc; represents the address of the instruction that has just
	  completed the write back stage of the pipeline. The &npc; represents
	  the address of the instruction which is the next to reach the write
	  back stage of the pipeline (which may be at an earlier phase than
	  write back, if the pipeline is not currently full).
	</para>

	<para>
	  The problem comes if the &npc; is written while the processor is
	  stalled. This must cause a flush of the pipeline, so until the
	  processor is unstalled there is no instruction anywhere in the
	  pipeline waiting to be executed. Thus a subsequent read of the &npc;
	  will return zero, <emphasis>not</emphasis> the value just written.
	</para>

	<para>
	  This is not generally what is wanted by a debugger. &gdb; will
	  regularly write the &npc; to a new value, but expects that
	  subsequent reads will return the value just written. It is therefore
	  essential that notwithstanding any other arrangements the
	  &npc; must be cached while the processor is stalled.
	</para>

	<para>
	  &gdb; from time to time may write the &npc; to its current
	  value. The intention is that this should have no effect, yet if the
	  &npc; &spr; is written the pipeline will be flushed. This can be
	  particularly catastrophic if the flush causes a delayed branch to be
	  lost.
	</para>

	<para>
	  Thus the interface must ensure that if the &npc; is not changed it
	  is not physically written.
	</para>

      </sect2>

      <sect2>
	<title>
	  JTAG register bit width
	</title>

	<para>
	</para>

      </sect2>

      <sect2>
	<title>
	  Hardware Single Step
	</title>

	<para>
	</para>

      </sect2>

    </sect1>

  </chapter>

  <chapter id="chap_optimization">
    <title>
      Optimizing the &gdb; Server
    </title>

    <sect1>
      <title>
	Assessing Performance
      </title>

      <para>
      </para>

    </sect1>
    
  </chapter>

  <chapter>
    <title>
      Summary
    </title>

    <para>
      This application note has shown how to build and optimize a &gdb; &rsp;
      interface to a cycle accurate model of a complete &soc; in
      &systemc;. The steps can be summarized as:
    </para>

    <orderedlist>
      <listitem>
	<para>
	</para>
      </listitem>

    </orderedlist>

    <para>
      The result is a &gdb; interface to a cycle accurate &systemc; model of a
      complete &soc;, with a performance which makes low-level firmware
      development a quite feasible activity.
    </para>

    <para>
      Suggestions for corrections or improvements are welcomed. Please contact
      the author at <ulink
      url="mailto:jeremy.bennett@embecosm.com"><literal>jeremy.bennett@embecosm.com</literal></ulink>.
    </para>

  </chapter>

  <glossary id="sec_glossary">
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>2-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>elaboration</glossterm>
      <glossdef>
	<para>
	  In an event driven simulator, the analysis of source Verilog to
	  create an executable which will subsequently perform the simulation.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Joint Test Action Group</glossterm>
      <acronym>JTAG</acronym>
      <glossdef>
	<para>
	  &jtag; is the usual name used for the IEEE 1149.1 standard entitled
	  <emphasis>Standard Test Access Port and Boundary-Scan
	  Architecture</emphasis> for test access ports used for testing
	  printed circuit boards and chips using boundary scan.
	</para>

	<para>
	  This standard allows external reading of state within the board or
	  chip. It is thus a natural mechanism for debuggers to connect to
	  embedded systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>linting</glossterm>
      <glossdef>
	<para>
	  A <emphasis>linting</emphasis> compiler (or feature of a compiler)
	  provides extra analysis of the source language to identify
	  potentially dangerous constructs. The problems identified by such
	  tools typically go beyond what the source language standard
	  requires, to identify good practice in the use of the source
	  language.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>
	<indexterm>
	  <primary>endianism</primary>
	</indexterm>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Open &systemc; Initiative</glossterm>
      <acronym>OSCI</acronym>
      <glossdef>
	<para>
	  The industry standardization body for &systemc;
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>&systemc;</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open &systemc; Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_atm_spec">
      <title>
	ATM User-Network Interface Specification,
      </title>
      <publishername>ATM Forum</publishername>,
      <pubdate>1993</pubdate>.
    </bibliomixed>

    <bibliomixed id="ref_mills_cummings_99">
      <firstname>Don</firstname> <surname>Mills</surname> and
      <firstname>Clifford</firstname> E <surname>Cummings</surname>
      <title>
	&rtl; Coding Styles That Yield Simulation and Synthesis Mismatches
      </title>
      <bibliomset relation="journal">
	<title>
	  SNUG 1999
	</title>
	<pubdate>1999</pubdate>.
	<bibliosource class="uri">
	  <ulink
	      url="http://www.sunburst-design.com/papers/">www.sunburst-design.com/papers</ulink>.
	</bibliosource>
      </bibliomset>
    </bibliomixed>

    <bibliomixed id="ref_cummings_99">
      <firstname>Clifford</firstname> E <surname>Cummings</surname>
      <title>
	"full_case parallel_case", the Evil Twins of Verilog Synthesis.
      </title>
      <bibliomset relation="journal">
	<title>
	  SNUG 1999
	</title>
	<pubdate>1999</pubdate>.
	<bibliosource class="uri">
	  <ulink
	      url="http://www.sunburst-design.com/papers/">www.sunburst-design.com/papers</ulink>.
	</bibliosource>
      </bibliomset>
    </bibliomixed>

    <bibliomixed id="ref_cummings_00">
      <firstname>Clifford</firstname> E <surname>Cummings</surname>
      <title>
	Nonblocking Assignments in Verilog Synthesis, Coding Styles That Kill!
      </title>
      <bibliomset relation="journal">
	<title>
	  SNUG 2000
	</title>
	<pubdate>2000</pubdate>.
	<bibliosource class="uri">
	  <ulink
	      url="http://www.sunburst-design.com/papers/">www.sunburst-design.com/papers</ulink>.
	</bibliosource>
      </bibliomset>
    </bibliomixed>

    <bibliomixed id="ref_dhrystone">
      <surname>Weicker</surname>, <firstname>Reinhold</firstname>.
      <title>
	Dhrystone: A Synthetic Systems Programming Benchmark.
      </title>
      <bibliomset relation="journal">
	<title>
	  Communications of the ACM,
	</title>
	<volumenum>27</volumenum>, <issuenum>10</issuenum>,
	<pubdate>October 1984</pubdate>, <pagenums>1013-1030</pagenums>.
      </bibliomset>
    </bibliomixed>

    <bibliomixed id="ref_doxygen">
      <title>
	Doxygen: Source code documentation generator tool,
      </title>
      <firstname>Dimitri</firstname> <surname>van Heesch</surname>,
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink url="http://www.doxygen.org">www.doxygen.org</ulink>
      </bibliosource>
      <indexterm>
	<primary>Doxygen</primary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_2">
      <title>
	&embecosm; Application Note 2. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide. Issue 3.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	November 2008.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>tool chain</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_3">
      <title>
	&embecosm; Application Note 3. Howto: Porting the GNU Debugger:
	Practical Experience with the OpenRISC 1000 Architecture. Issue 2.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	November 2008.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>cycle accurate modeling</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_4">
      <title>
	&embecosm; Application Note 4. Howto: GDB Remote Serial Protocol:
	Writing a RSP Server. Issue 2.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	November 2008.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>cycle accurate modeling</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_5">
      <title>
	&embecosm; Application Note 5. Using JTAG with SystemC: Implementation
	of a Cycle Accurate Interface. Issue 1.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	January 2009.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>cycle accurate modeling</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_app_note_6">
      <title>
	&embecosm; Application Note 6. High Performance SoC Modeling with
	&verilator;: A Tutorial for Cycle Accurate &systemc; Model Creation
	and Optimization. Issue 1.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	February 2009.
      </pubdate>
      <indexterm>
	<primary>&or1k;</primary>
	<secondary>cycle accurate modeling</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_esp4">
      <title>
	&embecosm; Software Package 4. Cycle Accurate &systemc; &jtag;
	Interface: Reference Implementation.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	January 2009.
      </pubdate>
      Available for free download from the &embecosm; website at
      <bibliosource class="uri">
	<ulink url="http://www.embecosm.com">www.embecosm.com</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_gcc_ug">
      <title>
	Using the GNU Compiler Collection (&gcc;)
      </title>
      <firstname>Richard</firstname> <surname>Stallman</surname> and the &gcc;
      Developer Community.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink url="http://gcc.gnu.org/onlinedocs/gcc/"/>
      </bibliosource>
      <indexterm>
	<primary>&gcc;</primary>
	<secondary>User Guide</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_gdb_ug">
      <title>
	Debugging with &gdb;: The &gnu; Source-Level Debugger,
      </title>
      <firstname>Richard</firstname> <surname>Stallman</surname>,
      <firstname>Roland</firstname> <surname>Pesch</surname>,
      <firstname>Stan</firstname> <surname>Shebbs</surname>, et al,
      issue <issuenum>9</issuenum>.
      <publisher>
	<publishername>
	  Free Software Foundation
	</publishername>
      </publisher>
      <pubdate>
	2008
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdb_toc.html"/>
      </bibliosource>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>User Guide</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_gdb_int">
      <title id="ref_gdb_int_xr">
	&gdb; Internals: A guide to the internals of the &gnu; debugger,
      </title>
      <firstname>John</firstname> <surname>Gillmore</surname> and
      <firstname>Stan</firstname> <surname>Shebbs</surname>,
      issue <issuenum>2</issuenum>.
      <publisher>
	<publishername>
	  Cygnus Solutions
	</publishername>
      </publisher>
      <pubdate>
	2006
      </pubdate>.
      <bibliosource class="uri">
	<ulink
	    url="http://sourceware.org/gdb/current/onlinedocs/gdbint_toc.html"/>
      </bibliosource>
      <indexterm>
	<primary>&gdb;</primary>
	<secondary>Internals document</secondary>
      </indexterm>
    </bibliomixed>

    <bibliomixed id="ref_gtkwave">
      <title>
	&gtkwave; 3.1 Wave Analyzer User's Guide.
      </title>
      <pubdate>
	February 2008.
      </pubdate>
      <bibliosource class="uri">
	<ulink url="http://gtkwave.sourceforge.net/">gtkwave.sourceforge.net/</ulink>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_icarus_verilog">
      <title>
	&icarus; 0.9
      </title>
      <firstname>Steve</firstname> <surname>Williams</surname>,
      <pubdate>
	January 2009.
      </pubdate>
      <bibliosource class="uri">
	<ulink
	url="http://www.icarus.com/eda/verilog/">www.icarus.com/eda/verilog</ulink>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_ieee_jtag">
      <title>
	IEEE standard test access port and boundary-scan architecture
      </title>
      <publisher>
	<publishername>
	  IEEE Computer Society
	</publishername>
      </publisher>
      <pubdate>
	2001 (reaffirmed 2008)
      </pubdate>.
      <biblioid class="pubnumber">
	IEEE Std 1149.1&trade;-2001
      </biblioid>.
    </bibliomixed>

    <bibliomixed id="ref_ti_jtag">
      <title>
	IEEE Std 1149.1 (&jtag;) Testability:
      </title>
      <subtitle>
	Primer.
      </subtitle>
      <publisher>
	<publishername>
	  Texas Instruments Semiconductor Group
	</publishername>
      </publisher>
      <pubdate>
	1997.
      </pubdate>
      Available for free download from the Texas Instruments website at
      <bibliosource class="uri">
	<ulink url="http://focus.ti.com/lit/an/ssya002d/ssya002d.pdf">focus.ti.com/lit/an/ssya002d/ssya002d.pdf</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_ieee_systemc">
      <title>
	IEEE Standard &systemc;&reg; Language:
      </title>
      <subtitle>
	Reference Manual.
      </subtitle>
      <publisher>
	<publishername>
	  IEEE Computer Society
	</publishername>
      </publisher>
      <pubdate>
	2005
      </pubdate>.
      <biblioid class="pubnumber">
	IEEE Std 1666&trade;-2005.
      </biblioid>
      Available for free download from
      <bibliosource class="uri">
	<ulink
	    url="http://standards.ieee.org/getieee/1666/index.html">standards.ieee.org/getieee/1666/index.html</ulink>
      </bibliosource>.
    </bibliomixed>

    <bibliomixed id="ref_orpsoc">
      <title>
	The OpenRISC Reference Platform System-on-Chip
      </title>
      <bibliosource class="uri">
	Available for download from <ulink
	url="http://www.opencores.org">www.opencores.org</ulink>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_osci_systemc_ug">
      <title>
	&systemc; Version 2.0 User Guide.
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative,
	</publishername>
      </publisher>
      <pubdate>
	2002.
      </pubdate>
      <bibliosource class="uri">
	Available for download from <ulink
	url="http://www.systemc.org">www.systemc.org</ulink>
      </bibliosource>
    </bibliomixed>

    <bibliomixed id="ref_verilator">
      <title>
	&verilator; 3.700.
      </title>
      <firstname>Wilson</firstname> <surname>Snyder</surname>,
      <pubdate>
	January 2009.
      </pubdate>
      <bibliosource class="uri">
	<ulink
	url="http://www.veripool.org/wiki/verilator">www.veripool.org/wiki/verilator</ulink>
      </bibliosource>
    </bibliomixed>

  </bibliography>

</book>
