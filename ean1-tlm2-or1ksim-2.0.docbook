<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" 
               "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!-- =========================================================================
Useful entities
========================================================================== -->

<!-- ========== Acronyms and abbreviations ========== -->

<!ENTITY api "<acronym>API</acronym>">
<!ENTITY fifo "<acronym>FIFO</acronym>">
<!ENTITY hdl "<acronym>HDL</acronym>">
<!ENTITY ieee "<acronym>IEEE</acronym>">
<!ENTITY iss "<acronym>ISS</acronym>">
<!ENTITY jtag "<acronym>JTAG</acronym>">
<!ENTITY mmu "<acronym>MMU</acronym>">
<!ENTITY osci "<acronym>OSCI</acronym>">
<!ENTITY posix "<acronym>POSIX</acronym>">
<!ENTITY soc "<acronym>SoC</acronym>">
<!ENTITY spr "<acronym>SPR</acronym>">
<!ENTITY tap "<acronym>TAP</acronym>">
<!ENTITY tlm "<acronym>TLM</acronym>">
<!ENTITY tlm2 "<acronym>TLM</acronym>&nbsp;2.0">
<!ENTITY uart "<acronym>UART</acronym>">
<!ENTITY uml "<acronym>UML</acronym>">

<!-- ========== applications ========== -->

<!-- = software applications = -->

<!ENTITY gdb "<application class='software'>GDB</application>">
<!ENTITY linux "<application class='software'>Linux</application>">
<!ENTITY make "<application class='software'>make</application>">
<!ENTITY macos "<application class='software'>Mac OS</application>">
<!ENTITY or1ksim "<application class='software'>Or1ksim</application>">
<!ENTITY systemc "<application class='software'>SystemC</application>" >

<!-- = Hardware applications = -->

<!ENTITY or1k "<application class='hardware'>OpenRISC 1000</application>">
<!ENTITY wishbone "<application class='hardware'>WishBone</application>">

<!-- = Commands = -->

<!ENTITY xterm "<application>xterm</application>" >

<!-- = Libraries = -->

<!ENTITY stdio "<systemitem class='library'>stdio</systemitem>" >

<!-- ========== Cross references ========== -->

<!-- = Organizations = -->

<!ENTITY embecosm "Embecosm">
<!ENTITY opencores "OpenCores">
<!ENTITY gpl "GNU General Public License">

<!ENTITY embecosm_www "Embecosm (<ulink url='http://www.embecosm.com'>www.embecosm.com</ulink>)">
<!ENTITY opencores_www "OpenCores (<ulink
  url='http://www.opencores.org'>www.opencores.org</ulink>)">
<!ENTITY gpl_www "GNU General Public License (<ulink url='http://www.gnu.org/licenses/gpl.html'>GNU General Public License</ulink>)">

]>

<!-- ==========================================================================

Copyright (c) 2008, 2010 Embecosm Limited <info@embecosm.com>.

This work is licensed under the Creative Commons Attribution 2.0 UK:
England & Wales License. To view a copy of this license, visit
http://creativecommons.org/licenses/by/2.0/uk/ or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105, USA.
	
This license means you are free:
  - to copy, distribute, display, and perform the work
  - to make derivative works

under the following conditions:
  - ATTRIBUTION. You must give the original author, Embecosm, credit;
  - For any reuse or distribution, you must make clear to others the license
    terms of this work;
  - Any of these conditions can be waived if you get permission from the
    copyright holder, Embecosm; and
  - Nothing in this license impairs or restricts the author's moral rights.

===============================================================================

Application note describing the first stage in the conversion of an ISS to use
OSCI TLM 2.0, convenience sockets.
=========================================================================== -->

<book lang="en_GB">
  <title>
    Building a Loosely Timed &soc; Model with &osci; TLM 2.0
  </title>
  <subtitle>
    A Case Study Using an Open Source &iss; and &linux; 2.6 Kernel
  </subtitle>

  <bookinfo>

    <author>
      <firstname>Jeremy</firstname>
      <surname>Bennett</surname>
    </author>

    <corpauthor>
      <ulink url="http://www.embecosm.com">&embecosm;</ulink>
    </corpauthor>

    <pubdate>
      May 2010
    </pubdate>

    <releaseinfo>
      Application Note 1. Issue 2
    </releaseinfo>

    <copyright>
      <year>
	2008, 2010
      </year>
      <holder>
	&embecosm; Limited
      </holder>
    </copyright>

    <legalnotice id="legalnotice">
      <title>
	Legal Notice
      </title>

      <para>
	This work is licensed under the Creative Commons Attribution 2.0 UK:
	England &amp; Wales License. To view a copy of this license, visit
	<ulink
	url="http://creativecommons.org/licenses/by/2.0/uk/">http://creativecommons.org/licenses/by/2.0/uk/</ulink>
	or send a letter to Creative Commons, 171 Second Street, Suite 300,
	San Francisco, California, 94105, USA.
      </para>
	
      <para>
	This license means you are free:
	<itemizedlist>
	  <listitem>
	    <para>
	      to copy, distribute, display, and perform the work
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      to make derivative works
	    </para>
	  </listitem>
	</itemizedlist>
	under the following conditions:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis>Attribution.</emphasis> You must give the original
	      author, &embecosm_www;, credit;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For any reuse or distribution, you must make clear to others the
	      license terms of this work;
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Any of these conditions can be waived if you get permission from
	      the copyright holder, &embecosm;; and
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Nothing in this license impairs or restricts the author's moral
	      rights.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>

      <para>
	The software examples written by &embecosm; and used in this document
	are licensed under the &gpl_www;. For detailed licensing information
	see the file <filename>COPYING</filename> in the source code of the
	examples.
      </para>

      <para>
	&embecosm; is the business name of &embecosm; Limited, a private
	limited company registered in England and Wales. Registration number
	6577021.
      </para>

    </legalnotice>
  </bookinfo>

  <chapter>
    <title>
      Introduction
    </title>

    <para>
      The Open <firstterm>&systemc;</firstterm> Initiative
      (<firstterm>&osci;</firstterm>) has issued the second version of its
      standard for <firstterm>Transaction&#32;Level&#32;Modeling</firstterm>
      (&tlm;) in June 2008 <xref linkend="ref_osci_tlm" />. This defines an
      interface for writing high level software models of hardware. An updated
      version (TLM 2.0.1) was released in July 2009.
    </para>

    <para>
      The &osci; standard is comprehensive. As well as a powerful general
      purpose interface, it defines a number of
      <emphasis>convenience</emphasis> components to facilitate adoption of
      the technology.
    </para>

    <para>
      This application note provides an introductory tutorial on using &tlm2;
      for loosely timed models&mdash;ideally suited for early development of
      embedded software. It demonstrates through a practical case study the
      development of a complete &soc;, capable of running a modern &linux; 2.6
      kernel, using the &tlm2; <emphasis>convenience</emphasis> components.
    </para>

    <para>
      One of the most important components in any &soc; system model is the
      processor core <firstterm>Instruction Set Simulator</firstterm>
      (&iss;). This application note demonstrates how to wrap an existing
      &iss; to provide a &tlm2; compliant interface.
    </para>

    <para>
      This application note is the first in a series from &embecosm_www;,
      providing case studies in &osci; &tlm2; use. The objective is to provide
      an introduction to &tlm2; within a practical context. Examples are
      provided throughout, based on open source components, which are freely
      reusable under the &gpl;.
    </para>

    <sect1>
      <title>
	New in Issue 2
      </title>

      <para>
	Issue 2 of the application note is based on TLM 2.0.1. The wrapping of
	the &iss; is extended to cover modeling of the &jtag; interface and its
	connection to the GNU debugger, &gdb;.
      </para>

      <para>
	To aid in understanding how the components fit together, this issue
	includes &uml; class and sequence diagrams, showing the relationships
	and interaction between classes.
      </para>

      <para>
	The examples have been reworked to make them easier to build. In
	particular the example OpenRISC programs are now also built
	automatically.
      </para>

      <para>
	Finally, Robert <foreignphrase>G&uuml;nzel</foreignphrase> (see <xref
	linkend="sec_ack" />), as well as making a number of well informed
	suggestions for improvements which I have adopted, has written a paper
	on using this application note under &macos; (<xref linkend="app_macos"
	/>).
      </para>

    </sect1>

    <sect1>
      <title>
	Target Audience
      </title>

      <para>
	&systemc; represents a challenge to engineers, because it bridges the
	divide between the worlds of hardware and software. These are two
	distinct disciplines, the languages of hardware design such as Verilog
	and VHDL are very different in philosophy to the languages of software
	development such as C++ and Java. Yet both are brought together in the
	world of the <firstterm>System on Chip</firstterm>
	&soc;, where large embedded software systems must run
	on complex silicon chips often containing multiple processor cores of
	different architectures.
      </para>

      <para>
	This application note is aimed at any engineer intending to bridge the
	gap between hardware and software. It recognizes that the reader will
	most likely be expert in only one of these. Explanation is provided
	throughout of both the hardware ideas and software ideas being
	covered.
      </para>

      <para>
	The reader is assumed to have basic programming familiarity with C and
	C++ and the key concepts of object oriented programming: classes and
	instances of classes. A basic understanding of system level hardware
	design and the construction of &soc; from components
	linked by buses (or on-chip networks).
      </para>

      <para>
	Familiarity with &systemc; is assumed. The user guide supplied with
	&systemc; provides a good introduction <xref
	linkend="ref_osci_systemc_ug" />.
      </para>

    </sect1>

    <sect1>
      <title>
	About the &embecosm; TLM 2.0 Application Notes
      </title>

      <para>
	The &osci; &tlm2; standard represents a significant advance in
	standardizing the creation of fast models of
	hardware.
      </para>

      <para>
	However the &osci; reference implementation lacks training material
	and examples to introduce new users to the technology.
      </para>

      <para>
	This series of &embecosm; Application Notes was prompted by a customer
	requesting assistance in porting an existing &iss; to the &tlm2;
	standard. This is the first application note in the series. Further
	&embecosm; Application Notes, addressing different aspects of &tlm2;
	are available from the &embecosm; website at <ulink
	url="http://www.embecosm.com">www.embecosm.com</ulink>.
      </para>

    </sect1>

    <sect1 id="sec_ack">
      <title>
	Acknowledgment
      </title>

      <para>
	I am indebted to <foreignphrase>Dipl Ing</foreignphrase> Robert
	<foreignphrase>G&uuml;nzel</foreignphrase> of the Department of
	Integrated Circuit Design at the <foreignphrase>Technische
	Universit&auml;t Braunschweig</foreignphrase>, Germany, who made a
	number of suggestions for improvements (which I have adopted) and
	provided the instructions for &macos; (see <xref linkend="app_macos"
	/>).
      </para>

    </sect1>

  </chapter>

  <chapter>
    <title>
      Background to &systemc; and the &tlm2; Standard
    </title>

    <para>
      The development of &systemc; as a standard for modeling hardware started
      in 1996. Version 2.0 of the proposed standard was released by the Open
      SystemC Initiative (&osci;) in 2002. In 2006, &systemc; became IEEE
      standard 1666-2005 <xref linkend="ref_ieee_1666" />.
    </para>

    <para>
      &osci; has several groups working on supplementary standards. One of
      these is the &tlm; Working Group. It proposed its first standard for
      transaction level modeling in 2005. Two drafts for version 2.0 were
      released in 2006 and 2007. The version 2.0 standard issued in June
      2008, with a minor update (2.0.1) issued in June 2009 <xref
      linkend="ref_osci_tlm" />.
    </para>

    <sect1>
      <title>
	What is &systemc;
      </title>

      <para>
	Most software languages are not particularly suited to modeling
	hardware systems<footnote>
	  <para>
	    There are some exceptions, most notably Simula67, one the
	    languages which inspired C++. In some respects it is remarkably
	    like &systemc;.
	  </para>
	</footnote>. <firstterm>&systemc;</firstterm> was developed to provide
	features that facilitate hardware modeling, particularly the
	parallelism of hardware, in a mainstream programming
	language.
      </para>

      <para>
	An important objective was that software engineers should be
	comfortable with using &systemc;. Rather than invent a new language,
	&systemc; is based on the existing C++ language. &systemc; is a true
	super-set of C++, so any C++ program is automatically a valid &systemc;
	program.
      </para>

      <para>
	&systemc; uses the template, macro and library features of C++ to
	extend the language. The key features it provides are:
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    A C++ class, <classname>sc_module</classname>, suitable for
	    defining hardware modules containing parallel
	    processes
	  </para>

	  <note>
	    <para>
	      <emphasis>Process</emphasis> is a general term in &systemc;
	      to describe the various ways of representing parallel flows
	      of control. It has nothing to do with processes in the &linux;
	      or Microsoft Windows operating systems.
	    </para>
	  </note>
	</listitem>

	<listitem>
	  <para>
	    A mechanism to define functions modeling the parallel
	    threads of control within <classname>sc_module</classname>
	    classes;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Two classes, <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent points of
	    connection to and from a <classname>sc_module</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_interface</classname> to describe the
	    software services required by a <classname>sc_port</classname>
	    or provided by a <classname>sc_export</classname>;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A class, <classname>sc_prim_channel</classname> to represent the
	    channel connecting ports;
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A set of derived classes, of
	    <classname>sc_prim_channel</classname>,
	    <classname>sc_interface</classname>,
	    <classname>sc_port</classname> and
	    <classname>sc_export</classname> to represent and connect common
	    channel types used in hardware design such as signals, buffers and
	    FIFOs; and
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A comprehensive set of types to represent data in both
	    <firstterm>2-state</firstterm> and <firstterm>4-state</firstterm>
	    logic.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	The full specification is 441 pages long <xref
	linkend="ref_ieee_1666" />. The &osci; reference distribution
	includes a very useful introductory user guide and tutorial <xref
	linkend="ref_osci_systemc_ug" />.
      </para>
	
    </sect1>

    <sect1 id="sec_what_is_tlm">
      <title>
	What is a &tlm;
      </title>

      <sect2>
	<title>
	  Hardware and Software Views of Parallelism
	</title>

	<para>
	  To understand transaction level modeling, it is essential to
	  understand the difference in approach to parallelism taken in
	  hardware and software design.
	</para>

	<para>
	  A hardware engineer, typically writing in a
	  <firstterm>Hardware&#32;Description&#32;Language</firstterm> (&hdl;)
	  such as Verilog or VHDL, describes a design as a collection of
	  parallel activities, which communicate via shared data. The parallel
	  activities are <literal>always</literal> (Verilog) or
	  <literal>process</literal> (VHDL) blocks. The shared data structures
	  are wires or signals.
	</para>

	<para>
	  This follows very naturally the way that physical hardware
	  behaves. There is no one <emphasis>flow of
	  control</emphasis>&mdash;all parallel components are active at the
	  same time, with their individual flow of control.
	</para>

	<para>
	  By contrast, a software engineer typically describes parallelism in
	  a design as a number of threads, which pass flow of control between
	  them. The threads communicate by a number of mechanisms (message
	  passing or remote procedure call for example), but although there is
	  <emphasis>logical</emphasis> parallelism, only one thread is ever
	  physically active at one time.
	</para>

	<para>
	  This follows naturally the behavior on a conventional uni-processor
	  CPU, where there is a single program counter indicating the next
	  instruction to execute, and so only one flow of control. Even with
	  modern multiprocessors, this is still a natural way of programming
	  for the software engineer, because the number or threads or
	  processes will often exceed the number of processor cores available.
	</para>
      </sect2>

      <sect2>
	<title>
	  Modeling Hardware Parallelism in Software
	</title>

	<para>
	  A simple way to model hardware is via a round-robin, which updates
	  the state of each component as time advances. Each component is
	  represented as a software function. A master clock function calls
	  each component function in turn when the clock advances&mdash;for
	  example on each clock edge. The wires between the components are
	  represented as variables shared between the components. A number of
	  tools (e.g. ARC VTOC, ARM RealView &soc; Designer, Carbon SpeedCompiler,
	  Verilator) use this approach to cycle accurate modeling.
	</para>

	<para>
	  With its close parallel of the way hardware is designed with
	  languages such as Verilog and VHDL, this approach has merit for
	  detailed modeling. It is well suited to cycle accurate modeling where
	  every hardware register and wire must be accurate.
	</para>

	<para>
	  Efficiency demands that not every HDL <literal>process</literal> or
	  <literal>always</literal> is built as a separate function. Automated
	  tools which generate cycle accurate models in &systemc; from HDL can
	  often reduce complex designs to a small number of functions executed
	  on each cycle.
	</para>

	<para>
	  For less detailed models, the overhead in calling each component
	  whenever time advances cannot be justified.
	</para>

	<para>
	  The solution is to model each component only when it has something
	  to do. The individual components communicate by sending messages
	  requesting data be transferred between each other. The exchange of
	  messages is called a transaction, and the approach
	  <firstterm>Transaction&#32;Level&#32;Modeling</firstterm> (&tlm;).
	</para>

	<para>
	  This mirrors the way hardware behaves at the high level, where
	  functional blocks communicate by reading and writing across buses.
	</para>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Overview of OSCI TLM 2.0
      </title>

      <para>
	&osci; &tlm2; offers a standard approach to building Transaction Level
	Models.
      </para>

      <para>
	At the simplest level a &tlm; is a set of &systemc; modules (i.e. C++
	classes), each providing one or more <firstterm>socket</firstterm>s
	through which the &systemc; modules may read and write data.
      </para>

      <para>
	The behavior of each module is provided by a number of parallel
	<firstterm>thread</firstterm>s (functions of the C++ class), which
	communicate with the threads in other modules by passing data
	(i.e. reading or writing) through the sockets. This communication is
	known as a <firstterm>transaction</firstterm> and the data passed as a
	<firstterm>payload</firstterm>. <xref linkend="fig_tlm_overview" />
	shows the key components in a &tlm2; model.
      </para>

      <figure id="fig_tlm_overview">
	<title>
	  Key components in an &osci; &tlm2; model.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="tlm_overview.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <sect2 id="sec_payload">
	<title>
	  Transaction Payload
	</title>

	<para>
	  The data passed in a transaction may take any form. However the
	  &tlm2; standard defines a <firstterm>generic payload</firstterm>
	  which is suitable for many uses, and which can be extended if
	  required. By using the generic payload, a &tlm2; model will maximize
	  interoperability.
	</para>

	<para>
	  The main features of the generic payload are:
	</para>

	<variablelist>

	  <varlistentry>
	    <term>Command</term>
	    <listitem>
	      <para>
		Is this a read or a write?
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Address</term>
	    <listitem>
	      <para>
		What is the address (in the hardware sense of an address in
		memory).
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Data</term>
	    <listitem>
	      <para>
		A pointer to the physical data as an array of bytes
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Byte Enable Mask</term>
	    <listitem>
	      <para>
		A pointer to an array indicating which bytes of the data are
		valid.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Response</term>
	    <listitem>
	      <para>
		An indication of whether the transaction was successful, and
		if not the nature of the error.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  Further features provide support for streaming, custom memory
	  management and extensions to the generic payload.
	</para>

	<para>
	  A &tlm2; <firstterm>transport&#32;function</firstterm> is used to
	  pass the payload to another &systemc; thread and obtain a
	  response&mdash;i.e. a transaction.
	</para>

	<para>
	  The generic payload is suitable for modeling a wide range of bus
	  interfaces and protocols. However where additional features are
	  required, &tlm2; provides an extension mechanism. The chapter on
	  implementing a transactional &jtag; debugger interface (see <xref
	  linkend="chap_jtag"/>) describes the use of this extension mechanism
	  to model the data for a bit-serial interface.
	</para>

      </sect2>

      <sect2>
	<title>
	  Initiators and Targets
	</title>

	<para>
	  A module's threads may act as either
	  <firstterm>initiator</firstterm>s or
	  <firstterm>target</firstterm>s. An initiator is responsible for
	  creating a payload (see <xref linkend="sec_payload" />) and calling
	  the transport function to send it. A target receives payloads from
	  the transport function for processing and response. In the case of
	  non-blocking interfaces (see <xref linkend="sec_block_non_block" />),
	  the target may create new transactions backwards in response to a
	  transaction from an initiator.
	</para>

	<para>
	  Initiator calls are made through initiator sockets, target calls
	  received through target sockets. A module may implement both target
	  and initiator sockets, allowing its threads to both generate and
	  receive traffic.
	</para>
      </sect2>


      <sect2 id="sec_block_non_block">
	<title>
	  Blocking, Non-Blocking, Debug and Direct Memory Interfaces
	</title>

	<para>
	  There are two principal types of &tlm2; transport function.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      The <firstterm>blocking</firstterm> transport functions are
	      called by the initiator thread, received by the target thread,
	      which processes the request and then returns the result. Until
	      the transaction has been processed and released the initiator
	      thread is blocked.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      The <firstterm>non-blocking</firstterm> transport functions are
	      called by the initiator thread, received by the target thread,
	      which immediately returns, before processing the
	      request. Subsequently the target, having processed the request
	      makes a transport call <emphasis>backwards</emphasis> to the
	      initiator to return the result.
	    </para>
	  </listitem>
	</orderedlist>

	<para>
	  In the non-blocking case there are actually two types of transport
	  used. The <firstterm>forward&#32;transport&#32;path</firstterm> is
	  used by the initiator to pass the request to the target and the
	  <firstterm>backward&#32;transport&#32;path</firstterm> used by the
	  target to return the response. The advantage of the non-blocking
	  transport interface is that the initiator can carry on processing,
	  while the target is processing the request originally made.
	</para>

	<para>
	  In addition &tlm2; provides two more specialized types of
	  transaction.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      A <emphasis>debug transaction</emphasis> is a read that does not
	      affect the state of the model. These are for use by debuggers,
	      which wish to see the state of a model, without affecting that
	      state.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      &tlm2; recognizes that a full-blown transaction is too
	      heavyweight for some types of access. For example an ISS
	      accessing memory using transactions would destroy
	      performance. &tlm2; provides the concept of a
	      <firstterm>direct&#32;memory&#32;interface</firstterm>, allowing
	      threads direct access to blocks of memory in other threads for
	      high performance.
	    </para>
	  </listitem>
	</orderedlist>

      </sect2>

      <sect2>
	<title>
	  Loosely Timed, Approximately Timed and Untimed &tlm;
	</title>

	<para>
	  &tlm2; considers two levels of timing detail.
	</para>

	<orderedlist>
	  <listitem>
	    <para>
	      A <firstterm>loosely&#32;timed</firstterm> model uses
	      transactions corresponding to a complete read or write across a
	      bus or network in physical hardware. It provides timing at the
	      level of the individual transaction.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      An <firstterm>approximately&#32;timed</firstterm> model breaks
	      down transactions into a number of <firstterm>phase</firstterm>s
	      corresponding much more closely to the phasing of particular
	      hardware protocols (for example the address and data phases of
	      an AHB read or write).
	    </para>
	  </listitem>
	</orderedlist>

	<para>
	  Typically loosely timed models are implemented with a blocking
	  interface and approximately timed models with a non-blocking
	  interface.
	</para>

	<para>
	  &tlm2; also introduces the concept of
	  <firstterm>temporal&#32;decoupling</firstterm>. Standard &systemc;
	  keeps a single synchronized view of time, which is used by all
	  threads in all modules. However with temporal decoupling, each
	  thread can keep its own local view of time, allowing the thread to
	  run ahead in simulation time, until it needs to synchronize with
	  another thread. This improves performance in loosely timed models
	  with blocking interfaces, by avoiding bottlenecks in processing.
	</para>

	<para>
	  To ensure that one thread doesn't run away hogging all the
	  processing, &tlm2; temporal decoupling uses the concept of the
	  <firstterm>quantum</firstterm>, the greatest amount that a thread
	  may differ in timing from the central view of time. This allows
	  other threads a chance to catch up
	</para>

	<para>
	  &tlm2; does not have an explicit concept of an untimed socket
	  (something that was explicit in &tlm;&nbsp;1.0). The standardization
	  group took the view that in practice all models need some concept of
	  time, so purely untimed models are of little value.
	</para>

	<para>
	  However, untimed models are easily implemented as loosely timed
	  models which always set the timing parameter in transport calls to
	  zero. The example in <xref linkend="chap_iss_wrapper" />, <xref
	  linkend="chap_uart" /> and <xref linkend="chap_terminal" /> uses this
	  approach to create an untimed model. This is then refined in <xref
	  linkend="chap_sync" /> to add synchronous timing information and in
	  <xref linkend="chap_temporal_decoupling" /> to add temporal
	  decoupling.
	</para>
      </sect2>

      <sect2>
	<title>
	  &tlm2; Convenience Sockets
	</title>

	<para>
	  The standard &tlm2; approach to modeling requires the user to
	  derive their own classes from the standard &tlm2; sockets, so that
	  those sockets can then implement the &tlm2; interfaces. Modules then
	  instantiate these derived sockets and use the bind function to connect
	  them to sockets on other modules.
	</para>

	<para>
	  This is a very flexible approach, but the need to define new derived
	  classes for sockets is an unnecessary layer of complexity for simple
	  modeling. For such uses, the &tlm2; standard defines a number of
	  <firstterm>convenience&#32;socket</firstterm>s which can be
	  instantiated directly by modules, and which specify their interface
	  functions as callbacks.
	</para>

	<para>
	  These convenience sockets are used throughout the case study in this
	  application note.
	</para>

      </sect2>
    </sect1>
  </chapter>

  <chapter id="sec_case_study">
    <title>
      Case Study: A Loosely Timed &soc; Using &tlm2;
    </title>

    <para>
      In this case study, &tlm2; convenience sockets are used to wrap an
      existing &iss;. This is then built into a simple &soc; using additional
      hand-written &tlm2; components.
    </para>

    <para>
      Modeling uses the &tlm2; <glossterm>generic payload</glossterm> with no
      extensions. It is independent of the specific bus architecture that will
      be used in the implementation.
    </para>

    <para>
      The &iss; used is from the &opencores_www; project. This open source
      project has developed a complete 32/64-bit architecture, the &or1k;,
      complete with GNU compiler chain, architectural simulator and &linux;
      port. This application note uses the &or1k; architectural simulator,
      &or1ksim; as the &iss; for all the examples.
    </para>

    <para>
      The model is constructed in a number of stages:
    </para>

    <orderedlist>

      <listitem>
	<para>
	  The basic wrapper for the &or1ksim; &iss; is built using &tlm2;
	  convenience sockets and tested with a simple logger. In this first
	  stage timing is ignored&mdash;this is effectively an untimed
	  model. See <xref linkend="chap_iss_wrapper" /> and <xref
	  linkend="chap_iss_wrapper_test" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  A model &uart; is added as an example peripheral, demonstrating how
	  &tlm2; and existing &systemc; technologies can be mixed. See <xref
	  linkend="chap_uart" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  A model of a terminal is added as a test bench for the &soc;. This
	  demonstrates how to add &systemc; components which use operating
	  system I/O without blocking the &systemc; thread. See <xref
	  linkend="chap_terminal" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  Synchronous timing is added to each component, making the model
	  loosely timed. See <xref linkend="chap_sync" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  Temporal decoupling is added to the &or1ksim; &iss;, &uart; and
	  terminal, to improve the performance of the model. See <xref
	  linkend="chap_temporal_decoupling" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  Interrupt modeling is added to the &uart; and the &or1ksim; &iss;,
	  allowing the model to run &linux;. See
	  <xref linkend="chap_linux" />.
	</para>
      </listitem>

      <listitem>
	<para>
	  A second thread, modeling the &jtag; interface to the processor is
	  added to the wrapper. This demonstrates how the &iss; wrapper can be
	  multi-threaded, while the underlying &or1k; &iss; remains single
	  threaded. This interface allows the model to be driven from a
	  debugger such as &gdb;. See <xref linkend="chap_jtag" />.
	</para>
      </listitem>

    </orderedlist>

    <para>
      Simple applications, compiled with the &or1k; tool chain are used
      throughout to exercise the model components. The final model
      is demonstrated booting a &linux; 2.6 kernel.
    </para>

    <sect1>
      <title>
	The Example Designs
      </title>

      <para>
	The example, a simple &soc;, is based on the &or1ksim; &iss; for the
	&or1k; architecture. The &or1k; architecture is a conventional 32-bit
	DSP/RISC design, with optional caches and
	&mmu;. &or1ksim; is an interpreting &iss; written in
	C, which in its standard configuration models main memory and a number
	of peripherals as well as the CPU itself.
      </para>

      <para>
	A key feature of &or1ksim; is that it is single threaded and the code
	is generally not re-entrant. Much of the challenge in wrapping such an
	&iss; is ensuring consistency within a multi-threaded &systemc;
	environment.
      </para>

      <para>
	Information on obtaining and setting up the open source &or1ksim;
	simulator and its tool chain are given in <xref
	linkend="ref_app_note_2" endterm="ref_app_note_2_xr" /> <xref
	linkend="ref_app_note_2" />.
      </para>

      <para>
	For <xref linkend="chap_iss_wrapper" /> through <xref
	linkend="chap_temporal_decoupling" /> the &or1ksim; &iss; is configured
	to model only the CPU and main memory, with example peripherals
	modeled as separate &systemc; modules. For <xref linkend="chap_linux"
	/>, the &iss; is configured to model the data and instruction
	&mmu;s and a
	<firstterm>programmable&#32;interrupt&#32;controller</firstterm>
	(<acronym>PIC</acronym>). This allows the &iss; to support interrupt
	driven peripherals and hence &linux;
      </para>

      <para>
	In <xref linkend="chap_jtag" /> a second thread is introduced to the
	wrapper to model the &jtag; debugging interface. This allows the model
	to be run under the control of a debugger such as &gdb;
      </para>

      <sect2>
	<title>
	  &or1ksim; &iss; &tlm2; Wrapper with Logger
	</title>

	<para>
	  In <xref linkend="chap_iss_wrapper" /> the &tlm2; wrapper for the
	  &or1ksim; &iss; is developed. In <xref
	  linkend="chap_iss_wrapper_test" /> the wrapped &iss; is tested by
	  connection to a simple &tlm2; logger module. This module records
	  transactions sent to it on standard output as shown in <xref
	  linkend="fig_iss_test" />.
	</para>

	<figure id="fig_iss_test">
	  <title>
	    Testing the &tlm2; wrapper for &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="iss_test.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="iss_test.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2>
	<title>
	  Simple &soc; Design
	</title>

	<para>
	  To build a simple &soc; the &or1ksim; &iss; CPU/memory subsystem is
	  connected to a &uart; modeled in &systemc; using &tlm2;. The test
	  bench for the system is a terminal, also modeled in &systemc; using
	  &tlm2; as shown in <xref linkend="fig_simple_soc" />. The model is
	  built up in stages starting with the &iss; wrapper module developed
	  in <xref linkend="chap_iss_wrapper" />. In <xref linkend="chap_uart"
	  /> and <xref linkend="chap_terminal" /> models of the &uart; and
	  terminal are added to create an untimed model. Synchronous timing to
	  create a loosely timed model is added in <xref linkend="chap_sync"
	  /> and temporal decoupling to improve performance is added in <xref
	  linkend="chap_temporal_decoupling" />. .
	</para>

	<figure id="fig_simple_soc">
	  <title>
	    Simple &soc; based on the &or1k; &or1ksim;.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2 id="sec_example_soc_intr">
	<title>
	  &soc; with Interrupt Support
	</title>

	<para>
	  To run &linux; (see <xref linkend="chap_linux" />), the example must be
	  extended to support interrupt driver I/O. It also needs memory
	  management and other peripheral functions. This is provided
	  internally to the &or1ksim; &iss;. This design is shown in <xref
	  linkend="fig_simple_soc_intr" />.
	</para>

	<figure id="fig_simple_soc_intr">
	  <title>
	    Simple &soc; based on the &or1k; &or1ksim; with interrupts and
	    &mmu; enabled.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple_soc_intr.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2 id="sec_example_soc_jtag">
	<title>
	  &soc; with Debugger Support
	</title>

	<para>
	  A software debugger typically interacts with a processor via an
	  independent debugging interface. For the &or1k; the debug interface
	  uses &ieee; 1149.1 &jtag;. To allow the debugger to connect to the
	  model we must model this interface. This design is shown in <xref
	  linkend="fig_simple_soc_jtag" />.
	</para>

	<figure id="fig_simple_soc_jtag">
	  <title>
	    Simple &soc; based on the &or1k; &or1ksim; with separate &jtag;
	    interface.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-jtag.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-jtag.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Example Code
      </title>

      <sect2>
	<title>
	  Source Code for Example Models and Programs
	</title>

	<para>
	  The code of the distribution is organized as follows.
	</para>

	<variablelist termlength="9">
	  <varlistentry>
	    <term>
	      <filename>configure</filename>
	    </term>
	    <listitem>
	      <para>
		The main configuration script.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <filename>linux.cfg</filename>
	    </term>
	    <listitem>
	      <para>
		An &or1ksim; configuration file for use when running &linux;.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <filename>progs-or32</filename>
	    </term>
	    <listitem>
	      <para>
		A collection of OpenRISC 1000 programs which run on the models
		created. Binaries are provided as well as source, but to
		recompile the example programs requires the &or1k; tool
		chain. See <xref linkend="ref_app_note_2"
		endterm="ref_app_note_2_xr" /> <xref linkend="ref_app_note_2"
		/> for more information on building the &or1k; tool chain.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <filename>simple.cfg</filename>
	    </term>
	    <listitem>
	      <para>
		An &or1ksim; configuration file for use when running simple
		examples.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <filename>sysc-models</filename>
	    </term>
	    <listitem>
	      <para>
		The SystemC code for the various models. A separate directory
		is provided for each model. In each case the models build on
		previous models using the C++ class inheritance mechanism.
	      </para>

	      <variablelist termlength="9">
		<varlistentry>
		  <term>
		    <filename>logger</filename>
		  </term>
		  <listitem>
		    <para>
		      The simplest model, providing a base class wrapper to
		      &or1ksim; and connecting to a simple logger class, which
		      can check the correct behavior of the bus. See <xref
		      linkend="chap_iss_wrapper" /> and <xref
		      linkend="chap_iss_wrapper_test" />.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>
		    <filename>simple-soc</filename>
		  </term>
		  <listitem>
		    <para>
		      The simplest complete &soc; model, adding a &uart; and
		      terminal emulator to the &or1ksim; model. The base
		      &or1ksim; wrapper class from <filename>logger</filename>
		      is extended to allow other threads to execute. See <xref
		      linkend="chap_uart" /> and <xref linkend="chap_terminal"
		      />.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>
		    <filename>sync-soc</filename>
		  </term>
		  <listitem>
		    <para>
		      This extends the &soc; wrapper from
		      <filename>simple-soc</filename> to add synchronized
		      timing. Derived classes of the &uart; and terminal
		      emulator also add synchronized timing. See <xref
		      linkend="chap_sync" />.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>
		    <filename>decoup-soc</filename>
		  </term>
		  <listitem>
		    <para>
		      Decoupled timing is added to the &soc; wrapper from
		      <filename>sync-soc</filename>. A decoupled version of
		      the &uart; is also implemented. See <xref
		      linkend="chap_temporal_decoupling" />.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>
		    <filename>intr-soc</filename>
		  </term>
		  <listitem>
		    <para>
		      This is a version of the &soc; wrapper from
		      <filename>decoup-soc</filename> which adds interrupt
		      handling. A version of the &uart; which supports
		      interrupt based operation is also implemented. This
		      allows Linux to be supported. See <xref
		      linkend="chap_linux" />.
		    </para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term>
		    <filename>jtag-soc</filename>
		  </term>
		  <listitem>
		    <para>
		      The &soc; wrapper from <filename>intr-soc</filename> is
		      extended with an additional thread implementing a &jtag;
		      interface. This allows code running on the model to be
		      debugged using a tool such as &gdb;. See <xref
		      linkend="chap_jtag" />.
		    </para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <filename>uml</filename>
	    </term>
	    <listitem>
	      <para>
		&uml; design information for all the models, created with
		<application class='software'>BoUML</application> is provided
		in this directory.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>
	  Various other files and directories are included. These form part of
	  the standard <acronym>GNU</acronym> <command>autotools</command>
	  infrastructure.
	</para>

      </sect2>

      <sect2>
	<title>
	  Code Documentation
	</title>

	<para>
	  The code throughout is documented with
	  <application>Doxygen</application> (see <ulink
	  url="http://www.doxygen.org">www.doxygen.org</ulink>). This provides
	  a description of the code, generated automatically from the
	  source. The generated HTML can be found in the
	  <filename>doc/html</filename> sub-directory of both the &systemc;
	  model directory and the &or1k; program directory.
	</para>
      </sect2>

      <sect2 id="sec_coding_conv">
	<title>
	  &systemc; Model Coding Conventions
	</title>

	<para>
	  All the examples in this application note separate the definition of
	  a class (i.e. <emphasis>what</emphasis> it does) in a
	  <filename>.h</filename> file, from the implementation
	  (i.e. <emphasis>how</emphasis> it does it) in a
	  <filename>.cpp</filename> file. Class <parameter>X</parameter> is
	  defined in file <filename><parameter>X</parameter>.h</filename> and
	  implemented in <filename><parameter>X</parameter>.cpp</filename>.
	</para>

	<para>
	  The examples use the convention that classes and other type names
	  start with an Upper Case letter
	  (e.g. <classname>Or1ksimSC</classname>), variables and functions
	  start with a lower case letter (e.g. <literal>dataBus</literal>) and
	  defined or enumerated constants are all in UPPER CASE
	  (e.g. <literal>#define BAUD_RATE 9600</literal>). All &systemc;
	  module classes end with the characters 'SC'.
	</para>

      </sect2>

      <sect2>
	<title>
	  Modifying the Standard &or1ksim; &iss;
	</title>

	<para>
	  It is not intended that the reader should have to understand the
	  internal workings of &or1ksim;. With the exception of the examples
	  in <xref linkend="chap_jtag"/>, the changes described in this
	  application note form part of &or1ksim; 0.3.0.
	</para>

	<para>
	  The changes required to support &jtag; described in <xref
	  linkend="chap_jtag"/> will form part of &or1ksim; 0.4.0. In the
	  meantime they are available by building &or1ksim; from the
	  &opencores; <command>Subversion</command> tree.
	</para>

	<para>
	  More information is provided in <xref linkend="app_download" />.
	</para>

      </sect2>

      <sect2>
	<title>
	  Derived classes
	</title>

	<para>
	  C++ provides the hierarchical class mechanism, where
	  <firstterm>derived&#32;class</firstterm>es inherit (some) of the
	  functions and variables of their
	  <firstterm>base&#32;class</firstterm>. This feature is heavily used
	  within &systemc;&mdash;for example all module classes are derived
	  classes of the &systemc; base class,
	  <classname>sc_module</classname>.
	</para>

	<para>
	  The &systemc; models in each section of this application note are
	  built using derived classes of the models from previous sections.
	</para>

	<para>
	  Those functions and variables which other classes will use are
	  declared as <literal>public</literal>. For &systemc; modules this
	  usually means the constructor and any &systemc; ports or
	  sockets. Occasionally there are some utility functions which are
	  also made public (see for example
	  <function>Or1ksimExt::isLittleEndian</function> in <xref
	  linkend="sec_uart_or1ksim_libext" />)<footnote>
	    <para>
	      Object oriented purists prefer to expose only class functions as
	      the <literal>public</literal> interface, so hiding all state
	      implementation from external view. There is considerable merit
	      in this, but the common &systemc; convention is to expose actual
	      ports or sockets, rather than accessor functions for those
	      objects. This application note follows this practice.
	    </para>
	    </footnote>.
	</para>

	<para>
	  Variables and functions in classes that are not for use by other
	  classes, but are required in derived classes are declared as
	  <literal>protected</literal> (i.e. visible to derived classes).
	</para>

	<para>
	  The remaining functions and variables, which are for use only by the
	  current class, are declared <literal>private</literal> (visible only
	  to this class). This avoids any unplanned reuse by derived classes.
	</para>

	<para>
	  Some of the functions will be reimplemented in later derived
	  classes. Such functions are also declared <literal>virtual</literal>.
	</para>

	<para>
	  In summary <literal>public</literal> functions and variables may be
	  used by any other class, <literal>protected</literal> functions and
	  variables may be <emphasis>used</emphasis> only by this class and
	  any derived classes and <literal>private</literal> functions and
	  variables may be used only by this class. <literal>virtual</literal>
	  functions may be <emphasis>reimplemented</emphasis> in derived
	  classes.
	</para>
      </sect2>

      <sect2>
	<title>
	  Configuration
	</title>

	<para>
	  The entire example system is now built using the
	  <acronym>GNU</acronym>; <command>autotools</command>. This provides
	  for flexibility in configuration and building of the system.
	</para>

	<note>
	  <para>
	    This is a major change since issue 1 of this application note.
	  </para>
	</note>

	<para>
	  Full details of how to configure and build the models are in <xref
	  linkend="app_download"/>.
	</para>

      </sect2>
    </sect1>

  </chapter>

  <chapter id="chap_iss_wrapper">
    <title>
      Wrapping the &iss;
    </title>

    <para>
      The conversion of an existing &iss; to a  &systemc;
      module with &tlm2; sockets involves several steps.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Modify the existing &iss; (in this example &or1ksim; written in C)
	  so it  behaves in a manner suitable for wrapping (see <xref
	  linkend="sec_iss_mods" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Define a &systemc; module for the wrapper (see <xref
	  linkend="sec_iss_wrapper_def" />) and provide its implementation
	  (see <xref linkend="sec_iss_wrapper_impl" />).
	</para>
      </listitem>

      <listitem>
	<para>
	  Test the wrapper with a simple logger module attached to the &tlm2;
	  socket and a suitable test application running as embedded code on the
	  &iss; (see <xref linkend="chap_iss_wrapper_test" />).
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The code for the &or1ksim; wrapper module
      (<filename>Or1ksimSC.cpp</filename> and
      <filename>Or1ksimSC.h</filename>) may be found in the
      <filename>sysc-models/logger</filename> directory of the distribution.
    </para>

    <sect1 id="sec_iss_mods">
      <title>
	Modifying the &or1ksim; &iss; for &tlm2;
      </title>

      <para>
	Most &iss; need some modification before they can be incorporated into
	a &tlm2; framework. Like many &iss;, &or1ksim; is designed as a
	standalone program. The options are:
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Keep the &iss; as a standalone program, but modify it to call
	    out to a &systemc; model of the peripherals as required.
	  </para>
	</listitem>

	<listitem id="or1ksim_lib_opt">
	  <para>
	    Modify the &iss; to be a library with a set of public interfaces
	    that can be part of a larger system.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Given the choice, option <xref linkend="or1ksim_lib_opt" /> is more
	flexible, making the &iss; widely reusable in other environments. It
	is the approach adopted in this application note.
      </para>

      <para>
	Almost all the modifications required for this application note have
	now been incorporated in &or1ksim; 0.3.0. However some additional
	modifications are required to support the &jtag; interface described
	in <xref linkend="chap_jtag" />. Those additional modifications will
	form part of &or1ksim;&nbsp;0.4.0, but in the meantime are available
	from the &or1ksim; <command>Subversion</command> tree on the
	&opencores; website (<ulink
	url="http://www.opencores.org/">www.opencores.org</ulink>). See <xref
	linkend="app_download" /> for details.
      </para>

      <sect2 id="sec_or1ksim_libcals">
	<title>
	  Converting &or1ksim; to a Library
	</title>

	<para>
	  The &or1ksim; <function>main</function> function first initializes
	  the &iss;, then sits in a loop executing instructions. This
	  <function>main</function> function is replaced by a series of
	  functions which form the interface to the library. The interface
	  functions needed are:
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
int  or1ksim_init (const char *config_file,
                   const char *image_file,
                   void       *class_ptr,
                   int       (*upr) (void              *class_ptr,
                                     unsigned long int  addr,
                                     unsigned char      mask[],
                                     unsigned char      rdata[],
                                     int                data_len),
                   int       (*upw) (void              *class_ptr,
                                     unsigned long int  addr,
                                     unsigned char      mask[],
                                     unsigned char      wdata[],
                                     int                data_len));
		</programlisting>
	      </informalfigure>
	    </para>

	    <para>
	      <function>or1ksim_init</function> initializes the
	      simulator. For &or1ksim;, configuration data is read from a
	      file, which is passed as the first argument,
	      <literal>config_file</literal>. The program image is passed as
	      a second argument, <literal>image_file</literal>.
	    </para>

	    <para>
	      &or1ksim; also needs to be able to call up to the &systemc;
	      model of which it is part&mdash;to read and write from the
	      peripheral address space. These are provided as the fourth
	      and fifth arguments, <function>upr</function> and
	      <function>upw</function>. More explanation of the upcall
	      mechanism can be found in <xref linkend="sec_upcall" />.
	    </para>

	    <para>
	      Function calls between C and C++ can be awkward. The upcall
	      functions form part of the &systemc; module object, but are
	      written as static functions with C linkage. To enable these
	      functions to invoke functions in the &systemc; module, they are
	      passed a pointer to the module class instance to use as a
	      handle. This pointer forms the third argument,
	      <literal>class_ptr</literal>.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
int  or1ksim_run( double  duration );
		</programlisting>
	      </informalfigure>
	    </para>
	    <para>
	      <function>or1ksim_run</function> runs the simulator for the
	      specified time in seconds.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  Both these interface functions are provided as standard in &or1ksim;
	  0.3.0.
	</para>

      </sect2>
      <sect2 id="sec_or1ksim_generic_sec">
	<title>
	  Additional Functionality for &or1ksim;
	</title>

	<para>
	  The standard &or1ksim; &iss; incorporates the functionality of
	  several common peripherals. The objective of this application note
	  is to demonstrate the &iss; driving external peripherals modeled in
	  &systemc; using &tlm2; interfaces.
	</para>

	<para>
	  &or1ksim; peripherals are configured in a textual configuration
	  file, with a section (introduced by the keyword
	  <literal>section</literal>) for each device attached. This
	  configuration file specifies the memory mapped addresses of the
	  peripheral. Any reads or writes to those addresses will be directed
	  to the code of the peripheral within &or1ksim;.
	</para>

	<para>
	  &or1ksim; is extended with a new class of peripheral,
	  <literal>generic</literal>, which specifies an external
	  peripheral. The specification in the configuration file specifies
	  the memory mapped address range covered and whether byte, half word
	  or full word access are enabled. Multiple <literal>generic</literal>
	  sections may be defined (for different address ranges) in the
	  configuration file.
	</para>

	<para>
	  Code is added to &or1ksim;, so that any read or write to a
	  <literal>generic</literal> peripheral is redirected back to the
	  wrapper code via the upcalls specified as arguments to
	  <function>or1ksim_init</function> (see <xref
	  linkend="sec_or1ksim_libcals" /> and <xref linkend="sec_upcall" />).
	</para>
      </sect2>
    </sect1>


    <sect1 id="sec_iss_wrapper_def">
      <title>
	&or1ksim; Wrapper Module Class Definition
      </title>

      <para>
	The class definition for the &or1ksim; &iss; wrapper module may be
	found in the file <filename>sysc_models/logger/Or1ksimSC.h</filename>.
      </para>

      <sect2 id="sec_Or1ksimSC_def_inc">
	<title>
	  Included Headers
	</title>

	<para>
	  The &or1ksim; &systemc; wrapper module class,
	  <classname>Or1ksimSC</classname>, is defined in the file
	  <filename>Or1ksimSC.h</filename>. It will provide a single initiator
	  socket, for data access, <literal>dataBus</literal>. No instruction
	  accesses are planned, so modeling an external instruction bus is
	  unnecessary.
	</para>

	<para>
	  The module includes the <filename>tlm.h</filename> header, which
	  defines the core &tlm2; interface and the required convenience
	  wrapper header&mdash;in this case for a simple initiator socket.
	</para>

	<para>
	  The &posix; <filename>stdint.h</filename> header is also included, since
	  the definitions and code will make use of the fixed width native
	  types defined there.
	</para>

	<informalfigure>
	  <programlisting>
#include &lt;stdint.h&gt;

#include "tlm.h"
#include "tlm_utils/simple_initiator_socket.h"
#include "or1ksim.h"
	  </programlisting>
	</informalfigure>

        <note>
	  <para>
	    There is no need to include the standard
	    <filename>systemc</filename> header, since this is included
	    automatically by <filename>tlm.h</filename>.
	  </para>
	</note>

      </sect2>

      <sect2 id="sec_Or1ksimSC_def_module">
	<title>
	  Module Declaration
	</title>

	<para>
	  The module is declared as a standard &systemc; module, i.e. as a
	  derived class of <classname>sc_core::sc_module</classname>.
	</para>

	<informalfigure>
	  <programlisting>
class Or1ksimSC
  : public sc_core::sc_module
{
	  </programlisting>
	</informalfigure>

        <note>
	  <para>
	    &systemc; provides a macro, so that a module can be defined by:
	  </para>

	  <informalfigure>
	    <programlisting>
SC_MODULE( Or1ksimSC )
	    </programlisting>
	  </informalfigure>

	  <para>
	    However this is equivalent (IEEE 1666-2005 section 5.2.5) to the
	    C++ derived class declaration
	  </para>

	  <informalfigure>
	    <programlisting>
class Or1ksimSC
  : public sc_core::sc_module
{
 public:
	    </programlisting>
	  </informalfigure>

          <para>
	    By using <literal>SC_MODULE</literal> all functions and variables
	    will be visible to all other classes (<literal>public</literal>)
	    unless there is a subsequent <literal>protected:</literal> or
	    <literal>private:</literal> declaration.
	  </para>

          <para>
	    The examples provided with &systemc; and &tlm2; all use explicit
	    declarations of classes derived from
	    <classname>sc_module</classname> rather than the
	    <literal>SC_MODULE</literal> macro. This application note uses the
	    same approach.
	  </para>
	</note>

      </sect2>

      <sect2 id="sec_Or1ksimSC_def_constructor">
	<title>
	  Constructor and Destructor
	</title>

	<para>
	  <classname>Or1ksimSC</classname> needs a custom constructor, which
	  can be passed the &or1ksim; &iss; configuration and image files. It
	  will call the <function>or1ksim_init</function> function within the
	  &or1ksim; library (see <xref linkend="sec_or1ksim_libcals" />) to
	  initialize the &iss;.
	</para>

	<informalfigure>
	  <programlisting>
Or1ksimSC( sc_core::sc_module_name  name,
           const char              *configFile,
           const char              *imageFile );
	  </programlisting>
	</informalfigure>

	<para>
	  The default destructor is sufficient here. The module has no tidying
	  up to do on termination.
	</para>

      </sect2>

      <sect2 id="sec_Or1ksimSC_def_pub_if">
	<title>
	  Public Interface
	</title>

	<para>
	  The only public interface is the &tlm2; simple initiator convenience
	  socket, <literal>dataBus</literal>. The &tlm2; convenience sockets are
	  templated with
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      the class of which any callbacks are members;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a bus width (default <literal>BUSWIDTH</literal>, 32); and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      a protocol type (default the &tlm2; base protocol types).
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  For this case study, the default bus width and protocol are
	  appropriate and need not be specified. There is no default class for
	  the template, so <classname>Or1ksimSC</classname> is used. A class must be
	  specified, even where (as in this case for a simple blocking
	  initiator) no callbacks are actually required.
	</para>

	<informalfigure>
	  <programlisting>
  tlm_utils::simple_initiator_socket&lt;Or1ksimSC&gt;  dataBus;
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2 id="sec_Or1ksimSC_def_threads">
	<title>
	  Threads
	</title>
      
        <para>
	  The module has a single thread, which executes the instructions of
	  the &iss;. The <function>run</function> function implements this:
	</para>

	<informalfigure>
	  <programlisting>
  void  run();
	  </programlisting>
	</informalfigure>

	<para>
	  The thread is not part of the public interface, but will but will be
	  reused and reimplemented in derived classes later in the application
	  note, so it is declared <literal>protected</literal> and
	  <literal>virtual</literal>.
	</para>
      </sect2>

      <sect2 id="sec_upcall">
	<title>
	  Upcalls
	</title>

	<para>
	  The &or1ksim; &iss; makes requests to read and write peripherals via
	  the upcalls passed as arguments to <function>or1ksim_init</function>
	  (see <xref linkend="sec_or1ksim_libcals" />).
	</para>

	<para>
	  The &or1ksim; &iss; is implemented in C, which cannot easily call
	  C++ class instance functions. The solution is to declare two
	  <emphasis>static</emphasis> member functions which can be called
	  from C. The call to <function>or1ksim_init</function> also received
	  the address of the actual C++ class instance (cast to
	  <literal>void&nbsp;*</literal>). This pointer is passed back with
	  the upcall, so the static function can call the corresponding
	  instance function.
	</para>

	<para>
	  A total of 4 functions are needed, one static and one instance each
	  for read and write. The static functions use the native C/C++ types
	  (unsigned long int), but convert to defined fixed width types for
	  the instance functions. The native &systemc; 64-bit unsigned type is
	  used for the address (which is always 64 bits in &tlm2; function
	  calls) and the <firstterm>&posix;</firstterm> 32-bit unsigned data
	  type is used for the byte enable mask and data.
	</para>

	<para>
	  These upcall functions are not changed throughout this application
	  note, so are declared private.
	</para>

	<informalfigure>
	  <programlisting>
static int  staticReadUpcall (void              *instancePtr,
                              unsigned long int  addr,
                              unsigned char      mask[],
                              unsigned char      rdata[],
                              int                dataLen);

static int  staticWriteUpcall (void              *instancePtr,
                               unsigned long int  addr,
                               unsigned char      mask[],
                               unsigned char      wdata[],
                               int                dataLen);

int         readUpcall (unsigned long int  addr,
                        unsigned char      mask[],
                        unsigned char      rdata[],
                        int                dataLen);

int         writeUpcall (unsigned long int  addr,
                         unsigned char      mask[],
                         unsigned char      wdata[],
                         int                dataLen);
	  </programlisting>
	</informalfigure>

        <caution>
	  <para>
	    It might seem logical to use the &systemc; limited precision
	    types, rather than the &posix; types. However the &systemc; types
	    are <emphasis>not</emphasis> native C++ types, so will not cast as
	    expected.
	  </para>
	</caution>

	<para>
	  The transport mechanism is common to both, so provided in a utility
	  function, <function>doTrans</function>. This function will be used
	  and re-implemented in derived classes, so is declared
	  <literal>protected</literal> and <literal>virtual</literal>.
	</para>

	<para>
	  When invoked, each upcall will need to populate a new payload. Since
	  this is something local in both scope and extent to the upcall and
	  its lifetime, the instinct is to declare it as an automatic variable
	  within each upcall.
	</para>

	<para>
	  However the &tlm2; generic payload has a large underlying structure
	  and complex initialization, so such a local declaration carries a
	  significant performance penalty if it is constructed each time the
	  upcall is used.
	</para>

	<para>
	  Since only one upcall is ever in use at any one time, we can declare
	  the payload as a class instance variable. Since it is only used by
	  the upcalls, it can be private to this class.
	</para>

	<informalfigure>
	  <programlisting>
  tlm::tlm_generic_payload  trans;
	  </programlisting>
	</informalfigure>

	<note>
	  <para>
	    The performance overhead in instantiating a generic payload is not
	    mentioned in the &tlm2; <acronym>LRM</acronym>. I am indebted to Robert
	    <foreignphrase>G&uuml;nzel</foreignphrase> for bringing the issue
	    to my attention.
	  </para>
	</note>

      </sect2>
    </sect1>

    <sect1 id="sec_iss_wrapper_impl">
      <title>
	&or1ksim; Wrapper Module Class Implementation
      </title>

      <para>
	The class implementation for <classname>Or1ksimSC</classname> may be
	found found in <filename>sysc-modules/logger/Or1ksimSC.cpp</filename>
	in the distribution.
      </para>

      <sect2>
	<title>
	  Headers and Macros
	</title>

	<para>
	  All the definitions required are obtained from the definition file:
	</para>

	<informalfigure>
	  <programlisting>
#include "Or1ksimSC.h"
	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of a C++ class that is a &systemc; module with
	  &systemc; threads (<literal>SC_THREAD</literal>), methods
	  (<literal>SC_METHOD</literal>) or clocked threads
	  (<literal>SC_CTHREAD</literal>) requires a number of definitions for
	  that class to be set up using the <literal>SC_HAS_PROCESS</literal>
	  macro.
	</para>

	<informalfigure>
	  <programlisting>
SC_HAS_PROCESS( Or1ksimSC );
	  </programlisting>
	</informalfigure>

	<caution>
	  <para>
	    The <literal>SC_HAS_PROCESS</literal> macro is a common cause of
	    confusion with new users to &systemc;. It doesn't appear in the
	    user guide and tutorial examples. The reason is that those
	    examples use the <literal>SC_CTOR</literal> macro to define the
	    constructor for the class, which provides the same definitions as
	    the <literal>SC_HAS_PROCESS</literal> macro.
	  </para>

	  <para>
	    The <literal>SC_CTOR</literal> macro can only be used where the
	    constructor's implementation is given within the class
	    definition. As explained in <xref linkend="sec_coding_conv" />,
	    this application note follows the standard C++ practice of
	    separating the class definition from its implementation, with the
	    constructor implemented separately from the class definition.
	  </para>

	  <para>
	    In cases such as this, where the constructor implementation is
	    separate from the definition, &systemc; requires that the
	    <literal>SC_HAS_PROCESS</literal> macro is used before the code of
	    any class functions. The macro is only required if the constructor
	    uses <literal>SC_METHOD</literal>, <literal>SC_THREAD</literal> or
	    <literal>SC_CTHREAD</literal> to associate a process with the
	    module class.
	  </para>
	</caution>

      </sect2>

      <sect2>
	<title>
	  Constructor
	</title>

	<para>
	  The constructor passes the name to the constructors of its base
	  class (<classname>sc_module</classname>) and its simple initiator socket
	  (<literal>dataBus</literal>), then calls the
	  <function>or1ksim_init</function> function in the &or1ksim; library
	  to initialize the &iss;.
	</para>

	<para>
	  The member function, <function>run</function> is associated with the
	  class as a &systemc; thread, using the <literal>SC_THREAD</literal>
	  macro. It will be called automatically by the &systemc; kernel after
	  elaboration (i.e &systemc; initialization).
	</para>

	<informalfigure>
	  <programlisting>
Or1ksimSC::Or1ksimSC ( sc_core::sc_module_name  name,
                       const char              *configFile,
                       const char              *imageFile ) :
  sc_module( name ),
  dataIni( "data_initiator" )
{
  or1ksim_init( configFile, imageFile, this, staticReadUpcall,
                staticWriteUpcall );

  SC_THREAD( run );               // Thread to run the ISS

}       /* Or1ksimSC() */
	  </programlisting>
	</informalfigure>


      </sect2>

      <sect2 id="sec_Or1ksimSC_impl_thread">
	<title>
	  Thread
	</title>

      <para>
	The main thread, <function>run</function>, invokes the &or1ksim;
	&iss; to run for ever (by passing a negative time argument). The &iss;
	will use the upcalls (see <xref linkend="sec_upcall" />) to request
	reads from and writes to the peripheral address space.
      </para>

      <para>
	The thread is called automatically when the &systemc; kernel has
	completed elaboration (i.e. is initialized).
      </para>

      <informalfigure>
	<programlisting>
void
Or1ksimSC::run()
{
  scLastUpTime   = sc_core::sc_time_stamp();
  or1kLastUpTime = or1ksim_time();

  (void)or1ksim_run( -1.0 );

}       // Or1ksimSC()
	</programlisting>
      </informalfigure>

      </sect2>

      <sect2>
	<title>
	  Upcalls
	</title>

      <para>
	Two functions are declared as static member functions to implement the
	upcalls from the &or1ksim; library (see <xref linkend="sec_upcall" />
	for an explanation of why these functions are static).
      </para>

      <para>
	The static functions receive the pointer to the
	<classname>Or1ksimSC</classname> instance which originally started the
	&or1ksim; &iss; (provided as an argument to
	<function>or1ksim_init</function> described in <xref
	linkend="sec_Or1ksimSC_impl_thread" />).
      </para>

      <para>
	This allows each static function to call the instance function which
	implements the upcall, as shown here with
	<function>staticReadUpcall</function>:
      </para>

      <informalfigure>
	<programlisting>
int
Or1ksimSC::staticReadUpcall (void              *instancePtr,
                             unsigned long int  addr,
                             unsigned char      mask[],
                             unsigned char      rdata[],
                             int                dataLen)
{
  Or1ksimSC *classPtr = (Or1ksimSC *) instancePtr;
  return  classPtr->readUpcall (addr, mask, rdata, dataLen);

}       // staticReadUpcall()
	</programlisting>
      </informalfigure>

        <para>
	  The <varname>instancePtr</varname> argument allows identification of
	  the particular instance of the class which called
	  <function>or1ksim_run</function> and hence to which the upcall is
	  directed. The remaining arguments are passed to the instance method
	  unchanged.
	</para>

	<caution>
	  <para>
	    It might be thought that providing a direct upcall to the C++
	    upcall functions of the class would be more efficient, using the C++
	    member reference operator (<literal>::*</literal>). However the
	    linkage to a member is much more complex (to cope with inheritance
	    and overloading). Lack of standardization in the C++
	    <firstterm>Application Binary Interface</firstterm>
	    (<acronym>ABI</acronym>) means that such linkage between C and C++
	    will not necessarily work.
	  </para>

	  <para>
	    Linkage to static functions is much simpler and usually works
	    between C and C++. So the approach used here is more reliable.
	  </para>
	</caution>

	<para>
	  The upcalls from the &iss; generate the transactional
	  activity. These functions set up the payload, execute the transaction
	  (i.e exchange the payload and result with the target) and return the
	  result to the &iss;.
	</para>

	<para>
	  The example here is coded in a very simple fashion, in the knowledge
	  that the requests to read are always four bytes long (the &or1k; has
	  a simple 32 bit bus), possibly with some bytes masked out for byte
	  and half-word reads. This matches the default
	  <literal>BUSWIDTH</literal> of the simple initiator socket.
	</para>

	<para>
	  As noted in <xref linkend="sec_upcall" />, the payload is declared
	  as a class instance variable, rather than locally here for
	  performance reasons. This has the added benefit that it will also
	  work should we ever convert the model to using a non-blocking
	  socket, where the lifetime of the payload would need to be longer
	  than the lifetime of the upcall. &tlm2; requires that the payload,
	  data and mask fields all remain valid for the duration of the
	  complete transaction.
	</para>

      </sect2>

      <sect2 id="sec_Or1ksimSC_impl_btrans">
	<title>
	  Blocking Transport
	</title>

	<para>
	  Once the payload fields are set up, the
	  <function>doTrans</function> function (which is used for both read
	  and write) is called to transport the payload to the target and
	  return the result.
	</para>

	<para>
	  The transport function requires a time to be supplied, even when
	  timing is not being used (as in this case). This must be time
	  variable, not a constant, since the target can update the value. A
	  dummy variable is declared with zero time and passed to the blocking
	  transport function of the socket with the payload.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_time  dummyDelay = sc_core::SC_ZERO_TIME;
  dataBus->b_transport( trans, dummyDelay );
	  </programlisting>
	</informalfigure>

        <para>
	  This implementation is sufficient for modeling just the &or1ksim;
	  &iss; in &systemc;. However at no time does the thread execute a
	  &systemc; <function>wait</function> call. In the absence of any such
	  yield, no other thread would be able to execute. This will be remedied
	  in <xref linkend="chap_uart" /> when other threads are added to model
	  peripherals.
	</para>

      </sect2>
    </sect1>
  </chapter>

  <chapter id="chap_iss_wrapper_test">
    <title>
      Testing the &or1ksim; &iss; &tlm2; Wrapper
    </title>

    <para>
      The test configuration was shown earlier in <xref linkend="fig_iss_test"
      />. For this a simple logger is needed, which must implement a &tlm2;
      simple target socket.
    </para>

    <para>
      In addition, a simple embedded application is needed to run on the
      &or1ksim; &iss;, which will make reads and writes to peripheral address
      space, which can be detected by the logger.
    </para>

    <para>
      All the behavior is in the callback function&mdash;there are no &systemc;
      threads. This means the logger will be suitable for testing the
      <classname>Or1ksimSC</classname> wrapper module, even though its thread
      never yields (see <xref linkend="sec_Or1ksimSC_impl_btrans" />).
    </para>

    <para>
      The code for the logger module (<filename>LoggerSC.cpp</filename> and
      <filename>LoggerSC.h</filename>) and the main program
      (<filename>loggerMainSC.cpp</filename> may be found with the &or1ksim;
      wrapper code in the <filename>sysc-models/logger</filename> directory of
      the distribution.
    </para>

    <sect1>
      <title>
	Overall Design of the Test Program
      </title>

      <para>
	The key aspects of the overall program are captured in a &uml; class
	diagram and a &uml; sequence diagram, showing how a read transaction
	is processed.
      </para>

      <sect2>
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the design is shown in <xref
	  linkend="fig_logger_class_diagram" />. The &or1ksim; wrapper class
	  creates its own &tlm2; convenience initiator port, with which a &tlm2;
	  generic payload will be associated to carry traffic. Conversely the
	  logger class creates its own &tlm2; convenience target port through
	  which it will receive the associated payload. The class structure of
	  the underlying SystemC &tlm2; environment connecting initiator and
	  target ports is not shown.
	</para>

	<figure id="fig_logger_class_diagram">
	  <title>
	    Class diagram for the &or1ksim; test model.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="logger-classes.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="logger-classes.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2>
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating the handling of a read transaction
	  for the design is shown in <xref linkend="fig_logger_sequence_diagram"
	  />. The &or1ksim; wrapper class invokes the underlying &or1ksim;
	  &iss; through its <function>run</function> function.
	</para>

	<para>
	  The <function>run</function> function executes without further
	  interruption. Whenever it needs to read or write via the external
	  bus, it uses the <function>staticReadUpcall</function> or
	  <function>staticWriteUpcall</function> function. This in turn
	  invokes the <function>readUpcall</function> function for the wrapper
	  instance.
	</para>

	<para>
	  The various &tlm2; generic payload functions are used to set up the
	  payload, before the payload is passed to the initiator port using
	  its <function>b_transport</function> function (for simplicity the
	  call to <function>do_trans</function> is omitted from the
	  diagram). The packet is passed internally to the connected target
	  port, where it invokes the handler function
	  (<function>loggerReadWrite</function>) to handle the payload. The
	  payload is modified as appropriate before being returned to the
	  initiator.
	</para>

	<figure id="fig_logger_sequence_diagram">
	  <title>
	    Sequence diagram for a read transaction with the &or1ksim; test
	    model.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="logger-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="logger-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<note>
	  <para>
	    All the actions in this diagram are synchronous. There is a single
	    thread of control, which flows from the wrapper module to the
	    logger module as a transaction is processed.
	  </para>
	</note>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Definition of the &tlm2; Logger Module
      </title>

      <para>
	The code for the logger module definition may be found in
	<filename>sysc-models/logger/LoggerSC.h</filename> in the
	distribution.
      </para>

      <sect2>
	<title>
	  Include Files
	</title>

	<para>
	  The logger is based on the &tlm2; convenience simple target socket,
	  so needs the appropriate header, in addition to the standard &tlm2;
	  header:
	</para>

	<informalfigure>
	  <programlisting>
#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Module Declaration and Constructor
	</title>

        <para>
	  The class is a standard &systemc; module:
	</para>

	<informalfigure>
	  <programlisting>
class LoggerSC
: public sc_core::sc_module
	  </programlisting>
	</informalfigure>

        <para>
	  A custom constructor is needed, which will be used to register the
	  callback function for the simple target convenience socket blocking
	  transport.
	</para>

	<informalfigure>
	  <programlisting>
  LoggerSC( sc_core::sc_module_name  name );
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Public Interface
	</title>

	<para>
	  The public interface is the single simple target convenience
	  socket.
	</para>

	<informalfigure>
	  <programlisting>
  tlm_utils::simple_target_socket&lt;LoggerSC&gt;  loggerPort;
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Blocking Transport
	</title>

	<para>
	  Blocking transport is via a callback function:
	</para>

	<informalfigure>
	  <programlisting>
  void  loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                         sc_core::sc_time         &amp;delay );
	  </programlisting>
	</informalfigure>

        <para>
	  All the behavior of the module is captured in this callback
	  function. There are no &systemc; threads required.
	</para>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Implementation of the &tlm2; Logger Module
      </title>

      <para>
	The code for the logger module implementation may be found in
	<filename>sysc-models/logger/LoggerSC.cpp</filename> in the
	distribution.
      </para>

      <sect2>
	<title>
	  Included Headers
	</title>

	<para>
	  The logger will be doing a certain amount of stream IO, so includes
	  the C++ headers that define stream manipulation functions. The &posix;
	  standard integer types are also included.
      </para>

      <informalfigure>
	<programlisting>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stdint.h&gt;

#include "LoggerSC.h"
	</programlisting>
      </informalfigure>

      </sect2>

      <sect2>
	<title>
	  Constructor
	</title>

        <para>
	  The constructor passes its argument (the module) name to the base
	  class <classname>sc_module</classname> constructor. The body of the
	  function then registers the <function>loggerReadWrite</function>
	  function as the callback for blocking transport to this convenience
	  socket. This means that any initiator which requests blocking
	  transport (by calling the initiator socket's
	  <function>b_transport</function> function) will invoke this callback
	  function in the target.
	</para>

	<informalfigure>
	  <programlisting>
LoggerSC::LoggerSC( sc_core::sc_module_name  name ) :
  sc_module( name )
{
  loggerPort.register_b_transport( this, &amp;LoggerSC::loggerReadWrite );

}       // Or1ksimSC()
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The callback function, <function>loggerReadWrite</function> records
	  the key information regarding any transaction it receives. The
	  payload is a &tlm2; generic payload, with appropriate access
	  functions. In this simple implementation, a length of 4 bytes is
	  assumed for the data in the payload.
	</para>
	
	<para>
	  To get at the data and byte enable mask, the pointers to
	  <literal>unsigned char</literal> are cast to pointers to the &posix;
	  fixed width type, <literal>uint32_t</literal>, as was used with
	  <classname>Or1ksimSC</classname>. Endianness issues due to the byte
	  pointers not being word aligned are not an issue, because the
	  <classname>Or1ksimSC</classname> module also declared them as
	  <literal>uint32_t</literal>.
	</para>

	<informalfigure>
	  <programlisting>
void
LoggerSC::loggerReadWrite( tlm::tlm_generic_payload &amp;payload,
                           sc_core::sc_time         &amp;delay )
{
  // Break out the address, mask and data pointer.

  tlm::tlm_command   comm    = payload.get_command();
  sc_dt::uint64      addr    = payload.get_address();
  unsigned char     *maskPtr = payload.get_byte_enable_ptr();
  unsigned char     *dataPtr = payload.get_data_ptr();

  // Record the payload fields (data only if it's a write)

  const char *commStr;

  switch( comm ) {
  case tlm::TLM_READ_COMMAND:   commStr = "Read";   break;
  case tlm::TLM_WRITE_COMMAND:  commStr = "Write";  break;
  case tlm::TLM_IGNORE_COMMAND: commStr = "Ignore"; break;
  }

  std::cout &lt;&lt; "Logging" &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Command:      "   &lt;&lt; commStr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Address:      0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; (uint64_t)addr &lt;&lt; std::endl;
  std::cout &lt;&lt; "  Byte enables: 0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
            &lt;&lt;std::hex &lt;&lt; *((uint32_t *)maskPtr) &lt;&lt; std::endl;

  if( tlm::TLM_WRITE_COMMAND == comm ) {
    std::cout &lt;&lt; "  Data:         0x" &lt;&lt; std::setw( 8 ) &lt;&lt; std::setfill( '0' )
              &lt;&lt;std::hex &lt;&lt; *((uint32_t *)dataPtr) &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; std::endl;

  payload.set_response_status( tlm::TLM_OK_RESPONSE );  // Always OK

}       // loggerReadWrite()
	  </programlisting>
	</informalfigure>

      </sect2>
    </sect1>

    <sect1 id="sec_logger_main_prog">
      <title>
	The Model Main Program
      </title>

      <para>
	The logger module and the &or1ksim; wrapper module must be connected
	in the main program (<function>sc_main</function> since this is
	&systemc;), and the simulation invoked.
      </para>

      <para>
	The code for the main program may be found in
	<filename>sysc-models/logger/loggerMainSC.cpp</filename> in the
	distribution.
      </para>

      <sect2>
	<title>
	  Included Headers
	</title>

	<para>
	  The program includes the C++ <classname>iostream</classname> header,
	  main &tlm2; header and the header of the two modules which will be
	  used:
	</para>

	<informalfigure>
	  <programlisting>
#include &lt;iostream&gt;

#include "tlm.h"
#include "Or1ksimSC.h"
#include "LoggerSC.h"
	  </programlisting>
	</informalfigure>

	<para>
	  The two <classname>iostream</classname> entities used are brought
	  into the local namespace.
	</para>

	<informalfigure>
	  <programlisting>
using std::cerr;
using std::endl;
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Argument Processing
	</title>

	<para>
	  The program takes two arguments, an &or1ksim; configuration file
	  (described further in <xref linkend="sec_iss_run_test" />) and a
	  binary image to execute on the &or1ksim; &iss; (see <xref
	  linkend="sec_iss_or32_prog" />).
	</para>

	<informalfigure>
	  <programlisting>
int  sc_main( int   argc,
              char *argv[] )
{
  if( argc != 3 ) {
    cerr &lt;&lt; "Usage: TestSC &lt;config_file&gt; &lt;image_file&gt;" &lt;&lt; endl;
    exit( 1 );
  }
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Module Instantiation
	</title>

        <para>
	  Instances of the &or1ksim; &iss; and the logger are created, the
	  &iss; being passed the two program arguments for its initialization.
	</para>

	<informalfigure>
	  <programlisting>
  Or1ksimSC  iss( "or1ksim", argv[1], argv[2] );
  LoggerSC   logger( "logger" );
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Connecting the Modules
	</title>

        <para>
	  The target socket of the logger (<literal>loggerPort</literal>) is
	  connected by passing it as argument to the initiator socket of the
	  &iss; (<literal>dataBus</literal>). The C++ function application
	  operator, <literal>()</literal>, is overloaded for initiator sockets
	  to provide this binding function.
	</para>

	<informalfigure>
	  <programlisting>
  iss.dataBus( logger.loggerPort );
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Model Execution
	</title>

	<para>
	  Once the model is instantiated, simulation is invoked to run forever.
	</para>
	  
	<informalfigure>
	  <programlisting>
  sc_core::sc_start();
	  </programlisting>
	</informalfigure>

      </sect2>
    </sect1>

    <sect1 id="sec_iss_or32_prog">
      <title>
	Test Program to Run on the &or1ksim;
      </title>

      <para>
	The test program in <filename>progs-or32/logger-test.c</filename>
	defines a memory mapped volatile data structure and then writes to and
	reads from each element of that structure.
      </para>

      <para>
	The source code for the logger test program may be found in
	<filename>progs-or32/logger-test.c</filename> in the distribution. It
	uses the utility functions (<filename>progs-or32/utils.c</filename>
	and <filename>progs-or32/utils.h</filename>) and the bootloader
	(<filename>progs-or32/start.s</filename>).
      </para>

      <sect2>
	<title>
	  The Utility Functions
	</title>

	<para>
	  The test program uses some simple utility functions which can write
	  characters (<function>simputc</function>), string
	  (<function>simputs</function>) and hexadecimal numbers
	  (<function>simputh</function>). Its header is included:
	</para>

	<informalfigure>
	  <programlisting>
#include "utils.h"
	  </programlisting>
	</informalfigure>

	<para>
	  The utilities' implementation can be found in
	  <filename>utils.c</filename>.
	</para>

      </sect2>

      <sect2>
	<title>
	  Memory Mapped Data Structure
	</title>

	<para>
	  The memory mapped address is defined in the configuration of
	  &or1ksim; (see <xref linkend="sec_iss_run_test" />) to be
	  0x90000000. This is set as a defined constant in the test program.
	</para>

	<informalfigure>
	  <programlisting>
#define BASEADDR  0x90000000
	  </programlisting>
	</informalfigure>

	<para>
	  The memory mapped structure consists of a byte, half word (16 bits)
	  and full word (32 bits), all declared as <literal>volatile</literal>
	  within the <literal>struct</literal>. These are all declared with
	  the C types, which for the &or1k; tool chain are known to correspond
	  to these sizes.
	</para>

	<informalfigure>
	  <programlisting>
struct  testdev
{
  volatile unsigned char       byte;
  volatile unsigned short int  halfword;
  volatile unsigned long  int  fullword;
};
	  </programlisting>
	</informalfigure>

        <para>
	  The main program declares a pointer to this
	  <literal>struct</literal> at the <literal>BASEADDR</literal>, along
	  with 3 variables to hold the results of the various sized results
	  when reading.
	</para>

	<informalfigure>
	  <programlisting>
main()
{
  struct testdev *dev = (struct testdev *)BASEADDR;

  unsigned char       byteRes;
  unsigned short int  halfwordRes;
  unsigned long int   fullwordRes;
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Checking Write Access
	</title>

	<para>
	  The details of each write are logged and the value then written. (In
	  the absence of a <function>printf</function>, the logging is
	  necessarily cumbersome).
	</para>

	<informalfigure>
	  <programlisting>
  simputs( "Writing byte 0xa5 to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );
  dev->byte     =       0xa5;

  simputs( "Writing half word 0xbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );
  dev->halfword =     0xbeef;

  simputs( "Writing full word 0xdeadbeef to address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );
  dev->fullword = 0xdeadbeef;
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Checking Read Access
	</title>

        <para>
	  The values are then read back. No results are expected (the logger
	  does not set any values), but this should check the process behaves
	  as expected.
	</para>

	<informalfigure>
	  <programlisting>
  byteRes = dev->byte;
  simputs( "Read 0x" );
  simputh(  byteRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->byte)) );
  simputs( "\n" );

  halfwordRes = dev->halfword;
  simputs( "Read 0x" );
  simputh( halfwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->halfword)) );
  simputs( "\n" );

  fullwordRes = dev->fullword;
  simputs( "Read 0x" );
  simputh( fullwordRes );
  simputs( " from address 0x" );
  simputh( (unsigned long int)(&amp;(dev->fullword)) );
  simputs( "\n" );
	  </programlisting>
	</informalfigure>

        <para>
	  At the end of the program, the utility
	  <function>simexit</function> is used. This not only terminates the
	  program, but will also exit the simulation.
	</para>

      </sect2>

      <sect2>
	<title>
	  Program Compilation
	</title>

	<para>
	  The program is compiled as part of the overall &make; and will be
	  found in the <filename>progs-or32</filename> sub-directory of the
	  main build directory. A custom linker script ensures the program is
	  loaded with its bootloader at the correct address, with its entry
	  point at the &or1k; reset vector (<constant>0x100</constant>).
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_iss_run_test">
      <title>
	Running the Test
      </title>
      <sect2>
	<title>
	  Compiling the &systemc; Model
	</title>

	<para>
	  The complete program is compiled from the top level &make; file. Both a
	  standalone program (<filename>logger</filename>) and a
	  <command>libtool</command> compliant library
	  (<filename>liblogger.la</filename>) are created. The library
	  provides a convenient mechanism for reusing the code from this
	  model, when creating subsequent models which use derived classes.
	</para>

	<para>
	  The SystemC modules are all compiled with
	  <literal>SC_INCLUDE_DYNAMIC_PROCESSES</literal> defined when
	  using &tlm2;. This is a requirement for using the &tlm2;
	  library. The final executable is linked against the &systemc;
	  library.
	</para>

      </sect2>
      <sect2>
	<title>
	  Configuring the &or1k; &or1ksim; &iss;
	</title>

	<para>
	  The &or1ksim; &iss; is configured using a textual configuration
	  file, described in more detail in <xref linkend="ref_app_note_2"
	  endterm="ref_app_note_2_xr" /> <xref linkend="ref_app_note_2"
	  />. For the modified &or1ksim; &iss;, <literal>generic</literal>
	  peripherals can be added (see <xref
	  linkend="sec_or1ksim_generic_sec" />), which will cause code to call
	  out via the upcall mechanism to the &or1ksim; &systemc; wrapper
	  module (see <xref linkend="sec_upcall" />).
	</para>

	<para>
	  The &or1ksim; configuration file for this example is in
	  <filename>simple.cfg</filename>. It disables all the standard
	  peripherals and specifies one block of memory from address 0x0. It
	  adds a <literal>generic</literal> peripheral allowing byte, half
	  word and full word access to addresses mapped from 0x90000000 to
	  0x90000007, with the following configuration file entry
	</para>

	<informalfigure>
	  <programlisting>
section generic
  enabled      =          1
  baseaddr     = 0x90000000
  size         =        0x8
  name         = "External UART"
  byte_enabled =          1
  hw_enabled   =          1
  word_enabled =          1
end
	  </programlisting>
	</informalfigure>

      </sect2>
      <sect2>
	<title>
	  Running the Compiled Model
	</title>

        <para>
	  The compiled program can be executed by passing in as arguments
	  the &or1ksim; configuration file and the &or1k; binary. The result
	  is shown in <xref linkend="fig_logger-test" />.
	</para>

	<figure id="fig_logger-test">
	  <title>
	    Output from the logger test of the &or1ksim; wrapper module.
	  </title>

	  <informalfigure>
	    <screen>
$ ./sysc-models/logger/logger ../simple.cfg progs-or32/logger-test

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED

   ... &lt;Or1ksim initialization messages&gt;

Writing byte 0xa5 to address 0x090000000
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0x000000ff
  Data:         0x003f54a5

Writing half word 0xbeef to address 0x090000002
Logging
  Command:      Write
  Address:      0x90000000
  Byte enables: 0xffff0000
  Data:         0xefbe8fc4

   ... &lt;More test program output&gt;

Read half word 0x0FFFF from address 0x090000002
Logging
  Command:      Read
  Address:      0x90000004
  Byte enables: 0xffffffff

Read full word 0x028372F09 from address 0x090000004
exit(0)
@reset : cycles 0, insn #0
@exit  : cycles 33297, insn #16581
 diff  : cycles 33297, insn #16581
$ 
	    </screen>
	  </informalfigure>

	</figure>

	<para>
	  Each access from the application program generates the expected
	  transactional access. All accesses are 32 bits wide, but for byte
	  and half-word access the relevant bytes are masked off. The reads
	  return meaningless values (the logger was not designed to package a
	  return value), but in each case the value returned fits in the size
	  requested as expected.
	</para>

	<note>
	  <para>
	    The &or1ksim; &iss; can be configured to model little-endian
	    architectures. The &tlm2; payloads are always packed with data
	    using the endianness of the model.
	  </para>

	  <para>
	    If the exercise were repeated with a little-endian version of
	    &or1ksim; the addresses of the access would be unchanged (they are
	    word aligned), but the byte enable masks for the byte and half
	    word accesses would be inverted.
	  </para>
	</note>

      </sect2>
    </sect1>
  </chapter>

<chapter id="chap_uart">
    <title>
      Modeling Peripherals
    </title>

    <para>
      This example uses a single peripheral, a &uart;. The &uart; model is
      based on National Semiconductor 16450 design. The &or1ksim; &iss;
      wrapper must be extended to work with this &uart;.
    </para>

    <para>
      The code for the &uart; module (<filename>UartSC.cpp</filename> and
      <filename>UartSC.h</filename>) may be found with the extended &or1ksim;
      wrapper code (<filename>Or1ksimExtSC.cpp</filename> and
      <filename>Or1ksimExtSC.h</filename>) in the
      <filename>sysc-models/simple-soc</filename> directory of the
      distribution.
    </para>

    <sect1>
      <title>
	Details of the 16450 &uart;
      </title>

      <para>
	The 16450 &uart; is a very long established industry component. Data
	written a byte at a time into the transmit buffer is converted to
	serial pulses on the output (Tx) pin. Serial pulses on the input (Rx)
	pin are recognized and converted to byte values, which can be read
	from the receive buffer. Typically Rx and Tx are connected to a
	terminal and keyboard which can generate and recognize the pulses of
	data. The &uart; can also generate additional signals for terminals and
	keyboards to provide physical flow control, but that is beyond the
	scope of this model. The key interfaces are shown in <xref
	linkend="fig_uart" />.
      </para>

	<figure id="fig_uart">
	  <title>
	    16450 &uart;: Key interfaces.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="uart.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      <para>
	The 16450 &uart; specifies a set of registers which control the &uart;
	behavior. On the Tx/Rx side, this includes setting the board rate and
	the pattern of stop, start and data bits. On the CPU side this
	includes configuring interrupt behavior (if any) and setting flags to
	show the status of transmit and receive buffers. The registers are
	shown in <xref linkend="tab_ns_16450_regs" />.
      </para>

      <table id="tab_ns_16450_regs" frame='all'>
	<title>
	  NS 16450 &uart; Registers
	</title>
	<tgroup cols='4' align="left" colsep="1" rowsep="1">
	  <colspec colwidth="4*" colname="address" />
	  <colspec colwidth="4*" colname="register" />
	  <colspec colwidth="2*" colname="rw" />
	  <colspec colwidth="16*" colname="description" />

	  <thead>
	    <row>
	      <entry>
		Address
	      </entry>
	      <entry>
		Register
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		Description
	      </entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry morerows="2">
		0
	      </entry>
	      <entry>
		<literal>RXBUF</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for read data.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>TXBUF</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 0 (see register
		  <literal>LCR</literal>, this is the buffer for data to be
		  written.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLL</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the low byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry morerows="1">
		1
	      </entry>
	      <entry>
		<literal>IER</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  The interrupt enable register. The lower 4 bits control
		  which events generate an interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		<literal>DLH</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  When the <literal>DLAB</literal> bit is 1 (see register
		  <literal>LCR</literal>, this is the high byte of the divisor
		  latch (which controls &uart; performance)
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		2
	      </entry>
	      <entry>
		<literal>IIR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Interrupt identification register. Bit 0 indicates if an
		  interrupt is pending, bits 1-2 the reason for the
		  interrupt.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		3
	      </entry>
	      <entry>
		<literal>LCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Line control register. Various bits controlling the behavior
		  of the &uart;. Of these, <literal>DLAB</literal>, bit 7, the
		  divisor latch access bit is important, because it controls
		  the behavior of registers 0
		  (<literal>RXBUF</literal>/<literal>TXBUF</literal>/<literal>DLL</literal>)
		  and 1 (<literal>IER</literal>/<literal>DLH</literal>).
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		4
	      </entry>
	      <entry>
		<literal>MCR</literal>
	      </entry>
	      <entry align="center">
		W
	      </entry>
	      <entry>
		<para>
		  Modem control register. Bits 0-4 control the
		  behavior of the modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		5
	      </entry>
	      <entry>
		<literal>LSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Line status register. Bits 0-6 report the status of the
		  &uart;. Of these, DR, bit 0, receiver data ready is
		  important, indicating there is valid data in
		  <literal>RXBUF</literal>.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		6
	      </entry>
	      <entry>
		<literal>MSR</literal>
	      </entry>
	      <entry align="center">
		R
	      </entry>
	      <entry>
		<para>
		  Modem Status Register. Bits reporting the state of the
		  modem.
		</para>
	      </entry>
	    </row>

	    <row>
	      <entry>
		7
	      </entry>
	      <entry>
		<literal>SCR</literal>
	      </entry>
	      <entry align="center">
		R/W
	      </entry>
	      <entry>
		<para>
		  Scratch register. Not used by the &uart;, but may be used by
		  the application to store an 8-bit value.
		</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
      </para>

    </sect1>

    <sect1>
      <title>
	&uart; Module Design
      </title>

      <para>
	A transaction level model cannot show all the intricacies of a
	&uart;&mdash;the whole point is to simplify and remove detail.
      </para>

      <para>
	The &tlm; should allow the CPU to read and write registers and
	communicate with a model terminal/keyboard which will send and
	receive characters and generate interrupts as appropriate. While all
	writable registers can be written and all readable registers read,
	only those registers and bits of registers which are relevant to this
	level of modeling will have any impact on behavior.
      </para>

      <sect2>
	<title>
	  &uart; Model Interfaces
	</title>

	<para>
	  A &tlm2; socket is the natural model for the bus interface to the
	  CPU. However the interface to the terminal is much simpler.
	  Standard byte wide &systemc; buffers
	  (<classname>sc_buffer</classname>) will be suitable, one for the Rx
	  direction and one for Tx. The buffer is implemented for the Rx
	  direction and a port to a buffer for the Tx direction. The terminal
	  (see <xref linkend="chap_terminal" />) will offer the complementary
	  arrangement.
	</para>

	<note>
	  <para>
	    A &systemc; buffer (<classname>sc_buffer</classname>) is used
	    rather than a &systemc; signal (<classname>sc_signal</classname>),
	    since it must report all writes to the buffer, rather than just
	    changes to the value (as would be the case with a signal). At this
	    level of modeling it is quite possible that two identical bytes
	    would follow each other.
	  </para>
	</note>

	<para>
	  The interrupt is not modeled as an interface at this stage, so the
	  &uart; will only be suitable for polled use. An interrupt interface
	  is added in <xref linkend="chap_linux" />.
	</para>

      </sect2>

      <sect2>
	<title>
	  &uart; Model Registers
	</title>

	<para>
	  The divisor latch affects the baud rate, which will affect timing of
	  transfers. This will be covered in a later section (see <xref
	  linkend="chap_sync" />), but is not needed for the current untimed
	  model. The value can be written and read, but does not affect
	  behavior.
	</para>

	<para>
	  All interrupts are modeled (see <xref linkend="sec_uart_interrupts"
	  />), so all bits in the interrupt enable and interrupt control
	  register are modeled.
	</para>

	<para>
	  The modem control and status registers are only modeled to the
	  extent of supporting modem loopback. This is used by some software
	  to determine the nature of the modem (for example in the standard
	  &linux; serial line driver).
	</para>

	<para>
	  The line control register sets details of the bit transfers. In a
	  later section (see <xref linkend="chap_sync" />), this will affect
	  the timing of transfers, but it is not relevant to the current
	  untimed model.
	</para>

	<para>
	  In the Line Status Register, the <literal>Data Ready</literal> and
	  <literal>Transmitter Holding Empty</literal>/<literal>Transmitter
	  Empty</literal> bits are the only ones modeled. The model does not
	  distinguish a separate buffer and holding transmit register, so the
	  last two of these will move in step in the model.
	</para>

      </sect2>

      <sect2 id="sec_uart_interrupts">
	<title>
	  &uart; Model Interrupts
	</title>

	<para>
	  All interrupts are modeled, although there is no way to cause a
	  receiver line status interrupt. The modem status interrupt can only
	  be generated when modem loopback is in operation.
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_uart_or1ksim_libext">
      <title>
	 Extending the <classname>Or1ksimSC</classname> Wrapper Module
      </title>

      <para>
	For a larger system, the &or1ksim; wrapper module described in <xref
	linkend="chap_iss_wrapper" /> must be extended. A public function is
	required for peripheral models to establish the CPU endianness.
      </para>

      <para>
	The function must be added to the underlying &or1ksim; library and
	then a wrapper function added to the <classname>Or1ksimSC</classname>
	wrapper module.
      </para>

      <para>
	In <xref linkend="sec_Or1ksimSC_impl_btrans" /> it was noted that the
	absence of any call to <function>wait</function> meant the &or1ksim;
	&iss; could be the only thread in the model. The
	<function>doTrans</function> function must be extended to yield
	after each transaction to allow other threads to run. For our new
	model, this would prevent the &uart; and terminal models from running.
      </para>

      <para>
	These extensions are achieved by defining a new
	class, <classname>Or1ksimExtSC</classname> derived from the existing
	<classname>Or1ksimSC</classname> class. It inherits all the
	functionality of the existing class, re-implements that of the transport
	function, <function>doTrans</function> and adds an additional public
	interface function, <function>isLittleEndian</function>.
      </para>
      <sect2 id="sec_or1ksim_extlib">
	<title>
	  Adding an Endianness Test Function to the &or1ksim; Library
	</title>

	<para>
	  The additional function is straightforward, since endianness is a
	  compile time constant in the &or1ksim; &iss;.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
int  or1ksim_is_le();
		</programlisting>
	      </informalfigure>
	    </para>

	    <para>
	      <function>or1ksim_is_le</function> returns 1 if &or1ksim; is
	      modeling a <firstterm>little&#32;endian</firstterm>
	      architecture, 0 otherwise. It is needed to ensure the payload is
	      packed with the correct byte ordering.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  This function is a standard part of the &or1ksim; 0.3.0 library.
	</para>

      </sect2>
      <sect2>
	<title>
	  Extended &or1ksim; Wrapper Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimExtSC</classname> is derived from
	  <classname>Or1ksimSC</classname>, so the definition file includes
	  its header. The module class can then inherit from that class.
	</para>

	<informalfigure>
	  <programlisting>
#include "Or1ksimSC.h"

class Or1ksimExtSC
: public Or1ksimSC
{
	  </programlisting>
	</informalfigure>

	<para>
	  A custom constructor must be defined. Custom constructors do not
	  inherit, so a new custom constructor is defined just to pass the
	  arguments on to the base class.
	</para>

	<informalfigure>
	  <programlisting>
  Or1ksimExtSC( sc_core::sc_module_name  name,
                const char              *configFile,
                const char              *imageFile );
	  </programlisting>
	</informalfigure>

	<para>
	  A new public function to report the endianness of the underlying CPU
	  model is defined
	</para>

	<informalfigure>
	  <programlisting>
bool  isLittleEndian();
	  </programlisting>
	</informalfigure>

	<para>
	  The <function>doTrans</function> function is reimplemented here, to
	  allow the thread to yield. The function remains protected and
	  virtual, since it will be redefined again later in this application
	  note.
	</para>

	<informalfigure>
	  <programlisting>
virtual void  doTrans( tlm::tlm_generic_payload &amp;trans );
	  </programlisting>
	</informalfigure>

	<para>
	  The extended &or1ksim; wrapper module class,
	  <classname>Or1ksimExtSC</classname>, definition may be found in
	  <filename>sys-models/simple-soc/Or1ksimExtSC.h</filename> in the
	  distribution. It uses the &tlm2; simple target convenience socket
	  (described earlier in <xref linkend="chap_iss_wrapper_test" />).
	</para>

      </sect2>
      <sect2>
	<title>
	  Extended &or1ksim; Wrapper Module Class Implementation
	</title>

	<para>
	  The constructor just passes its arguments to its base class
	</para>

	<informalfigure>
	  <programlisting>
Or1ksimExtSC::Or1ksimExtSC ( sc_core::sc_module_name  name,
                             const char              *configFile,
                             const char              *imageFile ) :
  Or1ksimSC( name, configFile, imageFile )
{
 }      // Or1ksimExtSC()
	  </programlisting>
	</informalfigure>

	<para>
	  <function>isLittleEndian</function> is a simple wrapper for the
	  underlying &or1ksim; &iss; library function<footnote>
	    <para>
	      A technicality is that the &or1ksim; library function,
	      <function>is_little_endian</function> returns an
	      <literal>int</literal>, since C does not have a
	      <literal>bool</literal> type. A C++ compiler would automatically
	      convert one to the other, but making the comparison explicit is
	      good for clarity. The same code will be generated, so there is
	      no loss of performance.
	    </para>
	  </footnote>.
	</para>

	<informalfigure>
	  <programlisting>
bool
Or1ksimExtSC::isLittleEndian()
{
  return (1 == or1ksim_is_le());

}	// or1ksimIsLe()
	  </programlisting>
	</informalfigure>

	<para>
	  The majority of the code for <function>doTrans</function> is
	  unchanged from its implementation in
	  <classname>Or1ksimSC</classname>. The addition is a
	  <function>wait</function> for zero time immediately after the
	  transaction has completed. This allows the &systemc; thread to
	  yield, so that any other threads that are ready can take a turn.
	</para>

	<informalfigure>
	  <programlisting>
  wait( sc_core::SC_ZERO_TIME );
	  </programlisting>
	</informalfigure>

	<caution>
	  <para>
	    The call to <function>wait</function> is essential. &systemc; is
	    not preemptive. Other threads are only considered for execution
	    when the currently executing thread yields. If the code were to
	    return here, control would pass back to the underlying &or1ksim;
	    &iss; until its next upcall, with no opportunity for another
	    &systemc; thread (such as that for the &uart; or terminal) to
	    execute.
	  </para>

	  <para>
	    The implementation currently is untimed, so a zero delay wait is
	    perfectly acceptable. That just gives all the other untimed
	    threads a turn at execution.
	  </para>

	  <para>
	    The logger described in <xref linkend="chap_iss_wrapper_test" />
	    worked without this call to <function>wait</function>, because
	    it had no thread&mdash;all its functionality was in the blocking
	    transaction callback function. This is part of the same thread as
	    the original transport call from the initiator port in the
	    &or1ksim; wrapper.
	  </para>
	</caution>

	<para>
	  The extended &or1ksim; wrapper module class,
	  <classname>Or1ksimExtSC</classname> implementation may be found in
	  <filename>sys-models/simple-soc/Or1ksimExtSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>

    <sect1>
      <title>
	&uart;: Module Class Definition
      </title>

      <para>
	The &uart; module class, <classname>UartSC</classname> definition may
	be found in <filename>sys-models/simple-soc/UartSC.h</filename> in the
	distribution. It uses the &tlm2; simple target convenience socket
	(described earlier in <xref linkend="chap_iss_wrapper_test" />).
      </para>

      <sect2>
	<title>
	  Headers and Constant Definitions
	</title>

	<para>
	  The header files for &tlm2; and the simple target convenience
	  socket are included.
      </para>

      <informalfigure>
	<programlisting>
#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"
	</programlisting>
      </informalfigure>

      <para>
	Convenience constants for the address mask, named register offsets and
	bit fields are then defined. The address mask is needed, since in this
	simple &soc; model there is no arbiter/decoder to strip out the higher
	order bits from the address before the transaction is sent to the
	&uart;.
      </para>

      <informalfigure>
	<programlisting>
#define UART_ADDR_MASK      7     // Mask for addresses (3 bit bus)
	</programlisting>
      </informalfigure>

      <para>
	Named constants are defined giving the address offset of each register
	of the &uart;
      </para>

      <informalfigure>
	<programlisting>
#define UART_BUF  0               // R/W: Rx/Tx buffer, DLAB=0
#define UART_IER  1             // R/W: Interrupt Enable Register, DLAB=0
#define UART_IIR  2             // R: Interrupt ID Register
#define UART_LCR  3             // R/W: Line Control Register
#define UART_MCR  4             // W: Modem Control Register
#define UART_LSR  5             // R: Line Status Register
#define UART_MSR  6             // R: Modem Status Register
#define UART_SCR  7             // R/W: Scratch Register
	</programlisting>
      </informalfigure>

        <para>
	  Bit masks are declared for each of the bits and bit fields of
	  interest in the &uart;. For example the interrupt identification
	  register needs a mask for the pending bit of a mask for the two bits
	  representing the highest priority interrupt and a mask for each
	  possible interrupt.
	</para>

	<informalfigure>
	  <programlisting>
#define UART_IIR_IPEND  0x01    // Interrupt pending (active low)

#define UART_IIR_MASK   0x06    // the IIR status bits
#define UART_IIR_RLS    0x06    // Receiver line status
#define UART_IIR_RDA    0x04    // Receiver data available
#define UART_IIR_THRE   0x02    // Transmitter holding reg empty
#define UART_IIR_MOD    0x00    // Modem status
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Class Declaration and Constructor
	</title>

        <para>
	  The main class is a standard &systemc; module class derived from
	  <classname>sc_core::sc_module</classname>.
	</para>

	<informalfigure>
	  <programlisting>
class UartSC
: public sc_core::sc_module
{
	  </programlisting>
	</informalfigure>

	<para>
	  The module has a customized constructor, specifying an input clock
	  rate (which in the &soc; example will be the &soc; clock rate), and a flag
	  to indicate the endianness of the model.
	</para>

	<informalfigure>
	  <programlisting>
  UartSC( sc_core::sc_module_name  name,
          unsigned long int        _clockRate,
          bool                     _isLittleEndian );
	  </programlisting>
	</informalfigure>

      </sect2>

      <sect2>
	<title>
	  Public Interface
	</title>

	<para>
	  The interfaces to the &uart; model are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      The simple target convenience socket, <literal>bus</literal>,
	      representing the bus from the CPU;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A byte wide &systemc; buffer
	      (<classname>sc_buffer&lt;unsigned&nbsp;char&gt;</classname>) for
	      the Rx pin; and
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      A byte wide &systemc; output port
	      (<classname>sc_out&lt;unsigned&nbsp;char&gt;</classname>) for
	      the Tx pin.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  No external port is provided for the interrupt at this stage. That
	  will be added in <xref linkend="chap_linux" />
	</para>

      </sect2>

      <sect2>
	<title>
	  &systemc; Processes
	</title>

	<para>
	  A &systemc; thread, <function>busThread</function>, is provided to
	  handle transactions arriving on the bus. A &systemc; method,
	  statically sensitive to writes to the Rx buffer is used to handle
	  bytes arriving in the Rx buffer.
	</para>

	<note>
	  <para>
	    Unlike threads, &systemc; methods may not yield by calling
	    <function>wait</function>. A &systemc; method is started when one
	    of its static sensitivities is triggered and runs to
	    completion. It is suitable here, where it runs when a character is
	    received, copying that character to the &uart;
	    <literal>RXBUF</literal> register and then exiting.
	  </para>

	  <para>
	    it is worth using &systemc; methods whenever possible, because
	    they can potentially be implemented more efficiently than threads.
	  </para>
	</note>

      </sect2>

      <sect2>
	<title>
	  Blocking Transport Callback
	</title>

	<para>
	  The blocking transport callback function is
	  <function>busReadWrite</function>. This in turn calls for two
	  separate functions which implement read specific
	  (<function>busRead</function>) and write specific
	  (<function>busWrite</function>) behavior.
	</para>

      </sect2>

      <sect2>
	<title>
	  Utility Functions
	</title>

	<para>
	  A utility function, <function>modemLoopback</function> determines
	  the state of registers and generates an interrupt in the event of
	  modem loopback being requested (a bit in the modem control
	  register). It is used by the <function>busRead</function> and
	  <function>busWrite</function> functions.
	</para>

	<para>
	  Three utility functions are provided to handle
	  interrupts. <function>setIntrFlags</function> sets the interrupt
	  indication register according to which interrupts are currently
	  pending. <function>genIntr</function> generates an interrupt and
	  <function>clrIntr</function> clears an interrupt. In this
	  implementation these functions ensure all register flags are set
	  correctly but do not drive an external interrupt signal.
	</para>

	<para>

	  A set of convenience utilities are provided to set and clear flags
	  in registers (<function>set</function> and
	  <function>clear</function>) and to test the state of a flag bit in a
	  register (<function>isSet</function> and
	  <function>isClear</function>).
	</para>

      </sect2>

      <sect2>
	<title>
	  &uart; State
	</title>

	<para>
	  <classname>struct regs</classname> is used to hold
	  the value of each register. There are ten of these, since register
	  0 is really two registers, depending on whether it is being read
	  (<literal>rbr</literal>) or written (<literal>thr</literal>) and the
	  divisor latch is really an extra 16 bit register.
	</para>

	<informalfigure>
	  <programlisting>
  struct {
    unsigned char       rbr;            // R: Rx buffer,
    unsigned char       thr;            // R: Tx hold reg,
    unsigned char       ier;            // R/W: Interrupt Enable Register
    unsigned char       iir;            // R: Interrupt ID Register
    unsigned char       lcr;            // R/W: Line Control Register
    unsigned char       mcr;            // W: Modem Control Register
    unsigned char       lsr;            // R: Line Status Register
    unsigned char       msr;            // R: Modem Status Register
    unsigned char       scr;            // R/W: Scratch Register            
    unsigned short int  dl;             // R/W: Divisor Latch
  } regs;
	  </programlisting>
	</informalfigure>

	<para>
	  An additional register, <literal>intrPending</literal>, holds flags
	  (corresponding to the interrupt enable register bits) indicating which
	  interrupts are currently pending. A flag initialized at construction
	  records the model endianness, <literal>isLittleEndian</literal>.
	</para>

      </sect2>

      <sect2>
	<title>
	  Notifying the Bus Thread of Transaction Activity
	</title>

	<para>
	  A function is needed for the &tlm2; callback function,
	  <function>busReadWrite</function> to notify the thread handling
	  data being sent for transmission
	  (<function>busThread</function>). This is achieved with a
	  &systemc; event:
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_event  txReceived;
	  </programlisting>
	</informalfigure>

	<para>
	  The callback function notifies on this event, to trigger behavior in
	  the <function>busThread</function>.
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_uart_impl">
      <title>
	&uart; Module Class Implementation
      </title>

            <para>
	The &uart; module class, <classname>UartSC</classname> implementation
	may be found in <filename>sys-models/simple-soc/UartSC.cpp</filename>
	in the distribution.
      </para>

      <sect2>
	<title>
	  &uart; Constructor
	</title>
	
	<para>
	  Implementation of the constructor is preceded, like
	  <classname>Or1ksimSC</classname>, by the &systemc; macro.
	</para>

	<informalfigure>
	  <programlisting>
SC_HAS_PROCESS( UartSC );
	  </programlisting>
	</informalfigure>

	<para>
	  The constructor calls the base class
	  (<classname>sc_module</classname>) constructor to set the module
	  name, saves the endianness flag in its internal state variable and
	  clears the interrupt pending flags. The thread to handle bus I/O is
	  associated with this module.
	</para>

	<informalfigure>
	  <programlisting>
  SC_THREAD( busThread );
	  </programlisting>
	</informalfigure>

	<para>
	  The method handling data on the Rx buffer is associated with this
	  module with static sensitivity to writes to that buffer. It is not
	  initialized.
	</para>

	<informalfigure>
	  <programlisting>
  SC_METHOD( rxMethod );
  sensitive &lt;&lt; rx;
  dont_initialize();
	  </programlisting>
	</informalfigure>

        <para>
	  The blocking transport callback is registered for the
	  <literal>bus</literal> socket, in the same manner as was used for
	  the logger, <classname>LoggerSC</classname>.
	</para>

	<informalfigure>
	  <programlisting>
  bus.register_b_transport( this, &amp;UartSC::busReadWrite );
	  </programlisting>
	</informalfigure>

	<para>
	  Finally the registers (<literal>regs</literal>) are cleared.
	</para>
      </sect2>

      <sect2>
	<title>
	  &uart; Processes
	</title>
	
	<para>
	  We use the term <emphasis>processes</emphasis> in the &systemc;
	  sense to cover both <literal>SC_THREAD</literal> and
	  <literal>SC_METHOD</literal>.
	</para>

	<para>
	  The <function>busThread</function> is a
	  <literal>SC_THREAD</literal>. It sits in a perpetual loop. It first
	  marks the transmit buffer as empty (on reset the flags are cleared,
	  so the buffer will appear full).
	</para>

	<note>
	  <para>
	    The 16450 &uart; describes two flags for transmit buffer status, one
	    to indicate that the transmit holding register is empty and a
	    second to indicate that the internal transmit buffer register is
	    empty.
	  </para>

	  <para>
	    For simplicity, this model does not model a separate internal
	    register (effectively a one byte FIFO), so both flags are set and
	    cleared together.
	  </para>
	</note>

	<para>
	  If the transmit buffer empty interrupt is enabled, the thread
	  generates an interrupt to indicate that the buffer is empty.
	</para>

	<para>
	  The thread then waits until it is notified via the &systemc; event
	  <literal>txReceived</literal> that a byte is in the buffer to be
	  sent. This event will be triggered by the
	  <function>busWrite</function> callback when a value is written into
	  the transmit holding register.
	</para>

	<note>
	  <para>
	    It might be thought that a &systemc; <literal>SC_METHOD</literal>
	    sensitive to <varname>txReceived</varname> would be more
	    efficient.
	  </para>

	  <para>
	    That would certainly be suitable in this implementation. However
	    this is a virtual function, and when we reimplement later to add
	    timing, we will wish to call <function>wait</function>, which
	    requires a &systemc; <literal>SC_THREAD</literal>.
	  </para>
	</note>

	<para>
	  The second process, <function>rxMethod</function> is a &systemc;
	  <literal>SC_METHOD</literal>, sensitive to characters appearing in
	  the Rx buffer. The character is read into the read buffer register
	  and the line status data ready flag is set to indicate availability.
	</para>

	<para>
	  If the receive data interrupt is enabled, an interrupt is asserted
	  to indicate data availability.
	</para>

      </sect2>

      <sect2>
	<title>
	  &uart; Blocking Transport Callback
	</title>
	
	<para>
	  The registered callback function is <function>busReadWrite</function>,
	  which breaks out the address, byte enable mask pointer and data
	  pointer. A <literal>switch</literal> statement on the mask is used
	  to determine the offset of the actual byte requested and hence the
	  exact byte address, allowing for the endianness of the model. This
	  also provides a check that only a single byte is being requested.
	</para>

	<informalfigure>
	  <programlisting>
  switch( *((uint32_t *)maskPtr) ) {
  case 0x000000ff: offset = isLittleEndian ? 0 : 3; break;
  case 0x0000ff00: offset = isLittleEndian ? 1 : 2; break;
  case 0x00ff0000: offset = isLittleEndian ? 2 : 1; break;
  case 0xff000000: offset = isLittleEndian ? 3 : 0; break;

  default:              // Invalid request

    payload.set_response_status( tlm::TLM_GENERIC_ERROR_RESPONSE );
    return;
  }
	  </programlisting>
	</informalfigure>

	<para>
	  In a perfect world, the router/arbiter function would have masked
	  the address to the range handled by the &uart;. However for this
	  simple model, the full address is received, so masking with
	  <literal>UART_ADDR_MASK</literal> is carried out here, to give the
	  address of the &uart; register being read.
	</para>

	<para>
	  Separate functions, <function>busRead</function> and
	  <function>busWrite</function> are used to implement the register
	  specific behavior, selected as appropriate based on the payload
	  command field.
	</para>

	<para>
	  Single byte reads and writes always succeed, so the response is set
	  to <literal>tlm::TLM_OK_RESPONSE</literal> in all cases.
	</para>

      </sect2>

      <sect2>
	<title>
	  &uart; Read Behavior
	</title>
	
	<para>
	  Read behavior is handled by <function>busRead</function>.  A
	  switch on the address is used to identify the result to be returned,
	  usually just the value in the register if it is readable. The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then reads to the first two registers (read buffer and
	      interrupt enable) yield instead the low and high bytes of the
	      divisor latch.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the read buffer (when <literal>DLAB=0</literal>) yields
	      the byte just read, if flag <literal>DR</literal> is set in the
	      line status register. The act of reading causes the
	      <literal>DR</literal> flag and the read buffer full interrupt to
	      be cleared. If no interrupts remain pending then the interrupt
	      pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the interrupt indicator register clears the transmit
	      buffer empty interrupt if it was pending. If no interrupts
	      remain pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the line status register clears any error indications
	      and the receive line status interrupt if it was pending,
	      although the model has no way of setting any of these
	      indications. If no interrupts remain pending, then the interrupt
	      pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Reading the modem status register clears all flags and the modem
	      status interrupt if it was pending. However the modem loopback
	      indication may still be in operation and if so the bits and
	      interrupts are set to indicate the state of the loopback by a
	      call to <function>modemloopback</function>. If no interrupts
	      remain pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	</itemizedlist>
	
      </sect2>

      <sect2>
	<title>
	  &uart; Write Behavior
	</title>
	
	<para>
	  Write behavior is handled by <function>busWrite</function>.  A
	  switch on the address is used to identify the action
	  required. Usually the register is just written (if writable). The
	  interesting cases are:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      If the <literal>DLAB</literal> bit is set in the line control
	      register, then writes to the first two registers (read buffer and
	      interrupt enable) update the low and high bytes of the
	      divisor latch respectively.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Writing the transmit hold register (when
	      <literal>DLAB=0</literal>) triggers a new transfer. The flags
	      are set to indicate data is in the register, the transmit buffer
	      empty interrupt is cleared, and the bus thread
	      (<function>busThread</function>) notified via the &systemc;
	      event <literal>txReceived</literal>. If no interrupts remain
	      pending, then the interrupt pending flag is cleared.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      If the modem loopback bit is set by a write to the modem control
	      register, then the modem status bits are set appropriately by a
	      call to <function>modemLoopback</function>. If enabled a modem
	      status interrupt may be generated.
	    </para>
	  </listitem>

	</itemizedlist>

      </sect2>

      <sect2>
	<title>
	  &uart; Utility Functions
	</title>
	
	<para>
	  <function>setIntrFlags</function> determines the setting of the
	  interrupt identification register according to which interrupts are
	  currently pending (in <literal>intrPending</literal>).
	</para>

	<para>
	  <function>genIntr</function> generates an interrupt by marking the
	  corresponding interrupt as pending if the interrupt is enabled and
	  setting the interrupt identification register flags
	  appropriately. In this implementation, no external signal is
	  generated (see <xref linkend="chap_linux" /> for details of
	  generating an interrupt signal).
	</para>

	<para>
	  <function>clrIntr</function> clears the interrupt pending flag (no
	  need to check if the interrupt is enabled in this case) and sets the
	  appropriate interrupt identification register flags. Again there is
	  no external signal generated in this implementation.
	</para>

	<para>
	  A set of functions are provided to set, clear and test bits in
	  registers. Using these makes the code much more readable<footnote>
  	    <para>
	      Many programmers use <literal>#define</literal>d macros for
	      functions such as these. However such macros have no
	      encapsulation (they can be used by anyone including the header)
	      and have a nasty habit of clashing with other programs macros. By
	      using functions, the functions can be made private to the
	      <classname>UartSC</classname> class alone.
	    </para>

	    <para>
	      A modern C++ compiler will often generate code in line for such
	      small functions, so they will be implemented as efficiently as
	      if they had been <literal>#define</literal>d as macros. Indeed
	      the added type information gives the potential for greater
	      optimization.
	    </para>
	  </footnote>.
	</para>

      </sect2>
    </sect1>

  </chapter>

  <chapter id="chap_terminal">
    <title>
      Adding a Terminal as a Test Bench
    </title>

    <para>
      The &or1ksim; &iss; described in <xref linkend="chap_iss_wrapper" /> and
      the &uart; described in described in <xref linkend="chap_uart" /> can be
      put together as a minimal &soc;. However a test bench is needed to
      exercise that &soc;
    </para>

    <para>
      The usual way of exercising a &soc; with a &uart; is to connect a
      terminal to the &uart;. This section describes a suitable &systemc;
      model of a terminal and how to connect it to create the complete &soc;.
    </para>

    <para>
      This is not a &tlm2; component&mdash;the interfaces are standard
      &systemc; buffers, so the description is less detailed. However it serves
      to illustrate an important general technique when using
      &systemc;&mdash;how to interact with the operating system functions.
    </para>

    <para>
      The problem is that many operating system calls block. Consider
      modeling the terminal as a thread which reads characters from a console
      window. This will block until characters are typed. However the block
      does not use the &systemc; <function>wait</function> call, so
      &systemc; is not aware that the thread has yielded. The simulation
      will hang until characters are received.
    </para>

    <para>
      This implementation of the terminal will show how to wrap non-blocking
      versions of operating system functions with &systemc; events, to give
      versions that block correctly using &systemc;
      <function>wait</function>, so allowing the thread to yield.
    </para>

    <para>
      The code for the terminal module (<filename>TermSC.cpp</filename> and
      <filename>TermSC.h</filename>) and the main program
      (<filename>simpleSocMainSC.cpp</filename> may be found with the &uart;
      module and extended &or1ksim; &iss; wrapper code in the
      <filename>sysc-models/simple-soc</filename> directory of the
      distribution.
    </para>

    <sect1>
      <title>
	Overall Design of the Simple &soc; Model
      </title>

      <para>
	The key aspects of the overall simple &soc; model are captured in a
	&uml; class diagram and a &uml; sequence diagram, showing how a write
	transaction transfers a character to the modeled terminal.
      </para>

      <sect2 id="sec_simple_classes">
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the simple &soc; design incorporating a
	  &uart; and terminal is shown in <xref
	  linkend="fig_simple_soc_class_diagram" />. Elements from the earlier
	  logger example (see <xref linkend="chap_iss_wrapper_test" />) are
	  shown in less detail. The &uart; replaces the logger class, and
	  links to a terminal/keyboard emulator via byte wide
	  <classname>sc_buffer</classname> buffers. The
	  <varname>txReceived</varname> &systemc; event is used by the &tlm2;
	  target socket handler of the &uart; (which is executed in the thread
	  of the calling initiator socket) to notify the bus handling thread
	  of the &uart; that there is a byte to be passed on to the terminal.
	</para>

	<figure id="fig_simple_soc_class_diagram">
	  <title>
	    Class diagram for the simple &or1ksim; &soc;.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-classes.svg" format="SVG"
			 width="14cm" scalefit="1" align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-classes.png"
			 format="PNG" width="80%" scalefit="1" align="center" />
	      </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2 id="sec_simple_sequence_diagram">
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating the handling of a write transaction
	  for the design is shown in <xref
	  linkend="fig_simple_soc_sequence_diagram" />. For simplification,
	  the setting up of the transport call by the &or1ksim; wrapper is not
	  shown, since this is the same as for the logger example (see <xref
	  linkend="fig_logger_sequence_diagram" />). As a further
	  simplification the &uart; is shown writing to the receive buffer of
	  the terminal directly, whereas in detail this is via the
	  <classname>sc_out</classname> port of the &uart; and a connecting
	  <classname>sc_signal</classname>.
	</para>

	<para>
	  When a sequence of memory mapped reads and write lead to a byte
	  being received in the &uart;'s transmit buffer, the &uart; target
	  port handler signals the bus handling thread using the
	  <varname>txReceived</varname> &systemc; event. The &uart;'s bus
	  handling thread then passes that byte to the terminal's buffer,
	  where it can be written to the screen.
	</para>

	<figure id="fig_simple_soc_sequence_diagram">
	  <title>
	    Sequence diagram for a write transaction with the &or1ksim; simple
	    &soc;.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="simple-soc-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<note>
	  <para>
	    The notification of the byte arrival is an asynchronous
	    activity. It triggers behavior in a separate thread of the
	    &uart;. Although not conventional &uml; notation, the two threads
	    are shown as separate lines under the &uart; to make this
	    clear. Similarly the transfer to the terminal's receive buffer is
	    an asynchronous activity, with a new thread of control (a
	    &systemc; <classname>SC_METHOD</classname>).
	  </para>

	  <para>
	    It is the existence of these separate threads of control which
	    requires the &or1ksim; wrapper to execute
	    <function>wait</function>, to allow those threads a chance to
	    execute.
	  </para>
	</note>

      </sect2>
    </sect1>
    
    <sect1>
      <title>
	&systemc; Terminal Module Design
      </title>

      <para>
	The terminal provides a &systemc; buffer to model the Rx and a port to
	model the Tx pins of a serial connection. The visualization is
	provided by a &linux; &xterm; running in a child process, with
	communication through a pseudo-TTY<footnote>
	  <para>
	    The description here is specific to &linux;. A future version of
	    this application note will describe use under Microsoft Windows.
	  </para>
        </footnote>.
      </para>

      <para>
	Two &systemc; processes are used, one a method waiting for bytes from
	the UART in the Rx buffer, the other a thread waiting for bytes from
	the &xterm;. When bytes are received in the Rx buffer, they are
	written to the &xterm;. When bytes are received from the &xterm; they
	are written to the Tx port. The key interfaces are shown in <xref
	linkend="fig_terminal" />.
      </para>

      <figure id="fig_terminal">
	<title>
	  &systemc; terminal model using a &xterm; child process.
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="terminal.svg"
		       format="SVG"
		       width="14cm"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	  <imageobject>
	    <imagedata fileref="terminal.png"
		       format="PNG"
		       width="80%"
		       scalefit="1"
		       align="center" />
	  </imageobject>
	</mediaobject>
      </figure>

      <para>
	The difficulty is in waiting for the xterm. As described above,
	reading from the pseudo-TTY is an operating system call, and does not
	use the &systemc; <function>wait</function>, so the thread will not
	yield and the simulation will block. Instead the pseudo-TTY is set up
	to use asynchronous I/O, which will cause a &linux;
	<literal>SIGIO</literal> to be raised whenever data is available to
	read. The event handler for <literal>SIGIO</literal> will then notify
	a &systemc; event, and it is this &systemc; event on which the thread
	can safely wait.
      </para>

    </sect1>

    <sect1>
      <title>
	Terminal Module Class Definition
      </title>

      <para>
	The terminal module class, <classname>TermSC</classname> definition
	may be found in <filename>sys-models/simple-soc/TermSC.h</filename> in
	the distribution.
      </para>      

      <sect2>
	<title>
	  Mapping Signals to Class Instances
	</title>

	<para>
	  The operating system signal handlers require C style linkage, so
	  cannot be used with C++ member functions (the same issue addressed
	  by the &or1ksim; wrapper in <xref linkend="sec_upcall" />). Thus the
	  <literal>SIGIO</literal> handler will be a static function. However
	  each instance (there could be multiple terminals in a simulation)
	  will have a different file descriptor, which can be used to identify
	  the owning class instance.
	</para>

	<para>
	  The set of mappings from file descriptor to class instance is held
	  in a linked list with static head pointer. The <literal>struct
	  Fd2Inst</literal> is provided for that list, with entries for the
	  file descriptor, instance and a pointer to the next in the list.
	</para>

      </sect2>
      
      <sect2>
	<title>
	  The &systemc; Class
	</title>

	<para>
	  <classname>TermSC</classname> is declared as a standard &systemc;
	  class, with a buffer for bytes coming in, and a port for bytes out
	  (which will connect to a buffer in the &uart;). In this case it has
	  a custom destructor as well as constructor, which will be used to
	  kill the child process running the &xterm; when the class is
	  deleted.
	</para>

      </sect2>

      <sect2>
	<title>
	  Setting up the &xterm;
	</title>

	<para>
	  A set of utility functions are provided to set up the &xterm;. A
	  function, <function>xtermRead</function>, is provided to read from
	  the &xterm; and a function, <function>xtermWrite</function> to write
	  to the &xterm;. Both these functions are blocking on the operating
	  system. The write function should always be able to write with
	  minimal delay. However the read function must only be called when
	  the <literal>SIGIO</literal> signal handler has determined input is
	  available, in order to avoid blocking the &systemc; simulation.
	</para>

	<para>
	  There is some internal state to hold the pseudo-TTY file descriptors
	  and the process ID of the &xterm; (so it can be killed by the
	  destructor). It is the slave file descriptor that is used for both
	  input and output.
	</para>
      </sect2>

      <sect2>
	<title>
	  Signal and event handling
	</title>

	<para>
	  The <literal>SIGIO</literal> signal handler
	  (<function>ioHandler</function>) is declared static as noted
	  above. The static <literal>instList</literal> of type
	  <classname>Fd2Inst</classname> points to the list of mappings from file
	  descriptor to class instance.
	</para>

	<para>
	  The &systemc; event used to signal when input is available is pointed
	  to by <literal>ioEvent</literal>.
	</para>

	<caution>
	  <para>
	    It is essential that the event is declared as a pointer. If the
	    event itself were declared here, it would be available at
	    elaboration, and would crash the system (try it!).
	  </para>

	  <para>
	    The solution is to declare the pointer and allocate the event
	    instance dynamically when the &xterm; is created. The memory can be
	    freed from the destructor on termination.
	  </para>
	</caution>
      </sect2>

    </sect1>

    <sect1>
      <title>
	Terminal Module Class Implementation
      </title>

      <para>
	The implementation is a standard &systemc; module communicating via
	the Rx buffer and Tx port. It has a &systemc; method sensitive to
	writes to the Rx buffer and a &systemc; thread listening to the
	&xterm;.
      </para>

      <para>
	The setup of the pseudo-TTYs and the &xterm; in a separate process
	uses standard operating system functions, not described further
	here. The key factor is that the file descriptor for the pseudo-TTY to
	the &xterm; is set up to be asynchronous, with &linux; signal
	<literal>SIGIO</literal> raised when input is available and handled by
	the <function>ioHandler()</function> function.
      </para>

      <para>
	The terminal module class, <classname>TermSC</classname>
	implementation may be found in
	<filename>sys-models/simple-soc/TermSC.cpp</filename> in the
	distribution.
      </para>

      <sect2>
	<title>
	  &systemc; Processes
	</title>

	<para>
	  The method listening to the &uart;, <function>rxMethod</function> is
	  sensitive to writes to the <literal>rx</literal> buffer. When
	  triggered, the character is read from the buffer and immediately
	  copied to the &xterm;. Although this is a blocking operating system
	  write, it should return with minimal delay. In an environment where
	  any blocking were a concern, a non-blocking write could be used
	  instead.
	</para>

	<para>
	  The thread listening to the &xterm;,
	  <function>xtermThread</function> sits in a perpetual loop, waiting
	  on the &systemc; event pointed to by
	  <literal>ioEvent</literal>. This will safely allow the thread to
	  yield to the &systemc; scheduler until a character is ready.
	</para>

	<para>
	  When input is available, the event is notified (see <xref
	  linkend="sec_xterm_sig_hand" />). The thread can safely make an
	  operating system read to get the character, knowing that data is
	  definitely available.
	</para>
      </sect2>
      

      <sect2 id="sec_xterm_sig_hand">
	<title>
	  Signal and event handling
	</title>

	<para>
	  During initialization of the &xterm; the &systemc; event,
	  <literal>ioEvent</literal> is allocated:
	</para>

	<informalfigure>
	  <programlisting>
  ioEvent = new sc_core::sc_event();
	  </programlisting>
	</informalfigure>

	<para>
	  When <function>ioHandler</function> is called in response to a &linux;
	  <literal>SIGIO</literal> event, it does not know which pseudo-TTY
	  was responsible. The file descriptor responsible is identified by
	  using an operating system <function>select</function> call. Using
	  the mappings in <literal>instList</literal>, the corresponding class
	  instance can be identified and its <literal>ioEvent</literal>
	  notified.
	</para>

	<informalfigure>
	  <programlisting>
  for( Fd2Inst *cur = instList; cur != NULL ; cur = cur->next ) {
    if( FD_ISSET( cur->fd, &amp;readFdSet )) {
      (cur->inst)->ioEvent->notify();
    }
  }
	  </programlisting>
	</informalfigure>

        <para>
	  This event then allows the <function>xtermThread</function> to run
	  and read a character.
	</para>
      </sect2>
    </sect1>

    <sect1>
      <title>
	The Complete &soc;
      </title>

      <sect2 id="sec_simple_soc_main">
	<title>
	  The Model Main Program
	</title>

	<para>
	  The structure of the main program
	  (<filename>simpleSocMainSC.cpp</filename>) is similar to that for
	  the logger test program (see <xref linkend="sec_logger_main_prog"
	  />). The &tlm2; header and the headers for each module (&or1ksim;
	  &iss;, &uart; and terminal) are included.
	</para>

	<informalfigure>
	  <programlisting>
#include "tlm.h"
#include "Or1ksimExtSC.h"
#include "UartSC.h"
#include "TermSC.h"
	  </programlisting>
	</informalfigure>

	<para>
	  As before the main program (<function>sc_main</function>) takes as
	  arguments the &or1ksim; configuration file and &or1k;
	  image. Instances of the three modules are declared.
	</para>

	<informalfigure>
	  <programlisting>
  Or1ksimExtSC  iss( "or1ksim", argv[1], argv[2] );
  UartSC        uart( "uart", iss.isLittleEndian() );
  TermSC        term( "terminal" );
	  </programlisting>
	</informalfigure>

	<para>
	  The endianness for the &uart; is set using the public utility function
	  in <classname>Or1ksimExtSC</classname>. The &tlm; sockets of &uart;
	  and &iss; can be connected:
	</para>

	<informalfigure>
	  <programlisting>
  iss.dataBus( uart.bus );
	  </programlisting>
	</informalfigure>

	<para>
	  The Rx buffer in the &uart; is connected to the Tx port in the
	  terminal and the Rx buffer in the terminal is connected to the Tx
	  port in the &uart;.
	</para>

	<informalfigure>
	  <programlisting>
  uart.tx( term.rx );
  term.tx( uart.rx );
	  </programlisting>
	</informalfigure>

        <para>
	  The simulation can then be started with a call to
	  <function>sc_start</function>.
	</para>

      </sect2>

      <sect2>
	<title>
	  Test Program to Run on the &or1ksim; &iss;
	</title>

	<para>
	  The test program, <filename>uart-loop.c</filename> is a simple
	  polling loop back driver of the UART. Characters are read and
	  immediately echoed back.
	</para>

	<para>
	  A <literal>volatile</literal> structure is declared for the &uart;
	  registers, with <literal>#define</literal>d constants for the base
	  address and the register bits of interest.
	</para>

	<informalfigure>
	  <programlisting>
#define BASEADDR   0x90000000
#define BAUD_RATE        9600
#define CLOCK_RATE  100000000           // 100 Mhz

struct uart16450
{
  volatile unsigned char  buf;          // R/W: Rx &amp; Tx buffer when DLAB=0  
  volatile unsigned char  ier;          // R/W: Interrupt Enable Register   
  volatile unsigned char  iir;          // R: Interrupt ID Register         
  volatile unsigned char  lcr;          // R/W: Line Control Register       
  volatile unsigned char  mcr;          // W: Modem Control Register        
  volatile unsigned char  lsr;          // R: Line Status Register          
  volatile unsigned char  msr;          // R: Modem Status Register         
  volatile unsigned char  scr;          // R/W: Scratch Register            
};

#define UART_LSR_TEMT   0x40            // Transmitter serial register empty
#define UART_LSR_THRE   0x20            // Transmitter holding register empty
#define UART_LSR_DR     0x01            // Receiver data ready

#define UART_LCR_DLAB   0x80            // Divisor latch access bit
#define UART_LCR_8BITS  0x03		// 8 bit data bits
	  </programlisting>
	</informalfigure>

	<para>
	  The utility functions to set and clear flags in the &uart; (see <xref
	  linkend="sec_uart_impl" />) are reused here, modified for C rather
	  than C++ and <literal>volatile</literal> register arguments. They
	  are included from the file <filename>binutils.c</filename>
	</para>

	<informalfigure>
	  <programlisting>
#include "bitutils.c"
	  </programlisting>
	</informalfigure>

	<para>
	  The main program declares a pointer to the UART register structure,
	  <literal>uart</literal>, at the base address. Initialization
	  requires setting the divisor latch, to divide the main clock down to
	  16 x the baud rate and setting 8-bit data.
	</para>

	<informalfigure>
	  <programlisting>
  volatile struct uart16450 *uart = (struct uart16450 *)BASEADDR;
  unsigned short int         divisor;

  divisor = CLOCK_RATE/16/BAUD_RATE;            // DL is for 16x baud rate

  set( &amp;(uart->lcr), UART_LCR_DLAB );           // Set the divisor latch
  uart->buf  = (unsigned char)( divisor       &amp; 0x00ff);
  uart->ier  = (unsigned char)((divisor &gt;&gt; 8) &amp; 0x00ff);
  clr( &amp;(uart->lcr), UART_LCR_DLAB );

  set( &amp;(uart->lcr), UART_LCR_8BITS );		// Set 8 bit data
  packet
	  </programlisting>
	</informalfigure>

	<para>
	  The remainder of the program is a perpetual loop:
	</para>

	<itemizedlist>

	  <listitem>
	    <para>
	      Wait for a character in the read buffer (flag
	      <literal>DR</literal> of the line status register is set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Read the character from the buffer and print it.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Wait for the transmit buffer to clear (flags
	      <literal>TEMT</literal> and <literal>THRE</literal> of the line
	      status register are set).
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      Write the character back.
	    </para>
	  </listitem>
	</itemizedlist>

	<informalfigure>
	  <programlisting>
  while( 1 ) {
    unsigned char  ch;

    do {                        // Loop until a char is available
      ;
    } while( is_clr(uart->lsr, UART_LSR_DR) );

    ch = uart->buf;

    simputs( "Read: '" );       // Log what was read
    simputc( ch );
    simputs( "'\n" );

    do {                        // Loop until the transmit register is free
      ;
    } while( is_clr( uart->lsr, UART_LSR_TEMT | UART_LSR_THRE ) );
      
    uart->buf = ch;
  }
	  </programlisting>
	</informalfigure>

	<para>
	  The source code for the &uart; loopback program may be found in
	  <filename>progs-or32/uart-loop.c</filename> in the distribution. It
	  will be built using the &or1k; tool chain as part of the overall
	  system build.
	</para>

      </sect2>

      <sect2 id="sec_simple_soc_run">
	<title>
	  Compiling and Running the Model
	</title>

	<para>
	  The complete program is compiled from the top level &make;
	  file. Both a standalone program (<filename>simple-soc</filename>)
	  and a <command>libtool</command> compliant library
	  (<filename>libsimple-soc.la</filename>) are created, and both
	  incorporate the library created when building the logger test (see
	  <xref linkend="sec_iss_run_test" />). The library provides a
	  convenient mechanism for reusing the code from this model, when
	  creating subsequent models which use derived classes.
	</para>

	<para>
	  The &or1ksim; configuration is also unchanged. Like the logger, the
	  &uart; registers start at address 0x90000000 and are a total of 8
	  bytes in length.
	</para>

	<para>
	  Running the model requires specifying the configuration file
	  (unchanged) and the binary executable (this time the &uart; loop
	  back program). Assuming the programs have been built in a directory
	  named <filename>build</filename>, the following command line is
	  suitable.
	</para>

	<informalfigure>
	  <programlisting>
./build/sysc-models/simple-soc simple.cfg progs_or32/uart-loop
	  </programlisting>
	</informalfigure>

	<para>
	  The &xterm; terminal should appear. Select it and type some
	  characters. The window running the model, will show the logged
	  output from the terminal, reporting the same characters being
	  written, as shown in <xref linkend="fig_uart-loopback_log" />.
	</para>

	<figure id="fig_uart-loopback_log">
	  <title>
	    &uart; loop back program log output.
	  </title>

	  <informalfigure>
	    <screen>
$ ./build/sysc-models/simple-soc simple.cfg progs_or32/uart-loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Or1ksim 0.3.0

   ... &lt;Or1ksim initialization messages&gt;

Read: 'F'
Read: 'a'
Read: 'r'

   ... &lt;more Or1ksim output&gt;

Read: '!'
Read: '!'
Read: '!'
	    </screen>
	  </informalfigure>

	</figure>

	<para>
	  At the same time the characters will be echoed on the xterm, as
	  shown in <xref linkend="fig_uart-loopback_screen" />.
	</para>

	<figure id="fig_uart-loopback_screen">
	  <title>
	    &xterm; with the &uart; loop back program running.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="uart_xterm.png"
			 format="PNG"
			 width="13.754cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<para>
	  Well it makes a change from "Hello World!".
	</para>

	<para>
	  As an exercise, rebuild the model, removing the call to
	  <function>wait</function> in the
	  <function>Or1ksimExtSC::doTrans</function> function. Observe that
	  the program hangs without accepting any characters. The reason for
	  this is given in the description of <function>doTrans</function>
	  in <xref linkend="sec_uart_or1ksim_libext" />.
	</para>

	<para>
	  A debugger connected to the model will show that execution is stuck
	  in &or1ksim; &iss;, waiting for the data ready flag to be set in the
	  &uart;. This can never occur, since neither &uart; nor terminal are
	  given the chance to execute the threads that would set this flag.
	</para>
      </sect2>

      <sect2>
	<title>
	  Model Timing
	</title>

	<para>
	  This model is completely untimed. It executes the behavior of the
	  design, and for that reason such models are useful in system
	  verification.
	</para>

	<para>
	  The next stages will add timing to this model. To allow this to be
	  demonstrated, add some logging to the &uart; and terminal to report
	  the timing of reads and writes.
	</para>

	<para>
	  Edit the <function>rxMethod</function> in
	  <classname>UartSC</classname>, to print out the time when a
	  character is received from the terminal.
	</para>

	<informalfigure>
	  <programlisting>
void
UartSC::rxMethod()
{
  regs.rbr  = rx.read();

  sc_core::sc_time  now = sc_core::sc_time_stamp();
  cout &lt;&lt; "Char " &lt;&lt; (char)(regs.rbr) &lt;&lt; " read at  " &lt;&lt; sc_time_stamp ()
       &lt;&lt; endl;

  set( regs.lsr, UART_LSR_DR );         // Mark data ready
  genIntr( UART_IER_RBFI );             // Interrupt if enabled

}       // rxMethod()
	  </programlisting>
	</informalfigure>

	<para>
	  Similarly edit the <function>rxMethod</function> function in
	  <classname>TermSC</classname>, to print out the time when a
	  character is received from the UART.
	</para>

	<informalfigure>
	  <programlisting>
void
TermSC::rxMethod()
{
  xtermWrite( rx.read() );		// Write it to the screen

  cout &lt;&lt; "Char written at " &lt;&lt; sc_time_stamp() &lt;&lt; endl;

}	// rxMethod()
	  </programlisting>
	</informalfigure>

	<para>
	  In both cases the C++ <classname>iostream</classname> header will be
	  needed at the top of the file (<filename>UartSC.cpp</filename> and
	  <filename>TermSC.cpp</filename>), and the entities used will need to
	  be brought into the local namespace.
	</para>

	<informalfigure>
	  <programlisting>
#include &lt;iostream&gt;


using sc_core::sc_time_stamp;

using std::cout;
using std::endl;
	  </programlisting>
	</informalfigure>

	<note>
	  <para>
	    For convenience these changes are already made in the files in the
	    distribution, but the two <classname>cout</classname> invocations
	    are commented out. All that is needed is to remove the commenting.
	  </para>

	  <para>
	    Once removed, the commenting should stay removed for all the
	    future examples, since they all need to show timing details.
	  </para>
	</note>

	<para>
	  The model can now be rerun as before, and will print out precise
	  timing. The output is shown in
	  <xref linkend="fig_uart-loopback_log_timed" />.
	</para>

	<figure id="fig_uart-loopback_log_timed">
	  <title>
	    &uart; loop back program log output with timing annotation.
	  </title>

	  <informalfigure>
	    <screen>
	    $ ./build/sysc-models/simple-soc simple.cfg progs_or32/uart-loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Or1ksim 0.3.0

   ... &lt;Or1ksim initialization messages&gt;

Char read at    0 s
Read: 'F'
Char written at 0 s
Char read at    0 s
Read: 'a'
Char written at 0 s
Char read at    0 s
Read: 'r'

   ... &lt;Lots more output&gt;
	    </screen>
	  </informalfigure>

	</figure>

	<para>
	  As can be seen all the reads and writes occur at time zero.
	</para>

      </sect2>
    </sect1>
  </chapter>

  <chapter id="chap_sync">
    <title>
      Adding Synchronous Timing to the Model
    </title>

    <para>
      The current models are all untimed. In the &tlm2; components
      (<classname>Or1ksimExtSC</classname> and <classname>UartSC</classname>)
      the delay parameter to the blocking transport function has been ignored
      by setting it to zero.
    </para>

    <para>
      In this section, the models are extended to synchronize explicitly with
      the &systemc; clock.
    </para>

    <para>
      The synchronization is not perfect&mdash;the underlying &or1ksim; &iss;
      executes outside the &systemc; world. Synchronization is only possible
      when it makes an upcall for read or write. In <xref
      linkend="chap_temporal_decoupling" /> this model will be further
      extended to add control over the underlying &iss; and its interaction
      with &systemc; time.
    </para>

    <para>
      The code for the timed &uart; module
      (<filename>UartSyncSC.cpp</filename> and
      <filename>UartSyncSC.h</filename>), The code for the timed terminal
      module (<filename>TermSyncSC.cpp</filename> and
      <filename>TermSyncSC.h</filename>), the code for the timed &or1ksim;
      &iss; wrapper (<filename>Or1ksimSyncSC.cpp</filename> and
      <filename>Or1ksimSyncSC.h</filename>) and the main program for the
      complete model (<filename>syncSocMain.cpp</filename>) may be founded in
      the <filename>sysc-models/sync-soc</filename> directory of the
      distribution.
    </para>
    
    <sect1>
      <title>
	Summary of Changes Required for Synchronous Timing
      </title>

      <para>
	Each module of the existing &soc; requires some changes. New classes,
	<classname>Or1ksimSyncSC</classname>,
	<classname>UartSyncSC</classname> and
	<classname>TermSyncSC</classname> are derived from the existing
	classes to provide added functionality. In addition the underlying
	&or1ksim; &iss; library will need extending. The main program will
	need modifying to use these new classes.
      </para>

      <itemizedlist>

	<listitem>
	  <para>
	    <classname>Or1ksimSyncSC</classname>. A public function to report
	    the clock rate of the underlying &or1ksim; &iss; is added
	    (requiring an extension to the &or1ksim; library), and the
	    transport function, <function>doTrans</function> modified to add
	    timing information.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>UartSyncSC</classname>. This now models the time taken
	    to put a character out on the Tx wire, so must know its input
	    clock rate (in this &soc;, the &or1ksim; clock rate), so that baud
	    rate can be calculated from the divisor latch. Also models the
	    true time to process a read or write on the bus and returns this
	    with the transaction response.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    <classname>TermSyncSC</classname>. This now models the time taken
	    to put a character out to the UART, so must know its baud
	    rate. This requires an updated thread listening to the xterm, so
	    that the baud rate delay can be added.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    &or1ksim; &iss; library. Information functions are added to return
	    the model clock rate (used as input clock rate for the UART) and
	    to determine the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with &systemc;).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    A new main program <filename>syncSocMainSC.cpp</filename> to build
	    the new classes into a synchronized &soc;. Information functions
	    are added to return the model clock rate (used as input clock rate
	    for the UART) and the time spent executing instructions (so
	    <classname>Or1ksimSyncSC</classname> can determine the
	    synchronization time with &systemc;.
	  </para>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>
	Overall Design of the Synchronized &soc; Model
      </title>

      <para>
	The key aspects of the overall synchronized &soc; model are captured
	in a &uml; class diagram and a &uml; sequence diagram, showing how the
	timing information is added when processing a transaction.
      </para>

      <sect2 id="sec_sync_classes">
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the synchronized &soc; design
	  incorporating a &uart; and terminal is shown in <xref
	  linkend="fig_sync_soc_class_diagram" />. The design is almost
	  identical to that for the simple &soc; (see <xref
	  linkend="sec_simple_classes" />). The only difference is that the
	  &or1ksim; &iss; wrapper, &uart; and terminal modules are all
	  subclassed to add the behavior needed for synchronized timing.
	</para>

	<figure id="fig_sync_soc_class_diagram">
	  <title>
	    Class diagram for the &or1ksim; &soc; with synchronized timing.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="sync-soc-classes.svg" format="SVG"
			 width="14cm" scalefit="1" align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="sync-soc-classes.png"
			 format="PNG" width="80%" scalefit="1" align="center" />
	      </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2>
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating the handling of a transaction
	  for the design is shown in <xref
	  linkend="fig_sync_soc_sequence_diagram" />. Only the handling of the
	  transaction by the wrapper is shown, since there is no significant
	  change in the interactions of the &uart; and terminal (see <xref
	  linkend="sec_simple_sequence_diagram" />).
	</para>

	<para>
	  Before each upcall transaction, the &or1ksim; wrapper class waits
	  for the period of time used by the underlying &or1ksim; &iss;. This
	  brings all other threads into synchronization, giving them the
	  opportunity to catch up.
	</para>

	<para>
	  After each upcall transaction is complete, the timing point of the
	  underlying &or1ksim; &iss; is reset to zero.
	</para>

	<figure id="fig_sync_soc_sequence_diagram">
	  <title>
	    Sequence diagram for the &or1ksim; &soc; with synchronized timing,
	    showing the timing calls.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="sync-soc-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="sync-soc-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Extending the <classname>Or1ksimExtSC</classname> Wrapper Module
      </title>

      <sect2 id="sec_or1ksim_libsync">
	<title>
	  Adding Clock Rate and Timing Functions to the &or1ksim; Library
	</title>

	<para>
	  Three additional functions are needed in the &or1ksim; library to
	  support synchronized timing. The &uart; will need to know the clock
	  rate of the model (to work out the baud rate from the value of the
	  divisor latch). The <classname>Or1ksimSyncSC</classname> class
	  itself will need a pair of functions, one to set a timing point in
	  the &iss; the second to return the amount of time since the last
	  timing point. This the amount of time the underlying &iss; has used
	  when synchronizing with &systemc;.
	</para>

	<para>
	  The three additional functions are simple additions. The clock rate is
	  a configuration parameter, while a run time count of instructions
	  executed is already maintained. An extra record in the run-time
	  structure allows a time to be recorded (in seconds through dividing
	  the count by the clock rate), which can be compared in subsequent
	  calls to give the &iss; time used since the last time point<footnote>
	    <para>
	      This is a loosely timed model. The timing from the &iss; is
	      approximate&mdash;it does not model the microarchitecture in
	      detail. Cycle estimates will not be exact&mdash;that requires a
	      fully cycle accurate model.
	    </para>
	  </footnote>.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
unsigned long int  or1ksim_clock_rate();
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_clock_rate</function> returns the &or1ksim;
	      &iss; clock rate in Hz. This information will be used by the
	      &uart; to allow it to set its baud rate.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
void  or1ksim_set_time_point();
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_set_time_point</function> records the current
	      &iss; simulation time (clock cycles divided by clock rate) in
	      the run-time data structure.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
double  or1ksim_get_time_period();
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_get_time_period</function> returns the time
	      in seconds since the last time point was set. This function is
	      needed to keep the &systemc; model of time due to instruction set
	      processing accurate, both in the synchronous &soc; and when
	      temporal decoupling is added later (see <xref
	      linkend="chap_temporal_decoupling" />.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  All these functions are a standard part of the &or1ksim; 0.3.0
	  library.
	</para>
 
     </sect2>

      <sect2>
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimSyncSC</classname> is derived
	  from the existing <classname>Or1ksimExtSC</classname> module
	  class. The header of the base class,
	  <classname>Or1ksimExtSC</classname> is included and the new class
	  derived from that base class.
	</para>

	<informalfigure>
	  <programlisting>
#include "Or1ksimExtSC.h"

class Or1ksimSyncSC
  : public Or1ksimExtSC
{
	  </programlisting>
	</informalfigure>

        <para>
	  A custom constructor must be defined, but has the same arguments as
	  the base class constructor, to which it will pass its arguments.
	</para>

	<para>
	  The new &or1ksim; library call to give the clock rate is wrapped by
	  a public function<footnote>
	    <para>
	      The use of unsigned long int reflects the usage in the &or1ksim;
	      &iss;. The designers do not anticipate usage to model designs in
	      excess of 4GHz!
	    </para>
	  </footnote>.
	</para>

	<informalfigure>
	  <programlisting>
  unsigned long int  getClockRate();
	  </programlisting>
	</informalfigure>

	<para>
	  The virtual function, <function>doTrans</function> function is
	  reimplemented&mdash;it will replace the call to
	  <function>doTrans</function> in the base class to add timing
	  synchronization.
	</para>

	<para>
	  The definition of the &or1ksim; &iss; wrapper module class with
	  synchronized timing, <classname>Or1ksimSyncSC</classname> may be
	  found in <filename>sys-models/sync-soc/Or1ksimSyncSC.h</filename> in
	  the distribution.
	</para>          

      </sect2>

      <sect2 id="sec_Or1ksimSyncSC_impl">
	<title>
	  <classname>Or1ksimSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor passes its arguments directly to the base class
	  constructor. It then uses the &or1ksim; library function,
	  <function>or1ksim_set_time_point</function> to set an initial time
	  point at the start of simulation. The first call to
	  <function>or1ksim_get_time_period</function> will return the time
	  since the &iss; started.
	</para>

	<para>
	  The <function>doTrans</function> function (which is used for both
	  read and write) is extended from the version used with
	  <classname>Or1ksimExtSC</classname> to synchronize with the &systemc;
	  clock.
	</para>

	<para>
	  There are two components to the time taken in this model, the time
	  taken by the &or1ksim; &iss; and the time taken in any
	  peripherals. At the time of an upcall, the &systemc; wrapper thread
	  will not have yielded control since either initialization or the
	  last upcall, when a time point was set in the &iss; using
	  <function>or1ksim_set_time_point</function>.
	</para>

	<para>
	  A call to <function>or1ksim_get_time_period</function> gives the
	  time used by the &iss; in this period. This is used as the argument
	  to <function>wait</function>, allowing any other threads in the
	  &systemc; world to run until the calculated simulation time is
	  reached.
	</para>

	<informalfigure>
	  <programlisting>
  wait( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
	  </programlisting>
	</informalfigure>

	<para>
	  At this time the blocking transport function of the simple initiator
	  socket is called with the payload and specifying a zero time offset
	  (since the call to <function>wait</function> means the thread is
	  synchronized with the &systemc; clock).
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_time  delay = sc_core::SC_ZERO_TIME;
  dataBus->b_transport( trans, delay );
	  </programlisting>
	</informalfigure>

	<para>
	  On return, the <literal>delay</literal> parameter will have been
	  updated with any additional delay due to the transaction&mdash;in
	  this case an estimate of the number of cycles to read or write the
	  relevant &uart; register. This delay represents the additional time
	  modeled since this thread last called
	  <function>wait</function>. The thread should
	  <function>wait</function> for this time, to allow other threads to
	  catch up.
	</para>

	<para>
	  However, since this is a synchronized model, the target (which is
	  still part of this thread of control, just in a different object)
	  will have already called <function>wait</function> to model the time
	  taken to read or write. So in this case, <literal>delay</literal>
	  will still be zero on return.
	</para>

	<para>
	  The read or write is now complete. A new time point is set with
	  <function>set_time_point</function> before control is returned to
	  the &iss;. The &iss; will start measuring time from this start
	  point, ready for use in the next upcall.
	</para>

	<informalfigure>
	  <programlisting>
  or1ksim_set_time_point();
	  </programlisting>
	</informalfigure>

        <para>
	  The utility <function>getClockRate</function> is a simple wrapper
	  for the underlying &or1ksim; library function (see <xref
	  linkend="sec_or1ksim_libsync"/>). It will be used in the main
	  program (see <xref linkend="sec_sync_main_prog" />).
	</para>

	<informalfigure>
	  <programlisting>
unsigned long int
Or1ksimSyncSC::getClockRate()
{
  return or1ksim_clock_rate();

}       // getClockRate()
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &or1ksim; &iss; wrapper module class with
	  synchronized timing, <classname>Or1ksimSyncSC</classname> may be
	  found in <filename>sys-models/sync-soc/Or1ksimSyncSC.cpp</filename>
	  in the distribution.
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_uart_sync">
      <title>
	Extending the <classname>UartSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>UartSyncSC</classname> derived from
	<classname>UartSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	The time taken for the serial pulses (start, data, parity, stop bits)
	on the real &uart; will be modeled as a delay before writing data onto
	the Tx output port. The corresponding delay on the Rx buffer port will
	be modeled by the terminal writing into that port<footnote>
	  <para>
	    This is not the ideal solution. The delay is really a property of
	    the channel, so should be modeled by a derived class of the
	    standard &systemc; buffer which provides a defined delay between
	    data being written and data availability being signaled. The
	    approach used here (transmitter models the delay) represents a
	    practical compromise.
	  </para>
	</footnote>.
      </para>

      <para>
	The &tlm2; socket modeling the bus is extended to model the time taken
	for reads to and writes from the bus.
      </para>

      <sect2>
	<title>
	  <classname>UartSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition (in <filename>UartSyncSC.h</filename>) includes
	  the header of the base class and defines two new constants to
	  represent the delay in reading and writing in nanoseconds.
	</para>

	<informalfigure>
	  <programlisting>
#define UART_READ_NS       60   // Time to access the UART for read
#define UART_WRITE_NS      60   // Time to access the UART for write
	  </programlisting>
	</informalfigure>

	<para>
	  The class is derived directly from the base class,
	  <classname>UartSC</classname>. A new custom constructor is needed,
	  with an additional parameter specifying the input clock rate. This
	  is used in conjunction with the divisor latch to specify the baud
	  rate.
	</para>

	<informalfigure>
	  <programlisting>
  UartSyncSC( sc_core::sc_module_name  name,
              unsigned long int        _clockRate,
              bool                     _isLittleEndian );
	  </programlisting>
	</informalfigure>

	<para>
	  The <function>busThread</function> thread is reimplemented to add the
	  timing delay (as a call to <function>wait</function> in
	  transmitting a character as described above).
	</para>

	<para>
	  The blocking transport function, <function>busReadWrite</function>
	  is reimplemented to add in the bus delays in reading and
	  writing. Again this will be achieved by calls to
	  <function>wait</function>, so keeping the model synchronous.
	</para>

	<para>
	  The <function>busWrite</function> must also be reimplemented, since
	  any change to the divisor latch or the line control register (which
	  specifies the bit format being sent on the wire) could affect the
	  baud rate and timing for <function>busThread</function>
	</para>

	<para>
	  A new utility function, <function>resetCharDelay</function> is
	  defined to compute the delay in putting a character on the Tx port
	  from the clock rate, divisor latch and line control register.
	</para>

	<para>
	  Two new member variables are declared, to hold the clock rate and
	  the calculated delay to put a character on the Tx port.
	</para>

	<para>
	  The implementation of the &uart; module class with synchronized
	  timing, <classname>UartSyncSC</classname> may be found in
	  <filename>sys-models/sync-soc/UartSyncSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>UartSyncSC</classname> Module Class Implementation
	</title>
	  
	<para>
	  The custom constructor passes the name and
	  <literal>_isLittleEndian</literal> flag to the base class
	  constructor. The clock rate is saved in the state variable,
	  <literal>clockRate</literal>.
	</para>

	<informalfigure>
	  <programlisting>
UartSyncSC::UartSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        _clockRate,
                        bool                     _isLittleEndian ) :
  UartSC( name, _isLittleEndian ),
  clockRate( _clockRate )
{

}       /* UartSyncSC() */
	  </programlisting>
	</informalfigure>

	<para>
	  The new version of <function>busThread</function> adds only one
	  line to the version in the base class. A call to
	  <function>wait(&nbsp;charDelay&nbsp;)</function> is added when the
	  transmit request is received (notified on the &systemc; event,
	  <literal>txReceived</literal>).
	</para>

	<informalfigure>
	  <programlisting>
    wait( txReceived );                         // Wait for a Tx request
    wait( charDelay );                          // Wait baud delay
    tx.write( regs.thr );                       // Send char to terminal
	  </programlisting>
	</informalfigure>

	<para>
	  The new version of <function>busReadWrite</function> draws most of
	  its functionality from the base class version. However it then
	  synchronizes with a time delay for the read or write access. Since
	  the thread is now synchronous, a time delay of zero is returned with
	  the transaction.
	</para>

	<informalfigure>
	  <programlisting>
void
UartSyncSC::busReadWrite( tlm::tlm_generic_payload &amp;payload,
                          sc_core::sc_time         &amp;delay )
{
  UartSC::busReadWrite( payload, delay );       // base function

  switch( payload.get_command() ) {
  case tlm::TLM_READ_COMMAND:
    wait( sc_core::sc_time( UART_READ_NS, sc_core::SC_NS ));
    delay = sc_core::SC_ZERO_TIME;
    break;

    &lt;code for write commands etc&gt;

	  </programlisting>
	</informalfigure>

	<para>
	  The new version of <function>busWrite</function> similarly relies
	  on the base class for most of its functionality.
	</para>

	<informalfigure>
	  <programlisting>
void
UartSyncSC::busWrite( unsigned char  uaddr,
                      unsigned char  wdata )
{
  UartSC::busWrite( uaddr, wdata );
	  </programlisting>
	</informalfigure>

	<para>
	  However any change to the divisor latch or line control register
	  could change the baud rate or the number of bits in each Tx
	  transmission, and hence the modeled delay to send a character.
	</para>

	<para>
	  The function identifies if this has happened and if so calls
	  <function>resetCharDelay</function> to recalculate the delay.
	</para>

	<informalfigure>
	  <programlisting>
  switch( uaddr ) {
  case UART_BUF:                // Only change if divisorLatch update (DLAB=1)
  case UART_IER:
    if( isSet( regs.lcr, UART_LCR_DLAB ) ) {
      resetCharDelay();
    }
    break;

  case UART_LCR:
    resetCharDelay();           // Could change baud delay
    break;
	  </programlisting>
	</informalfigure>

	<para>
	  The time taken to put a character on the Tx line is the product of
	  the time taken to put one bit on the line (the inverse of the baud
	  rate) and the bits required for the character (start bit, data bits,
	  optional parity bit, stop bit(s)). The baud rate is determined by
	  the input clock rate and the 16-bit divisor latch.
	</para>
	  
	<note>
	  <para>
	    The divisor latch for a 16450 divides the input clock to yield an
	    internal clock 16x the baud rate (i.e. not the actual baud rate
	    itself).
	  </para>

	  <para>
	    The 16450 specification supports an input clock up to 24 MHz, so
	    the 16 bit divisor latch can yield an internal clock for rates
	    down to 50 baud. However for a software model this limitation can
	    be ignored. Faster input clocks can be specified, but it will not
	    be possible to configure a 16-bit divisor latch for very low baud
	    rates.
	  </para>
	</note>

	<para>
	  The number of bits to send a character is determined by the line
	  control registers. There is always a stop bit, there can be 5-8 data
	  bits, an optional parity bit and 1, 1.5 or 2 stop bits. The
	  <function>resetCharDelay</function> function calculates the total
	  delay.
	</para>

	<para>
	  The implementation of the &uart; module class with synchronized
	  timing, <classname>UartSyncSC</classname> may be found in
	  <filename>sys-models/sync-soc/UartSyncSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Extending the <classname>TermSC</classname> Module Class
      </title>

      <para>
	A new class, <classname>TermSyncSC</classname> derived from
	<classname>TermSC</classname> implements the additional functionality
	for synchronized timing.
      </para>

      <para>
	As with the &uart; (see <xref linkend="sec_uart_sync" />), the
	terminal will model the time taken to put the bits of a character on
	its Tx port. This mirrors the arrangement with the UART, so when the
	two are connected, delays in both directions are correctly modeled.
      </para>

      <sect2>
	<title>
	  <classname>TermSyncSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>TermSyncSC</classname> is derived from
	  <classname>TermSC</classname>. The header for that class is included
	  and the new class derived from it.
	</para>

	<informalfigure>
	  <programlisting>
#include "TermSC.h"

class TermSyncSC
  : public TermSC
{
	  </programlisting>
	</informalfigure>

	<para>
	  A new custom constructor is needed, which takes a second argument to
	  specify the baud rate.
	</para>

	<informalfigure>
	  <programlisting>
  TermSyncSC( sc_core::sc_module_name  name,
              unsigned long int        baudRate );
	  </programlisting>
	</informalfigure>

	<para>
	  The <function>xtermThread</function> thread will be
	  reimplemented. No further derived classes are anticipated, so this
	  function is declared <literal>private</literal> and not marked as
	  <literal>virtual</literal>.
	</para>

	<para>
	  A variable is needed to hold the baud rate. For convenience the
	  class does not hold the baud rate, but the corresponding delay that
	  this represents in sending a character.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_time  charDelay;
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the terminal module class with synchronized
	  timing, <classname>TermSyncSC</classname> may be found in
	  <filename>sys-models/sync-soc/TermSyncSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>TermSyncSC</classname> Module Class Implementation
	</title>

	<para>
	  The custom constructor calls the base class constructor to set the
	  module name. The body of the constructor is calculates the delay due
	  to the baud rate. There is no configurability (this terminal
	  supports 1 start, 8 data, 0 parity and 1 stop bits only), so this is
	  a one off calculation.
	</para>

	<informalfigure>
	  <programlisting>
TermSyncSC::TermSyncSC( sc_core::sc_module_name  name,
                        unsigned long int        baudRate ) :
  TermSC( name )  
{
  charDelay = sc_core::sc_time( 10.0 / (double)baudRate, sc_core::SC_SEC );

}       /* TermSyncSC() */
	  </programlisting>
	</informalfigure>

	<para>
	  The <function>xtermThread</function> thread is almost identical to
	  the base class version. A single line is added after the character
	  is read from the &xterm; and before it is written to the port
	  to add the modeled baud rate delay.
	</para>

	<informalfigure>
	  <programlisting>
    int ch = xtermRead();               // Should not block

    wait( charDelay );                  // Model baud rate delay
    tx.write( (unsigned char)ch );      // Send it

	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of the terminal module class with synchronized
	  timing, <classname>TermSyncSC</classname> may be found in
	  <filename>sys-models/sync-soc/TermSyncSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>


    <sect1 id="sec_sync_main_prog">
      <title>
	Main Program for the Synchronous Model
      </title>

      <para>
	As with the untimed &soc; (see <xref linkend="sec_simple_soc_main" />),
	the main program includes the headers for &tlm2; and the component
	modules, but this time using the synchronously timed versions.
      </para>

      <informalfigure>
	<programlisting>
#include "tlm.h"
#include "Or1ksimSyncSC.h"
#include "UartSyncSC.h"
#include "TermSyncSC.h"
	</programlisting>
      </informalfigure>

      <para>
	The baud rate for the terminal is defined as a constant for
	convenience.
      </para>

      <informalfigure>
	<programlisting>
#define BAUD_RATE  9600
	</programlisting>
      </informalfigure>

      <para>
	As before the main program (<function>sc_main</function>) takes as
	arguments the &or1ksim; configuration file and &or1k; image. Instances
	of the three modules are declared, but now have additional
	arguments. The &uart; requires an input clock rate&mdash;obtained from
	the &iss; via the <classname>Or1ksimSyncSC</classname> public utility
	function, <function>getClockRate</function> (see <xref
	linkend="sec_Or1ksimSyncSC_impl" />). The Terminal requires its baud
	rate to be set.
      </para>

      <informalfigure>
	<programlisting>
  Or1ksimSyncSC  iss( "or1ksim", argv[1], argv[2] );
  UartSyncSC     uart( "uart", iss.getClockRate(), iss.isLittleEndian() );
  TermSyncSC     term( "terminal", BAUD_RATE );
	</programlisting>
      </informalfigure>

      <para>
	The remainder of the program, connecting components and starting the
	simulation is identical to the untimed version.
      </para>
	
      <para>
	The implementation of the main program for the &soc; model with
	synchronized timing may be found in
	<filename>sys-models/sync-soc/syncSocMainSC.cpp</filename> in the
	distribution.
      </para>

    </sect1>

    <sect1>
      <title>
	Compiling and Running the Synchronous Model
      </title>

      <para>
	The complete program is compiled from the top level &make;
	file. Both a standalone program (<filename>simple-soc</filename>)
	and a <command>libtool</command> compliant library
	(<filename>libsimple-soc.la</filename>) are created, and both
	incorporate the library created when building the logger test (see
	<xref linkend="sec_iss_run_test" />). The library provides a
	convenient mechanism for reusing the code from this model, when
	creating subsequent models which used derived classes.
      </para>

      <para>
	The &or1ksim; configuration is also unchanged. Like the logger, the
	&uart; registers start at address 0x90000000 and are a total of 8
	bytes in length.
      </para>

      <para>
	Running the model requires specifying the configuration file
	(unchanged) and the binary executable (this time the &uart; loop
	back program). Assuming the programs have been built in a directory
	named <filename>build</filename>, the following command line is
	suitable.
      </para>

      <informalfigure>
	<programlisting>
.build/sysc-models/sync-soc simple.cfg progs_or32/uart-loop
	</programlisting>
      </informalfigure>

      <para>
	Once again the &xterm; terminal should appear. Select it and type some
	characters. The window running the model, will show the logged output
	from the terminal, reporting the same characters being written and
	timing of the reads and writes. However this time, the time progresses
	as the characters are written, as shown in <xref
	linkend="fig_uart-loopback_sync_log" />.
      </para>

      <figure id="fig_uart-loopback_sync_log">
	<title>
	  &uart; loop back program log output.
	</title>

	<informalfigure>
	  <screen>
$ .build/sysc-models/sync-soc simple.cfg progs_or32/uart-loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Or1ksim 0.3.0

   ... &lt;Or1ksim initialization messages&gt;

Char F read at  415740466667 ps
Read: 'F'
Char written at 416796660 ns
Char a read at  451075036667 ps
Read: 'a'
Char written at 452131230 ns
Char r read at  516688386667 ps
Read: 'r'
Char written at 517744580 ns

   ... &lt;Lots more output&gt;
	  </screen>
	</informalfigure>

      </figure>

      <para>
	The read timing is as the character leaves the terminal,
	<emphasis>after</emphasis> the terminal has added the baud rate
	delay. The write timing is as the character leaves the &uart; after the
	echo loop in the embedded application on the &or1ksim; &iss; and
	<emphasis>after</emphasis> the &uart; has added the baud-rate
	delay. So the timing from the <emphasis>read</emphasis> message to the
	<emphasis>write</emphasis> message should be the time for the &uart;
	delay for the current baud rate and packet bits plus the execution
	time for the code to echo the character on the &or1ksim; &iss;.
      </para>

      <para>
	The &uart; was initialized to use 1 start bit, 8 data bits and 1 stop
	bit, which at 9600 baud takes around 1040&mu;s. The time shown in
	<xref linkend="fig_uart-loopback_sync_log" /> for the first character
	to be read and written back is approximately 1056&mu;s. This seems
	reasonable, allowing approximately 1600 cycles (16&mu;s at 100MHz) for
	the &or1ksim; &iss; to process the read and write code.
      </para>
    </sect1>
  </chapter>

<chapter id="chap_temporal_decoupling">
    <title>
      Adding Temporal Decoupling to the Model
    </title>

    <para>
      In this case study temporal decoupling is added to the &tlm2; model of
      an &soc;. The &soc; model with arbiter from the previous example is
      reused.
    </para>

    <para>
      The code for the decoupled &or1ksim; &iss; wrapper
      (<filename>Or1ksimDecoupSC.cpp</filename> and
      <filename>Or1ksimDecoupSC.h</filename>), the code for the decoupled
      &uart; module (<filename>UartDecoupSC.cpp</filename> and
      <filename>UartDecoupSC.h</filename>) and the main program for the
      complete model (<filename>decoupSocMainSC.cpp</filename>) may be founded
      in the <filename>sysc-models/decoup-soc</filename> directory of the
      distribution.
    </para>

    <sect1> <title> What is Temporal Decoupling
      </title>

      <para>
	The idea of temporal decoupling is very simple and has been around for
	a long time (see for example <xref linkend="ref_fitch_88"
	endterm="ref_fitch_88_xr" />). In a parallel system, the various
	threads keep their own local time, and only synchronize when they need
	to communicate with each other. It is particularly suited to
	timed-based modeling, since it ensures that no one thread hogs the
	execution.
      </para>

      <para>
	It is worth noting that temporal decoupling does not improve overall
	model performance <abbrev>per se</abbrev>. All the same elements will
	need to be modeled. However it does ensure that the various threads
	in the model stay <emphasis>approximately</emphasis> in step over the
	duration of the run, making for a more realistic model. In our example
	it ensures that the &or1ksim; model yields control regularly to allow
	the &uart; and terminal models to keep up.
      </para>

      <para>
	&tlm2; provides some convenience classes to help threads implement
	temporal decoupling. The nomenclature used by these classes can be
	more than a little confusing&mdash;the following should help to
	explain how the technique works.
      </para>

      <para>
	There are two key points about temporal decoupling.
      </para>

      <orderedlist>
	<listitem>
	  <para>
	    Temporal decoupling is a property of <emphasis>threads</emphasis>,
	    not module classes. So it is each <emphasis>thread</emphasis> that
	    must keep track of its local view of time.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Nothing in the &tlm2; system checks a program is following the
	    rules. It is up to each thread to ensure it is compliant.
	  </para>
	</listitem>
      </orderedlist>

      <para>
	Not all threads need use temporal decoupling, although the more that
	do, the greater the potential benefit. In general temporal decoupling
	is only appropriate for threads using &tlm2; blocking interfaces for
	their communication&mdash;typically loosely timed models. Where
	temporal decoupling is implemented it is managed by the threads
	driving <emphasis>initiator</emphasis> sockets.
      </para>

      <sect2>
	<title>
	  Timing Concepts
	</title>

	<para>
	  &tlm2; defines four different timing entities to describe temporal
	  decoupling. These are illustrated in <xref
	  linkend="fig_temporal_decoupling" />.
	</para>

	<figure id="fig_temporal_decoupling">
	  <title>
	    Diagram illustrating temporal decoupling
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="temporal_decoupling.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

	<variablelist>

	  <varlistentry>
	    <term>
	      (System) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which all threads
		synchronize. For example a <emphasis>Global Quantum</emphasis>
		of 100&mu;s means that all threads synchronize on 100&mu;s
		200&mu;s, 300&mu;s etc. Although the &tlm2; standard refers to
		this as just the Global Quantum, it is a system wide concept
		and for clarity this application note refers to it as the
		<emphasis>System Global Quantum</emphasis>.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      (Thread) Global Quantum
	    </term>

	    <listitem>
	      <para>
		This represents the time unit on which a particular thread
		synchronizes. The &tlm2; standard allows different threads to
		have their own private time unit of synchronization, which is
		very confusingly also referred to in the standard as the
		Global Quantum.
	      </para>

	      <para>
		To avoid confusion, in this application note, the term
		<emphasis>Thread Global Quantum</emphasis> is used to mean the
		global quantum used by a particular thread.
	      </para>

	      <para>
		Having different values for the global quantum in different
		threads is a recipe for complete confusion, while offering few
		advantages. The user is strongly recommended to set the Thread
		Global Quantum to the same value as the System Global Quantum
		when the thread is created and not change it.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Quantum
	    </term>

	    <listitem>
	      <para>
		For each thread, this represents the time remaining from the
		current &systemc; time (as returned by
		<function>sc_time_stamp</function>) until the end of the
		current Thread Global Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 235&mu;s and
		the Thread Global Quantum is 100&mu;s, then the Local Quantum
		will be 65&mu;s&mdash;the time until the 300&mu;s Thread Global
		Quantum synchronization is due.
	      </para>

	      <para>
		If the recommendation that all threads set their Thread Global
		Quantum to be the same as the System Global Quantum is
		followed, then the value of the Local Quantum will be the same
		in all threads.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      Local Time Offset
	    </term>

	    <listitem>
	      <para>
		Each thread is allowed to hold a local view of time, which runs
		ahead of the current &systemc; time. This is known as
		the <emphasis>Local Time Offset</emphasis>
	      </para>

	      <para>
		The Local Time Offset must not take the thread's local view of
		time past the next Thread Global Quantum, i.e. it cannot exceed
		the Local Quantum.
	      </para>

	      <para>
		For example if the current &systemc; time stamp is 235&mu;s and
		the Thread Global Quantum is 100&mu;s, then a local time offset
		of 45&mu;s would represent a thread local effective time of
		280&mu;s.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

      </sect2>

      <sect2>
	<title>
	  The Global Quantum Class,
	  <classname>tlm_global_quantum</classname>
	</title>

	<para>
	  &tlm2; defines a <firstterm>singleton</firstterm> class<footnote>
	    <para>
	      A singleton is a class of which only one instance can be
	      created. The constructor is declared private (so no other class
	      can create it), and a static function is provided to return the
	      single instance. This static function will create the single
	      instance the first time it is called, and thereafter just return
	      a reference to that same instance.
	    </para>

	    <para>
	      Singleton classes are useful for holding centrally required
	      values and providing centrally required functions in a system,
	      where having duplicate provision would lead to incorrect
	      behavior.
	    </para>
	  </footnote> which can be used to hold the system global quantum. A
	  set of functions to manipulate the global quantum are provided.
	</para>

	<variablelist>

	  <varlistentry>
	    <term>
	      <function>instance</function>
	    </term>
	    <listitem>
	      <para>
		Returns a reference to the singleton global quantum object
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>set</function>
	    </term>
	    <listitem>
	      <para>
		Sets the global quantum (as a &systemc;
		<classname>sc_time</classname> object)
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>get</function>
	    </term>
	    <listitem>
	      <para>
		Returns the value of the global quantum
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>
	      <function>compute_local_quantum</function>
	    </term>
	    <listitem>
	      <para>
		Returns the local quantum, i.e. the time from the current
		&systemc; time stamp to the next multiple of the global
		quantum.
	      </para>
	    </listitem>
	  </varlistentry>

	</variablelist>

	<para>
	  The intention is that at start up the main program should set the
	  system global quantum in the singleton
	  <classname>tlm_global_quantum</classname> object. All threads can then
	  set their thread global quantum by getting the value from the
	  <classname>tlm_global_quantum</classname> object.
	</para>

      </sect2>


      <sect2>
	<title>
	  &tlm2; Quantum Keepers
	</title>

	<para>
	  &tlm2; provides a utility class for threads to keep track of their
	  thread global quantum, local quantum and local time offset. This is
	  in the <literal>tlm_utils</literal> namespace (like the convenience
	  sockets) with a header in
	  <filename>tlm_utils/tlm_quantumkeeper.h</filename>.
	</para>

	<para>
	  A module will instantiate one quantum keeper for each thread that is
	  uses temporal decoupling, initializing them in the constructor.
	</para>

	<para>
	  Two functions are provided to manage the thread global quantum:
	  <function>set_global_quantum</function> to set the value and
	  <function>get_global_quantum</function>. Typically a module
	  constructor will get the <emphasis>system</emphasis> global quantum
	  with a call to the singleton
	  <classname>tlm_global_quantum</classname> and immediately use that
	  to set the thread global quantum for each thread's quantum
	  keeper.
	</para>

	<para>
	  One function is provided to manage the local quantum. The
	  <function>reset</function> function calls
	  <function>compute_local_quantum</function> to calculates the local
	  quantum from the time stamp and the global quantum (which is done by
	  calling the <function>compute_local_quantum</function> in the
	  singleton <classname>tlm_global_quantum</classname> object) and sets
	  the local time offset to zero.
	</para>

	<para>
	  Typically a constructor will call <function>reset</function> for
	  each thread immediately after setting the thread global
	  quantum. The <function>compute_local_quantum</function> in the
	  quantum keeper is <literal>protected</literal>, so cannot be called
	  directly (which seems to be an omission). If the value of the local
	  quantum is needed, this can be obtained using the
	  <function>compute_local_quantum</function> function in the
	  singleton <classname>tlm_global_quantum</classname> object.
	</para>

	<para>
	  Four functions are provided to manage the local time
	  offset. <function>set</function> sets the local time offset to a
	  particular value, <function>inc</function> increments by a given
	  value and <function>get_local_time</function> returns the current
	  value of the local time
	  offset. <function>get_current_time</function> computes the local
	  effective time, i.e. the &systemc; time stamp plus the local time
	  offset<footnote>
	    <para>
	      The naming is not
	      consistent. <function>get_local_time</function> should have
	      been just <function>get</function> for consistency with
	      <function>set</function> and
	      <function>inc</function>.
	      <function>get_current_time</function> would be better named
	      <function>get_effective_time</function>, to match its
	      description in the standard.
	    </para>
	  </footnote>. The intention is that a thread advances model time, it
	  will call <function>set</function> and <function>inc</function>
	  to update the local decoupled view of time.
	</para>

	<para>
	  Two functions are provided to handle synchronization. The test
	  <function>need_sync</function> returns true if the local time offset
	  exceeds the local quantum. <function>sync</function> calls
	  <function>wait</function> for the local time offset, synchronizing
	  the thread with the global &systemc; view of time, and allowing
	  other threads to catch up. It then calls <function>reset</function>
	  to update the local quantum and zero the local time
	  offset. <function>sync</function> should always be called when
	  <function>need_sync</function> is true, but may be called at any
	  other time if required.
	</para>

      </sect2>

      <sect2>
	<title>
	  Other Styles of Temporal Decoupling
	</title>

	<para>
	  &tlm2; presents one model of temporal decoupling, with an explicit
	  regular synchronization time.
	</para>

	<para>
	  Other temporal decoupling models can build on the &tlm2;
	  infrastructure, for instance to remove the regular synchronization
	  time, and instead only synchronize when the local time offset
	  reaches some prescribed maximum. A class derived from the
	  <classname>tlm_gatekeeper</classname> class can modify the control
	  and synchronization functions, to allow different approaches to be
	  tried.
	</para>
      </sect2>



    </sect1>

    <sect1>
      <title>
	Guidelines for Using &tlm2; Temporal Decoupling
      </title>

      <para>
	Temporal decoupling is not for use everywhere. These guidelines may help.
      </para>

      <orderedlist>

	<listitem>
	  <para>
	    Use temporal decoupling for models based on blocking transactions,
	    as used for loosely timed models. There is no obvious value to
	    temporal decoupling in non-blocking models.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Only apply temporal decoupling to threads that are communicating
	    via &tlm2; transactions. Other &systemc; protocols (for example
	    via FIFO) have no way of communicating delays between threads (the
	    equivalent of the delay parameter in &tlm2; transport functions).
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Let the thread controlling the initiator manage the temporal
	    decoupling and synchronization. Targets should just return the
	    incremented delay, and avoid synchronizing if possible.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Allocate one quantum keeper for each thread that drives an
	    initiator socket and is implementing temporal decoupling.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Ensure that the thread global quantum is always the same as the
	    system global quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Select a global quantum that is small enough not to swamp timing
	    behavior of the system. For example in the &soc; used in this
	    application note, the finest time granularity that matters is the
	    time to put a character over a 9600 baud link, approximately
	    1ms. A time around 10-50% of this would be a reasonable time to
	    use as a global quantum.
	  </para>
	</listitem>
      </orderedlist>

    </sect1>

    <sect1>
      <title>
	Overall Design of the Temporally Decoupled &soc; Model
      </title>

      <para>
	The key aspects of the overall decoupled &soc; model are captured
	in a &uml; class diagram and a &uml; sequence diagram, showing
	interaction with the quantum keeper during processing.
      </para>

      <sect2 id="sec_decoup_classes">
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the decoupled &soc; design
	  incorporating a &uart; and terminal is shown in <xref
	  linkend="fig_decoup_soc_class_diagram" />. The design is similar
	  to that for the synchronized &soc; (see <xref
	  linkend="sec_sync_classes" />). The
	  &or1ksim; &iss; wrapper and &uart; are both
	  subclassed to add the behavior needed for decoupled timing. There is
	  no need to subclass the terminal module, since it has no &tlm;
	  interface, and so therefore cannot use decoupling.
	</para>

	<para>
	  The new <classname>Or1ksimDecoupSC</classname> class is associated
	  with both the system global quantum keeper (<varname>tgq</varname>)
	  and the quantum keeper for the &iss; thread
	  (<varname>issQk</varname>).
	</para>

	<figure id="fig_decoup_soc_class_diagram">
	  <title>
	    Class diagram for the &or1ksim; &soc; with decoupled timing.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="decoup-soc-classes.svg" format="SVG"
			 width="14cm" scalefit="1" align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="decoup-soc-classes.png"
			 format="PNG" width="80%" scalefit="1" align="center" />
	      </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2 id="sec_decoup_sequence_diagrams">
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating the behavior of the &or1ksim;
	  wrapper and its interaction with the quantum keepers for the design
	  is shown in <xref linkend="fig_decoup_soc_sequence_diagram" />. Only
	  the operations of the wrapper and quantum keepers are sown, since
	  there is no significant change in the interactions of the &uart; and
	  terminal (see <xref linkend="sec_simple_sequence_diagram" />).
	</para>

	<para>
	  Where before, calls to <function>wait</function> were used to
	  enforce synchronized timing, this time the <function>sync</function>
	  function of the &iss; gatekeeper is used to ensure a consistent view
	  of time. Rather than being held in strict synchronization, the
	  threads are allowed to catch up at least at each system global
	  quantum boundary.
	</para>

	<figure id="fig_decoup_soc_sequence_diagram">
	  <title>
	    Sequence diagram for the &or1ksim; &soc; with decoupled timing,
	    showing interaction with the quantum keepers.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="decoup-soc-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="decoup-soc-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Temporal Decoupling the &or1ksim; Wrapper Class
      </title>

      <para>
	The only thread that can be decoupled in the current model is the
	&or1ksim; wrapper class, <classname>Or1ksimDecoupSC</classname>, since
	it is the only thread with a &tlm2; initiator socket.
      </para>

      <para>
	&iss; are natural candidates for temporal decoupling, since they often
	can run large blocks of code without any need for hardware
	interaction. This is particularly important for modern compiling &iss;
	(e.g ARM <application>SystemGenerator</application>, ARC
	<application>xISS</application>), which achieve their performance by
	executing thousands of instructions at a time.
      </para>

      <para>
	The changes needed to add temporal decoupling are:
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Change the main thread, <function>run</function> so that it only
	    tries to execute instructions up to the end of the current global
	    quantum.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Change the upcall transport function,
	    <function>doTrans</function>, so that it increments the local
	    time offset, rather than synchronizing via
	    <function>wait</function>.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Updates to the &or1ksim; &iss; library to support running to a
	    fixed time time point.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	A new class, <classname>Or1ksimDecoupSC</classname> is derived from
	<classname>Or1ksimSyncSC</classname> to implement the required
	functionality.
      </para>

      <sect2>
	<title>
	  Adding a Function to the &or1ksim; Library to Support Temporal
	  Decoupling
	</title>

	<para>
	  One additional function is needed in the &or1ksim; library to
	  support temporal decoupling. The <function>or1ksim_run</function>
	  already allows the user to specify a duration for which the
	  simulation will run. A function, is added to change the duration of a
	  run already in progress.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
void  or1ksim_reset_duration( double duration );
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_reset_duration</function> resets the
	      duration of a call to <function>or1ksim_run</function> which
	      is already in progress. The argument is the duration for which
	      the run should continue <emphasis>from the current
	      time</emphasis> (i.e. not from the time of the original call to
	      <function>or1ksim_run</function>).
	    </para>

	    <para>
	      This function is needed because upcalls may lead to a
	      synchronization, increasing the time for which the &iss; may run
	      before needing resynchronization.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  This function is a standard part of the &or1ksim; 0.3.0 library.
	</para>

      </sect2>


      <sect2>
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The new class, <classname>Or1ksimDecoupSC</classname> is derived
	  from <classname>or1ksimSyncSC</classname>, whose header it
	  includes. A custom constructor is defined with the same arguments as
	  the base class constructor.
	</para>

	<para>
	  The &iss; thread, <function>run</function> and the transport
	  function, <function>doTrans</function> are both reimplemented to add
	  temporal decoupling.
	</para>

	<para>
	  A pointer to the system global quantum, <varname>tgq</varname>, and
	  a quantum keeper for the &iss; thread, <varname>issQk</varname> are
	  defined.
	</para>

	<informalfigure>
	  <programlisting>
  tlm::tlm_global_quantum      *tgq;
  tlm_utils::tlm_quantumkeeper  issQk;
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &or1ksim; &iss; wrapper module class with
	  decoupled timing, <classname>Or1ksimDecoupSC</classname> may be
	  found in
	  <filename>sys-models/decoup-soc/Or1ksimDecoupSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2 id="sec_or1ksimdecoupsc_impl">
	<title>
	  <classname>Or1ksimDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class,
	  <classname>Or1ksimSyncSC</classname>. The quantum keeper for the
	  &iss; thread is then initialized with the system global quantum and
	  the local quantum calculated and local time offset zeroed with a
	  call to <function>reset</function>.
	</para>

	<informalfigure>
	  <programlisting>
  tgq = &amp;(tlm::tlm_global_quantum::instance());

  issQk.set_global_quantum( refTgq.get() );
  issQk.reset();
	  </programlisting>
	</informalfigure>

	<note>
	  <para>
	    The global quantum accessor function,
	    <function>instance</function> returns a reference to the global
	    quantum. We convert it to a pointer, since C++ does not allow
	    initialization of a reference instance variable in the constructor.
	  </para>
	</note>

	<para>
	  The main thread function, <function>run</function> is reimplemented
	  to ensure that the &iss; simulation does not run past the end of the
	  current quantum. Instead of running for ever
	  (<function>or1ksim_run(&nbsp;-1.0&nbsp;);</function>), the &iss; is
	  run for the local time quantum, less the local time offset. This
	  means the &iss; will return exactly at the point when it should need
	  to synchronize again.
	</para>

	<para>
	  The body of the program is a perpetual loop, which calculates the
	  time left until the next global quantum then calls the &iss; for that
	  period.
	</para>

	<informalfigure>
	  <programlisting>
  while( true ) {
    sc_core::sc_time  timeLeft =
      tgq->compute_local_quantum() - issQk.get_local_time();
	  </programlisting>
	</informalfigure>

	<para>
	  On return, <function>or1ksim_get_time_period</function> is used to
	  find out how much computation has actually been carried out and
	  advance local time accordingly. This may be different to the
	  duration requested, since an upcall may set a new time point and
	  adjusted the duration. A new time point is immediately set ready for
	  the next loop.
	</para>

	<informalfigure>
	  <programlisting>
    (void)or1ksim_run( timeLeft.to_seconds());

    issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
    or1ksim_set_time_point();
	  </programlisting>
	</informalfigure>

	<para>
	  If the local time offset has reached the end of the global quantum,
	  the thread synchronizes. This replaces the call to
	  <function>wait</function> in the synchronized version of the model
	  (<xref linkend="chap_sync" />).
	</para>

	<informalfigure>
	  <programlisting>
    if( issQk.need_sync() ) {
      issQk.sync();
	  </programlisting>
	</informalfigure>

	<para>
	  The transport function, <function>doTrans</function> has the same
	  structure as the synchronous version in the base class. However
	  instead of calling <function>wait</function> to delay calculation,
	  it updates the local time offset. The time offset is advanced for
	  the &iss; simulation since the last time point and a new time point
	  is set.
	</para>

	<informalfigure>
	  <programlisting>
  issQk.inc( sc_core::sc_time( or1ksim_get_time_period(), sc_core::SC_SEC ));
  or1ksim_set_time_point();
	  </programlisting>
	</informalfigure>

	<para>
	  The delay argument to the blocking transport is the local time
	  offset. This may be increased by the target (to model read/write
	  delay), and the new value becomes the local time offset on return.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_time  delay = issQk.get_local_time();
  dataBus->b_transport( trans, delay );
  issQk.set( delay );
	  </programlisting>
	</informalfigure>

	<para>
	  At this point synchronization could be required&mdash;the read/write
	  delay could have pushed the local time offset past the global
	  quantum.
	</para>

	<informalfigure>
	  <programlisting>
  if( issQk.need_sync() ) {
    issQk.sync();
  }
	  </programlisting>
	</informalfigure>

	<para>
	  The duration remaining for the &iss; simulation is reset in the same
	  way as in the main thread to be the local quantum less the local
	  time offset. On return the &iss; will continue for that period.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_time  timeLeft      =
    tgq->compute_local_quantum() - issQk.get_local_time();

  or1ksim_reset_duration ( timeLeft.to_seconds() );
	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of the &or1ksim; &iss; wrapper module class with
	  decoupled timing, <classname>Or1ksimDecoupSC</classname> may be
	  found in
	  <filename>sys-models/decoup-soc/Or1ksimDecoupSC.cpp</filename> in
	  the distribution.
	</para>

      </sect2>


    </sect1>

    <sect1>
      <title>
	Modifying the &uart; to Support Temporal Decoupling
      </title>

      <para>
	Although the threads in the &uart; class are not temporarily
	decoupled, a small modification is needed. The callback for the target
	socket is part of this class, and it must handle delay data for the
	initiator in <classname>Or1ksimDecoupSC</classname> suitably.
      </para>

      <para>
	A new class, <classname>UartDecoupSC</classname>, derived from
	<classname>UartSyncSC</classname> is defined to provide a modified
	&tlm2; convenience target socket blocking callback function.
      </para>

      <sect2>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Definition
	</title>

	<para>
	  The class definition includes the header of the base class and is
	  derived from it. The constructor has the same parameters as the base
	  class, <classname>UartSyncSC</classname>.
	</para>

	<para>
	  A reimplemented version of the &tlm2; convenience callback,
	  <function>busReadWrite</function> is defined with the same
	  parameters as the base class function.
	</para>

	<para>
	  The definition of the &uart; module class with decoupled timing,
	  <classname>UartDecoupSC</classname> may be found in
	  <filename>sys-models/decoup-soc/UartDecoupSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>uartDecoupSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor just calls the base class constructor, passing on all
	  its arguments.
	</para>

	<para>
	  The <function>BusReadWrite</function> callback has the same
	  structure as the version in the base class. Like the base class
	  it calls the original <classname>UartSC</classname> version to carry
	  out most of the functionality.
	</para>

	<caution>
	  <para>
	    The call is therefore to the <emphasis>base class of the base
	    class</emphasis> of this class. The call cannot be to the base
	    class, since that would call <function>wait</function>,
	    defeating the temporal decoupling.
	  </para>
	</caution>

	<para>
	  The difference is in updating the delay. The synchronous base class
	  waited to model the timing delay and set the delay in the response
	  to zero. In this version the code just increments the delay (which
	  is the local time offset) by the additional time to carry out the
	  read or write.
	</para>

	<informalfigure>
	  <programlisting>
  switch( payload.get_command() ) {

  case tlm::TLM_READ_COMMAND:
    delay += sc_core::sc_time( UART_READ_NS, sc_core::SC_NS );
    break;
	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of the &uart; module class with decoupled timing,
	  <classname>UartDecoupSC</classname> may be found in
	  <filename>sys-models/decoup-soc/UartDecoupSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_temp_decoup_main">
      <title>
	Main Program for Temporal Decoupling
      </title>

      <para>
	The main program, <filename>decoupSocMainSC.cpp</filename> is similar in
	structure to the main program used for the synchronous version (see
	<xref linkend="sec_sync_main_prog" />). This time the headers for the
	versions of the &or1ksim; wrapper and &uart; implementing temporal
	decoupling are used and the time to use as the global quantum is
	defined as a parameter.
      </para>

      <informalfigure>
	<programlisting>
#include "Or1ksimDecoupSC.h"
#include "UartDecoupSC.h"
#include "TermSyncSC.h"

#define QUANTUM_US   100
	</programlisting>
      </informalfigure>

      <para>
	Before any modules are instantiated, the system global quantum must be
	set. For the initial version a value of 100&mu;s is selected, 10% of
	the time taken to transmit a character at 9600 baud, so there should
	be no awkward timing interactions.
      </para>

      <informalfigure>
	<programlisting>
  tgq->set( sc_core::sc_time( QUANTUM_US, sc_core::SC_US ));
	</programlisting>
      </informalfigure>

      <para>
	Thereafter the program follows the same structure (but using the
	versions of the &or1ksim; wrapper and &uart; with temporal
	decoupling).
      </para>

      <para>
	The implementation of the &systemc; main program for the decoupled
	&soc; may be found in
	<filename>sys-models/decoup-soc/decoupSocMainSC.cpp</filename> in the
	distribution.
      </para>

    </sect1>

    <sect1>
      <title>
	Compiling and Running the Decoupled Model
      </title>

      <para>
	The complete program is compiled from the top level &make;
	file. Both a standalone program (<filename>simple-soc</filename>)
	and a <command>libtool</command> compliant library
	(<filename>libsimple-soc.la</filename>) are created, and both
	incorporate the library created when building the logger test (see
	<xref linkend="sec_iss_run_test" />). The library provides a
	convenient mechanism for reusing the code from this model, when
	creating subsequent models which used derived classes.
      </para>

      <para>
	The &or1ksim; configuration is also unchanged. Like the logger, the
	&uart; registers start at address 0x90000000 and are a total of 8
	bytes in length.
      </para>

      <para>
	Running the model requires specifying the configuration file
	(unchanged) and the binary executable (this time the &uart; loop
	back program). Assuming the programs have been built in a directory
	named <filename>build</filename>, the following command line is
	suitable.
      </para>

      <informalfigure>
	<programlisting>
.build/sysc-models/decoup-soc simple.cfg progs_or32/uart-loop
	</programlisting>
      </informalfigure>

      <para>
	The results look very similar to those for the synchronized version,
	as shown in <xref
	linkend="fig_uart-loopback_decoup_log" />.
      </para>

      <figure id="fig_uart-loopback_decoup_log">
	<title>
	  &uart; loop back program log output with temporal decoupling.
	</title>

	<informalfigure>
	  <screen>
$ .build/sysc-models/decoup-soc simple.cfg progs_or32/uart-loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Or1ksim 0.3.0

   ... &lt;Or1ksim initialization messages&gt;

Char F read at  554441676667 ps
Read: 'F'
Char written at 555541610 ns
Char a read at  604641666667 ps
Read: 'a'
Char written at 605741610 ns
Char r read at  666641666667 ps
Read: 'r'
Char written at 667741600 ns

   ... &lt;Lots more output&gt;
	  </screen>
	</informalfigure>

      </figure>

      <para>
	The timing reported for the first character, 'F', is
	1100&mu;s&mdash;in the synchronized version it was 1056&mu;s. The
	global quantum was set to 100&mu;s, which means that other threads may
	have a delay of up to 100&mu;s before they can run, affecting the time
	they will report for their actions.
      </para>

      <para>
	If the quantum is changed from 100&mu;s to 10ms, the change is more
	dramatic, as shown in  <xref
	linkend="fig_uart-loopback_decoup_10ms_log" />.
      </para>

      <figure id="fig_uart-loopback_decoup_10ms_log">
	<title>
	  &uart; loop back program log output with temporal decoupling and
	  10ms global quantum.
	</title>

	<informalfigure>
	  <screen>
$ .build/sysc-models/decoup-soc simple.cfg progs_or32/uart-loop

             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED
Or1ksim 0.3.0

   ... &lt;Or1ksim initialization messages&gt;

Char F read at  541041666667 ps
Read: 'F'
Char written at 551041600 ns
Char a read at  641041686667 ps
Read: 'a'
Char written at 651041620 ns
Char r read at  1471041676667 ps
Read: 'r'
Char written at 1481041600 ns
	  </screen>
	</informalfigure>

      </figure>

      <para>
	The time taken to write the first character is now 10ms, completely
	dominated by the quantum. The typing of characters at the xterm is
	notably sluggish.
      </para>

      <para>
	This is characteristic of loosely timed models with temporal
	decoupling. The objective is to model the gross behavior of the system
	with a reasonable view of the timing, such that events happen in the
	correct sequence. However detailed timing can be sacrificed in the
	interest of greater model performance.
      </para>

      <para>
	The value for the global quantum is a subjective choice. In this case,
	with a busy polling &uart; loop back function, any delays were wasted
	in additional polling cycles, so a small quantum was appropriate.
      </para>

      <para>
	In a more realistic scenario, the &uart; would be interrupt driven (or
	at least not polled continuously). Very likely the &uart; would only
	be lightly used, while other parts of the system were working. Under
	such circumstances, a global quantum of 100-500&mu;s (10%-50% of the
	time to put one character on the &uart;) would be reasonable. The
	timing of characters output would be out by up to 100%, but the model
	would gain from fewer synchronizations.
      </para>

      <para>
	In other scenarios an even higher quantum could be justified&mdash;for
	example if the &uart; were only for occasional diagnostic output,
	where sluggishness did not matter. However when modeling a 100MHz
	&iss; as part of the &soc;, the benefits of such large global quantum
	values would be minimal.
      </para>

      <para>
	Beware that an excessively large quantum may break software with
	timing dependencies. It may mean that interrupt sequences do not
	arrive in a reasonable order, or flood in all at once. An example of
	this is shown in <xref linkend="chap_linux" />.
      </para>

      <para>
	The other step to take to improve the system would be to move to an
	exclusively &tlm2; model. The &systemc; buffer is a good way to model
	the &uart; to terminal connection. However by using a &tlm2; socket in
	each direction, the &uart; could adopt temporal decoupling, giving
	further improvement in the overall model.
      </para>

    </sect1>
  </chapter>

  <chapter id="chap_linux">
    <title>
      Modeling Interrupts and Running &linux; on the Example &soc;
    </title>

    <para>
      The Simple &soc; used in the previous sections is not sufficient to run
      &linux;. Two significant extensions are needed.
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  Memory management must be added to support &linux; virtual
	  memory. This is provided by enabling the internal &mmu;s (instruction
	  and data) of the &or1ksim; &iss;.
	</para>
      </listitem>

      <listitem>
	<para>
	  The &systemc; &uart; peripheral must be extended to handle
	  interrupts.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The example design was shown in <xref linkend="sec_example_soc_intr"/>,
      but for convenience the diagram is repeated here in <xref
      linkend="fig_simple_soc_intr2" />.
    </para>

    <figure id="fig_simple_soc_intr2">
      <title>
	Simple &soc; based on the &or1k; &or1ksim; with interrupts and &mmu;.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="simple_soc_intr.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      Enabling memory management is a matter of modifying the configuration
      file for &or1ksim;. The &linux; port used here expects to boot from flash
      memory, so the internal memory of &or1ksim; is also extended to provide
      this.
    </para>

    <para>
      The &uart; model, <classname>UartDecoupSC</classname> is further
      extended by a new derived class, <classname>UartIntrSC</classname>
      providing a &systemc; <classname>sc_out&lt;bool&gt;</classname> port
      through which the interrupt signal is driven.
    </para>

    <para>
      The code for the &or1ksim; &iss; wrapper with interrupts enabled
      (<filename>Or1ksimIntrSC.cpp</filename> and
      <filename>Or1ksimIntrSC.h</filename>), the code for the interrupt
      enabled &uart; module (<filename>UartIntrSC.cpp</filename> and
      <filename>UartIntrSC.h</filename>) and the main program for the complete
      model (<filename>intrSocMainSC.cpp</filename>) may be found in the
      <filename>sysc-models/intr-soc</filename> directory of the distribution.
    </para>

    <sect1>
      <title>
	Overall Design of the &soc; Model with Interrupts
      </title>

      <para>
	The key aspects of the overall decoupled &soc; model are captured
	in a &uml; class diagram and a &uml; sequence diagram, showing how an
	interrupt is processed during a write transaction to the &uart;.
	
      </para>

      <sect2 id="sec_intr_classes">
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the  &soc; with interrupts
	  incorporating a &uart; and terminal is shown in <xref
	  linkend="fig_intr_soc_class_diagram" />. The design is similar
	  to that for the temporally decoupled &soc; (see <xref
	  linkend="sec_decoup_classes" />). The
	  &or1ksim; &iss; wrapper and &uart; are both
	  subclassed to add the behavior needed for interrupt handling. There is
	  no need to subclass the terminal module, since it has not interrupts
	  to be modeled.
	</para>

	<para>
	  The new <classname>Or1ksimIntrSC</classname> class is associated
	  with an array of 32 signals, which may be connected to peripherals
	  wishing to raise an interrupt.
	</para>

	<para>
	  The new <classname>UartIntrSC</classname> class is associated with a
	  &systemc; &fifo; used to collect interrupts raised from both Rx and
	  Tx ports. It also has a &systemc; output port,
	  <varname>intr</varname> on which it drives any interrupt it raises.
	</para>

	<figure id="fig_intr_soc_class_diagram">
	  <title>
	    Class diagram for the &or1ksim; &soc; with interrupts.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="intr-soc-classes.svg" format="SVG"
			 width="14cm" scalefit="1" align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="intr-soc-classes.png"
			 format="PNG" width="80%" scalefit="1" align="center" />
	      </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2 id="sec_intr_sequence_diagrams">
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating how the &or1ksim; wrapper handles
	  an interrupt when a character is written to the &uart; is shown in
	  <xref linkend="fig_intr_soc_sequence_diagram" />. Only 
	  the interaction between the wrapper and the &uart; is shown, since
	  the other components largely retain their existing
	  functionality. The model is fully decoupled, but for compactness the
	  actions to handle decoupled timing are omitted.
	</para>

	<para>
	  The &or1ksim; wrapper maintains a separate process (a &systemc;
	  <literal>SC_METHOD</literal>) to handle interrupts. Similarly the
	  &uart; adds a new thread to handle interrupts. Although not standard
	  &uml; separate threads of control are shown for each of these
	  objects in the sequence diagram.
	</para>

	<figure id="fig_intr_soc_sequence_diagram">
	  <title>
	    Sequence diagram for a write transaction on the &or1ksim; &soc;
	    with interrupts.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="intr-soc-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="intr-soc-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>
    </sect1>

    <sect1>
      <title>
	Extending the <classname>Or1ksimDecoupSC</classname> Module Class
      </title>

      <para>
	The &or1ksim; &iss; library is extended to provide
	&api; calls to generate an interrupt. The &or1ksim;
	includes a <firstterm>programmable interrupt controller</firstterm>
	(<acronym>PIC</acronym>), which is enabled. The new
	&api; call, <function>or1ksim_interrupt</function>,
	provides an edge-triggered interrupt, and takes as parameter the
	interrupt number to be triggered. The new &api;
	calls, <function>or1ksim_interrupt_set</function> and
	<function>or1ksim_interrupt_set</function>, provide for setting and
	clearing level sensitive interrupts. The choice of interrupt type to
	use is made in the &or1ksim; configuration file.
      </para>

      <para>
	The &or1ksim; wrapper, <classname>Or1ksimDecoupSC</classname> is further
	extended by a new derived class, <classname>Or1ksimIntrSC</classname>,
	which provides an array of signal ports to connect to external devices
	which wish to generate interrupts.
      </para>

      <sect2>
	<title>
	  Adding Interrupt Generation Functions to the &or1ksim; Library
	</title>

	<para>
	  The additional function allows the external &systemc; model to call
	  into the &or1ksim; &iss; to request an interrupt. The &iss; requires
	  that interrupts are not taken mid-instruction (for example while a
	  peripheral memory access upcall is in progress), so a flag is set
	  internally, allowing the &iss; to trigger the interrupt at the start
	  of the next instruction.
	</para>

	<para>
	  The standard version of &or1ksim; uses edge triggered interrupts,
	  and they are used in this example. However &or1ksim; can support
	  level triggered interrupts. For this additional interface functions
	  are provided, although they are not used in this example.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
void or1ksim_interrupt( int  i );
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_interrupt</function> requests the the
	      interrupt given by its argument be taken at the start of the
	      next instruction cycle. This is edge-triggered interrupt
	      functionality, and there is no need to clear the interrupt.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
void or1ksim_interrupt_set( int  i );
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_interrupt_set</function> asserts
	      the interrupt given by its argument for consideration by
	      &or1ksim; at the start of the next instruction cycle. This is
	      for level triggered interrupt handling, and must be explicitly
	      cleared when the interrupt handling is complete.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
void or1ksim_interrupt_clear( int  i );
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_interrupt_clear</function> deasserts the
	      interrupt given by its argument for consideration by &or1ksim;
	      at the start of the next instruction cycle. This is to clear an
	      interrupt previously asserted with <function>void
	      or1ksim_interrupt_set</function> when using level triggered
	      interrupt handling.

	      <function>or1ksim_interrupt</function> requests the
	      interrupt given by its argument be taken at the start of the
	      next instruction cycle.
	    </para>
	  </listitem>
	</itemizedlist>

	<para>
	  These functions are a standard part of the &or1ksim; 0.3.0 library.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimIntrSC</classname> is
	  derived from the existing <classname>Or1ksimDecoupSC</classname>
	  module class, whose header, <filename>Or1ksimDecoupSC.h</filename>,
	  is included. The number of interrupts to be supported is given by
	  the constant, <literal>NUM_INTR</literal>.
	</para>
	
	<informalfigure>
	  <programlisting>
#define  NUM_INTR  32
	  </programlisting>
	</informalfigure>

	<para>
	  The new class derived from the base class and a custom constructor
	  defined. The possible interrupts are represented by an array of
	  <classname>sc_signal</classname>.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_signal&lt;bool&gt;  intr[NUM_INTR];
	  </programlisting>
	</informalfigure>

	<tip>
	  <para>
	    It would have been possible to define an array of signal input
	    ports, <classname>sc_in&lt;bool&gt;</classname>. However these
	    ports must then be explicitly connected (bound), requiring tie-off
	    signals to be created in the main program.
	  </para>

	  <para>
	    By creating actual signals, interrupts that are unused can be left
	    unbound and ignored.
	  </para>
	</tip>

	<para>
	  A &systemc; method is required to handle the interrupts (since it
	  never waits, a thread is not needed). This can respond to interrupts
	  in parallel with the main &iss; execution thread.
	</para>

	<informalfigure>
	  <programlisting>
  void  intrMethod();
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &or1ksim; &iss; wrapper module class with
	  interrupts, <classname>Or1ksimIntrSC</classname> may be
	  found in
	  <filename>sys-models/intr-soc/Or1ksimIntrSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>Or1ksimIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class constructor
	  for processing. It then sets up <function>intrMethod</function> as a
	  &systemc; method process, sensitive to the positive edge of each
	  interrupt signal. There is no need to initialize this function.
	</para>

	<informalfigure>
	  <programlisting>
  SC_METHOD( intrMethod );
  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    sensitive &lt;&lt; intr[i].posedge_event();
  }
  dont_initialize();
	  </programlisting>
	</informalfigure>
	
	<para>
	  The interrupt method is triggered by a positive edge on one of the
	  signals. It loops through to find which interrupt was triggered and
	  generates a call to <function>or1ksim_interrupt</function> for that
	  interrupt number. In principle more than one could be triggered in the
	  same cycle, so all are checked.
	</para>

	<informalfigure>
	  <programlisting>
  for( i = 0 ; i &lt; NUM_INTR ; i++ ) {
    if( intr[i].event()) {
      or1ksim_interrupt( i );
    }
  }
	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of the &or1ksim; &iss; wrapper module class with
	  interrupts, <classname>Or1ksimIntrSC</classname> may be found in
	  <filename>sys-models/intr-soc/Or1ksimIntrSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>


    <sect1>
      <title>
	Extending the <classname>UartDecoupSC</classname> Module Class
      </title>

      <para>
	The existing &uart; module processes interrupts, but does not generate
	an external interrupt signal. To generate an interrupt signal,
	<classname>UartDecoupSC</classname> is further extended by a new
	derived class, <classname>UartIntrSC</classname>, which provides a
	signal port and a new thread to drive that signal port
      </para>

      <para>
	An extra thread is required, because both the
	<function>rxMethod</function> and <function>busThread</function>
	processes may wish to drive signals, but &systemc; requires that a
	signal is driven by a single process. Just as in hardware design a
	simple wire would not normally have more than one driver.
      </para>

      <para>
	The new process communicates with the existing processes via a FIFO
	internal to the UART, allowing <function>rxMethod</function> and
	<function>busThread</function> to both request interrupt activity
	and for those requests to be processed in the order they were
	generated.
      </para>

      <sect2>
	<title>
	  <classname>UartIntrSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>UartIntrSC</classname> is
	  derived from the existing <classname>UartDecoupSC</classname>
	  module class, whose header, <filename>UartDecoupSC.h</filename>,
	  is included.
	</para>

	<para>
	  A custom constructor is declared, and a signal output port,
	  <literal>sc_out&lt;bool&gt; intr</literal> through which the
	  interrupt will be driven.
	</para>

	<para>
	  The new thread, <function>intrThread</function> is declared. It
	  will use re-implemented versions of the <function>genIntr</function>
	  and <function>clrIntr</function> functions from the base class,
	  <classname>UartSC</classname>.
	</para>

	<para>
	  A Boolean FIFO is used to hold the queue of requests from the
	  existing processes, <function>rxMethod</function> and
	  <function>busThread</function>.
	</para>

	<informalfigure>
	  <programlisting>
  sc_core::sc_fifo&lt;bool&gt;  intrQueue;
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &uart; module class with interrupts,
	  <classname>UartIntrSC</classname> may be found in
	  <filename>sys-models/intr-soc/UartIntrSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>

	<title>
	  <classname>UartIntrSC</classname> Module Class Implementation
	</title>

	<para>
	  Since this class declares a new &systemc; process,
	  <literal>SC_HAS_PROCESS</literal> is used. The constructor passes
	  its arguments to the base class,
	  <classname>UartDecoupSC</classname> and sets the FIFO queue size to 1.
	</para>

	<informalfigure>
	  <programlisting>
UartIntrSC::UartIntrSC( sc_core::sc_module_name  name,
                        unsigned long int        _clockRate,
                        bool                     _isLittleEndian ) :
  UartDecoupSC( name, _clockRate, _isLittleEndian ),
  intrQueue( 1 )
{
	  </programlisting>
	</informalfigure>

	<note>
	  <para>
	    The choice of FIFO size means that there should be only one
	    request for interrupt pending. In principle this could block an
	    attempt by the <function>rxMethod</function> to write to the FIFO,
	    and since &systemc; methods may not wait (unlike threads) a
	    run time error will occur.
	  </para>

	  <para>
	    This is an explicit model design decision. If there is interrupt
	    congestion, then it would be useful to know&mdash;indicating
	    design issues over the UART capacity. If this were not an issue,
	    then it would be quite valid to use a larger FIFO capacity.
	  </para>
	</note>

	 <para>
	   The constructor then creates the new &systemc; method for
	   <function>intrThread</function>.
	 </para>

	 <para>
	   <function>intrThread</function> has a very simple
	   &api;. If <literal>true</literal> is read it
	   asserts an interrupt (drives the interrupt port
	   <literal>true</literal>), otherwise it deasserts the interrupt port
	   (drives the interrupt port <literal>false</literal>).
	 </para>

	 <para>
	   On initialization, the interrupt port is deasserted
	   (<literal>false</literal>). The thread then sits in a perpetual
	 loop, copying requests from the FIFO to the interrupt signal output
	 port.</para>

	 <informalfigure>
	   <programlisting>
  while( true ) {
    intr.write( intrQueue.read() );
  }
	   </programlisting>
	 </informalfigure>

	 <para>
	   The interrupt generator, <function>genIntr</function> is almost
	   identical to the version in the base class,
	   <classname>UartSC</classname>. The only difference is that if an
	   interrupt is generated, a request to drive the signal is written
	   onto the internal interrupt FIFO for processing by the
	   <function>intrThread</function> thread.
	 </para>

	 <informalfigure>
	   <programlisting>
    setIntrFlags();                    // Show highest priority
    intrQueue.write( true );            // Request an interrupt signal
	   </programlisting>
	 </informalfigure>

	 <para>
	   The interrupt clear routing is a similar modification, this time
	   requesting the interrupt signal to be cleared by writing
	   <literal>false</literal> on the FIFO queue.
	 </para>

	 <informalfigure>
	   <programlisting>
  if( isSet( regs.iir, UART_IIR_IPEND )) {     // 1 = not pending
    intrQueue.write( false );                   // Deassert if none left
	   </programlisting>
	 </informalfigure>

	<para>
	  The implementation of the &uart; module class with interrupts,
	  <classname>UartIntrSC</classname> may be found in
	  <filename>sys-models/intr-soc/UartIntrSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>
    </sect1>

    <sect1 id="sec_intr_main">
      <title>
	Main Program for the Interrupt Driven Model
      </title>

      <para>
	The main program for the model supporting interrupts is in
	<filename>intrSocSC.cpp</filename>. It has a very similar structure to
	the main program used with the temporal decoupling example in <xref
	linkend="sec_temp_decoup_main" />, but uses the new versions of the
	&or1ksim; wrapper class and &uart; module,
	<classname>Or1ksimIntrSC</classname> and
	<classname>UartIntrSC</classname>. 
      </para>

      <para>
	A baud rate of 115,200 is expected for the &linux; kernel serial port
	and a global quantum of 10&mu;s is appropriate for this. A constant is
	defined to hold the interrupt port number used by the &uart; (2).
      </para>

      <informalfigure>
	<programlisting>
#define BAUD_RATE   115200
#define QUANTUM_US      10

#define INTR_UART        2
	</programlisting>
      </informalfigure>

      <para>
	The main program structure is unchanged, except that the &uart;
	interrupt output port needs to be connected to the correct signal in
	the &or1ksim; wrapper:
      </para>

      <informalfigure>
	<programlisting>
  uart.intr( iss.intr[INTR_UART] );
	</programlisting>
      </informalfigure>

      <para>
	The code for the SystemC main program for the &soc; with interrupts
	may be found in
	<filename>sys-models/intr-soc/intrSocMainSC.h</filename> in the
	distribution.
      </para>

    </sect1>

    <sect1 id="sec_intr_running">
      <title>
	Running the Interrupt Driven Model
      </title>

      <para>
	Compilation and linking of the program follows the same procedure as
	previous examples.
      </para>

      <para>
	As a simple test, the interrupt loop program used in earlier examples
	is extended to demonstrate basic interrupt handling. However the main
	test is booting a &linux; kernel.
      </para>

      <sect2>
	<title>
	  Simple Test for the Interrupt Driven &soc; Model
	</title>

	<para>
	  A simple test is provided in <filename>uart-loop-intr.c</filename>
	  as an extension of <filename>uart-loop.c</filename>. After a
	  character is read, the program loops to wait until the interrupt
	  pending flag is clear (indicating the transmit buffer is empty).
	</para>

	<informalfigure>
	  <programlisting>
    do {                        /* Wait for interrupts to clear */
      ;
    } while( is_set( uart->iir, UART_IIR_IPEND ) );
	  </programlisting>
	</informalfigure>

	<para>
	  This is a very basic test&mdash;if all is well it behaves
	  identically to the existing loop program. If there is a problem
	  clearing the transmit buffer empty interrupt, or the received data
	  available interrupt is not cleared when data is read, then the
	  program will lock up waiting for the interrupt pending flag to
	  clear.
	</para>

	<para>
	  The source code for the interrupt driven &uart; program may be found
	  in <filename>progs-or32/uart-loop-intr.c</filename> in the
	  distribution. It is built using the standard &or1k; tool chain as
	  part of the main system build.
	</para>

      </sect2>

      <sect2>
	<title>
	  Running &linux;
	</title>

	<para>
	  This test uses a &linux;&nbsp;2.6.19 kernel built for the standalone
	  &or1ksim; as described in <xref
	  linkend="ref_app_note_2" endterm="ref_app_note_2_xr" /> <xref
	  linkend="ref_app_note_2" />. A configuration file, which enables the
	  internal <firstterm>memory management unit</firstterm>s
	  (&mmu;s) and Programmable Interrupt Controller
	  (<acronym>PIC</acronym>) of the &or1ksim; is provided,
	  <filename>linux.cfg</filename>. This also declares additional
	  internal memory space in &or1ksim; for flash and
	  <acronym>SRAM</acronym>.
	</para>

	<para>
	  The &systemc; model is then run with this configuration file and the
	  &linux; kernel binary.
	</para>

	<informalfigure>
	  <informalfigure>
	    <programlisting>
./IntrSocSC linux.cfg ../linux-2.6.19/vmlinux
	    </programlisting>
	  </informalfigure>
	</informalfigure>

	<para>
	  Initially &linux; copies itself from flash memory to
	  <acronym>RAM</acronym>.
	</para>

	<informalfigure>
	  <screen>
Copying Linux... Ok, booting the kernel.
	  </screen>
	</informalfigure>


	<para>
	  After a pause while initial booting is taking place the serial
	  interface is ready, allowing the normal kernel boot messages to
	  appear:
	</para>

	<informalfigure>
	  <screen>
Linux version 2.6.19-or32 (jeremy@thomas) (gcc version 3.4.4) #59 Wed Jun 25 18:
48:06 BST 2008
Detecting Processor units:
  Signed 0x391
Setting up paging and PTEs.
write protecting ro sections (0xc0002000 - 0xc024c000)
Setting up identical mapping (0x80000000 - 0x90000000)
Setting up identical mapping (0x92000000 - 0x92002000)
Setting up identical mapping (0xb8070000 - 0xb8072000)
Setting up identical mapping (0x97000000 - 0x97002000)
Setting up identical mapping (0x99000000 - 0x9a000000)
Setting up identical mapping (0x93000000 - 0x93002000)
Setting up identical mapping (0xa6000000 - 0xa6100000)
Setting up identical mapping (0x1e50000 - 0x1fa0000)
dtlb_miss_handler c00040c8
itlb_miss_handler c00041a8
Built 1 zonelists.  Total pages: 3953
Kernel command line: root=/dev/ram console=ttyS0

   &lt;Lots more &linux; kernel messages...&gt;

Serial: 8250/16550 driver $Revision: 1.90 $ 4 ports, IRQ sharing disabled
serial8250.0: ttyS0 at MMIO 0x90000000 (irq = 2) is a 16450

   &lt;Lots more &linux; kernel messages...&gt;

VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
init started:  BusyBox v1.4.1 (2007-03-22 18:53:56 EST) multi-call binary
Starting pid 22, console /dev/ttyS0: '/etc/init.d/rcS'

Please press Enter to activate this console.
	  </screen>
	</informalfigure>


	<para>
	  This takes a simulated time of about 37 seconds, and on a modern PC
	  an elapsed time of around 20-25 seconds (the &or1ksim; &iss; in this
	  minimal configuration runs at 150-200MHz <footnote>
	    <para>
	      This may seem exceptionally fast for an interpreting &iss;, but
	      this model is configured with slow RAM with a 20-25 cycle access
	      time and no caches. So 150-200MHz represents only 5-10
	      MIPS. That's why booting a basic &linux; kernel takes 37s of
	      simulated time, rather than the 2-3s that might reasonably be
	      expected!
	    </para>
	  </footnote>).
	</para>
  
	<para>
	  At this point hitting return will start up a &linux; shell,
	  running some basic commands and in this example the
	  <application>BusyBox</application> utilities (see the <ulink
	  url="http://www.busybox.com">website</ulink> for more details).
	</para>

	<informalfigure>
	  <screen>
Please press Enter to activate this console. 
Startingpid 25, console /dev/ttyS0: '/bin/sh'


BusyBox v1.4.1 (2007-03-22 18:53:56 EST) Built-in shell (ash)
Enter 'help' for a list of built-in commands.

# ls /proc
1              2              bus            iomem          self
10             25             cmdline        ioports        slabinfo
11             26             cpuinfo        kcore          stat
12             3              crypto         kmsg           sys
13             4              devices        loadavg        sysrq-trigger
14             5              diskstats      locks          sysvipc
15             6              driver         meminfo        tty
16             7              execdomains    misc           uptime
17             8              filesystems    mounts         version
18             9              fs             net            vmstat
19             buddyinfo      interrupts     partitions     zoneinfo
# busybox mount
rootfs on / type rootfs (rw)
/dev/root on / type ext2 (ro)
proc on /proc type proc (rw)
# 
	  </screen>
	</informalfigure>


	<para>
	  The importance of choosing a suitable value for the global quantum
	  is well illustrated here. Rebuild the model with a global quantum of
	  100&mu;s&mdash;rather longer than the time it takes to transmit one
	  character at 115,200 baud.
	</para>

	<informalfigure>
	  <informalfigure>
	    <programlisting>
#define QUANTUM_US     100
	    </programlisting>
	  </informalfigure>
	</informalfigure>

	<para>
	  The time taken to boot is marginally faster (19s), but this time the
	  terminal cannot cope with the erratic interrupt behavior.
	</para>

	<informalfigure>
	  <screen>
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 104k freed
init started:  BusyBox v1.4.
Please press Ent
	  </screen>
	</informalfigure>


	<para>
	  The &linux; serial driver loses interrupts and the system locks up
	  and will eventually crash with an unhandled interrupt exception.
	</para>

      </sect2>
    </sect1>



  </chapter>

  <chapter id="chap_jtag">
    <title>
      Adding a &jtag; Interface to the Model
    </title>

    <para>
      All the models in previous chapters have considered only the main
      &wishbone; bus interface to the &or1k;. However the processor also
      provides a debug interface, which at the hardware level is implemented
      via a &ieee; 1149.1 &jtag;.
    </para>

    <para>
      At the simplest level, it is easy to have a transactional view of &jtag;.
      Registers are shifted in and registers are shifted out. A simple
      read-modify-write transaction.
    </para>

    <para>
      The difficulty is that &jtag; is a bit serial interface, whereas &tlm2;
      really models simple reads and writes over bus interfaces (such as
      &wishbone;). The solution is to represent the &jtag; register in a byte
      vector, and use a &tlm2; generic payload extension to describe the
      &jtag; specific characteristics of bit length and target action (reset,
      shift through the instruction register or shift through the data
      register). This is described in <xref linkend="sec_payload_extension"/>.
    </para>

    <para>
      The example design extended to support &jtag; was shown in <xref
      linkend="sec_example_soc_jtag"/>, but for convenience the diagram is
      repeated here in <xref linkend="fig_simple_soc_jtag2" />.
    </para>

    <figure id="fig_simple_soc_jtag2">
      <title>
	Simple &soc; based on the &or1k; &or1ksim; with interrupts, &mmu; and
	&jtag; debug interface.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="simple-soc-jtag.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="simple-soc-jtag.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      For this example, a full debugger is not used to drive the &jtag;
      interface. Instead a simple &jtag; logger,
      <classname>JtagLoggerSC</classname>, is used. This initializes the
      &jtag; interface, then reads the <emphasis>Next Program
      Counter</emphasis> (<acronym>NPC</acronym>) &spr; once per second. This
      is achieved by shifting a &jtag; register for a debug unit
      <literal>WRITE_COMMAND</literal> to specify the &spr; to read, followed
      by shifting a &jtag; register for a debug unit
      <literal>GO_COMMAND</literal> to read the actual register. This
      simplified design is shown in <xref linkend="fig_simple_soc_jtag_logger"
      />.
    </para>

    <figure id="fig_simple_soc_jtag_logger">
      <title>
	Simple &soc; based on the &or1k; &or1ksim; with interrupts, &mmu; and
	&jtag; logger.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="simple-soc-jtag-logger.svg"
		     format="SVG"
		     width="14cm"
		     scalefit="1"
		     align="center" />
	</imageobject>
	<imageobject>
	  <imagedata fileref="simple-soc-jtag-logger.png"
		     format="PNG"
		     width="80%"
		     scalefit="1"
		     align="center" />
	</imageobject>
      </mediaobject>
    </figure>

    <para>
      The <classname>Or1ksimIntrSC</classname> is extended with a new &tlm2;
      target port and handler for &jtag;. This in turn requires a new &tlm2;
      generic payload extension class, <classname>JtagExtensionSC</classname>.
    </para>

    <para>
      The code for the Or1ksim wrapper with &jtag; interface
      (<filename>Or1ksimJtagSC.cpp</filename>,
      <filename>Or1ksimJtagSC.h</filename>), the code for the generic payload
      extension (<filename>JtagExtensionSC.cpp</filename>,
      <filename>JtagExtensionSC.h</filename>), the code for the &jtag; logger
      (<filename>JtagLoggerSC.cpp</filename>,
      <filename>JtagLoggerSC.h</filename>) and the main program for the
      complete model (<filename>jtagSocMain.cpp</filename>) may be found in
      the <filename>sysc-models/jtoc-soc</filename> directory of the
      distribution.
    </para>

    <sect1>
      <title>
	Overall Design of the SoC Model with &jtag; Interface
      </title>

      <para>
	The key aspects of the overall decoupled SoC model are captured in a
	UML class diagram and a UML sequence diagram, showing how a
	transaction for the &jtag; port is processed.
      </para>

      <sect2>
	<title>
	  Class Structure
	</title>

	<para>
	  The overall class diagram for the &soc; with &jtag; debug support
	  incorporating a &uart;, terminal and simple debug logger is shown in
	  <xref linkend="fig_jtag_soc_class_diagram" />. The design is similar
	  to that for the &soc; with interrupts (see <xref
	  linkend="sec_intr_classes" />). The overall diagram is now quite
	  complex, so, for clarity, only those classes new to the &jtag;
	  enabled design are shown. The remaining detail was shown earlier in
	  <xref linkend="fig_intr_soc_class_diagram" />.
	</para>

	<para>
	  The &or1ksim; &iss; wrapper is subclassed to add the new target port
	  and handler for &jtag;. This needs a &systemc;
	  <firstterm>mutex</firstterm> in order to ensure that access to the
	  &jtag; port does not clash with running of the underlying &or1ksim;
	  model. This is discussed in more detail in <xref
	  linkend="sec_payload_extension" />.
	</para>

	<para>
	  The new logger class, <classname>JtagLoggerSC</classname> provides a
	  simple stream of debug &jtag; register transfers through the debug
	  &tlm2; interface. That interface makes use of the mandatory
	  extension class <classname>JtagExtensionSC</classname> to specify
	  details of the &jtag; register being shifted.
	</para>

	<figure id="fig_jtag_soc_class_diagram">
	  <title>
	    Class diagram for the &or1ksim; &soc; with &jtag; interface.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="jtag-soc-classes.svg" format="SVG"
			 width="14cm" scalefit="1" align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="jtag-soc-classes.png"
			 format="PNG" width="80%" scalefit="1" align="center" />
	      </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

      <sect2>
	<title>
	  Behavioral Diagrams
	</title>

	<para>
	  A sequence diagram, illustrating how the &or1ksim; wrapper handles a
	  debug transaction is shown in <xref
	  linkend="fig_jtag_soc_sequence_diagram" />. Only the interaction
	  between the wrapper and the &jtag; debug interface is shown, since
	  the other components largely retain their existing
	  functionality. The model is fully decoupled and processes
	  interrupts, but for compactness these details are not repeated here.
	</para>

	<para>
	  The key feature is the use of a &systemc; mutex to ensure that the
	  &jtag; transactions are only processed between calls to the
	  &or1ksim; <function>run</function> method.
	</para>

	<figure id="fig_jtag_soc_sequence_diagram">
	  <title>
	    Sequence diagram for a debug transaction on the &or1ksim; &soc;
	    with &jtag; interface.
	  </title>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="jtag-soc-sequence-diagram.svg"
			 format="SVG"
			 width="14cm"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="jtag-soc-sequence-diagram.png"
			 format="PNG"
			 width="80%"
			 scalefit="1"
			 align="center" />
	    </imageobject>
	  </mediaobject>
	</figure>

      </sect2>

    </sect1>

    <sect1 id="sec_payload_extension">
      <title>
	A &tlm2; Interface for &jtag; Using a Payload Extension
      </title>

      <para>
	The &systemc; &tlm2; generic payload is intended for use with models
	of conventional buses. The payload is a multiple of bytes long and
	transmitted over an interface that is a multiple of bytes wide.
      </para>

      <para>
	This is not a good fit for bit-serial interfaces such as &ieee; 1149.1
	&jtag;.
      </para>

      <para>
	It is possible to build a completely new payload, customized to such
	an interface, and which would permit use of all the other &tlm2;
	infrastructure. However such a task is complex and time-consuming, and
	is not good for compatibility between models.
      </para>

      <para>
	As an alternative, &systemc; permits extension of the generic
	payload. There are two flavors of extension,
	<emphasis>ignorable</emphasis> extensions are used where the generic
	payload is still meaningful without the extension being
	present. <emphasis>Mandatory</emphasis> extensions are used where the
	information in the payload is essential to correct operation of
	targets and initiators.
      </para>

      <para>
	Ignorable extensions are preferred wherever possible, since they
	maximize reusability of the interface. The C++ type system is used to
	enforce mandatory extensions, and their use requires sharing a
	defining type between all targets and initiators.
      </para>

      <para>
	For the &jtag; interface we use an ignorable extension. Where present,
	this specifies what type of transaction is required (reset, shift
	through the instruction register, shift through the data register) and
	the exact bit length of the register being shifted. The actual data is
	supplied as a byte vector in the generic payload as normal.
      </para>

      <para>
	Where the extension data is not provided, the type of transaction is
	inferred from the generic payload's address: 0 for shifting through
	the instruction register, 1 for shifting through the data register and
	any other value for reset. The bit length is calculated as 8 times the
	generic payload data length.
      </para>

      <para>
	In practice the extension will always be used, but by being ignorable,
	we allow the maximum possible reuse of the interface in applications.
      </para>

      <sect2>
	<title>
	  <classname>JtagExtensionSC</classname> Extension Class Definition
	</title>

	<para>
	  The extension class is a subclass of the abstract &systemc; template
	  class <classname>tlm::tlm_extension</classname>
	</para>

	<informalfigure>
	  <programlisting>
class JtagExtensionSC: public tlm::tlm_extension&lt;JtagExtensionSC&gt;
	  </programlisting>
	</informalfigure>

	<para>
	  The extension holds data on the &jtag; access type required (reset,
	  shift through the instruction register, shift through the data
	  register) and the exact number of bits to be shifted. For long term
	  compatibility a data field to request debug is added, although it is
	  not used in this application note.
	</para>

	<para>
	  An enumeration type is specified to define the access type. This is
	  public, since targets and initiators must be able to reference it.
	</para>

	<informalfigure>
	  <programlisting>
  enum AccessType {
    RESET,
    SHIFT_IR,
    SHIFT_DR
  };
	  </programlisting>
	</informalfigure>

	<para>
	  The constructor initializes the data fields to appropriate default
	  values (type RESET, bit size zero, debug disabled).
	</para>

	<informalfigure>
	  <programlisting>
JtagExtensionSC ();
	  </programlisting>
	</informalfigure>

	<para>
	  It might be thought appropriate to have variants that could
	  simultaneously initialize the arguments, allowing for easy dynamic
	  allocation and destruction of extensions as needed. However
	  allocation of the extension class is expensive in &systemc;, and
	  dynamic allocation is discouraged. Instead a single instance is
	  typically allocated and reused.
	</para>

	<para>
	  Two virtual methods from the parent class must be implemented to
	  allow instances to cloned and copied.
	</para>

	<informalfigure>
	  <programlisting>
virtual tlm::tlm_extension_base* clone() const;
virtual void copy_from (tlm::tlm_extension_base const &amp;ext);
	  </programlisting>
	</informalfigure>

	<para>
	  The public interface to the extension is through its accessors, a
	  pair for each data field.
	</para>

	<informalfigure>
	  <programlisting>
AccessType  getType () const;
void        setType (AccessType _type);

int         getBitSize () const;
void        setBitSize (int  _bitSize);

bool        getDebugEnabled () const;
void        setDebugEnabled (bool  _debugEnabled);
	  </programlisting>
	</informalfigure>

	<para>
	  The data itself is held privately within the class.
	</para>

	<informalfigure>
	  <programlisting>
AccessType  type;
int         bitSize;
bool        debugEnabled;
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &systemc; generic payload extension class for
	  &jtag;, <classname>JtagExtensionSC</classname>, may be found in
	  <filename>sys-models/jtag-soc/JtagExtensionSC.h</filename> in the
	  distribution.
	</para>
	  
      </sect2>

      <sect2>
	<title>
	  <classname>JtagExtensionSC</classname> Extension Class Implementation
	</title>

	<para>
	  The constructor simply initializes the private data fields to
	  default values (type RESET, bit size zero, debugging disabled).
	</para>

	<para>
	  The two virtual methods which must be implemented,
	  <function>clone</function> and <function>copy_from</function> use
	  boilerplate code from the &tlm2; language reference manual. This is
	  quite sufficient for a simple extension like this.
	</para>

	<para>
	  Finally the three pairs of accessor methods allow each field to be
	  read or set.
	</para>

	<para>
	  The implementation of the &systemc; generic payload extension class
	  for &jtag;, <classname>JtagExtensionSC</classname>, may be found in
	  <filename>sys-models/jtag-soc/JtagExtensionSC.cpp</filename> in the
	  distribution.
	</para>
	  
      </sect2>

    </sect1>

    <sect1>
      <title>
	Extending the <classname>Or1ksimIntrSC</classname> Module Class
      </title>

      <para>
	The Or1ksim ISS library is extended to provide API calls to handle
	&jtag; registers being shifted in and out. The &api;
	call, <function>or1ksim_jtag_reset</function>, causes the &jtag; unit
	to process through a reset sequence. The &api;
	calls, <function>or1ksim_jtag_shift_ir</function> and
	<function>or1ksim_jtag_shift_dr</function>, take a byte vector and bit
	length as arguments and shift specified number of bits through the
	instruction register and data register respectively.
      </para>

      <para>
	All three &api; calls return the time taken by the function in seconds
	(as a C++ <type>double</type>). A key aspect of this &api; is that the
	calls may not be used during the execution of
	<function>or1ksim_run</function>. This could occur during processing
	of an upcall, but at such a time the processor is mid-instruction and
	the state for debug unit processing is inconsistent. This requirement
	is enforced in the wrapper by use of a &systemc;
	<classname>sc_mutex</classname>.
      </para>

      <para>
	The Or1ksim wrapper, <classname>Or1ksimIntrSC</classname> is further
	extended by a new derived class, <classname>Or1ksimJtagSC</classname>,
	which provides a &tlm2; target port to for &jtag; transactions and a
	handler method, <function>jtagHandler</function>, for those
	requests.
      </para>

      <para>
	The &jtag; target port makes use of &tlm2; generic payload with an
	ignorable extension, used to specify precisely the &jtag; operation
	required and the size in bits of the &jtag; register. The class
	<classname>JtagExtensionSC</classname> (see <xref
	linkend="sec_payload_extension" />) is defined for this purpose.
      </para>

      <sect2>
	<title>
	  Adding &jtag; Interface Functions to the Or1ksim library
	</title>

	<para>
	  These additional functions allow the external &systemc; model to
	  call into the &or1ksim; &iss; to request debugging activity through
	  use of a &jtag; register. The &iss; requires that interrupts are not
	  taken mid-instruction (for example while a peripheral memory access
	  upcall is in progress). However it is up to the caller to enforce
	  this restriction.
	</para>

	<para>
	  &jtag; registers are represented as a byte vector, with the least
	  significant bits in the lowest numbered byte. Where the number of
	  bits is not a multiple of eight, it is the most significant byte
	  which holds the odd number of bits, shifted to the least significant
	  position within the byte. Thus for a 12-bit register, bits 0-7 would
	  be in byte 0 and bits 8-11 would be in the least significant 4 bits
	  of byte 1.
	</para>

	<itemizedlist>
	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
double  or1ksim_jtag_reset ();
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_jtag_reset</function> requests the &or1ksim;
	      &iss; debug unit go through a &jtag; reset cycle to put the
	      <firstterm>Test Access Port</firstterm> (&tap;) in a consistent
	      state. It returns the time taken in seconds.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
double  or1ksim_jtag_shift_ir (unsigned char *jreg,
			       int            num_bits);
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_jtag_shift_ir</function> shifts the &jtag;
	      register specified by its arguments through the &jtag;
	      instruction register. It returns the time taken in seconds.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <informalfigure>
		<programlisting>
double  or1ksim_jtag_shift_dr (unsigned char *jreg,
			       int            num_bits);
		</programlisting>
	      </informalfigure>
	    </para>
	    
	    <para>
	      <function>or1ksim_jtag_shift_dr</function> shifts the &jtag;
	      register specified by its arguments through the &jtag; data
	      register. It returns the time taken in seconds.
	    </para>
	  </listitem>

	</itemizedlist>

	<para>
	  The behavior of the debug unit in response to &jtag; register
	  transfers is fully documented in descriptions of the Test Access
	  Port <xref linkend="ref_mohor_jtag"/> and the OpenCores Debug Unit
	  <xref linkend="ref_mohor_debug"/>.
	</para>

	<caution>
	  <para>
	    These functions are currently only available in &or1ksim; built
	    from the &opencores; Subversion tree. In particular they are not a
	    standard part of the &or1ksim; 0.3.0 library.
	  </para>
	</caution>

      </sect2>

      <sect2>
	<title>
	  <classname>Or1ksimJtagSC</classname> Module Class Definition
	</title>

	<para>
	  The new module class, <classname>Or1ksimIntrSC</classname> is
	  derived from the existing <classname>Or1ksimIntrSC</classname>
	  module class, whose header, <filename>Or1ksimIntrSC.h</filename>, is
	  included.
	</para>

	<para>
	  The key addition to the public interface is a 1-bit wide &tlm2;
	  target port for &jtag; transactions.
	</para>

	<informalfigure>
	  <programlisting>
tlm_utils::simple_target_socket&amp;Or1ksimJtagSC, 1&amp;  jtag;
	  </programlisting>
	</informalfigure>

	<para>
	  The constructor is identical in form to that of the base class,
	  taking the same arguments. It will have more work to do, setting up
	  the target &tlm2; port handler and clearing the mutex.
	</para>

	<para>
	  The protected virtual <function>run</function> method is
	  reimplemented in this class. Functionally it is very similar to the
	  base implementation, but a &systemc; mutex is used to ensure that it
	  does not run while a &jtag; transaction is being processed.
	</para>

	<para>
	  As described earlier (see <xref linkend="sec_payload_extension"/>),
	  the &jtag; transactional interface uses an ignorable payload
	  extension. If this extension is not present, the address field of
	  the generic payload is used to infer the action required. For
	  convenience the addresses corresponding to the instruction and data
	  registers are specified.
	</para>

	<informalfigure>
	  <programlisting>
static const unsigned int  ADDR_SHIFT_IR = 0;
static const unsigned int  ADDR_SHIFT_DR = 1;
	  </programlisting>
	</informalfigure>

	<para>
	  &jtag; transactions cannot be processed while the underlying
	  &or1ksim; &iss; is running. This is enforced using a &systemc;
	  mutex.
	</para>

	<informalfigure>
	  <programlisting>
sc_core::sc_mutex  or1ksimMutex;
	  </programlisting>
	</informalfigure>

	<para>
	  Finally we need a handler for &jtag; transactions that are received.
	</para>

	<informalfigure>
	  <programlisting>
void  jtagHandler( tlm::tlm_generic_payload &amp;payload,
                   sc_core::sc_time         &amp;delay );
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the Or1ksim ISS wrapper module class with &jtag;
	  debug support, <classname>Or1ksimJtagSC</classname> may be found in
	  <filename>sys-models/jtag-soc/Or1ksimJtagSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>Or1ksimJtagSC</classname> Module Class Implementation
	</title>

	<para>
	  The constructor passes its arguments to the base class. It then
	  associates the &jtag; target port with its handler and clears the
	  mutex.
	</para>

	<informalfigure>
	  <programlisting>
// Bind the handler to the JTAG target port.
jtag.register_b_transport( this, &amp;Or1ksimJtagSC::jtagHandler );

// Unlock the Mutex
or1ksimMutex.unlock ();
	  </programlisting>
	</informalfigure>

	<para>
	  The implementation of the <function>run</function> method is very
	  similar to the base class for temporally decoupled models (see <xref
	  linkend="sec_or1ksimdecoupsc_impl"/>). However the call to
	  <function>or1ksim_run</function> is surrounded by lock/unlock of the
	  mutex to ensure it cannot run at the same time as a thread
	  requesting &jtag; access.
	</para>

	<informalfigure>
	  <programlisting>
or1ksimMutex.lock ();
(void)or1ksim_run (timeLeft.to_seconds ());
or1ksimMutex.unlock ();
	  </programlisting>
	</informalfigure>

	<para>
	  The handler for &jtag; transactions attempts to determine the type
	  and exact bit size of the register from the extension payload. If
	  this is not present (it is an ignorable extension), then it uses the
	  generic payload address and data length instead.
	</para>

	<informalfigure>
	  <programlisting>
// Retrieve the extension.
JtagExtensionSC *ext;
payload.get_extension (ext);

// Check if the extension exists. Set up the access type and bit size as
// appropriate.
JtagExtensionSC::AccessType  type;
int                          bitSize;

if (NULL == ext)
  {
    unsigned int  addr = (unsigned int) payload.get_address ();

    type    = (ADDR_SHIFT_IR == addr) ? JtagExtensionSC::SHIFT_IR :
              (ADDR_SHIFT_DR == addr) ? JtagExtensionSC::SHIFT_DR :
                                        JtagExtensionSC::RESET ;
    bitSize = 8 * (int) payload.get_data_length ();
  }
else
  {
    type     = ext->getType ();
    bitSize = ext->getBitSize ();
  }
	  </programlisting>
	</informalfigure>

	<para>
	  The handler then calls the appropriate function in the &or1ksim;
	  &iss;, surrounding the call by a mutex lock/unlock, to ensure that
	  &jtag; transactions are not processed while the &iss; is
	  running. This could occur if an upcall caused a
	  <function>wait&nbsp;()</function> allowing processing of a &jtag;
	  transaction to occur.
	</para>

	<para>
	  The implementation of the Or1ksim ISS wrapper module class with
	  &jtag; debug support, <classname>Or1ksimJtagSC</classname> may be
	  found in <filename>sys-models/jtag-soc/Or1ksimJtagSC.cpp</filename>
	  in the distribution.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	A &jtag; Traffic Generating Class
      </title>

      <para>
	In normal use, a debugger, such as &gdb; would be connected to the
	&jtag; port. For demonstrating the interface, we use a stripped down
	&jtag; logger class. This uses the debug interface to read the
	processor's next program counter &spr; once per (modeled) second.
      </para>

      <para>
	With the &or1ksim; debug unit (see <xref linkend="ref_mohor_debug"/>),
	this requires the following steps.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    Reset the &jtag; interface
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Shift <literal>DEBUG</literal> (0x8) into the &jtag; instruction
	    register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Construct a &jtag; data register to select module
	    <literal>CPU0</literal> so we can access its &spr;s and shift that
	    into the &jtag; data register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Construct a &jtag; data register for the
	    <literal>WRITE_COMMAND</literal> debug unit command, specifying
	    that we wish to read the next program counter &spr; and shift that
	    into the &jtag; data register.
	  </para>
	</listitem>

	<listitem>
	  <para>
	    Construct a &jtag; data register for the
	    <literal>GO_COMMAND</literal> debug unit command, to collect the
	    value read from the next program counter &spr; and shift that into
	    the &jtag; data register.
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	These last two steps are repeated with a wait of one second between,
	to give a regular report on the value of the next program counter.
      </para>

      <sect2>
	<title>
	  <classname>JtagLoggerSC</classname> Module Class Definition
	</title>

	<para>
	  The logger will require a simple &tlm2; initiator socket, which
	  will use the generic payload with a custom extension,
	  <classname>JtagExtensionSC</classname>. The relevant headers are
	  included.
	</para>

	<informalfigure>
	  <programlisting>
#include &lt;tlm.h&gt;
#include &lt;tlm_utils/simple_initiator_socket.h&gt;

#include "JtagExtensionSC.h"
	  </programlisting>
	</informalfigure>

	<para>
	  The logger declares an initiator &tlm2; port to connect to the
	  target port in the &or1ksim; wrapper. This is the public interface
	  to this module.
	</para>

	<informalfigure>
	  <programlisting>
tlm_utils::simple_initiator_socket&lt;JtagLoggerSC, 1&gt;  jtag;
	  </programlisting>
	</informalfigure>

	<para>
	  A constructor is needed to connect the extension to the generic
	  payload and to declare the &systemc; thread generating &jtag;
	  transactions.
	</para>

	<informalfigure>
	  <programlisting>
JtagLoggerSC (sc_core::sc_module_name  name);
	  </programlisting>
	</informalfigure>

	<para>
	  The module uses a single allocation of payload and extension. The
	  temptation is to allocate and free these dynamically locally where
	  they are needed. However, as noted earlier (see <xref
	  linkend="sec_payload_extension"/> this is an expensive operation in
	  &systemc;, so we have a single instance of each. The extension will
	  be associated with the payload in the constructor.
	</para>

	<informalfigure>
	  <programlisting>
tlm::tlm_generic_payload  payload;
JtagExtensionSC           ext;
	  </programlisting>
	</informalfigure>

	<para>
	  A &systemc; thread is used to generate the traffic, and this is
	  implemented in the private method, <function>runJtag</function>.
	</para>

	<informalfigure>
	  <programlisting>
virtual void  runJtag();
	  </programlisting>
	</informalfigure>

	<para>
	  The &jtag; registers for the &or1ksim; debug unit have a complex
	  structure. A set of utility methods is provided to construct the
	  registers.
	</para>

	<informalfigure>
	  <programlisting>
void  jtagReset (sc_core::sc_time &amp;delay);

void  jtagInstruction (unsigned char     inst,
                       sc_core::sc_time &amp;delay);

void  jtagSelectModule (unsigned char     moduleId,
                        sc_core::sc_time &amp;delay);

void  jtagWriteCommand (unsigned char      accessType,
                        unsigned long int  addr,
                        unsigned long int  numBytes,
                        sc_core::sc_time  &amp;delay);

void  jtagGoCommandRead (unsigned char      data[],
                         unsigned long int  dataBytes,
                         sc_core::sc_time  &amp;delay);

// Utilities
unsigned long int   crc32 (unsigned long long int  value,
                           int                     num_bits,
                           unsigned long int       crc_in);

unsigned long long  reverseBits (unsigned long long  val,
                                 int                 len);
	  </programlisting>
	</informalfigure>

	<para>
	  The definition of the &jtag; logger module class,
	  <classname>JtagLoggerSC</classname> may be found in
	  <filename>sys-models/jtag-soc/JtagLoggerSC.h</filename> in the
	  distribution.
	</para>

      </sect2>

      <sect2>
	<title>
	  <classname>JtagLoggerSC</classname> Module Class Implementation
	</title>

	<para>
	  The class is declared as having a dynamic process, since the
	  constructor will set up a &systemc; thread.
	</para>

	<informalfigure>
	  <programlisting>
SC_HAS_PROCESS (JtagLoggerSC);
	  </programlisting>
	</informalfigure>

	<para>
	  The constructor passes the module name up to the base class. It
	  associates the payload extension instance with the generic payload
	  instance. Finally it declares a new &systemc; thread.
	</para>

	<para>
	  We must use a <literal>SC_THREAD</literal> rather than
	  <literal>SC_METHOD</literal> since the thread method,
	  <function>runJtag</function> will <function>wait&nbsp;()</function>
	  for one second between each read of the next program counter.
	</para>

	<informalfigure>
	  <programlisting>
  payload.set_extension (&amp;ext);
  SC_THREAD (runJtag);
	  </programlisting>
	</informalfigure>

	<para>
	  The main thread method, <function>runJtag</function> uses the
	  various support utilities to construct &jtag; registers which are
	  then transported to the target wrapped &iss;
	</para>

	<para>
	  First the &jtag; reset, instruction and module selection are
	  shifted, each followed by a message, noting how long the step took.
	</para>

	<informalfigure>
	  <programlisting>
jtagReset (delay);
cout &lt;&lt; "Reset after " &lt;&lt; delay &lt;&lt; "." &lt;&lt; endl;
wait (SC_ZERO_TIME);

delay = SC_ZERO_TIME;
jtagInstruction (DEBUG_INST, delay);
cout &lt;&lt; "Instruction shifted after " &lt;&lt; delay &lt;&lt; "." &lt;&lt; endl;
wait (SC_ZERO_TIME);

delay = SC_ZERO_TIME;
jtagSelectModule (CPU0_MOD, delay);
cout &lt;&lt; "Module selected after " &lt;&lt; delay &lt;&lt; "." &lt;&lt; endl;
wait (SC_ZERO_TIME);
	  </programlisting>
	</informalfigure>

	<para>
	  A wait for zero time between each transaction ensures any other
	  thread has an opportunity to resume if needed.
	</para>

	<para>
	  The main loop reads the next program counter, waiting for one second
	  between each loop. The read involves two transactions, one
	  <literal>WRITE_COMMAND</literal> to specify the transfer required,
	  one <literal>GO_COMMAND</literal> to accomplish the transfer.
	</para>

	<informalfigure>
	  <programlisting>
while (true)
  {
    // Specify the WRITE_COMMAND to read the NPC SPR
    delay = SC_ZERO_TIME;
    jtagWriteCommand (READ32, SPR_NPC, 4, delay);
    cout &lt;&lt; "WRITE_COMMAND after " &lt;&lt; delay &lt;&lt; "." &lt;&lt; endl;
    wait (SC_ZERO_TIME);

    // Read the data, remembering that OR1200 is big endian
    unsigned char  res[4];            // For the data read back

    delay = SC_ZERO_TIME;
    jtagGoCommandRead (res, 4, delay);
    cout &lt;&lt; "GO_COMMAND after " &lt;&lt; delay &lt;&lt; "." &lt;&lt; endl;
    cout &lt;&lt; "- NPC = 0x" &lt;&lt; hex &lt;&lt; (int) res[3] &lt;&lt; (int) res[2]
         &lt;&lt; (int) res[1] &lt;&lt; (int) res[0] &lt;&lt; dec &lt;&lt; "." &lt;&lt; endl;
    wait (sc_time (1000.0, SC_MS));
  }
	  </programlisting>
	</informalfigure>

	<para>
	  The utilities to help in constructing registers and passing them to
	  the target are largely concerned with the minutiae of format. In
	  each the register is constructed, transported to the target and the
	  returned register analyzed.
	</para>

	<para>
	  The implementation of the &jtag; logger module class,
	  <classname>JtagLoggerSC</classname> may be found in
	  <filename>sys-models/jtag-soc/JtagLoggerSC.cpp</filename> in the
	  distribution.
	</para>

      </sect2>

    </sect1>

    <sect1>
      <title>
	Main Program for the Model with &jtag; Debug Interface
      </title>

      <para>
	The main program for the model with &jtag; interface is in
	<filename>jtagSocSC.cpp</filename>. It has a very similar structure to
	the main program used with the interrupt enabled example in <xref
	linkend="sec_intr_main"/>, but uses new versions of the Or1ksim
	wrapper class and adds in the &jtag; logger module to generate &jtag;
	debug port traffic.
      </para>

      <informalfigure>
	<programlisting>
JtagLoggerSC  logger ("logger");
logger.jtag (iss.jtag);
	</programlisting>
      </informalfigure>

      <para>
	The code for the SystemC main program for the SoC with &jtag; debug
	interface may be found in
	<filename>sys-models/jtag-soc/jtagSocMainSC.cpp</filename> in the
	distribution.
      </para>

    </sect1>

    <sect1>
      <title>
	Running the Model with &jtag; Debug Interface
      </title>

      <para>
	Compilation and linking of the program follows the same procedure as
	previous examples.
      </para>

      <para>
	As a simple test, the interrupt loop program with interrupts used in
	<xref linkend="sec_intr_running"/> is reused, but this time the value
	of the next program counter will also be printed on the console.
      </para>

      <sect2>
	<title>
	  Simple Test for the Model with &jtag; Debug Interface
	</title>

	<para>
	  The program is run in the same way as earlier tests. For example
	  from the build directory as follows.
	</para>

	<informalfigure>
	  <programlisting>
$ ./sysc-models/jtag-soc/jtag-soc ../simple.cfg progs-or32/uart-loop-intr
	  </programlisting>
	</informalfigure>

	<para>
	  As before a &xterm; screen will appear, and characters typed at the
	  keyboard will be reflected. This time however the console will also
	  log the results of the various &jtag; commands.
	</para>

	<informalfigure>
	  <screen>
             SystemC 2.2.0 --- May 16 2008 10:30:46
        Copyright (c) 1996-2006 by all Contributors
                    ALL RIGHTS RESERVED

  &lt;Lots of Or1ksim startup messages&gt;

Reset after 200 ns.
Instruction shifted after 160 ns.
Module selected after 2920 ns.
WRITE_COMMAND after 5 us.
GO_COMMAND after 4200 ns.
- NPC = 0x00142c.
Read: 'F'
Read: 'a'
Read: 'r'
Read: 'e'
Read: 'w'
Read: 'e'
Read: 'l'
Read: 'l'
Read: ' '
Read: 'G'
Read: 'a'
Read: 'l'
Read: 'a'
Read: 'x'
Read: 'y'
WRITE_COMMAND after 5 us.
GO_COMMAND after 4200 ns.
- NPC = 0x0012b0.
Read: '!'
WRITE_COMMAND after 5 us.
GO_COMMAND after 4200 ns.
- NPC = 0x001284.
	  </screen>
	</informalfigure>


	<para>
	  The values for the next program counter can be compared against an
	  ordered name table for the &uart; application.
	</para>

	<informalfigure>
	  <screen>
$ or32-elf-nm progs-or32/uart-loop-intr | sort
00000100 T _start
00001000 T _set
00001094 T _clr
00001164 T _is_set
0000121c T _is_clr
000012c8 T _main
00001564 T _simexit
00001584 T _simputc
000015a4 T _simputh
000016f0 T _simputs
	  </screen>
	</informalfigure>


	<para>
	  It can be seen that the first value (<constant>0x00142c</constant>)
	  falls within the <function>main</function> function,
	  while the second (<constant>0x0012b0</constant>) and third
	  (<constant>0x001284</constant>) fall within the flag testing
	  function, <function>is_clr</function>.
	</para>

      </sect2>

    </sect1>

  </chapter>

  <appendix id="app_download">
    <title>
      Downloading the Example Models
    </title>

    <para>
      The example models used in this application note may all be downloaded
      from the &embecosm; website, <ulink
      url="http://www.embecosm.com">www.embecosm.com</ulink>. They are
      licensed under the &gpl; so are freely available to be used.
    </para>

    <para>
      The main directory of the distribution contains:
    </para>

    <itemizedlist>
      <listitem>
	<para>
	  A directory, <filename>sysc-models</filename>, containing the
	  example &systemc; models;
	</para>
      </listitem>

      <listitem>
	<para>
	  A directory, <filename>progs-or32</filename>, containing the
	  &or1k; programs to be used with the models
	</para>
      </listitem>

      <listitem>
	<para>
	  Configuration files for use with &or1ksim; when running the simple
	  models and the &linux; kernel; and
	</para>
      </listitem>

      <listitem>
	<para>
	  A copy of the &gpl;
	</para>
      </listitem>
    </itemizedlist>

    <para>
      The &or1k; tool chain must be available to allow the target programs to
      be build. This is documented on the OpenCores website (<ulink
      url="http://www.opencores.org/">www.opencores.org</ulink>) and in a
      separate &embecosm; application note <xref linkend="ref_app_note_2"
      endterm="ref_app_note_2_xr"/>.
    </para>

    <caution>
      <para>
	This is a change from issue 1 of this application note, when
	precompiled versions were provided.
      </para>
    </caution>

    <para>
      Almost all the &or1ksim; library extensions are available in
      &or1ksim;&nbsp;0.3.0. However the additional functions needed for <xref
      linkend="chap_jtag"/> are currently only available with the &or1ksim;
      <command>Subversion</command> tree on the &opencores; website (<ulink
      url="http://www.opencores.org/">www.opencores.org</ulink>). These
      functions will be provided in &or1ksim;&nbsp;0.4.0, due to be released
      in the near future.
    </para>

    <sect1>
      <title>
	Configuring and Building
      </title>

      <para>
	The software is built in its own directory, thus avoiding
	contaminating the source with the built programs. Assuming that the
	programs have been downloaded and unpacked in a directory named
	<filename>embecosm-esp1-sysc-tlm2.0-examples-2.0</filename>, then
	configuration and building is achieved as follows.
      </para>

      <informalfigure>
	<programlisting>
mkdir build
cd build
../embecosm-esp1-sysc-tlm2.0-examples-2.0/configure <emphasis>options</emphasis>
make
	</programlisting>
      </informalfigure>

      <para>
	This will build all the &systemc; models and the &or1k;
	examples.
      </para>

      <para>
	A number of options to configure are essential to correct building.
      </para>

      <variablelist termlength="12">
	<varlistentry>
	  <term>
	    <literal>--target=or32-elf</literal>
	  </term>

	  <listitem>
	    <para>
	      This specifies the target for the cross compiler used to
	      compile the &or1k; programs. Normally this is
	      <literal>or32-elf</literal>. However an alternative may be
	      required for custom compiler tool chains.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <literal>--with-or1ksim=<replaceable>dirname</replaceable></literal>
	  </term>

	  <listitem>
	    <para>
	      <replaceable>dirname</replaceable> is the directory where the
	      &or1ksim; libraries have been installed. If this is not
	      specified, then the value of the environment variable
	      <envar>OR1KSIM_HOME</envar> will be used instead. If that is
	      not defined, then the configuration will fail with an error
	      message.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <literal>--with-systemc=<replaceable>dirname></replaceable></literal>
	  </term>

	  <listitem>
	    <para>
	      <replaceable>dirname</replaceable> is the directory of the
	      &systemc; installation. If this is not
	      specified, then the value of the environment variable
	      <envar>SYSTEMC</envar> will be used instead. If that is
	      not defined, then the configuration will fail with an error
	      message. 
	    </para>

	    <para>
	      Since it is normal to have <envar>SYSTEMC</envar> defined if
	      it is installed, this option is usually not needed.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
	    <literal>--with-tlm=<replaceable>dirname></replaceable></literal>
	  </term>

	  <listitem>
	    <para>
	      <replaceable>dirname</replaceable> is the directory of the
	      &systemc; &tlm2; installation. If this is not specified,
	      then the value of the environment variable
	      <envar>TLM_HOME</envar> will be used instead. If that is not
	      defined, then the configuration will fail with an error
	      message.
	    </para>

	    <para>
	      Since it is normal to have <envar>TLM_HOME</envar> defined
	      if &tlm2; is installed, this option is usually not needed.
	    </para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <para>
	There are a wide range of other generic options available to control
	configuration. These are seldom used, but can be seen by using the
	following command.
      </para>

      <informalfigure>
	<programlisting>
../configure --help
	</programlisting>
      </informalfigure>

      <para>
	The code is documented throughout with <application
	class="software">doxygen</application>;. The documentation can be
	generated by using the following command after configuration.
      </para>

      <informalfigure>
	<programlisting>
make doxygen
	</programlisting>
      </informalfigure>

    </sect1>

    <sect1>
      <title>
	Building the &linux; Kernel
      </title>

      <para>
	The &linux; kernel is built as described in <xref
	linkend="ref_app_note_2" endterm="ref_app_note_2_xr" /> <xref
	linkend="ref_app_note_2" />. This does require building the &or1ksim;
	tool chain. This includes patches to the &linux; kernel required to get
	it to work correctly on the &or1ksim; &iss;
      </para>

    </sect1>
  </appendix>

  <appendix id="app_macos">
    <title>
      Running with &macos;
    </title>
    
    <para>
      Robert <foreignphrase>G&uuml;nzel</foreignphrase> of the Department of
      Integrated Circuit Design at the <foreignphrase>Technische
      Universit&auml;t Braunschweig</foreignphrase>, Germany has managed to
      get both the OpenRISC tool chain and the examples in this application
      note running under &macos;&nbsp;10.4.
    </para>

    <para>
      There are three main issues that affect the &macos; version
    </para>

    <orderedlist>
      <listitem>
	<para>
	  X11 is not running by default.
	</para>
      </listitem>

      <listitem>
	<para>
	  There is no pseudo-terminal multiplexer
	</para>
      </listitem>

      <listitem>
	<para>
	  &macos; does not allow use of the <literal>F_SETOWN</literal> command
	  on the file descriptor of a pseudo terminal slave. Thus
	  <literal>SIGIO</literal> cannot be received, and there is thus no
	  way of knowing when the user is typing inside the &xterm;.
	</para>
      </listitem>
    </orderedlist>

    <para>
      Robert has written a detailed application note explaining how to resolve
      these issues. At the time of writing it is available from <ulink
      url="http://chschroeder.gamiro.de/rg/or1ksim_macOS10.4.pdf">chschroeder.gamiro.de/rg/or1ksim_macOS10.4.pdf</ulink>. Check
      on the &opencores; website (under &or1k; tool chain) for more recent
      updates.
    </para>

    <para>
      Resolving the third of the problems highlighted above required a
      substantial rewrite of the &uart; and terminal modules. In making this
      rewrite, Robert highlights various areas where efficiency of the model
      can be improved.
    </para>

  </appendix>

  <glossary>
    <title>
      Glossary
    </title>

    <glossentry>
      <glossterm>2-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which is based only on logic high and logic low
	  (binary 0 and binary 1) values.
	</para>

	<glossseealso>4-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>4-state</glossterm>
      <glossdef>
	<para>
	  Hardware logic model which considers unknown (<literal>X</literal>)
	  and unproven (<literal>Z</literal>) values as well as logic high and
	  logic low (binary 0 and binary 1).
	</para>

	<glossseealso>2-state</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Application&#32;Binary&#32;Interface</glossterm>
      <glossdef>
	<para>
	  The low-level interface between an application program and the
	  operating system, thus ensuring binary compatibility between programs.
	</para>

	<para>
	  C++ notoriously suffers from lack of agreed standards in this area.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>approximately&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style where timing information is provided
	  at the level of transactions representing the phases of data
	  transfer in a specific bus protocol (for example the address and
	  data phases of an <acronym>AHB</acronym> read or write).
	</para>

	<glossseealso>loosely&#32;timed</glossseealso>
	<glossseealso>phase</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>backward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport, the transport function which
	  returns the response transaction from target to initiator.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>forward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>big&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a big endian architecture, the
	  least significant byte in a data word resides at the highest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is little endian addressing.
	</para>

	<glossseealso>little&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>base&#32;class</glossterm>
      <glossdef>
	<para>
	  In object oriented programming a class from which other classes (the
	  derived classes) are derived, inheriting variables and
	  functions. Specifically a term favored by C++, also referred to as
	  a parent class or super-class.
	</para>

	<glossseealso>derived&#32;class</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which blocks the flow of
	  control in the initiator until the target has completed the
	  transaction request and responded.
	</para>

	<glossseealso>non-blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>convenience&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; wrapper, providing for simple TLM communication based on
	  C++ callbacks.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>derived&#32;class</glossterm>
      <glossdef>
	<para>
	  In object oriented programming a class which has inheriting
	  variables and functions from another class (known as the base
	  class). Specifically a term favored by C++, also referred to as a
	  child class or subclass.
	</para>

	<glossseealso>base&#32;class</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>direct&#32;memory&#32;interface</glossterm>
      <glossdef>
	<para>
	  In hardware and software design communication between memory and a
	  peripheral without the constant intervention of the processor.
	</para>

	<para>
	  In &tlm2; communication between two threads (typically representing
	  a processor and a memory block) by direct writing through a pointer
	  to the memory rather than by a transactional exchange.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>forward&#32;transport&#32;path</glossterm>
      <glossdef>
	<para>
	  In &tlm2; non-blocking transport the transport function, which
	  passes the opening transaction from initiator to target.
	</para>

	<glossseealso>transport&#32;function</glossseealso>
	<glossseealso>backward&#32;transport&#32;path</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>generic payload</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a class suitable for use as payload for
	  transactions. Recommended to maximize the interoperability of &tlm;s.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>generic payload extension</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>generic payload extension</glossterm>
      <glossdef>
	<para>
	  Within &tlm2;, a mechanism for extending the generic payload, thus
	  allowing initiators and targets to specify additional information.
	</para>

	<para>
	  In its simplest form, extensions are
	  <emphasis>ignorable</emphasis>. Initiators and targets will work
	  correctly if the extension is not present.
	</para>

	<para>
	  Extensions may also be <emphasis>mandatory</emphasis>. This is for
	  use where the additional information provided is necessary for
	  initiators and targets to work correctly.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>generic payload extension</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Hardware&#32;Description&#32;Language</glossterm>
      <acronym>HDL</acronym>
      <glossdef>
	<para>
	  A language (Verilog and <acronym>VHDL</acronym> are the best known),
	  which describes hardware. Can be used to describe both an actual
	  chip and its test bench.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>initiator</glossterm>
      <glossdef>
	<para>
	  The initiator of a transactional exchange to a target. In &tlm2; an
	  initiator module must implement an initiator socket of the
	  appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>target</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Instruction&#32;Set&#32;Simulator</glossterm>
      <acronym>ISS</acronym>
      <glossdef>
	<para>
	  A software model of a CPU core instruction set. Typically completely
	  models the instruction semantics, but not the full microarchitecture
	  of a particular CPU implementation. Timing information may be just
	  an instruction count, or may (as with the &or1ksim;) offer some
	  estimate of timing delays due to memory accesses, caching and
	  virtual memory access.
	</para>
      </glossdef>

    </glossentry>

    <glossentry>
      <glossterm>Joint Test Action Group</glossterm>
      <acronym>JTAG</acronym>
      <glossdef>
	<para>
	  &jtag; is the usual name used for the IEEE 1149.1 standard entitled
	  <emphasis>Standard Test Access Port and Boundary-Scan
	  Architecture</emphasis> for test access ports used for testing
	  printed circuit boards and chips using boundary scan.
	</para>
	<indexterm>
	  <primary>&jtag;</primary>
	</indexterm>

	<para>
	  This standard allows external reading of state within the board or
	  chip. It is thus a natural mechanism for debuggers to connect to
	  embedded systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>&osci;</acronym></glossterm>
      <glosssee>Open &systemc; Initiative</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>little&#32;endian</glossterm>
      <glossdef>
	<para>
	  A description of the relationship between byte and word addressing
	  on a computer architecture. In a little endian architecture, the
	  least significant byte in a data word resides at the lowest
	  byte address (of the bytes in the word) in memory.
	</para>

	<para>
	  The alternative is big endian addressing.
	</para>

	<glossseealso>big&#32;endian</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>loosely&#32;timed</glossterm>
      <glossdef>
	<para>
	  In &tlm2; a modeling style, where timing information is provided
	  at the level of transactions representing a complete data transfer
	  across a hardware bus.
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>memory management unit</glossterm>
      <acronym>MMU</acronym>
      <glossdef>
	<para>
	  A hardware component which maps virtual address references to
	  physical memory addresses via a page lookup table. An exception
	  handler may be required to bring non-existent memory pages into
	  physical memory from backing storage when accessed.
	</para>

	<para>
	  On a Harvard architecture (i.e. with separate logical instruction
	  and data address spaces), two MMUs are typically needed.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>mutex</glossterm>
      <glossdef>
	<para>
	  An object in a program which provides a lock, used to negotiate
	  mutual exclusion between multiple threads.
	</para>

	<para>
	  &systemc; provides a <classname>sc_mutex</classname> class to
	  implement mutual exclusion between &systemc; threads.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>non-blocking</glossterm>
      <glossdef>
	<para>
	  Within the context of TLM, a transaction which allows the flow of
	  control in the initiator to continue immediately the transaction is
	  sent. The response will be provided later by a transport call from
	  the target back to the initiator..
	</para>

	<glossseealso>blocking</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>passthrough</glossterm>
      <glossdef>
	<para>
	  A term describing a &tlm2; convenience socket which does not perform
	  an automatic conversion between blocking and non-blocking
	  transport. Potentially more efficient than the other types of
	  convenience socket.
	</para>

	<glossseealso>payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload</glossterm>
      <glossdef>
	<para>
	  The data passed between threads by a transaction.
	</para>

	<glossseealso>generic payload</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>payload extension</glossterm>
      <glosssee>generic payload extension</glosssee>
    </glossentry>

    <glossentry>
      <glossterm>phase</glossterm>
      <glossdef>
	<para>
	  In &tlm2; approximately timed modeling, a transaction exchange
	  representing a single phase of the specific bus protocol being
	  modeled (for example the address phase of an <acronym>AHB</acronym>
	  read or write).
	</para>

	<glossseealso>approximately&#32;timed</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>POSIX</acronym></glossterm>
      <glossdef>
	<para>
	  An IEEE standard for application programming interfaces and
	  utilities for Unix/&linux; operating systems.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>programmable interrupt controller</glossterm>
      <acronym>PIC</acronym>
      <glossdef>
	<para>
	  A hardware component which provides a large number of interrupt
	  ports, which are mapped onto one or two interrupt ports on an actual
	  processor. The <acronym>PIC</acronym> will provide a lookup table of
	  interrupt service functions for its interrupts, which the interrupt
	  service function on the processor can use to identify the correct
	  handler to use.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, the maximum time a thread may
	  run ahead of the main system clock. This may be regulated by a
	  quantum keeper.
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>quantum keeper</glossterm>
      <glossdef>
	<para>
	  In &tlm2; with temporal decoupling, an object which enforces the
	  rule that threads may not run more than the quantum ahead of the
	  main system clock
	</para>

	<glossseealso>temporal&#32;decoupling</glossseealso>
	<glossseealso>quantum</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>singleton</glossterm>
      <glossdef>
	<para>
	  In object oriented programming, a class which can have at most one
	  instance. Typically implemented by making the constructor private
	  and providing an access function which instantiates the class on its
	  first call and on all other calls returns a pointer to that instance.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>socket</glossterm>
      <glossdef>
	<para>
	  Within the context of &tlm2;, a &systemc; port and export combined
	  with the associated interfaces for blocking and non-blocking
	  transport, direct memory access and debug.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>SystemC</glossterm>
      <glossdef>
	<para>
	  A set of libraries and macros, which extend the C++ programming
	  language to facilitate modeling of hardware.
	</para>

	<para>
	  Standardized by the <glossterm>Open SystemC Initiative</glossterm>,
	  who provide an open source reference implementation.
	</para>

	<glossseealso>Open&#32;&systemc;&#32;Initiative</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>System on Chip</glossterm>
      <acronym>SoC</acronym>
      <glossdef>
	<para>
	  A silicon chip which includes one or more processor cores.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>tagged&#32;socket</glossterm>
      <glossdef>
	<para>
	  A &tlm2; convenience socket, which incorporates a numerical
	  <emphasis>tag</emphasis> to identify the socket in use. This allows
	  a single callback function to handle multiple sockets, with the tag
	  identifying the socket which caused the callback to be invoked.
	</para>

	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>target</glossterm>
      <glossdef>
	<para>
	  The responder to a transactional exchange initiated by an
	  initiator. In &tlm2; a target module must implement a target socket
	  of the appropriate type (blocking or non-blocking).
	</para>

	<glossseealso>initiator</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>temporal&#32;decoupling</glossterm>
      <glossdef>
	<para>
	  In &tlm2; the concept of allowing individual threads to run ahead of
	  the main simulation time stamp. The maximum permitted time of run
	  ahead is known as the <glossterm>quantum</glossterm> and may be
	  regulated by a quantum keeper.
	</para>

	<glossseealso>quantum</glossseealso>
	<glossseealso>quantum keeper</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Test Access Port</glossterm>
      <acronym>TAP</acronym>
      <glossdef>
	<para>
	  The interface to a &jtag; interface defined by IEEE 1149.1.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>thread</glossterm>
      <glossdef>
	<para>
	  In software, a logical parallel flow of control. In the context of
	  &systemc;, the main function of such a thread can be specified with
	  the <literal>SC_THREAD</literal> macro. In &systemc; a
	  <literal>SC_THREAD</literal> is distinguished from a
	  <literal>SC_METHOD</literal> because it can suspend execution with
	  <function>wait</function> calls.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym></glossterm>
      <glossdef>
	<para>
	  An abbreviation for (depending on context)
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm> or
	  <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>Transaction&#32;Level&#32;Modeling</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm><acronym>TLM</acronym>&nbsp;2.0</glossterm>
      <glossdef>
	<para>
	  The &osci; standard interface for writing
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>s in
	  &systemc;.
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transaction</glossterm>
      <glossdef>
	<para>
	  In &tlm; modeling the exchange of data between two threads.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>transport&#32;function</glossterm>
      <glossdef>
	<para>
	  The C++ function which transfers data from an initiator to a
	  target, and (for a non-blocking interface), the response back from
	  the target to the initiator. Within the context of &tlm2; blocking
	  and non-blocking transport interfaces are defined.
	</para>

	<glossseealso>&systemc;</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction</glossterm>
      <glossdef>
	<para>
	  An exchange of data (the payload) between two parallel processes. In
	  &tlm2; this transaction occurs through &systemc; ports implementing
	  the &tlm2; interfaces, which are known as sockets.
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>

	<glossseealso>payload</glossseealso>
	<glossseealso>socket</glossseealso>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Model</glossterm>
      <glossdef>
	<para>
	  A software model in which the components of the model communicate by
	  transferring information to and from each other (transactions).
	</para>

	<para>
	  A full description is provided in <xref linkend="sec_what_is_tlm" />.
	</para>
      </glossdef>
    </glossentry>

    <glossentry>
      <glossterm>Transaction&#32;Level&#32;Modeling</glossterm>
      <glossdef>
	<para>
	  The process of writing software models using
	  <glossterm>Transaction&#32;Level&#32;Model</glossterm>
	</para>

	<glossseealso>Transaction&#32;Level&#32;Model</glossseealso>
      </glossdef>
    </glossentry>

  </glossary>      

  <bibliography>
    <title>
      References
    </title>

    <bibliomixed id="ref_fitch_88">
      <title id="ref_fitch_88_xr">
	A loosely coupled parallel LISP execution system.
      </title>
      <author>
	<firstname>John </firstname>
	<surname>ffitch.</surname>
      </author>
      <publisher>
	<publishername>
	  International Specialist Seminar on the Design and Application of
	  Parallel Digital Processors,
	</publishername>
      </publisher>
      <pubdate>
	  11-15 Apr 1988.
      </pubdate>
      <pagenums>
	pp 128-133.
      </pagenums>
    </bibliomixed>

    <bibliomixed id="ref_mohor_debug">
      <title>
	SoC Debug Interface.
      </title>
      <author>
	<firstname>Igor </firstname>
	<surname>Mohor, </surname>
      </author>
      <issuenum>
	Issue 3.0
      </issuenum>
      <publisher>
	<publishername>
	  OpenCores (<ulink
	  url="http://www.opencores.org/">www.opencores.org</ulink>).
	</publishername>
      </publisher>
      <pubdate>
	  14 April 2004.
      </pubdate>
      <bibliomisc>
	Available from the OpenCores <command>Subversion</command> tree at
	<ulink
	url="http://www.opencores.org/ocsvn/dbg_interface/dbg_interface/trunk/doc/DbgSupp.pdf">http://www.opencores.org/ocsvn/dbg_interface/dbg_interface/trunk/doc/DbgSupp.pdf</ulink>.
      </bibliomisc>
    </bibliomixed>

    <bibliomixed id="ref_mohor_jtag">
      <title>
	&ieee; 1149.1 Test Access Port.
      </title>
      <author>
	<firstname>Igor </firstname>
	<surname>Mohor, </surname>
      </author>
      <issuenum>
	Issue 2.0.
      </issuenum>
      <publisher>
	<publishername>
	  OpenCores (<ulink
	  url="http://www.opencores.org/">www.opencores.org</ulink>).
	</publishername>
      </publisher>
      <pubdate>
	  30 January 2004.
      </pubdate>
      <bibliomisc>
	Available from the OpenCores <command>Subversion</command> tree at
	<ulink
	url="http://www.opencores.org/ocsvn/jtag/jtag/trunk/tap/doc/jtag.pdf">http://www.opencores.org/ocsvn/jtag/jtag/trunk/tap/doc/jtag.pdf</ulink>.
      </bibliomisc>
    </bibliomixed>

    <bibliomixed id="ref_app_note_2">
      <title id="ref_app_note_2_xr">
	&embecosm; Application Note 2. The &opencores; &or1k; Simulator and
	Tool Chain: Installation Guide.
      </title>
      <publisher>
	<publishername>
	  Embecosm Limited,
	</publishername>
      </publisher>
      <pubdate>
	June 2008.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_ieee_1666">
      <title id="ref_ieee_1666_xr">
	IEEE Standard &systemc; Language Reference Manual.
      </title>
      <publisher>
	<publishername>
	  IEEE Computer Society,
	</publishername>
      </publisher>
      <pubsnumber>
	1666-2005,
      </pubsnumber>
      <pubdate>
	31 March, 2006.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_osci_tlm">
      <title id="ref_osci_tlm_xr">
	OSCI TLM 2.0 User Manual.
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative,
	</publishername>
      </publisher>
      <pubdate>
	June, 2008.
      </pubdate>
    </bibliomixed>

    <bibliomixed id="ref_osci_systemc_ug">
      <title id="ref_osci_systemc_ug_xr">
	&systemc; Version 2.0 User Guide.
      </title>
      <publisher>
	<publishername>
	  Open &systemc; Initiative,
	</publishername>
      </publisher>
      <pubdate>
	2002.
      </pubdate>
    </bibliomixed>

  </bibliography>
</book>
 
